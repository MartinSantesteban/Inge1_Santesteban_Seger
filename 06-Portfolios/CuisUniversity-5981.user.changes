

----QUIT----(13 August 2023 19:14:09) CuisUniversity-5981.image priorSource: 5713367!

----STARTUP---- (13 August 2023 19:14:10) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5981.image!


----QUIT----(13 August 2023 19:14:10) CuisUniversity-5981.image priorSource: 10197065!

----STARTUP---- (17 August 2023 14:19:12) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


ObjectBuilder create: #Humano
	collaboratorNames: ''
	in: 'Primer Actividad'
	!

!classDefinition: #Humano category: 'Primer Actividad' stamp: 'MS 8/17/2023 14:20:08'!
DenotativeObject subclass: #Humano
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Primer Actividad'!

!classDefinition: 'Humano class' category: 'Primer Actividad' stamp: 'MS 8/17/2023 14:20:08'!
Humano class
	instanceVariableNames: ''!
!Humano class methodsFor: 'no messages' stamp: 'MS 8/17/2023 14:20:43'!
hola
	^'chau'! !

Humano hola!

Humano hola!

Humano hola!

Humano hola!

Humano hola!

 'chau' .!

 'chau' .!

 'chau' .!

ObjectBuilder create: #Bill
	collaboratorNames: ''
	in: 'Segunda Actividad'
	!

!classDefinition: #Bill category: 'Segunda Actividad' stamp: 'MS 8/17/2023 14:21:46'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Segunda Actividad'!

!classDefinition: 'Bill class' category: 'Segunda Actividad' stamp: 'MS 8/17/2023 14:21:46'!
Bill class
	instanceVariableNames: ''!

!classDefinition: 'Bill class' category: 'Segunda Actividad' stamp: 'MS 8/17/2023 14:22:31'!
Bill class
	instanceVariableNames: 'energia'!
!Bill class methodsFor: 'no messages' stamp: 'MS 8/17/2023 14:22:28'!
nacer
	energia := 28! !
!Bill class methodsFor: 'acciones' stamp: 'MS 8/17/2023 14:23:14'!
energia
	^energia! !
!Bill class methodsFor: 'acciones' stamp: 'MS 8/17/2023 14:23:38'!
caminar
	energia := energia - 3 days.! !
!Bill class methodsFor: 'acciones' stamp: 'MS 8/17/2023 14:23:43' prior: 50650361!
nacer
	energia := 28 days! !
!Bill class methodsFor: 'acciones' stamp: 'MS 8/17/2023 14:24:08'!
comer: cantidadDeCerebro
	! !
!Bill class methodsFor: 'acciones' stamp: 'MS 8/17/2023 14:25:06' prior: 50650374!
comer: cantidadDeCerebro
	energia := (2 days * cantidadDeCerebro) + energia! !
!Bill class methodsFor: 'acciones' stamp: 'MS 8/17/2023 14:25:07' prior: 50650378!
comer: cantidadDeCerebro
	energia := (2 days * cantidadDeCerebro) + energia.! !

 Bill nacer!

 Bill energia !

 Bill comer: 4!

 Bill .!

Bill nacer!

Bill energia!

Bill comer:4!

Bill energia!

Bill caminar!

Bill energia!

Bill caminar!

Bill energia!

----SNAPSHOT----(17 August 2023 14:27:04) CuisUniversity-5981.image priorSource: 10197292!

----STARTUP---- (25 August 2023 17:03:07) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/linux64/linux64/Peano.st----!

!classRemoval: #IIIIII stamp: 'MS 8/25/2023 17:03:41'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIII stamp: 'MS 8/25/2023 17:03:51'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/25/2023 17:03:55'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/25/2023 17:04:00'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

I + I!

I + II!

II next!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 17:05:06'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 17:05:06'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:05:06'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:05:06'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:05:06'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:05:06'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:05:06'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/25/2023 17:05:12'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/25/2023 17:05:12'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:05:12'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:05:12'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:05:12'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:05:12'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:05:12'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

!classRemoval: #III stamp: 'MS 8/25/2023 17:05:56'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/25/2023 17:06:00'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:06:38'!
* unNatural
	^(self + unNatural)
! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:10:31'!
/ unNatural
	^(self + unNatural)
! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:17:18'!
< unNatural
	^(self previous	 < self previous)! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:18:07' prior: 50650888!
< unNatural
	self = I
		ifTrue: true! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:20:23'!
<= unNatural
	self = I
		ifTrue: [^true].
		! !

!methodRemoval: II class #< stamp: 'MS 8/25/2023 17:20:46'!
< unNatural
	self = I
		ifTrue: true!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:22:04' prior: 50650897!
<= unNatural
	self = I
		ifTrue: [^true].
	unNatural = I 
		ifTrue: [^false].
	(self previous) <= (unNatural previous)
		! !

!methodRemoval: II class #/ stamp: 'MS 8/25/2023 17:22:27'!
/ unNatural
	^(self + unNatural)
!

!methodRemoval: II class #* stamp: 'MS 8/25/2023 17:22:33'!
* unNatural
	^(self + unNatural)
!

II next!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 17:22:59'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 17:22:59'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:22:59'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:22:59'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:22:59'!
<= unNatural
	self = I
		ifTrue: [^true].
	unNatural = I 
		ifTrue: [^false].
	(self previous) <= (unNatural previous)
		! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:22:59'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:22:59'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:22:59'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/25/2023 17:23:06'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/25/2023 17:23:06'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:06'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:06'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:06'!
<= unNatural
	self = I
		ifTrue: [^true].
	unNatural = I 
		ifTrue: [^false].
	(self previous) <= (unNatural previous)
		! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:06'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:06'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:06'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII !

III next !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/25/2023 17:23:42'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/25/2023 17:23:42'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:42'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:42'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:42'!
<= unNatural
	self = I
		ifTrue: [^true].
	unNatural = I 
		ifTrue: [^false].
	(self previous) <= (unNatural previous)
		! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:42'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:42'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:42'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIIII next!

DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIII category: 'Peano' stamp: 'MS 8/25/2023 17:23:49'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIII class' category: 'Peano' stamp: 'MS 8/25/2023 17:23:50'!
IIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:50'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:50'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:50'!
<= unNatural
	self = I
		ifTrue: [^true].
	unNatural = I 
		ifTrue: [^false].
	(self previous) <= (unNatural previous)
		! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:50'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:50'!
previous
	^previous
	! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:23:50'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII <= I!

IIII <= II!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:24:22' prior: 50650905!
<= unNatural
	self = I
		ifTrue: [^true].
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
		! !

IIII <= II !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:24:34' prior: 50651121!
<= unNatural
	self = I
		ifTrue: [^true].
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !

!classRemoval: #III stamp: 'MS 8/25/2023 17:24:43'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/25/2023 17:24:48'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIII stamp: 'MS 8/25/2023 17:24:52'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIII stamp: 'MS 8/25/2023 17:24:56'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 17:25:13'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 17:25:13'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:25:13'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:25:13'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:25:13'!
<= unNatural
	self = I
		ifTrue: [^true].
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:25:13'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:25:13'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:25:13'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/25/2023 17:25:17'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/25/2023 17:25:17'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:25:17'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:25:17'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:25:17'!
<= unNatural
	self = I
		ifTrue: [^true].
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:25:17'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:25:17'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:25:17'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII <= I!

IIII <= II!

IIII <= III!

IIII <= IIII!
!I class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:26:31'!
<= unNatural
	^true! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:27:15' prior: 50651129!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !

!classRemoval: #III stamp: 'MS 8/25/2023 17:27:25'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/25/2023 17:27:29'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 17:27:54'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 17:27:54'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:27:54'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:27:54'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:27:54'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:27:54'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:27:54'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:27:54'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/25/2023 17:27:58'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/25/2023 17:27:58'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:27:58'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:27:58'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:27:58'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:27:58'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:27:58'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:27:58'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII <= I!

IIII <= II!

IIII <= III!

IIII <= IIII!

II <= I!

II <= II!

II <= III!

II <= IIII!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:30:28'!
/ unNatural
	(self <= unNatural) ifTrue: [^((self - self)/unNatural) + I].! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:30:44' prior: 50651382!
/ unNatural
	(self <= unNatural) ifTrue: [^((self - self)/unNatural) + I].
! !

!classRemoval: #III stamp: 'MS 8/25/2023 17:30:52'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/25/2023 17:30:56'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 17:31:10'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 17:31:10'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:10'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:10'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:10'!
/ unNatural
	(self <= unNatural) ifTrue: [^((self - self)/unNatural) + I].
! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:10'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:10'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:10'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:10'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/25/2023 17:31:13'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/25/2023 17:31:13'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:13'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:13'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:13'!
/ unNatural
	(self <= unNatural) ifTrue: [^((self - self)/unNatural) + I].
! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:13'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:13'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:13'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:13'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII!

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/25/2023 17:31:19'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/25/2023 17:31:19'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:19'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:19'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:19'!
/ unNatural
	(self <= unNatural) ifTrue: [^((self - self)/unNatural) + I].
! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:19'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:19'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:19'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:19'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIIII next!

DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIII category: 'Peano' stamp: 'MS 8/25/2023 17:31:23'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIII class' category: 'Peano' stamp: 'MS 8/25/2023 17:31:23'!
IIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:23'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:23'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:23'!
/ unNatural
	(self <= unNatural) ifTrue: [^((self - self)/unNatural) + I].
! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:23'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:23'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:23'!
previous
	^previous
	! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:23'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIIIII next!

DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIII category: 'Peano' stamp: 'MS 8/25/2023 17:31:26'!
DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIII class' category: 'Peano' stamp: 'MS 8/25/2023 17:31:26'!
IIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:26'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:26'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:26'!
/ unNatural
	(self <= unNatural) ifTrue: [^((self - self)/unNatural) + I].
! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:26'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:26'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:26'!
previous
	^previous
	! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:31:26'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIIIIII / II!

IIIIIII / IIIII .!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:32:42' prior: 50651388!
/ unNatural
	(unNatural <= self) ifTrue: [^((self - self)/unNatural) + I].
! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:33:05' prior: 50651679!
/ unNatural
	(unNatural <= self) ifTrue: [^((self - unNatural)/unNatural) + I].
! !

!classRemoval: #IIIIIII stamp: 'MS 8/25/2023 17:35:02'!
DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIII stamp: 'MS 8/25/2023 17:35:05'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIII stamp: 'MS 8/25/2023 17:35:08'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/25/2023 17:35:12'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/25/2023 17:35:15'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 17:35:50'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 17:35:50'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:50'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:50'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:50'!
/ unNatural
	(unNatural <= self) ifTrue: [^((self - unNatural)/unNatural) + I].
! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:50'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:50'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:50'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:50'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/25/2023 17:35:57'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/25/2023 17:35:57'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:57'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:57'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:57'!
/ unNatural
	(unNatural <= self) ifTrue: [^((self - unNatural)/unNatural) + I].
! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:57'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:57'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:57'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:35:57'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/25/2023 17:36:02'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/25/2023 17:36:02'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:36:02'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:36:02'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:36:02'!
/ unNatural
	(unNatural <= self) ifTrue: [^((self - unNatural)/unNatural) + I].
! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:36:02'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:36:02'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:36:02'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:36:02'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII / II!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 17:37:53' prior: 50651685!
/ unNatural
	(unNatural <= self) ifTrue: [^((self - unNatural)/unNatural) + I].
! !

IIII / III!

II - I!

II - II!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:43:25' prior: 50651885!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue:  I].
! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:43:27' prior: 50651892!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue: I].
! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:43:52' prior: 50651898!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue: I
				ifFalse: ((self - unNatural)/unNatural) + 1].
! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:45:52' prior: 50651904!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue: [^I].
				^((self - unNatural)/unNatural) + 1].
! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:04' prior: 50651912!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue: [^I].
				^((self - unNatural)/unNatural) + I].
! !

!classRemoval: #IIIII stamp: 'MS 8/25/2023 18:46:10'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/25/2023 18:46:13'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/25/2023 18:46:17'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 18:46:31'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 18:46:31'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:31'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:31'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:31'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue: [^I].
				^((self - unNatural)/unNatural) + I].
! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:31'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:31'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:31'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:31'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/25/2023 18:46:36'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/25/2023 18:46:36'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:36'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:36'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:36'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue: [^I].
				^((self - unNatural)/unNatural) + I].
! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:36'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:36'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:36'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:36'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/25/2023 18:46:41'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/25/2023 18:46:41'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:41'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:41'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:41'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue: [^I].
				^((self - unNatural)/unNatural) + I].
! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:41'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:41'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:41'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:46:41'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

 IIIII .!

IIII/II!

 I .!

IIII/I!

 III .!

IIII / II!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:49:46' prior: 50651972!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue: [^II].
				^((self - unNatural)/unNatural) + I].
! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:49:55' prior: 50651920!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue: [^II].
				^((self - unNatural)/unNatural) + I].
! !

!classRemoval: #III stamp: 'MS 8/25/2023 18:49:59'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/25/2023 18:50:02'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIII stamp: 'MS 8/25/2023 18:50:04'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 18:50:24'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 18:50:24'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:24'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:24'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:24'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue: [^II].
				^((self - unNatural)/unNatural) + I].
! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:24'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:24'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:24'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:24'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/25/2023 18:50:31'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/25/2023 18:50:31'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:31'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:31'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:31'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue: [^II].
				^((self - unNatural)/unNatural) + I].
! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:31'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:31'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:31'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:31'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/25/2023 18:50:36'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/25/2023 18:50:36'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:36'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:36'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:36'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue: [^II].
				^((self - unNatural)/unNatural) + I].
! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:36'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:36'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:36'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:36'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII / II!

IIIII / II!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:50:58' prior: 50652122!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self - unNatural <= unNatural)
				ifTrue: [^I].
				^((self - unNatural)/unNatural) + I].
! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:54:31' prior: 50652315!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural)
				ifTrue: [^I].
				^((self - unNatural)/unNatural) + I].
! !

!classRemoval: #IIIII stamp: 'MS 8/25/2023 18:56:38'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/25/2023 18:56:41'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/25/2023 18:56:44'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 18:57:29'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 18:57:29'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:57:29'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:57:29'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:57:29'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural)
				ifTrue: [^I].
				^((self - unNatural)/unNatural) + I].
! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:57:29'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:57:29'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:57:29'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 18:57:29'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III / I!

III / II!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:02' prior: 50652323!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural) ifTrue: [^I].(self - unNatural <= unNatural) ifTrue: [^1].^((self - unNatural)/unNatural) + I.]! !

!classRemoval: #III stamp: 'MS 8/25/2023 19:05:21'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 19:05:39'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 19:05:39'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:39'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:39'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:39'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural) ifTrue: [^I].(self - unNatural <= unNatural) ifTrue: [^1].^((self - unNatural)/unNatural) + I.]! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:39'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:39'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:39'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:39'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/25/2023 19:05:43'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/25/2023 19:05:43'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:43'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:43'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:43'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural) ifTrue: [^I].(self - unNatural <= unNatural) ifTrue: [^1].^((self - unNatural)/unNatural) + I.]! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:43'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:43'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:43'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:43'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/25/2023 19:05:47'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/25/2023 19:05:47'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:47'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:47'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:47'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural) ifTrue: [^I].(self - unNatural <= unNatural) ifTrue: [^1].^((self - unNatural)/unNatural) + I.]! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:47'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:47'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:47'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:05:47'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII / III!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:08' prior: 50652404!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural) ifTrue: [^I].(self - unNatural <= unNatural) ifTrue: [^I].^((self - unNatural)/unNatural) + I.]! !

!classRemoval: #IIIII stamp: 'MS 8/25/2023 19:06:12'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/25/2023 19:06:16'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/25/2023 19:06:20'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 19:06:35'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 19:06:36'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:36'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:36'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:36'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural) ifTrue: [^I].(self - unNatural <= unNatural) ifTrue: [^I].^((self - unNatural)/unNatural) + I.]! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:36'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:36'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:36'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:36'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/25/2023 19:06:42'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/25/2023 19:06:42'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:42'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:42'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:42'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural) ifTrue: [^I].(self - unNatural <= unNatural) ifTrue: [^I].^((self - unNatural)/unNatural) + I.]! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:42'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:42'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:42'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:42'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/25/2023 19:06:46'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/25/2023 19:06:46'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:46'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:46'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:46'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural) ifTrue: [^I].(self - unNatural <= unNatural) ifTrue: [^I].^((self - unNatural)/unNatural) + I.]! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:46'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:46'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:46'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:06:46'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII / III!

IIII / IIII!

IIII / II!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:07:58' prior: 50652590!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural) ifTrue: [^I].(self - unNatural < unNatural) ifTrue: [^I].^((self - unNatural)/unNatural) + I.]! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:08:11'!
< unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:08:21' prior: 50652795!
< unNatural
	^(self previous) <= (unNatural previous)
	! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:10:47' prior: 50652801!
< unNatural
	^(self <= unNatural) and: (self = unNatural) not
	! !
!I class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:10:59'!
< unNatural
	^true! !
!I class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:18' prior: 50652811!
< unNatural
	^(self = unNatural) not! !

!classRemoval: #III stamp: 'MS 8/25/2023 19:11:23'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIII stamp: 'MS 8/25/2023 19:11:26'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/25/2023 19:11:29'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 19:11:45'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 19:11:45'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:45'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:45'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:45'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural) ifTrue: [^I].(self - unNatural < unNatural) ifTrue: [^I].^((self - unNatural)/unNatural) + I.]! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:45'!
< unNatural
	^(self <= unNatural) and: (self = unNatural) not
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:45'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:45'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:45'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:45'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/25/2023 19:11:49'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/25/2023 19:11:49'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:49'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:49'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:49'!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural) ifTrue: [^I].(self - unNatural < unNatural) ifTrue: [^I].^((self - unNatural)/unNatural) + I.]! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:49'!
< unNatural
	^(self <= unNatural) and: (self = unNatural) not
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:49'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:49'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:49'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:11:49'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III < II!

III < III!

III < IIII!

I < II!

I < I!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:12:17' prior: 50652787!
/ unNatural
	(unNatural < self) 
		ifTrue: [(self = unNatural) ifTrue: [^I].(self - unNatural < unNatural) ifTrue: [^I].^((self - unNatural)/unNatural) + I.]! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:12:20' prior: 50652962!
/ unNatural
	(unNatural <= self) 
		ifTrue: [(self = unNatural) ifTrue: [^I].(self - unNatural < unNatural) ifTrue: [^I].^((self - unNatural)/unNatural) + I.]! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:13:33' prior: 50652970!
/ unNatural
	(unNatural = self) ifTrue: [^I].
	(self < unNatural) ifTrue:[^((self - unNatural)/unNatural) + I]! !

!classRemoval: #IIII stamp: 'MS 8/25/2023 19:13:40'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/25/2023 19:13:44'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:14:06' prior: 50652978!
/ unNatural
	(unNatural = self) ifTrue: [^I].
	(self < unNatural) ifTrue:[^((self - unNatural)/unNatural) + I].! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:14:48' prior: 50652996!
/ unNatural
	(unNatural = self) ifTrue: [^I].
	(unNatural < self) ifTrue:[^((self - unNatural)/unNatural) + I].
	! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:15:42' prior: 50653003!
/ unNatural
	(unNatural = self) ifTrue: [^I].
	(unNatural < self) ifTrue:[^((self - unNatural)/unNatural) + I].
	! !

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 19:15:58'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 19:15:58'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:15:58'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:15:58'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:15:58'!
/ unNatural
	(unNatural = self) ifTrue: [^I].
	(unNatural < self) ifTrue:[^((self - unNatural)/unNatural) + I].
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:15:58'!
< unNatural
	^(self <= unNatural) and: (self = unNatural) not
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:15:58'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:15:58'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:15:58'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:15:58'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III / II!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:26' prior: 50653010!
/ unNatural
	(unNatural = self) ifTrue: [^I].
	(self - unNatural = I) ifTrue: [^I].
	(unNatural < self) ifTrue:[^((self - unNatural)/unNatural) + I].
	! !

!classRemoval: #III stamp: 'MS 8/25/2023 19:17:36'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 19:17:52'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 19:17:52'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:52'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:52'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:52'!
/ unNatural
	(unNatural = self) ifTrue: [^I].
	(self - unNatural = I) ifTrue: [^I].
	(unNatural < self) ifTrue:[^((self - unNatural)/unNatural) + I].
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:52'!
< unNatural
	^(self <= unNatural) and: (self = unNatural) not
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:52'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:52'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:52'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:52'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/25/2023 19:17:58'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/25/2023 19:17:58'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:58'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:58'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:58'!
/ unNatural
	(unNatural = self) ifTrue: [^I].
	(self - unNatural = I) ifTrue: [^I].
	(unNatural < self) ifTrue:[^((self - unNatural)/unNatural) + I].
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:58'!
< unNatural
	^(self <= unNatural) and: (self = unNatural) not
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:58'!
<= unNatural
	unNatural = I 
		ifTrue: [^false].
	^(self previous) <= (unNatural previous)
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:58'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:58'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:17:58'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII / II!

IIII / III!

IIII / IIII!

IIII / I!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:19:01' prior: 50653078!
/ unNatural
	(unNatural = self) ifTrue: [^I].
	(self - unNatural = I) ifTrue: [(unNatural = I) ifTrue: [^II].^I].
	(unNatural < self) ifTrue:[^((self - unNatural)/unNatural) + I].
	! !

!classRemoval: #II stamp: 'MS 8/25/2023 19:19:05'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

I next!

!classDefinition: #AnObsoleteII category: 'Workspace-Objects' stamp: 'MS 8/25/2023 19:20:33'!
DenotativeObject subclass: #AnObsoleteII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Workspace-Objects'!

 AnObsoleteII .!

!classRemoval: #III stamp: 'MS 8/25/2023 19:20:49'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #AnObsoleteII stamp: 'MS 8/25/2023 19:20:56'!
DenotativeObject subclass: #AnObsoleteII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Workspace-Objects'!

----STARTUP---- (25 August 2023 19:22:37) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/linux64/linux64/Peano.st----!

!classRemoval: #IIIIII stamp: 'MS 8/25/2023 19:23:00'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIII stamp: 'MS 8/25/2023 19:23:03'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/25/2023 19:23:06'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/25/2023 19:23:10'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!
!I class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:23:33'!
< unNatural
	^ (unNatural = I) not! !
!I class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:23:43'!
<= unNatural
	^true! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:24:00'!
< unNatural
	! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:25:07' prior: 50650790!
< unNatural
	^ (self <= unNatural) and:(self = unNatural) not! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:25:17'!
<= unNatural
	^ (self <= unNatural) and:(self = unNatural) not! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:25:32' prior: 50650799!
<= unNatural
	^ (self previous <= unNatural previous)! !

II next!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/25/2023 19:26:10'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/25/2023 19:26:10'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:26:10'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:26:10'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:26:10'!
< unNatural
	^ (self <= unNatural) and:(self = unNatural) not! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:26:10'!
<= unNatural
	^ (self previous <= unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:26:10'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:26:10'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:26:10'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

II < I!

I <= II!

I <= I!

I < I!

I < II!

II <= II!

II <= III!

II <= I!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/25/2023 19:27:49' prior: 50650804!
<= unNatural
	(unNatural = I) ifTrue: [^false]
	^ (self previous <= unNatural previous)! !

!classRemoval: #II stamp: 'MS 8/25/2023 19:27:54'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

----STARTUP---- (27 August 2023 22:33:00) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/linux64/linux64/Peano.st----!

!classRemoval: #IIIIII stamp: 'MS 8/27/2023 22:33:26'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIII stamp: 'MS 8/27/2023 22:33:43'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/27/2023 22:33:46'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/27/2023 22:33:49'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!
!I class methodsFor: 'as yet unclassified' stamp: 'MS 8/27/2023 22:34:14'!
< unNatural
	^true! !

----STARTUP---- (28 August 2023 13:04:13) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/linux64/linux64/Peano.st----!

!classRemoval: #IIIIII stamp: 'MS 8/28/2023 13:04:37'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIII stamp: 'MS 8/28/2023 13:04:40'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/28/2023 13:04:43'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/28/2023 13:04:46'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!
!I class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 13:04:51' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 13:04:51' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := AnObsoleteIII.
	existeSiguiente := true.
	previous := I.! !

!methodRemoval: I class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 13:04:51'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.!

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 13:04:51'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := AnObsoleteIII.
	existeSiguiente := true.
	previous := I.!
!I class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:05:03'!
< unNatural
	^true! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:06:10'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!I class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:06:29' prior: 50650816!
< unNatural
	^(unNatural = I) not! !
!I class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 13:06:32' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 13:06:32' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := AnObsoleteIII.
	existeSiguiente := true.
	previous := I.! !

!methodRemoval: I class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 13:06:32'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.!

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 13:06:32'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := AnObsoleteIII.
	existeSiguiente := true.
	previous := I.!

I < I!

I < II!

II < II!

II next!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/28/2023 13:07:15'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/28/2023 13:07:15'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:07:15'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:07:15'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:07:15'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:07:15'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:07:15'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:07:15'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

II < III!

II < II!

III <  III!

III <  II!

III <  I!

I < I!

II < I!
!I class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:08:03'!
* unNatural
	^unNatural! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:08:43'!
*unNatural
	^ (self + self) * (unNatural - I)! !
!I class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 13:08:56' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 13:08:56' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	existeSiguiente := true.
	previous := I.! !
!III class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 13:08:56' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	existeSiguiente := true.
	previous := II.! !

!methodRemoval: I class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 13:08:56'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.!

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 13:08:56'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	existeSiguiente := true.
	previous := I.!

!methodRemoval: III class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 13:08:56'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	existeSiguiente := true.
	previous := II.!

!classRemoval: #III stamp: 'MS 8/28/2023 13:09:03'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

I < II!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/28/2023 13:09:24'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/28/2023 13:09:24'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:24'!
*unNatural
	^ (self + self) * (unNatural - I)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:24'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:24'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:24'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:24'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:24'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:24'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/28/2023 13:09:26'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:09:26'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:26'!
*unNatural
	^ (self + self) * (unNatural - I)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:26'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:26'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:27'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:27'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:27'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:27'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/28/2023 13:09:29'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:09:30'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:30'!
*unNatural
	^ (self + self) * (unNatural - I)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:30'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:30'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:30'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:30'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:30'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:09:30'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

II * I!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:26' prior: 50650920!
*unNatural
	unNatural = I ifTrue: [^self]
	^(self + self) * (unNatural - I)! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:28' prior: 50651139!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !

!classRemoval: #IIIII stamp: 'MS 8/28/2023 13:10:32'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/28/2023 13:10:34'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/28/2023 13:10:39'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!
!I class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 13:10:50' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 13:10:50' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	existeSiguiente := true.
	previous := I.! !

!methodRemoval: I class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 13:10:50'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.!

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 13:10:50'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	existeSiguiente := true.
	previous := I.!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/28/2023 13:10:56'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/28/2023 13:10:56'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:56'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:56'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:56'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:56'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:56'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:56'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:56'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/28/2023 13:10:59'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:10:59'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:59'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:59'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:59'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:59'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:59'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:59'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:10:59'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

II * I!

I * IIII!

II * II!

II * III!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/28/2023 13:11:24'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:11:24'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIII category: 'Peano' stamp: 'MS 8/28/2023 13:11:24'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:11:24'!
IIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
previous
	^previous
	! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIII category: 'Peano' stamp: 'MS 8/28/2023 13:11:24'!
DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:11:24'!
IIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
previous
	^previous
	! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIII category: 'Peano' stamp: 'MS 8/28/2023 13:11:24'!
DenotativeObject subclass: #IIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:11:24'!
IIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
previous
	^previous
	! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:11:24'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III * II .!

II * III !

II * IIII !

DenotativeObject subclass: #IIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIII category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
DenotativeObject subclass: #IIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
IIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous
	^previous
	! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIII category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
DenotativeObject subclass: #IIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
IIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous
	^previous
	! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIII category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
DenotativeObject subclass: #IIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIIIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
IIIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous
	^previous
	! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIII category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
DenotativeObject subclass: #IIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIIIIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
IIIIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous
	^previous
	! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIII category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
DenotativeObject subclass: #IIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIIIIIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
IIIIIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous
	^previous
	! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIII category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
DenotativeObject subclass: #IIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIIIIIIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
IIIIIIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous
	^previous
	! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIII category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
DenotativeObject subclass: #IIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIIIIIIIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
IIIIIIIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous
	^previous
	! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIII category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
DenotativeObject subclass: #IIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIIIIIIIIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 13:14:03'!
IIIIIIIIIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous
	^previous
	! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 13:14:03'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

!classRemoval: #IIIIIIIIIIIIIIII stamp: 'MS 8/28/2023 13:14:45'!
DenotativeObject subclass: #IIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

----End fileIn of /home/martin/Desktop/Inge1/linux64/linux64/Peano.st----!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:12:40' prior: 50652059!
*unNatural
	unNatural = I ifTrue: [^self].
	^(unNatural + unNatural)! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:12:51' prior: 50652127!
*unNatural
	unNatural = I ifTrue: [^self].
	^(unNatural + unNatural) * (self - I)! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:14:39' prior: 50652133!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self + self) * (unNatural - I)! !

!classRemoval: #IIIIIIIIIIIIIII stamp: 'MS 8/28/2023 14:15:32'!
DenotativeObject subclass: #IIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIIIIIIIIIII stamp: 'MS 8/28/2023 14:15:39'!
DenotativeObject subclass: #IIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIIIIIIIIII stamp: 'MS 8/28/2023 14:15:42'!
DenotativeObject subclass: #IIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIIIIIIIII stamp: 'MS 8/28/2023 14:15:45'!
DenotativeObject subclass: #IIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIIIIIIII stamp: 'MS 8/28/2023 14:15:48'!
DenotativeObject subclass: #IIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIIIIIII stamp: 'MS 8/28/2023 14:15:53'!
DenotativeObject subclass: #IIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIIIIII stamp: 'MS 8/28/2023 14:15:56'!
DenotativeObject subclass: #IIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIIIII stamp: 'MS 8/28/2023 14:15:59'!
DenotativeObject subclass: #IIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIIII stamp: 'MS 8/28/2023 14:16:06'!
DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIII stamp: 'MS 8/28/2023 14:16:09'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIII stamp: 'MS 8/28/2023 14:16:11'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/28/2023 14:16:14'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/28/2023 14:16:17'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:22:48' prior: 50652139!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !

II * I!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/28/2023 14:23:14'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/28/2023 14:23:14'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:14'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:14'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:14'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:14'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:14'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:14'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:14'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

II * III!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/28/2023 14:23:18'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:23:18'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/28/2023 14:23:18'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:23:18'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIII category: 'Peano' stamp: 'MS 8/28/2023 14:23:18'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:23:18'!
IIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
previous
	^previous
	! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:18'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III * II!

III * III!

DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIII category: 'Peano' stamp: 'MS 8/28/2023 14:23:34'!
DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:23:34'!
IIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:34'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:34'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:34'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:34'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:34'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:34'!
previous
	^previous
	! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:34'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIII category: 'Peano' stamp: 'MS 8/28/2023 14:23:35'!
DenotativeObject subclass: #IIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:23:35'!
IIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
previous
	^previous
	! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

DenotativeObject subclass: #IIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIII category: 'Peano' stamp: 'MS 8/28/2023 14:23:35'!
DenotativeObject subclass: #IIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:23:35'!
IIIIIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
previous
	^previous
	! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:23:35'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

!classRemoval: #IIIIIIIII stamp: 'MS 8/28/2023 14:24:34'!
DenotativeObject subclass: #IIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIIIII stamp: 'MS 8/28/2023 14:24:37'!
DenotativeObject subclass: #IIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIIII stamp: 'MS 8/28/2023 14:24:41'!
DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIIII stamp: 'MS 8/28/2023 14:24:43'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIII stamp: 'MS 8/28/2023 14:24:46'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/28/2023 14:24:49'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/28/2023 14:24:53'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!
!I class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:25:21'!
/ unNatural
	! !

!methodRemoval: I class #/ stamp: 'MS 8/28/2023 14:25:34'!
/ unNatural
	!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:25:52'!
/ unNatural
	! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:27:06' prior: 50652663!
/ unNatural
	unNatural = I ifTrue: [^self]! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:27:08' prior: 50652667!
/ unNatural
	unNatural = I ifTrue: [^self]
	! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:27:57' prior: 50652672!
/ unNatural
	unNatural = I ifTrue: [^self].
	unNatural < self ifTrue:[^((self - unNatural)/(unNatural previous)) + I]! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:28:20' prior: 50652677!
/ unNatural
	unNatural = I ifTrue: [^self].
	unNatural < self ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:03' prior: 50652684!
/ unNatural
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self) )ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:05' prior: 50652691!
/ unNatural
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!I class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 14:29:45' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 14:29:45' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	existeSiguiente := true.
	previous := I.! !

!methodRemoval: I class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 14:29:45'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.!

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 14:29:45'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	existeSiguiente := true.
	previous := I.!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/28/2023 14:29:52'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/28/2023 14:29:52'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:52'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:52'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:52'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:52'!
/ unNatural
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:52'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:52'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:53'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:53'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/28/2023 14:29:56'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:29:56'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:56'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:56'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:56'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:56'!
/ unNatural
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:56'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:56'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:56'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:29:56'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III / II!

!classRemoval: #IIII stamp: 'MS 8/28/2023 14:32:35'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/28/2023 14:32:38'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/28/2023 14:32:53'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/28/2023 14:32:53'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:53'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:53'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:53'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:53'!
/ unNatural
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:53'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:53'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:53'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:53'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/28/2023 14:32:58'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:32:58'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:58'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:58'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:58'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:58'!
/ unNatural
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:58'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:58'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:58'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:32:58'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/28/2023 14:33:01'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:33:01'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:33:01'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:33:01'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:33:01'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:33:01'!
/ unNatural
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:33:01'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:33:01'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:33:01'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:33:01'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII / II!

IIII / III!
!I class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:33:29'!
/ unNatural
	! !

!classRemoval: #IIIII stamp: 'MS 8/28/2023 14:33:36'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/28/2023 14:33:39'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/28/2023 14:33:43'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/28/2023 14:34:02'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/28/2023 14:34:02'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:02'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:02'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:02'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:02'!
/ unNatural
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:02'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:02'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:02'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:02'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/28/2023 14:34:05'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:34:05'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:05'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:05'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:05'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:05'!
/ unNatural
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:05'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:05'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:05'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:05'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/28/2023 14:34:07'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:34:07'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:07'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:07'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:07'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:07'!
/ unNatural
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:07'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:07'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:07'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:07'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIIII next!

DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIII category: 'Peano' stamp: 'MS 8/28/2023 14:34:10'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:34:10'!
IIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:10'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:10'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:10'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:10'!
/ unNatural
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:10'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:10'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:10'!
previous
	^previous
	! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:34:10'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIIII / II!

IIIII / I!

IIIII / III!

IIII / II!

II / II!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:08' prior: 50652699!
/ unNatural
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !

!classRemoval: #IIIIII stamp: 'MS 8/28/2023 14:39:14'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIII stamp: 'MS 8/28/2023 14:39:17'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/28/2023 14:39:19'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/28/2023 14:39:23'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/28/2023 14:39:42'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/28/2023 14:39:42'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:42'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:42'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:42'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:42'!
/ unNatural
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:42'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:42'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:42'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:42'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/28/2023 14:39:45'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:39:45'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:45'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:45'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:45'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:45'!
/ unNatural
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:45'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:45'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:45'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:45'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/28/2023 14:39:49'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:39:49'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:49'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:49'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:49'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:49'!
/ unNatural
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:49'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:49'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:49'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:39:49'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII / II!

IIII / III !

IIIII next !

DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIII category: 'Peano' stamp: 'MS 8/28/2023 14:45:39'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:45:39'!
IIIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:45:39'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:45:39'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:45:39'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:45:39'!
/ unNatural
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:45:39'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:45:39'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:45:39'!
previous
	^previous
	! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:45:39'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIIII / III!

IIIII / III!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:46:59' prior: 50653341!
/ unNatural
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural)) + I].! !

!classRemoval: #IIIIII stamp: 'MS 8/28/2023 14:47:05'!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIIII stamp: 'MS 8/28/2023 14:47:08'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/28/2023 14:47:11'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/28/2023 14:47:15'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/28/2023 14:47:29'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/28/2023 14:47:29'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:29'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:29'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:29'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:29'!
/ unNatural
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural)) + I].! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:29'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:29'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:29'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:29'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/28/2023 14:47:32'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:47:32'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:32'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:32'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:32'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:32'!
/ unNatural
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural)) + I].! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:32'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:32'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:32'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:32'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/28/2023 14:47:35'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:47:35'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:35'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:35'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:35'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:35'!
/ unNatural
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural)) + I].! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:35'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:35'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:35'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:35'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIIII / III!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:47:57' prior: 50653630!
/ unNatural
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural previous)) + I].! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:48:12' prior: 50653851!
/ unNatural
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural)) + I].! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:50:27' prior: 50653860!
/ unNatural
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural)) + I].! !

II / III!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:16' prior: 50653869!
/ unNatural
	self < unNatural ifTrue: [].
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural)) + I].! !

!classRemoval: #IIIII stamp: 'MS 8/28/2023 14:51:22'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/28/2023 14:51:30'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/28/2023 14:51:38'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/28/2023 14:51:50'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/28/2023 14:51:50'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:50'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:50'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:50'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:50'!
/ unNatural
	self < unNatural ifTrue: [].
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural)) + I].! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:50'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:50'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:50'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:50'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/28/2023 14:51:53'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:51:53'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:53'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:53'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:53'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:53'!
/ unNatural
	self < unNatural ifTrue: [].
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural)) + I].! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:53'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:53'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:53'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:53'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/28/2023 14:51:56'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:51:56'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:56'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:56'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:56'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:56'!
/ unNatural
	self < unNatural ifTrue: [].
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural)) + I].! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:56'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:56'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:56'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:51:56'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIIII / III!

II/IIII!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:53:19' prior: 50653878!
/ unNatural
	self < unNatural ifTrue: [^nil].
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[^((self - unNatural)/(unNatural)) + I].! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:58:28' prior: 50654097!
/ unNatural
	|rec|
	self < unNatural ifTrue: [^nil].
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I]
		].! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:58:36' prior: 50654107!
/ unNatural
	|rec|
	self < unNatural ifTrue: [^nil].
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec
		].! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:58:39' prior: 50654118!
/ unNatural
	|rec|
	self < unNatural ifTrue: [^nil].
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	((unNatural < self) or: (unNatural = self))ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec.
		].! !

!classRemoval: #IIIII stamp: 'MS 8/28/2023 14:58:44'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/28/2023 14:58:46'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/28/2023 14:58:50'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:15' prior: 50654129!
/ unNatural
	|rec|
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	self < unNatural ifTrue: [^nil].
	((unNatural < self) or: (unNatural = self))ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec.
		].! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:32' prior: 50654157!
/ unNatural
	|rec|
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	self < unNatural ifTrue: [^nil].
	(unNatural < self)ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec.
		].! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:47' prior: 50654168!
/ unNatural
	|rec|
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	self < unNatural ifTrue: [^nil].
	(unNatural < self)ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec + I.
		].! !

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/28/2023 14:59:52'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/28/2023 14:59:52'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:52'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:52'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:52'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:52'!
/ unNatural
	|rec|
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	self < unNatural ifTrue: [^nil].
	(unNatural < self)ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec + I.
		].! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:52'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:52'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:52'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:52'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/28/2023 14:59:59'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/28/2023 14:59:59'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:59'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:59'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:59'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:59'!
/ unNatural
	|rec|
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	self < unNatural ifTrue: [^nil].
	(unNatural < self)ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec + I.
		].! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:59'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:59'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:59'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 14:59:59'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/28/2023 15:00:03'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/28/2023 15:00:03'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:00:03'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:00:03'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:00:03'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:00:03'!
/ unNatural
	|rec|
	unNatural = self ifTrue: [^I].
	unNatural = I ifTrue: [^self].
	self < unNatural ifTrue: [^nil].
	(unNatural < self)ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec + I.
		].! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:00:03'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:00:03'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:00:03'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:00:03'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII / II!

IIII / III!

IIIII / II !

III / II!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:05:50' prior: 50654179!
/ unNatural
	|rec|
	unNatural = self ifTrue: [^I].
	self < unNatural ifTrue: [^nil].
	(unNatural < self)ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec + I.
		].! !

!classRemoval: #IIIII stamp: 'MS 8/28/2023 15:05:54'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/28/2023 15:06:00'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/28/2023 15:06:03'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!
!I class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 15:06:11' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 15:06:11' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := AnObsoleteIII.
	existeSiguiente := true.
	previous := I.! !

!methodRemoval: I class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 15:06:11'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.!

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 15:06:12'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := AnObsoleteIII.
	existeSiguiente := true.
	previous := I.!

II next!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/28/2023 15:06:52'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/28/2023 15:06:52'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:52'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:52'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:52'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:52'!
/ unNatural
	|rec|
	unNatural = self ifTrue: [^I].
	self < unNatural ifTrue: [^nil].
	(unNatural < self)ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec + I.
		].! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:52'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:52'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:52'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:52'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/28/2023 15:06:55'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/28/2023 15:06:56'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:56'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:56'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:56'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:56'!
/ unNatural
	|rec|
	unNatural = self ifTrue: [^I].
	self < unNatural ifTrue: [^nil].
	(unNatural < self)ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec + I.
		].! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:56'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:56'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:56'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:06:56'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III / II!

III / II!

IIII / II .!

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/28/2023 15:10:50'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/28/2023 15:10:50'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:10:50'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:10:50'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:10:50'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:10:50'!
/ unNatural
	|rec|
	unNatural = self ifTrue: [^I].
	self < unNatural ifTrue: [^nil].
	(unNatural < self)ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec + I.
		].! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:10:50'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:10:50'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:10:50'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:10:50'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIIII / III!

IIIII / IIII!

IIIII / I!

IIIII / II!
!I class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:15' prior: 50653065!
/ unNatural
	^nil
	! !

!classRemoval: #IIIII stamp: 'MS 8/28/2023 15:13:21'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/28/2023 15:13:24'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/28/2023 15:13:27'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

II next!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: 'Peano' stamp: 'MS 8/28/2023 15:13:39'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'III class' category: 'Peano' stamp: 'MS 8/28/2023 15:13:39'!
III class
	instanceVariableNames: 'next existeSiguiente previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:39'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:39'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:39'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:39'!
/ unNatural
	|rec|
	unNatural = self ifTrue: [^I].
	self < unNatural ifTrue: [^nil].
	(unNatural < self)ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec + I.
		].! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:39'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:39'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:39'!
previous
	^previous
	! !
!III class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:39'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

III next!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: 'Peano' stamp: 'MS 8/28/2023 15:13:43'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIII class' category: 'Peano' stamp: 'MS 8/28/2023 15:13:43'!
IIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:43'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:43'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:43'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:43'!
/ unNatural
	|rec|
	unNatural = self ifTrue: [^I].
	self < unNatural ifTrue: [^nil].
	(unNatural < self)ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec + I.
		].! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:43'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:43'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:43'!
previous
	^previous
	! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:43'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIII next!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: 'Peano' stamp: 'MS 8/28/2023 15:13:46'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!

!classDefinition: 'IIIII class' category: 'Peano' stamp: 'MS 8/28/2023 15:13:46'!
IIIII class
	instanceVariableNames: 'next existeSiguiente previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:46'!
*unNatural
	unNatural = I ifTrue: [^self].
	^(self previous * unNatural) + unNatural! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:46'!
+ aNaturalNumber
	^ self previous + aNaturalNumber next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:46'!
- aNaturalNumber
	aNaturalNumber  = I ifTrue:[^self previous].
	^self previous - (aNaturalNumber previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:46'!
/ unNatural
	|rec|
	unNatural = self ifTrue: [^I].
	self < unNatural ifTrue: [^nil].
	(unNatural < self)ifTrue:[
		rec := ((self - unNatural)/(unNatural)).
		rec = nil ifTrue: [^I].
		^rec + I.
		].! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:46'!
< unNatural
	unNatural = I ifTrue: [^false].
	^(self previous < unNatural previous)! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:46'!
next
	next ifNil: [next := self cloneNamed: self name, 'I'.].
	next previous: self.
	^next
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:46'!
previous
	^previous
	! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MS 8/28/2023 15:13:46'!
previous: aNaturalNumber
	previous := aNaturalNumber.! !

IIIII / II!

IIIII / III!

II / II!

III / II!

IIII/II!

IIII/III!
!I class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 15:14:32' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 15:14:32' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	existeSiguiente := true.
	previous := I.! !
!III class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 15:14:32' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	existeSiguiente := true.
	previous := II.! !
!IIII class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 15:14:32' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	existeSiguiente := true.
	previous := III.! !
!IIIII class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 15:14:32' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	existeSiguiente := true.
	previous := IIII.! !

!methodRemoval: I class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 15:14:33'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.!

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 15:14:33'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	existeSiguiente := true.
	previous := I.!

!methodRemoval: III class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 15:14:33'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	existeSiguiente := true.
	previous := II.!

!methodRemoval: IIII class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 15:14:33'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	existeSiguiente := true.
	previous := III.!

!methodRemoval: IIIII class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 15:14:33'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	existeSiguiente := true.
	previous := IIII.!

II / III!

!classRemoval: #IIIII stamp: 'MS 8/28/2023 15:18:40'!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #IIII stamp: 'MS 8/28/2023 15:18:43'!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classRemoval: #III stamp: 'MS 8/28/2023 15:18:47'!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!
!I class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 15:18:55' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'MS 8/28/2023 15:18:55' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := AnObsoleteIII.
	existeSiguiente := true.
	previous := I.! !

!methodRemoval: I class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 15:18:55'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := II.
	existeSiguiente := true.
	previous := nil.!

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'MS 8/28/2023 15:18:55'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := AnObsoleteIII.
	existeSiguiente := true.
	previous := I.!

----STARTUP---- (1 September 2023 13:34:03) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


Object subclass: #XXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW2'!

!classDefinition: #XXX category: 'ISW2' stamp: 'MS 9/1/2023 13:35:38'!
Object subclass: #XXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW2'!

XXX new!

XXX new!
!XXX methodsFor: 'no messages' stamp: 'MS 9/1/2023 13:37:13'!
findOddsPart0

        | elements index odds |

        elements:= #(1 2 5 6 9).

        odds := OrderedCollection new.
        index := 1.

        [index <= elements size]
        whileTrue: [
                ((elements at: index) odd) ifTrue: [odds add: (elements at: index)].
                index := index +1.
                ].
        ^odds! !

#(1 2 5 6 9)!

----End fileIn of /home/martin/Desktop/Inge1/linux64/linux64/Packages/TerseGuide.pck.st----!
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:45:54' prior: 50650411!
findOddsPart0

        | elements index odds |

        elements:= #(1 2 5 6 9).

        odds := OrderedCollection new.
        index := 1.
elements do: [:a| a odd ifTrue: [odds add: a]]
		
 
        ^odds! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:45:58' prior: 50653345!
findOddsPart0

        | elements index odds |

        elements:= #(1 2 5 6 9).

        odds := OrderedCollection new.
        index := 1.
	elements do: [:a| a odd ifTrue: [odds add: a]]
		
 
        ^odds! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:46:07' prior: 50653355!
findOddsPart0

        | elements index odds |

        elements:= #(1 2 5 6 9).

        odds := OrderedCollection new.
	elements do: [:a| a odd ifTrue: [odds add: a]]
		
 
        ^odds! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:46:10' prior: 50653365!
findOddsPart0

        | elements index odds |

        elements:= #(1 2 5 6 9).

        odds := OrderedCollection new.
	elements do: [:a| a odd ifTrue: [odds add: a]]
		
 
        ^odds! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:46:29' prior: 50653374!
findOddsPart0

        | elements odds |

        elements:= #(1 2 5 6 9).

        odds := OrderedCollection new.
	elements do: [:a| a odd ifTrue: [odds add: a]]
		
 
        ^odds! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:46:58' prior: 50653383!
findOddsPart0

        | elements odds |

        elements:= #(1 2 5 6 9).
	odds := OrderedCollection new.
	elements do: [:a| a odd ifTrue: [odds add: a]]
		
 
        ^odds! !

XXX new!

(XXX new) findOddsPart0!

(XXX new) findOddsPart0!
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:48:03' prior: 50653392!
findOddsPart0

        | elements odds |

        elements:= #(1 2 5 6 9).
	odds := OrderedCollection new.
	elements do: [:a| a odd ifTrue: [odds add: a]].
        ^odds! !

(XXX new) findOddsPart0!

(XXX new) findOddsPart0!

(XXX new) findOddsPart0!

(XXX new) findOddsPart0!

(XXX new) findOddsPart0!

(XXX new) findOddsPart0!

(XXX new) findOddsPart0!

(XXX new) findOddsPart0!

(XXX new) findOddsPart0!

(XXX new) findOddsPart0!

(XXX new) findOddsPart0!
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:49:02'!
findOddsPart2

        | elements odds |

        elements:= #(1 2 5 6 9).
	odds := OrderedCollection new.
	elements do: [:a| a odd ifTrue: [odds add: a]].
        ^odds! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:49:09'!
findOddsPart1

        | elements odds |

        elements:= #(1 2 5 6 9).
	odds := OrderedCollection new.
	elements do: [:a| a odd ifTrue: [odds add: a]].
        ^odds! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:50:35' prior: 50653428!
findOddsPart1

        | elements |

        elements:= #(1 2 5 6 9).
        ^elements select: [:a| a is odd]! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:50:38' prior: 50653437!
findOddsPart1

        | elements |

        elements:= #(1 2 5 6 9).
        ^elements select: [:a| a is odd].! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:50:53' prior: 50653444!
findOddsPart1

        | elements |

        elements:= #(1 2 5 6 9).
        ^elements select: [:a| a odd].! !

(XXX new) findOddsPart1 !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:51:45'!
findDoubles

        | elements odds |

        elements:= #(1 2 5 6 9).
	odds := OrderedCollection new.
	elements do: [:a| a odd ifTrue: [odds add: a]].
        ^odds! !

OrderedCollection!

SequenceableCollection!
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:57:11' prior: 50653458!
findDoubles

        | elements res index |

        elements:= #(1 2 5 6 9).
	res := OrderedCollection new.
	index := 1.
	[index <= elements size]
		whileTrue: [res add: (elements at: index) * 2.index := index + 1.]
        ^res! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 13:57:23' prior: 50653468!
findDoubles

        | elements res index |

        elements:= #(1 2 5 6 9).
	res := OrderedCollection new.
	index := 1.
	[index <= elements size]
		whileTrue: [res add: (elements at: index) * 2.index := index + 1.].
        ^res! !

x findDoubles !

x!

x!

x := XXX new.!

x findDoubles!

x findDoubles!
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:00:50' prior: 50653478!
findDoubles

        | elements res index |

        elements:= #(1 2 5 6 9).
	res := OrderedCollection new.
	elements do: [:a| res add: (a * 2)].
        ^res! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:00:55' prior: 50653491!
findDoubles

        | elements res |

        elements:= #(1 2 5 6 9).
	res := OrderedCollection new.
	elements do: [:a| res add: (a * 2)].
        ^res! !

x := XXX new.!

x findDoubles!
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:02:56' prior: 50653499!
findDoubles

        | elements res |

        elements:= #(1 2 5 6 9).
        ^elements collect: [:a | 2 * a]! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:03:00' prior: 50653508!
findDoubles

        | elements  |

        elements:= #(1 2 5 6 9).
        ^elements collect: [:a | 2 * a]! !

x := XXX new.!

x findDoubles!

x := XXX new.!

x findDoubles !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:04:55'!
findFirstEven

        | elements  |

        elements:= #(1 2 5 6 9).
        ^elements detect: [:a | a even]! !

x := XXX new.!

x findFirstEven!
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:05:14' prior: 50653523!
findFirstEven

        | elements  |

        elements:= #(1 3 5 7 9).
        ^elements detect: [:a | a even]! !

x := XXX new.!

x findFirstEven!
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:05:38' prior: 50653531!
findFirstEven

        | elements  |

        elements:= #(1 3 5 7 9).
        ^elements detect: [:a | a even] ifNone: [].! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:05:44' prior: 50653539!
findFirstEven

        | elements  |

        elements:= #(1 3 5 7 9).
        ^elements detect: [:a | a even] ifNone: -1.! !

x := XXX new.!

x findFirstEven!

x findFirstEven!
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:06:29' prior: 50653546!
findFirstEven

        | elements  |

        elements:= #(1 3 5 7 9).
        ^elements detect: [:a | a even] ifNone: [self error: 'No hay un even']! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:06:31' prior: 50653555!
findFirstEven

        | elements  |

        elements:= #(1 3 5 7 9).
        ^elements detect: [:a | a even] ifNone: [self error: 'No hay un even'].! !

x := XXX new.!

x findFirstEven!
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:07:34' prior: 50653563!
findFirstEven

        | elements  |

        elements:= #(1 3 5 7 9).
        ^elements detect: [:a | a even] ifNone: [self error: 'No hay un even'].! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:08:42'!
findFirstEvenWithoutMatching

        | elements  |

        elements:= #(1 3 5 7 9).
        ^elements detect: [:a | a even] ifNone: [self error: 'No hay un even'].! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:11:27'!
sumElementsInjecting
        | elements  |

        elements:= #(1 3 5 7 9).
        ^elements detect: [:a | a even] ifNone: [self error: 'No hay un even'].! !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:14:46' prior: 50653587!
sumElementsInjecting
        | elements  |

        elements:= #(1 3 5 7 9).
        ^elements  inject: 0 into: [:rec :actual | rec + actual]! !

x := XXX new.!

x sumElementsInjecting !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:15:53'!
sumElementsSum
        | elements  |

        elements:= #(1 3 5 7 9).
        ^elements  inject: 0 into: [:rec :actual | rec + actual]! !

OrderedCollection!
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:23:56' prior: 50653604!
sumElementsSum
        | elements  |

        elements:= #(1 3 5 7 9).
        ^elements sum! !

x := XXX new.!

x sumElementsSum !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:24:27'!
extractVowels
        | elements  |

        elements:= #(1 3 5 7 9).
        ^elements sum! !

#(1 3 5 7 9)!

#(1 3 5 7 9)!

#(1 3 5 7 9)!

Array !
!XXX methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:28:35' prior: 50653619!
extractVowels
        | word |
	word := 'abcdefgh'.
        ^word select: [:a | a isVowel]! !

x := XXX new.!

x extractVowels !

----End fileIn of /home/martin/Desktop/Inge1/Repo/Inge1_Santesteban_Segre/peano.st----!

!classRemoval: #llllllllllllllll stamp: 'MS 9/1/2023 14:35:46'!
ll subclass: #llllllllllllllll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #lllllllllllllll stamp: 'MS 9/1/2023 14:35:46'!
ll subclass: #lllllllllllllll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #llllllllllllll stamp: 'MS 9/1/2023 14:35:46'!
ll subclass: #llllllllllllll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #lllllllllllll stamp: 'MS 9/1/2023 14:35:46'!
ll subclass: #lllllllllllll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #llllllllllll stamp: 'MS 9/1/2023 14:35:47'!
ll subclass: #llllllllllll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #lllllllllll stamp: 'MS 9/1/2023 14:35:47'!
ll subclass: #lllllllllll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #llllllllll stamp: 'MS 9/1/2023 14:35:47'!
ll subclass: #llllllllll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #lllllllll stamp: 'MS 9/1/2023 14:35:47'!
ll subclass: #lllllllll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #llllllll stamp: 'MS 9/1/2023 14:35:47'!
ll subclass: #llllllll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #lllllll stamp: 'MS 9/1/2023 14:35:47'!
ll subclass: #lllllll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #llllll stamp: 'MS 9/1/2023 14:35:48'!
ll subclass: #llllll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #lllll stamp: 'MS 9/1/2023 14:35:48'!
ll subclass: #lllll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #llll stamp: 'MS 9/1/2023 14:35:48'!
ll subclass: #llll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #lll stamp: 'MS 9/1/2023 14:35:48'!
ll subclass: #lll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #ll stamp: 'MS 9/1/2023 14:35:48'!
DenotativeObject subclass: #ll
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #l stamp: 'MS 9/1/2023 14:35:48'!
DenotativeObject subclass: #l
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

!classRemoval: #conversor stamp: 'MS 9/1/2023 14:35:49'!
DenotativeObject subclass: #conversor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'peano'!

----End fileIn of /home/martin/Desktop/Inge1/Repo/Inge1_Santesteban_Segre/00-NumerosNaturales/Numeros Naturales.st----!

I previous !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/1/2023 14:44:56' prior: 50654609!
restateA: aNaturalNumber
	^(aNaturalNumber previous - self previous)! !

----STARTUP---- (5 September 2023 12:05:58) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/GuiaDeEjercicios/CodigoRepetido/CodigoRepetido-Ejercicio.st----!

----End fileIn of /home/martin/Desktop/Inge1/GuiaDeEjercicios/CodigoRepetido/CodigoRepetido-Ejercicio.st----!
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 12:13:22'!
xxxx: unBloque
	"comment stating purpose of message"

	| millisecondsBeforeRunning millisecondsAfterRunning|
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	unBloque value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 12:13:40'!
medirTiempo: unBloque
	"comment stating purpose of message"

	| millisecondsBeforeRunning millisecondsAfterRunning|
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	unBloque value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 12:14:05' prior: 50655477!
medirTiempo: unBloque
	| millisecondsBeforeRunning millisecondsAfterRunning|
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	unBloque value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 12:14:28' prior: 50655489!
medirTiempo: unBloque
	| millisecondsBeforeRunning millisecondsAfterRunning|
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	unBloque value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	^ (millisecondsAfterRunning  - millisecondsBeforeRunning )! !

!methodRemoval: CustomerBookTest #xxxx: stamp: 'MS 9/5/2023 12:14:37'!
xxxx: unBloque
	"comment stating purpose of message"

	| millisecondsBeforeRunning millisecondsAfterRunning|
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	unBloque value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.!
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 12:17:32' prior: 50655210!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	self assert: (self medirTiempo: [ customerBook addCustomerNamed: 'John Lennon'.]) < (50 * millisecond).
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 12:18:15' prior: 50655227!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook millisecondsBeforeRunning millisecondsAfterRunning paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	

	customerBook removeCustomerNamed: paulMcCartney.

	
	self assert: (self medirTiempo: [customerBook removeCustomerNamed: paulMcCartney.]) < (100 * millisecond)
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 12:18:26' prior: 50655533!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook  paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	

	customerBook removeCustomerNamed: paulMcCartney.

	
	self assert: (self medirTiempo: [customerBook removeCustomerNamed: paulMcCartney.]) < (100 * millisecond)
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 12:20:03' prior: 50655548!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook  paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	self assert: (self medirTiempo: [customerBook removeCustomerNamed: paulMcCartney.]) < (100 * millisecond)
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 12:21:56' prior: 50655562!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook  paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	self assert: (self medirTiempo: [customerBook removeCustomerNamed: paulMcCartney.]) < (100 * millisecond)
	
! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 12:27:58'!
xxxx: aCustomerBook xx: x yy: y zz: z
	self assert: x equals: aCustomerBook numberOfActiveCustomers.
	self assert: y equals: aCustomerBook numberOfSuspendedCustomers.
	self assert: z equals: aCustomerBook numberOfCustomers.! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 12:32:41'!
xxxx: aCustomerBook numberOfActiveCustomers: activeCustomers numberOfSuspendedCustomers: suspendedCustomers totalNumberOfCustomers: totalCustomers
	self assert: activeCustomers equals: aCustomerBook numberOfActiveCustomers.
	self assert: suspendedCustomers equals: aCustomerBook numberOfSuspendedCustomers.
	self assert: totalCustomers equals: aCustomerBook numberOfCustomers.! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 12:36:13'!
assertCustomerMetrics: aCustomerBook numberOfActiveCustomers: activeCustomers numberOfSuspendedCustomers: suspendedCustomers totalNumberOfCustomers: totalCustomers
	self assert: activeCustomers equals: aCustomerBook numberOfActiveCustomers.
	self assert: suspendedCustomers equals: aCustomerBook numberOfSuspendedCustomers.
	self assert: totalCustomers equals: aCustomerBook numberOfCustomers.! !

!methodRemoval: CustomerBookTest #xxxx:numberOfActiveCustomers:numberOfSuspendedCustomers:totalNumberOfCustomers: stamp: 'MS 9/5/2023 12:36:24'!
xxxx: aCustomerBook numberOfActiveCustomers: activeCustomers numberOfSuspendedCustomers: suspendedCustomers totalNumberOfCustomers: totalCustomers
	self assert: activeCustomers equals: aCustomerBook numberOfActiveCustomers.
	self assert: suspendedCustomers equals: aCustomerBook numberOfSuspendedCustomers.
	self assert: totalCustomers equals: aCustomerBook numberOfCustomers.!

!methodRemoval: CustomerBookTest #xxxx:xx:yy:zz: stamp: 'MS 9/5/2023 12:36:32'!
xxxx: aCustomerBook xx: x yy: y zz: z
	self assert: x equals: aCustomerBook numberOfActiveCustomers.
	self assert: y equals: aCustomerBook numberOfSuspendedCustomers.
	self assert: z equals: aCustomerBook numberOfCustomers.!
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 12:37:41' prior: 50655277!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	
	self assertCustomerMetrics: customerBook numberOfActiveCustomers: 0 numberOfSuspendedCustomers:  1 totalNumberOfCustomers: 1.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 12:37:46'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 12:37:46'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 12:37:46'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 12:37:46'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 12:37:46'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 12:37:46'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 12:37:46'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 12:37:46'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 12:37:46'!
ERROR!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 12:38:20'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 12:38:20'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 12:38:20'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 12:38:20'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 12:38:20'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 12:38:20'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 12:38:20'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 12:38:20'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 12:38:20'!
ERROR!
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 12:39:31' prior: 50655574!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook  paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	customerBook addCustomerNamed: paulMcCartney.
	self assert: (self medirTiempo: [customerBook removeCustomerNamed: paulMcCartney.]) < (100 * millisecond)
	
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 12:39:38'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 12:39:38'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 12:39:38'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 12:39:38'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 12:39:38'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 12:39:38'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 12:39:38'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 12:39:38'!
PASSED!
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 12:40:21' prior: 50655297!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertCustomerMetrics: customerBook numberOfActiveCustomers:  0 numberOfSuspendedCustomers:  0 totalNumberOfCustomers: 0.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 12:40:28'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 12:40:28'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 12:40:28'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 12:40:28'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 12:40:28'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 12:40:28'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 12:40:28'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 12:40:28'!
PASSED!

----End fileIn of /home/martin/Downloads/CodigoRepetido-Ejercicio.st----!

!methodRemoval: CustomerBookTest #medirTiempo: stamp: 'MS 9/5/2023 13:58:46'!
medirTiempo: unBloque
	| millisecondsBeforeRunning millisecondsAfterRunning|
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	unBloque value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	^ (millisecondsAfterRunning  - millisecondsBeforeRunning )!
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 14:00:38'!
medirTiempo: aBlock

	|millisecondsBeforeRunning millisecondsAfterRunning|

	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	^(millisecondsAfterRunning-millisecondsBeforeRunning)! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'MS 9/5/2023 14:00:38' prior: 50655875!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds
	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.	
	customerBook := self libroConCliente: paulMcCartney.
	
	self assert: ((self medirTiempo: 
			[customerBook removeCustomerNamed: paulMcCartney.] )
		
			< (100 * millisecond))
	
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'MS 9/5/2023 14:00:38' prior: 50655865!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds
	| customerBook|
	
	customerBook := CustomerBook new.
	
	self assert: ((self medirTiempo: 
			[customerBook addCustomerNamed: 'John Lennon'.])
		 	< (50 * millisecond))
 	
! !

!methodRemoval: CustomerBookTest #tomarTiempo: stamp: 'MS 9/5/2023 14:00:38'!
tomarTiempo: aBlock

	|millisecondsBeforeRunning millisecondsAfterRunning|

	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	^(millisecondsAfterRunning-millisecondsBeforeRunning)!
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 14:02:15'!
XXXX: xxx YYYY: yyy ZZZZ: zzz
! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 14:02:18' prior: 50656191!
XXXX: xxx YYYY: yyy ZZZZ: zzz
	! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 14:03:00' prior: 50656195!
XXXX: xxx YYYY: yyy ZZZZ: zzz
	[xxx value. self fail]
		on: yyy 
		do: [:anError | zzz value.]! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 14:04:25' prior: 50656199!
XXXX: xxx YYYY: yyy ZZZZ: zzz
	[xxx value. self fail]
		on: yyy 
		do: zzz value.! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 14:06:51'!
XXXX: xxx errorType: yyy errorHandler: zzz
	[xxx value. self fail]
		on: yyy 
		do: zzz value.! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 14:10:35'!
blockExpectedToFail: xxx errorExpected: yyy onCatchDo: zzz
	[xxx value. self fail]
		on: yyy 
		do: zzz value.! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 14:12:28'!
blockExpectedToFail: aClosure errorExpected: anError errorHandler: aHandler
	[aClosure value. self fail]
		on: anError 
		do: aHandler value.! !

!methodRemoval: CustomerBookTest #XXXX:errorType:errorHandler: stamp: 'MS 9/5/2023 14:12:33'!
XXXX: xxx errorType: yyy errorHandler: zzz
	[xxx value. self fail]
		on: yyy 
		do: zzz value.!

!methodRemoval: CustomerBookTest #XXXX:YYYY:ZZZZ: stamp: 'MS 9/5/2023 14:12:37'!
XXXX: xxx YYYY: yyy ZZZZ: zzz
	[xxx value. self fail]
		on: yyy 
		do: zzz value.!

!methodRemoval: CustomerBookTest #blockExpectedToFail:errorExpected:onCatchDo: stamp: 'MS 9/5/2023 14:13:06'!
blockExpectedToFail: xxx errorExpected: yyy onCatchDo: zzz
	[xxx value. self fail]
		on: yyy 
		do: zzz value.!
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:14:49' prior: 50655888!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.
	
	self blockExpectedToFail: [customerBook addCustomerNamed: ''.] 
		errorExpected:  Error 
		errorHandler: 	[ :anError | 
			self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
			self assert: customerBook isEmpty ].
	! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 14:16:09'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 14:16:09'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 14:16:09'!
ERROR!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 14:16:09'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:16:09'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:16:09'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 14:16:09'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:16:09'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 14:16:09'!
ERROR!
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 14:16:25' prior: 50656222!
blockExpectedToFail: aClosure errorExpected: anError errorHandler: aHandler
	[aClosure value. self fail]
		on: anError 
		do: aHandler.! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 14:16:27'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 14:16:27'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 14:16:27'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 14:16:27'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:16:27'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:16:27'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 14:16:27'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:16:27'!
PASSED!
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:17:40' prior: 50655901!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self libroConCliente: johnLennon.
	
	self blockExpectedToFail: [ customerBook removeCustomerNamed: 'Paul McCartney'.] 
		errorExpected:  NotFound  
		errorHandler: 	[ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ].! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:17:47' prior: 50656332!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self libroConCliente: johnLennon.
	
	self blockExpectedToFail: [ customerBook removeCustomerNamed: 'Paul McCartney'.] 
		errorExpected:  NotFound  
		errorHandler: 	[ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ]! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 14:17:52'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 14:17:52'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 14:17:52'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 14:17:52'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:17:52'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:17:52'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 14:17:52'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:17:52'!
PASSED!
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 14:23:01'!
cantDo: aClosure errorExpected: anError errorHandler: aHandler
	[aClosure value. self fail]
		on: anError 
		do: aHandler.! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'MS 9/5/2023 14:23:01' prior: 50656348!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self libroConCliente: johnLennon.
	
	self cantDo: [ customerBook removeCustomerNamed: 'Paul McCartney'.] 
		errorExpected:  NotFound  
		errorHandler: 	[ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ]! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'MS 9/5/2023 14:23:01' prior: 50656248!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.
	
	self cantDo: [customerBook addCustomerNamed: ''.] 
		errorExpected:  Error 
		errorHandler: 	[ :anError | 
			self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
			self assert: customerBook isEmpty ].
	! !

!methodRemoval: CustomerBookTest #blockExpectedToFail:errorExpected:errorHandler: stamp: 'MS 9/5/2023 14:23:01'!
blockExpectedToFail: aClosure errorExpected: anError errorHandler: aHandler
	[aClosure value. self fail]
		on: anError 
		do: aHandler.!
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:25:28' prior: 50655952!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self libroConCliente: johnLennon.
	
	self cantDo: [ customerBook suspendCustomerNamed: 'George Harrison'.]
		errorExpected:  CantSuspend
		errorHandler: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ].! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:26:15' prior: 50655967!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	customerBook suspendCustomerNamed: johnLennon.
	
	self cantDo: [ customerBook suspendCustomerNamed: johnLennon.]
		errorExpected:  CantSuspend
		errorHandler: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ].
	
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:27:06' prior: 50656455!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook := self libroConCliente: johnLennon.
	
	self cantDo: [ customerBook suspendCustomerNamed: johnLennon.]
		errorExpected:  CantSuspend
		errorHandler: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ].
	
	
! !

(self new) !

(self new) !

(self new) !

(self new) !

(self new) !

(self new) !
!CustomerBook class methodsFor: 'nil' stamp: 'MS 9/5/2023 14:30:08'!
singleCustomerBook:  aName
	^(self new) addCustomerNamed: aName! !

!methodRemoval: CustomerBookTest #libroConCliente: stamp: 'MS 9/5/2023 14:34:31'!
libroConCliente: aCostumer

	|customerBook|
	customerBook := CustomerBook new.
	customerBook addCustomerNamed: aCostumer .
	^customerBook !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:36:05' prior: 50656156!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds
	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.	
	customerBook  := CustomerBook singleCustomerBook: paulMcCartney.
	
	self assert: ((self medirTiempo: 
			[customerBook removeCustomerNamed: paulMcCartney.] )
		
			< (100 * millisecond))
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:36:27' prior: 50656401!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook singleCustomerBook:  johnLennon.
	
	self cantDo: [ customerBook removeCustomerNamed: 'Paul McCartney'.] 
		errorExpected:  NotFound  
		errorHandler: 	[ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:36:32' prior: 50655916!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := CustomerBook singleCustomerBook:  paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	
	self assertCustomerMetrics: customerBook 
	numberOfActiveCustomers: 0 
	numberOfSuspendedCustomers: 1 
	totalNumberOfCustomers: 1.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:36:37' prior: 50655933!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := CustomerBook singleCustomerBook:  paulMcCartney.
	
	customerBook suspendCustomerNamed: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertCustomerMetrics: customerBook 
	numberOfActiveCustomers: 0 
	numberOfSuspendedCustomers: 0 
	totalNumberOfCustomers: 0.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:36:45' prior: 50656439!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook singleCustomerBook: johnLennon.
	
	self cantDo: [ customerBook suspendCustomerNamed: 'George Harrison'.]
		errorExpected:  CantSuspend
		errorHandler: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ].! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:36:52' prior: 50656474!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook singleCustomerBook:  johnLennon.
	
	self cantDo: [ customerBook suspendCustomerNamed: johnLennon.]
		errorExpected:  CantSuspend
		errorHandler: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ].
	
	
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 14:36:59'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 14:36:59'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 14:36:59'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 14:36:59'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:36:59'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:36:59'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 14:36:59'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:36:59'!
FAILURE!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:36:59'!
FAILURE!
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:37:35' prior: 50656587!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook singleCustomerBook:  johnLennon.
	
	self cantDo: [ customerBook suspendCustomerNamed: johnLennon.]
		errorExpected:  CantSuspend
		errorHandler: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ].
	
	
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 14:37:39'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 14:37:39'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 14:37:39'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 14:37:39'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:37:39'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:37:39'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 14:37:39'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:37:39'!
FAILURE!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:37:39'!
FAILURE!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 14:38:08'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 14:38:08'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 14:38:08'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 14:38:08'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:38:08'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:38:08'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 14:38:08'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:38:08'!
FAILURE!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:38:08'!
FAILURE!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 14:38:16'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 14:38:16'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 14:38:16'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 14:38:16'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:38:16'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:38:16'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 14:38:16'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:38:16'!
FAILURE!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:38:16'!
FAILURE!
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:38:47' prior: 50656638!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook singleCustomerBook:  johnLennon.
	
	self cantDo: [ customerBook suspendCustomerNamed: johnLennon.]
		errorExpected:  CantSuspend
		errorHandler: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon).].
	
	
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 14:38:50'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 14:38:50'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 14:38:50'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 14:38:50'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:38:50'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:38:50'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 14:38:50'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:38:50'!
FAILURE!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:38:50'!
FAILURE!
!CustomerBook class methodsFor: 'custom initializers' stamp: 'MS 9/5/2023 14:40:17' prior: 50656493!
singleCustomerBook:  aName
	^self new addCustomerNamed: aName! !
!CustomerBook class methodsFor: 'custom initializers' stamp: 'MS 9/5/2023 14:40:21' prior: 50656804!
singleCustomerBook:  aName
	^(self new addCustomerNamed: aName)! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 14:40:25'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 14:40:25'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 14:40:25'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 14:40:25'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:40:25'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:40:25'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 14:40:25'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:40:25'!
FAILURE!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:40:25'!
FAILURE!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:41:19'!
FAILURE!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:41:19'!
FAILURE!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:42:12'!
FAILURE!
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:43:33' prior: 50656754!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook singleCustomerBook:  johnLennon.
	customerBook suspendCustomerNamed: johnLennon.
	
	self cantDo: [ customerBook suspendCustomerNamed: johnLennon.]
		errorExpected:  CantSuspend
		errorHandler: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon).].
	
	
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 14:43:35'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 14:43:35'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 14:43:35'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 14:43:35'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:43:35'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 14:43:35'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 14:43:35'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 14:43:35'!
PASSED!
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 14:52:02' prior: 50656859!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook singleCustomerBook:  johnLennon.
	customerBook suspendCustomerNamed: johnLennon.

	self cantDo: [ customerBook suspendCustomerNamed: johnLennon.]
		errorExpected:  CantSuspend
		errorHandler: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon).].
	
	
! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 14:59:34'!
onlyJohnLennon: aCustomerBook

	self assert: 	aCustomerBook numberOfCustomers = 1.
	self assert: (aCustomerBook includesCustomerNamed: 'John Lennon').! !
!CustomerBookTest methodsFor: 'utility' stamp: 'MS 9/5/2023 15:00:12'!
assertOnlyJohnLennon: aCustomerBook

	self assert: 	aCustomerBook numberOfCustomers = 1.
	self assert: (aCustomerBook includesCustomerNamed: 'John Lennon').! !

!methodRemoval: CustomerBookTest #onlyJohnLennon: stamp: 'MS 9/5/2023 15:00:17'!
onlyJohnLennon: aCustomerBook

	self assert: 	aCustomerBook numberOfCustomers = 1.
	self assert: (aCustomerBook includesCustomerNamed: 'John Lennon').!
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 15:00:48' prior: 50656571!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook singleCustomerBook: johnLennon.
	
	self cantDo: [ customerBook suspendCustomerNamed: 'George Harrison'.]
		errorExpected:  CantSuspend
		errorHandler: [ :anError | self assertOnlyJohnLennon: customerBook].! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 15:01:04' prior: 50656907!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook singleCustomerBook:  johnLennon.
	customerBook suspendCustomerNamed: johnLennon.

	self cantDo: [ customerBook suspendCustomerNamed: johnLennon.]
		errorExpected:  CantSuspend
		errorHandler: [ :anError | self assertOnlyJohnLennon: customerBook].
	
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 15:01:28' prior: 50656518!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook singleCustomerBook:  johnLennon.
	
	self cantDo: [ customerBook removeCustomerNamed: 'Paul McCartney'.] 
		errorExpected:  NotFound  
		errorHandler: 	[ :anError | self assertOnlyJohnLennon: customerBook]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 15:01:49' prior: 50656534!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := CustomerBook singleCustomerBook:  paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	
	self assertCustomerMetrics: customerBook 
		numberOfActiveCustomers: 0 
		numberOfSuspendedCustomers: 1 
		totalNumberOfCustomers: 1.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'MS 9/5/2023 15:01:55' prior: 50656552!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := CustomerBook singleCustomerBook:  paulMcCartney.
	
	customerBook suspendCustomerNamed: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertCustomerMetrics: customerBook 
		numberOfActiveCustomers: 0 
		numberOfSuspendedCustomers: 0 
		totalNumberOfCustomers: 0.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 15:06:01'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 15:06:01'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 15:06:01'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 15:06:01'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 15:06:01'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 15:06:01'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 15:06:01'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 15:06:01'!
PASSED!
!CustomerBook methodsFor: 'customer management' stamp: 'MS 9/5/2023 15:11:27' prior: 50656075!
removeCustomerNamed: aName 

	active := active reject: [:name | name = aName].
	.

	1 to: suspended size do: 	
	[ :index |
		aName = (suspended at: index)
			ifTrue: [
				suspended removeAt: index.
				^ aName 
			] 
	].
	
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'MS 9/5/2023 15:11:27' prior: 50657060!
removeCustomerNamed: aName 

	active := active reject: [:name | name = aName].
	

	1 to: suspended size do: 	
	[ :index |
		aName = (suspended at: index)
			ifTrue: [
				suspended removeAt: index.
				^ aName 
			] 
	].
	
	^ NotFound signal.
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'MS 9/5/2023 15:11:54'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 15:11:54'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'MS 9/5/2023 15:11:54'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'MS 9/5/2023 15:11:54'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'MS 9/5/2023 15:11:54'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'MS 9/5/2023 15:11:54'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'MS 9/5/2023 15:11:54'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'MS 9/5/2023 15:11:54'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'MS 9/5/2023 15:11:54'!
ERROR!
!CustomerBook methodsFor: 'customer management' stamp: 'MS 9/5/2023 15:14:36' prior: 50657071!
removeCustomerNamed: aName 

	active := active reject: [:name | name = aName ifTrue:[^name]].
	

	1 to: suspended size do: 	
	[ :index |
		aName = (suspended at: index)
			ifTrue: [
				suspended removeAt: index.
				^ aName 
			] 
	].
	
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'MS 9/5/2023 15:15:05' prior: 50657116!
removeCustomerNamed: aName 

	active := active reject: [:name | name = aName].
	

	1 to: suspended size do: 	
	[ :index |
		aName = (suspended at: index)
			ifTrue: [
				suspended removeAt: index.
				^ aName 
			] 
	].
	
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'MS 9/5/2023 15:26:13'!
XXXX: xxx YYYY: yyy
1 to: xxx size do: 	
	[ :index |
		(yyy = xxx at: index)
			ifTrue: [
				xxx removeAt: index.
				^ yyy
			] 
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'MS 9/5/2023 15:29:58'!
List:list YYYY: customerName
1 to: list size do: 	
	[ :index |
		(customerName = list at: index)
			ifTrue: [
				list removeAt: index.
				^ customerName
			] 
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'MS 9/5/2023 15:34:33'!
RemoveCustomerFrom: list customer: customerName
1 to: list size do: 	
	[ :index |
		(customerName = list at: index)
			ifTrue: [
				list removeAt: index.
				^ customerName
			] 
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'MS 9/5/2023 15:50:00' prior: 50657128!
removeCustomerNamed: aName 

	1 to: active size do: 	
	[ :index |
		aName = (active at: index)
			ifTrue: [
				active removeAt: index.
				^ aName 
			] 
	].
	

	1 to: suspended size do: 	
	[ :index |
		aName = (suspended at: index)
			ifTrue: [
				suspended removeAt: index.
				^ aName 
			] 
	].
	
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'MS 9/5/2023 15:50:05' prior: 50657163!
removeCustomerNamed: aName 

	1 to: active size do: 	
	[ :index |
		aName = (active at: index)
			ifTrue: [
				active removeAt: index.
				^ aName 
			] 
	].
	
	1 to: suspended size do: 	
	[ :index |
		aName = (suspended at: index)
			ifTrue: [
				suspended removeAt: index.
				^ aName 
			] 
	].
	
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'MS 9/5/2023 15:51:16' prior: 50657177!
removeCustomerNamed: aName 

	1 to: active size do: 	
	[ :index |
		aName = (active at: index)
			ifTrue: [
				active removeAt: index.
				^ aName 
			] 
	].
	
	1 to: suspended size do: 	
	[ :index |
		aName = (suspended at: index)
			ifTrue: [
				suspended removeAt: index.
				^ aName 
			] 
	].
	
	^ NotFound signal.
! !

----STARTUP---- (7 September 2023 14:47:42) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Downloads/CodigoRepetido-Ejercicio(2).st----!

----STARTUP---- (12 September 2023 12:52:20) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/ClasesDeInge1/02-Numeros/Numero-Exercise.st----!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test07FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test08FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test09AparentFraccionesAreEqual stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test10AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test11MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test12AFraccionCanNotBeZero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test13AFraccionCanNotBeOne stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 12:54:08'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 12:54:08'!
ERROR!

!testRun: #NumeroTest #test14NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 12:54:08'!
ERROR!

!testRun: #NumeroTest #test15NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 12:54:08'!
FAILURE!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 12:54:08'!
ERROR!

!testRun: #NumeroTest #test16SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test17SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 12:54:08'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 12:54:08'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 12:54:08'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 12:54:08'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 12:54:08'!
PASSED!

!classRemoval: #Fraccion stamp: 'MS 9/12/2023 12:54:52'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Entero stamp: 'MS 9/12/2023 12:54:52'!
Numero subclass: #Entero
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Numero stamp: 'MS 9/12/2023 12:54:53'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #NumeroTest stamp: 'MS 9/12/2023 12:54:53'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

----STARTUP---- (12 September 2023 12:56:50) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/ClasesDeInge1/02-Numeros/Pre-Numeros-Ejercicio.st----!

----End fileIn of /home/martin/Desktop/Inge1/ClasesDeInge1/02-Numeros/Numero-Exercise.st----!

!classRemoval: #Fraccion stamp: 'MS 9/12/2023 12:59:54'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Entero stamp: 'MS 9/12/2023 12:59:54'!
Numero subclass: #Entero
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Numero stamp: 'MS 9/12/2023 12:59:54'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #NumeroTest stamp: 'MS 9/12/2023 12:59:55'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

----STARTUP---- (12 September 2023 13:03:40) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/ClasesDeInge1/02-Numeros/Numero-Exercise.st----!

!classRemoval: #Fraccion stamp: 'MS 9/12/2023 13:05:13'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Entero stamp: 'MS 9/12/2023 13:05:14'!
Numero subclass: #Entero
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Numero stamp: 'MS 9/12/2023 13:05:14'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #NumeroTest stamp: 'MS 9/12/2023 13:05:14'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

----End fileIn of /home/martin/Desktop/Inge1/ClasesDeInge1/02-Numeros/Numero-Ej.st----!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 13:06:05'!
ERROR!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 13:06:05'!
ERROR!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 13:06:05'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 13:06:05'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 13:06:05'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 13:06:05'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 13:06:05'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 13:06:05'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 13:06:05'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 13:06:05'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 13:06:05'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 13:06:05'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 13:06:05'!
ERROR!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 13:06:24'!
ERROR!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 13:06:24'!
ERROR!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 13:06:24'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 13:06:24'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 13:06:24'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 13:06:24'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 13:06:24'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 13:06:24'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 13:06:24'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 13:06:24'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 13:06:24'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 13:06:24'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 13:06:24'!
ERROR!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:15:08'!
ERROR!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:15:08'!
ERROR!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:15:08'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:15:08'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:15:08'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:15:08'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:15:08'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:15:08'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:15:08'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:15:08'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:15:08'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:15:08'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:15:08'!
ERROR!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:15:13'!
ERROR!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:21:55' prior: 50656041 overrides: 50655970!
+ anAdder

	(anAdder isKindOf: Entero) ifTrue: [^self class with: value + anAdder integerValue].	
	(anAdder isKindOf: Fraccion) ifTrue: [^Fraccion with: self * anAdder  denominator over: anAdder numerator ].
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:21:59'!
FAILURE!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:21:59'!
ERROR!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:21:59'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:21:59'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:21:59'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:21:59'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:21:59'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:21:59'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:21:59'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:21:59'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:21:59'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:21:59'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:21:59'!
ERROR!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:22:05'!
FAILURE!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:22:57'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:22:57'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:22:57'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:22:57'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:22:57'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:22:57'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:22:57'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:22:57'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:22:57'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:22:57'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:22:57'!
FAILURE!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:22:57'!
ERROR!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:22:57'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:22:57'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:22:57'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:22:58'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:22:58'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:22:58'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:22:58'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:22:58'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:22:58'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:22:58'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:22:58'!
ERROR!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:23:02'!
FAILURE!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:23:55' prior: 50656685 overrides: 50655970!
+ anAdder

	(anAdder isKindOf: Entero) ifTrue: [^self class with: value + anAdder integerValue].	
	(anAdder isKindOf: Fraccion) ifTrue: [^Fraccion with: (self * anAdder  denominator) over: anAdder numerator ].
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:24:02'!
FAILURE!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:24:02'!
ERROR!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:24:02'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:24:02'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:24:02'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:24:02'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:24:02'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:24:02'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:24:02'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:24:02'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:24:02'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:24:02'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:24:02'!
ERROR!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:24:05'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:24:20'!
FAILURE!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:25:43' prior: 50656973 overrides: 50655970!
+ anAdder

	(anAdder isKindOf: Entero) ifTrue: [^self class with: value + anAdder integerValue].	
	(anAdder isKindOf: Fraccion) ifTrue: [^Fraccion with: (self * anAdder  denominator + anAdder numerator) over: anAdder denominator ].
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:25:46'!
ERROR!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:25:46'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:25:46'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:25:46'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:25:46'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:25:46'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:25:46'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:25:46'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:25:46'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:25:46'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:25:46'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:25:46'!
ERROR!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:27:32' prior: 50656162 overrides: 50655970!
+ anAdder

	(anAdder isKindOf: Entero) ifTrue: [anAdder + self].
	(anAdder isKindOf: Fraccion) ifTrue: [
	| newNumerator newDenominator |

	newNumerator := (numerator * anAdder denominator) + (denominator * anAdder numerator).
	newDenominator := denominator * anAdder denominator.

	^newNumerator / newDenominator ].! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:27:36'!
FAILURE!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:27:36'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:27:36'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:27:36'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:27:36'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:27:36'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:27:36'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:27:36'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:27:36'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:27:36'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:27:36'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:27:36'!
ERROR!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:27:40'!
FAILURE!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:28:27' prior: 50657273 overrides: 50655970!
+ anAdder

	(anAdder isKindOf: Entero) ifTrue: [^Fraccion with: (self * anAdder  denominator + anAdder numerator) over: anAdder denominator].
	(anAdder isKindOf: Fraccion) ifTrue: [
	| newNumerator newDenominator |

	newNumerator := (numerator * anAdder denominator) + (denominator * anAdder numerator).
	newDenominator := denominator * anAdder denominator.

	^newNumerator / newDenominator ].! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:28:43' prior: 50657426 overrides: 50655970!
+ anAdder

	(anAdder isKindOf: Entero) ifTrue: 
		[^Fraccion with: (self * anAdder  denominator + anAdder numerator) over: anAdder denominator].
	(anAdder isKindOf: Fraccion) ifTrue:
		 [| newNumerator newDenominator |
	newNumerator := (numerator * anAdder denominator) + (denominator * anAdder numerator).
	newDenominator := denominator * anAdder denominator.

	^newNumerator / newDenominator ].! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:28:46' prior: 50657442 overrides: 50655970!
+ anAdder

	(anAdder isKindOf: Entero) ifTrue: 
		[^Fraccion with: (self * anAdder  denominator + anAdder numerator) over: anAdder denominator].
		
	(anAdder isKindOf: Fraccion) ifTrue:
		 [| newNumerator newDenominator |
	newNumerator := (numerator * anAdder denominator) + (denominator * anAdder numerator).
	newDenominator := denominator * anAdder denominator.

	^newNumerator / newDenominator ].! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:28:54' prior: 50657459 overrides: 50655970!
+ anAdder

	(anAdder isKindOf: Entero) ifTrue: 
		[^Fraccion with: (self * anAdder  denominator + anAdder numerator) over: anAdder denominator].
		
	(anAdder isKindOf: Fraccion) ifTrue:
		 [| newNumerator newDenominator |
		newNumerator := (numerator * anAdder denominator) + (denominator * anAdder numerator).
		newDenominator := denominator * anAdder denominator.
		^newNumerator / newDenominator ].! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:28:56'!
ERROR!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:28:56'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:28:56'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:28:56'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:28:56'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:28:56'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:28:56'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:28:56'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:28:56'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:28:56'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:28:56'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:28:56'!
ERROR!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:29:00'!
ERROR!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:29:09'!
ERROR!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:29:52' prior: 50657476 overrides: 50655970!
+ anAdder

	(anAdder isKindOf: Entero) ifTrue: 
		[^Fraccion with: (anAdder * self denominator + self numerator) over: self denominator].
		
	(anAdder isKindOf: Fraccion) ifTrue:
		 [| newNumerator newDenominator |
		newNumerator := (numerator * anAdder denominator) + (denominator * anAdder numerator).
		newDenominator := denominator * anAdder denominator.
		^newNumerator / newDenominator ].! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:29:54'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:29:54'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:29:54'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:29:54'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:29:54'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:29:54'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:29:54'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:29:54'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:29:54'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:29:54'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:29:54'!
ERROR!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:30:05'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:30:05'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:30:05'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:30:05'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:30:05'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:30:05'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:30:05'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:30:05'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:30:05'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:30:05'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:30:05'!
ERROR!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:36:49' prior: 50656035 overrides: 50655965!
* aMultiplier

	(aMultiplier isKindOf: Entero) ifTrue: [^self class with: value * aMultiplier integerValue].
	(aMultiplier isKindOf: Fraccion) ifTrue: [^Fraccion class with: self * aMultiplier numerator  over: aMultiplier denominator ].	! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:36:51'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:36:51'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:36:51'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:36:51'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:36:51'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:36:51'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:36:51'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:36:51'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:36:51'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:36:51'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:36:51'!
ERROR!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:37:21'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:37:21'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:37:21'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:37:21'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:37:21'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:37:21'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:37:21'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:37:21'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:37:21'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:37:21'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:37:21'!
ERROR!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:37:23'!
ERROR!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:37:49' prior: 50657923 overrides: 50655965!
* aMultiplier

	(aMultiplier isKindOf: Entero) ifTrue: [^self class with: value * aMultiplier integerValue].
	(aMultiplier isKindOf: Fraccion) ifTrue: [^Fraccion class with: (self * aMultiplier numerator)  over: aMultiplier denominator ].	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:37:57' prior: 50658209 overrides: 50655965!
* aMultiplier

	(aMultiplier isKindOf: Entero) ifTrue: [^self class with: value * aMultiplier integerValue].
	(aMultiplier isKindOf: Fraccion) ifTrue: [^Fraccion with: (self * aMultiplier numerator)  over: aMultiplier denominator ].	! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:38:02'!
ERROR!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:38:02'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:38:02'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:38:02'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:38:02'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:38:02'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:38:02'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:38:02'!
ERROR!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:38:02'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:38:02'!
ERROR!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:40:28' prior: 50656155 overrides: 50655965!
* aMultiplier

	(aMultiplier isKindOf: Entero) ifTrue: [^(numerator * aMultiplier)/(denominator)].
	(aMultiplier isKindOf: Fraccion) ifTrue: [^(numerator * aMultiplier numerator) / (denominator * aMultiplier denominator) ].	
	
	! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:40:43'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:40:43'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:40:43'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:40:43'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:40:43'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:40:43'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:40:43'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:40:56'!
ERROR!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:40:56'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:40:56'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:40:56'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:40:56'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:40:56'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:40:56'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:40:56'!
PASSED!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:43:39' prior: 50656052 overrides: 50655979!
/ aDivisor

	(aDivisor isKindOf: Entero) ifTrue: [^Fraccion with: self over: aDivisor].
	(aDivisor isKindOf: Fraccion)ifTrue: [^Fraccion with: self * aDivisor denominator over: aDivisor numerator].! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:43:55'!
ERROR!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:43:55'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:43:55'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:43:55'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:43:55'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:43:55'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:43:55'!
PASSED!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:45:09' prior: 50656184 overrides: 50655979!
/ aDivisor

	(aDivisor isKindOf: Fraccion)ifTrue:[^Fraccion with: self * aDivisor denominator over: aDivisor numerator].
	(aDivisor isKindOf: Entero) ifTrue: [^Fraccion with: self over: aDivisor].
! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:47:05' prior: 50658797 overrides: 50655979!
/ aDivisor

	(aDivisor isKindOf: Fraccion) ifTrue: [^(numerator * aDivisor denominator) / (denominator * aDivisor numerator)].
	(aDivisor isKindOf: Entero) ifTrue: [^Fraccion with: self over: aDivisor].
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:47:49' prior: 50658807 overrides: 50655979!
/ aDivisor

	(aDivisor isKindOf: Fraccion) ifTrue: [^(numerator * aDivisor denominator) / (denominator * aDivisor numerator)].
	(aDivisor isKindOf: Entero) ifTrue: [^Fraccion with: aDivisor * self denominator over: self numerator].
	! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:47:51'!
FAILURE!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:47:51'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:47:51'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:47:51'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:47:51'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:47:51'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:47:56'!
FAILURE!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 14:48:50' prior: 50658818 overrides: 50655979!
/ aDivisor

	(aDivisor isKindOf: Fraccion) ifTrue: [^(numerator * aDivisor denominator) / (denominator * aDivisor numerator)].
	(aDivisor isKindOf: Entero) ifTrue: [^Fraccion with: self numerator over: self denominator * aDivisor].
	! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 14:48:52'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 14:48:52'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 14:48:52'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 14:48:52'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 14:48:52'!
PASSED!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:06:42' prior: 50656046 overrides: 50655974!
- aSubtrahend

	(aSubtrahend isKindOf: Entero) ifTrue: [^self class with: value - aSubtrahend integerValue].
	(aSubtrahend isKindOf: Fraccion) ifTrue: [^Fraccion with: (self value * aSubtrahend denominator  - aSubtrahend numerator) over: 	(aSubtrahend denominator )].! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:06:45'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:06:45'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:06:45'!
ERROR!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:06:49'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:06:49'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:06:49'!
ERROR!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:07:28'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:07:28'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:07:28'!
ERROR!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:08:10'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:08:14'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:08:19'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:08:24'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:08:27'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:08:31'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:08:42'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:08:49'!
PASSED!
!Behavior method!
isZero
	#_coverageTracker7511315_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker7511315_
		cover: (11 to: 15)
		declaredAt: (11 to: 15)
		by: value.
	#_coverageTracker7511315_
		coverAll:
			{17 to: 17}
		evaluating: [
			receiver1 =
				(#_coverageTracker7511315_
					coverAll:
						{18 to: 19}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
+ anAdder
	#_coverageTracker7511321_ markAsExecuted.
	[ | receiver6 |
	receiver6 _ [ | receiver1 |
	receiver1 _ #_coverageTracker7511321_
		cover: (14 to: 20)
		declaredAt: (3 to: 9)
		by: anAdder.
	#_coverageTracker7511321_
		coverAll:
			{22 to: 30}
		evaluating: [
			receiver1 isKindOf:
				(#_coverageTracker7511321_
					coverAll:
						{32 to: 37}
					by: Entero) ]
		thatSends: #isKindOf:
		to: receiver1 ] value.
	#_coverageTracker7511321_
		coverAll:
			{40 to: 46}
		evaluating: [ receiver6 ifTrue: [ ^ [ | receiver5 |
				receiver5 _ [ | receiver2 |
				receiver2 _ #_coverageTracker7511321_
					coverAll:
						{50 to: 53}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker7511321_
					coverAll:
						{55 to: 59}
					evaluating: [ receiver2 class ]
					thatSends: #class
					to: receiver2 ] value.
				#_coverageTracker7511321_
					coverAll:
						{61 to: 65}
					evaluating: [
						receiver5 with:
							[ | receiver4 |
							receiver4 _ #_coverageTracker7511321_
								cover: (67 to: 71)
								declaredAt: (67 to: 71)
								by: value.
							#_coverageTracker7511321_
								coverAll:
									{73 to: 73}
								evaluating: [
									receiver4 +
										[ | receiver3 |
										receiver3 _ #_coverageTracker7511321_
											cover: (75 to: 81)
											declaredAt: (3 to: 9)
											by: anAdder.
										#_coverageTracker7511321_
											coverAll:
												{83 to: 94}
											evaluating: [ receiver3 integerValue ]
											thatSends: #integerValue
											to: receiver3 ] value ]
								thatSends: #+
								to: receiver4 ] value ]
					thatSends: #with:
					to: receiver5 ] value ]]
		thatSends: #ifTrue:
		to: receiver6 ] value.
	[ | receiver14 |
	receiver14 _ [ | receiver7 |
	receiver7 _ #_coverageTracker7511321_
		cover: (101 to: 107)
		declaredAt: (3 to: 9)
		by: anAdder.
	#_coverageTracker7511321_
		coverAll:
			{109 to: 117}
		evaluating: [
			receiver7 isKindOf:
				(#_coverageTracker7511321_
					coverAll:
						{119 to: 126}
					by: Fraccion) ]
		thatSends: #isKindOf:
		to: receiver7 ] value.
	#_coverageTracker7511321_
		coverAll:
			{129 to: 135}
		evaluating: [ receiver14 ifTrue: [ ^ [ | receiver13 |
				receiver13 _ #_coverageTracker7511321_
					coverAll:
						{139 to: 146}
					by: Fraccion.
				#_coverageTracker7511321_
					coverAll:
						{148 to: 152. 204 to: 208}
					evaluating: [
						receiver13
							with:
								[ | receiver11 |
								receiver11 _ [ | receiver9 |
								receiver9 _ #_coverageTracker7511321_
									coverAll:
										{155 to: 158}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker7511321_
									coverAll:
										{160 to: 160}
									evaluating: [
										receiver9 *
											[ | receiver8 |
											receiver8 _ #_coverageTracker7511321_
												cover: (162 to: 168)
												declaredAt: (3 to: 9)
												by: anAdder.
											#_coverageTracker7511321_
												coverAll:
													{171 to: 181}
												evaluating: [ receiver8 denominator ]
												thatSends: #denominator
												to: receiver8 ] value ]
									thatSends: #*
									to: receiver9 ] value.
								#_coverageTracker7511321_
									coverAll:
										{183 to: 183}
									evaluating: [
										receiver11 +
											[ | receiver10 |
											receiver10 _ #_coverageTracker7511321_
												cover: (185 to: 191)
												declaredAt: (3 to: 9)
												by: anAdder.
											#_coverageTracker7511321_
												coverAll:
													{193 to: 201}
												evaluating: [ receiver10 numerator ]
												thatSends: #numerator
												to: receiver10 ] value ]
									thatSends: #+
									to: receiver11 ] value
							over:
								[ | receiver12 |
								receiver12 _ #_coverageTracker7511321_
									cover: (210 to: 216)
									declaredAt: (3 to: 9)
									by: anAdder.
								#_coverageTracker7511321_
									coverAll:
										{218 to: 228}
									evaluating: [ receiver12 denominator ]
									thatSends: #denominator
									to: receiver12 ] value ]
					thatSends: #with:over:
					to: receiver13 ] value ]]
		thatSends: #ifTrue:
		to: receiver14 ] value.! !
!Behavior method!
numerator
	#_coverageTracker7511360_ markAsExecuted.
	^ #_coverageTracker7511360_
		cover: (15 to: 23)
		declaredAt: (15 to: 23)
		by: numerator.! !
!Behavior method!
* aMultiplier
	#_coverageTracker7511364_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker7511364_
		cover: (18 to: 28)
		declaredAt: (3 to: 13)
		by: aMultiplier.
	#_coverageTracker7511364_
		coverAll:
			{30 to: 38}
		evaluating: [
			receiver1 isKindOf:
				(#_coverageTracker7511364_
					coverAll:
						{40 to: 45}
					by: Entero) ]
		thatSends: #isKindOf:
		to: receiver1 ] value.
	#_coverageTracker7511364_
		coverAll:
			{48 to: 54}
		evaluating: [ receiver4 ifTrue: [ ^ [ | receiver3 |
				receiver3 _ [ | receiver2 |
				receiver2 _ #_coverageTracker7511364_
					cover: (59 to: 67)
					declaredAt: (59 to: 67)
					by: numerator.
				#_coverageTracker7511364_
					coverAll:
						{69 to: 69}
					evaluating: [
						receiver2 *
							(#_coverageTracker7511364_
								cover: (71 to: 81)
								declaredAt: (3 to: 13)
								by: aMultiplier) ]
					thatSends: #*
					to: receiver2 ] value.
				#_coverageTracker7511364_
					coverAll:
						{83 to: 83}
					evaluating: [
						receiver3 /
							(#_coverageTracker7511364_
								cover: (85 to: 95)
								declaredAt: (85 to: 95)
								by: denominator) ]
					thatSends: #/
					to: receiver3 ] value ]]
		thatSends: #ifTrue:
		to: receiver4 ] value.
	[ | receiver11 |
	receiver11 _ [ | receiver5 |
	receiver5 _ #_coverageTracker7511364_
		cover: (102 to: 112)
		declaredAt: (3 to: 13)
		by: aMultiplier.
	#_coverageTracker7511364_
		coverAll:
			{114 to: 122}
		evaluating: [
			receiver5 isKindOf:
				(#_coverageTracker7511364_
					coverAll:
						{124 to: 131}
					by: Fraccion) ]
		thatSends: #isKindOf:
		to: receiver5 ] value.
	#_coverageTracker7511364_
		coverAll:
			{134 to: 140}
		evaluating: [ receiver11 ifTrue: [ ^ [ | receiver10 |
				receiver10 _ [ | receiver7 |
				receiver7 _ #_coverageTracker7511364_
					cover: (145 to: 153)
					declaredAt: (59 to: 67)
					by: numerator.
				#_coverageTracker7511364_
					coverAll:
						{155 to: 155}
					evaluating: [
						receiver7 *
							[ | receiver6 |
							receiver6 _ #_coverageTracker7511364_
								cover: (157 to: 167)
								declaredAt: (3 to: 13)
								by: aMultiplier.
							#_coverageTracker7511364_
								coverAll:
									{169 to: 177}
								evaluating: [ receiver6 numerator ]
								thatSends: #numerator
								to: receiver6 ] value ]
					thatSends: #*
					to: receiver7 ] value.
				#_coverageTracker7511364_
					coverAll:
						{180 to: 180}
					evaluating: [
						receiver10 /
							[ | receiver9 |
							receiver9 _ #_coverageTracker7511364_
								cover: (183 to: 193)
								declaredAt: (85 to: 95)
								by: denominator.
							#_coverageTracker7511364_
								coverAll:
									{195 to: 195}
								evaluating: [
									receiver9 *
										[ | receiver8 |
										receiver8 _ #_coverageTracker7511364_
											cover: (197 to: 207)
											declaredAt: (3 to: 13)
											by: aMultiplier.
										#_coverageTracker7511364_
											coverAll:
												{209 to: 219}
											evaluating: [ receiver8 denominator ]
											thatSends: #denominator
											to: receiver8 ] value ]
								thatSends: #*
								to: receiver9 ] value ]
					thatSends: #/
					to: receiver10 ] value ]]
		thatSends: #ifTrue:
		to: receiver11 ] value.! !
!Behavior method!
/ aDivisor
	#_coverageTracker7511420_ markAsExecuted.
	[ | receiver7 |
	receiver7 _ [ | receiver1 |
	receiver1 _ #_coverageTracker7511420_
		cover: (15 to: 22)
		declaredAt: (3 to: 10)
		by: aDivisor.
	#_coverageTracker7511420_
		coverAll:
			{24 to: 32}
		evaluating: [
			receiver1 isKindOf:
				(#_coverageTracker7511420_
					coverAll:
						{34 to: 41}
					by: Fraccion) ]
		thatSends: #isKindOf:
		to: receiver1 ] value.
	#_coverageTracker7511420_
		coverAll:
			{44 to: 50}
		evaluating: [ receiver7 ifTrue: [ ^ [ | receiver6 |
				receiver6 _ [ | receiver3 |
				receiver3 _ #_coverageTracker7511420_
					cover: (55 to: 63)
					declaredAt: (55 to: 63)
					by: numerator.
				#_coverageTracker7511420_
					coverAll:
						{65 to: 65}
					evaluating: [
						receiver3 *
							[ | receiver2 |
							receiver2 _ #_coverageTracker7511420_
								cover: (67 to: 74)
								declaredAt: (3 to: 10)
								by: aDivisor.
							#_coverageTracker7511420_
								coverAll:
									{76 to: 86}
								evaluating: [ receiver2 denominator ]
								thatSends: #denominator
								to: receiver2 ] value ]
					thatSends: #*
					to: receiver3 ] value.
				#_coverageTracker7511420_
					coverAll:
						{89 to: 89}
					evaluating: [
						receiver6 /
							[ | receiver5 |
							receiver5 _ #_coverageTracker7511420_
								cover: (92 to: 102)
								declaredAt: (92 to: 102)
								by: denominator.
							#_coverageTracker7511420_
								coverAll:
									{104 to: 104}
								evaluating: [
									receiver5 *
										[ | receiver4 |
										receiver4 _ #_coverageTracker7511420_
											cover: (106 to: 113)
											declaredAt: (3 to: 10)
											by: aDivisor.
										#_coverageTracker7511420_
											coverAll:
												{115 to: 123}
											evaluating: [ receiver4 numerator ]
											thatSends: #numerator
											to: receiver4 ] value ]
								thatSends: #*
								to: receiver5 ] value ]
					thatSends: #/
					to: receiver6 ] value ]]
		thatSends: #ifTrue:
		to: receiver7 ] value.
	[ | receiver13 |
	receiver13 _ [ | receiver8 |
	receiver8 _ #_coverageTracker7511420_
		cover: (130 to: 137)
		declaredAt: (3 to: 10)
		by: aDivisor.
	#_coverageTracker7511420_
		coverAll:
			{139 to: 147}
		evaluating: [
			receiver8 isKindOf:
				(#_coverageTracker7511420_
					coverAll:
						{149 to: 154}
					by: Entero) ]
		thatSends: #isKindOf:
		to: receiver8 ] value.
	#_coverageTracker7511420_
		coverAll:
			{157 to: 163}
		evaluating: [ receiver13 ifTrue: [ ^ [ | receiver12 |
				receiver12 _ #_coverageTracker7511420_
					coverAll:
						{167 to: 174}
					by: Fraccion.
				#_coverageTracker7511420_
					coverAll:
						{176 to: 180. 197 to: 201}
					evaluating: [
						receiver12
							with:
								[ | receiver9 |
								receiver9 _ #_coverageTracker7511420_
									coverAll:
										{182 to: 185}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker7511420_
									coverAll:
										{187 to: 195}
									evaluating: [ receiver9 numerator ]
									thatSends: #numerator
									to: receiver9 ] value
							over:
								[ | receiver11 |
								receiver11 _ [ | receiver10 |
								receiver10 _ #_coverageTracker7511420_
									coverAll:
										{203 to: 206}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker7511420_
									coverAll:
										{208 to: 218}
									evaluating: [ receiver10 denominator ]
									thatSends: #denominator
									to: receiver10 ] value.
								#_coverageTracker7511420_
									coverAll:
										{220 to: 220}
									evaluating: [
										receiver11 *
											(#_coverageTracker7511420_
												cover: (222 to: 229)
												declaredAt: (3 to: 10)
												by: aDivisor) ]
									thatSends: #*
									to: receiver11 ] value ]
					thatSends: #with:over:
					to: receiver12 ] value ]]
		thatSends: #ifTrue:
		to: receiver13 ] value.! !
!Behavior method!
* aMultiplier
	#_coverageTracker7511449_ markAsExecuted.
	[ | receiver6 |
	receiver6 _ [ | receiver1 |
	receiver1 _ #_coverageTracker7511449_
		cover: (18 to: 28)
		declaredAt: (3 to: 13)
		by: aMultiplier.
	#_coverageTracker7511449_
		coverAll:
			{30 to: 38}
		evaluating: [
			receiver1 isKindOf:
				(#_coverageTracker7511449_
					coverAll:
						{40 to: 45}
					by: Entero) ]
		thatSends: #isKindOf:
		to: receiver1 ] value.
	#_coverageTracker7511449_
		coverAll:
			{48 to: 54}
		evaluating: [ receiver6 ifTrue: [ ^ [ | receiver5 |
				receiver5 _ [ | receiver2 |
				receiver2 _ #_coverageTracker7511449_
					coverAll:
						{58 to: 61}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker7511449_
					coverAll:
						{63 to: 67}
					evaluating: [ receiver2 class ]
					thatSends: #class
					to: receiver2 ] value.
				#_coverageTracker7511449_
					coverAll:
						{69 to: 73}
					evaluating: [
						receiver5 with:
							[ | receiver4 |
							receiver4 _ #_coverageTracker7511449_
								cover: (75 to: 79)
								declaredAt: (75 to: 79)
								by: value.
							#_coverageTracker7511449_
								coverAll:
									{81 to: 81}
								evaluating: [
									receiver4 *
										[ | receiver3 |
										receiver3 _ #_coverageTracker7511449_
											cover: (83 to: 93)
											declaredAt: (3 to: 13)
											by: aMultiplier.
										#_coverageTracker7511449_
											coverAll:
												{95 to: 106}
											evaluating: [ receiver3 integerValue ]
											thatSends: #integerValue
											to: receiver3 ] value ]
								thatSends: #*
								to: receiver4 ] value ]
					thatSends: #with:
					to: receiver5 ] value ]]
		thatSends: #ifTrue:
		to: receiver6 ] value.
	[ | receiver12 |
	receiver12 _ [ | receiver7 |
	receiver7 _ #_coverageTracker7511449_
		cover: (112 to: 122)
		declaredAt: (3 to: 13)
		by: aMultiplier.
	#_coverageTracker7511449_
		coverAll:
			{124 to: 132}
		evaluating: [
			receiver7 isKindOf:
				(#_coverageTracker7511449_
					coverAll:
						{134 to: 141}
					by: Fraccion) ]
		thatSends: #isKindOf:
		to: receiver7 ] value.
	#_coverageTracker7511449_
		coverAll:
			{144 to: 150}
		evaluating: [ receiver12 ifTrue: [ ^ [ | receiver11 |
				receiver11 _ #_coverageTracker7511449_
					coverAll:
						{154 to: 161}
					by: Fraccion.
				#_coverageTracker7511449_
					coverAll:
						{163 to: 167. 201 to: 205}
					evaluating: [
						receiver11
							with:
								[ | receiver9 |
								receiver9 _ #_coverageTracker7511449_
									coverAll:
										{170 to: 173}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker7511449_
									coverAll:
										{175 to: 175}
									evaluating: [
										receiver9 *
											[ | receiver8 |
											receiver8 _ #_coverageTracker7511449_
												cover: (177 to: 187)
												declaredAt: (3 to: 13)
												by: aMultiplier.
											#_coverageTracker7511449_
												coverAll:
													{189 to: 197}
												evaluating: [ receiver8 numerator ]
												thatSends: #numerator
												to: receiver8 ] value ]
									thatSends: #*
									to: receiver9 ] value
							over:
								[ | receiver10 |
								receiver10 _ #_coverageTracker7511449_
									cover: (207 to: 217)
									declaredAt: (3 to: 13)
									by: aMultiplier.
								#_coverageTracker7511449_
									coverAll:
										{219 to: 229}
									evaluating: [ receiver10 denominator ]
									thatSends: #denominator
									to: receiver10 ] value ]
					thatSends: #with:over:
					to: receiver11 ] value ]]
		thatSends: #ifTrue:
		to: receiver12 ] value.! !
!Behavior method!
printOn: aStream
	#_coverageTracker7511470_ markAsExecuted.
	[ | cascadeReceiver |
	cascadeReceiver _ #_coverageTracker7511470_
		cover: (20 to: 26)
		declaredAt: (10 to: 16)
		by: aStream.
	[ | receiver1 |
	receiver1 _ cascadeReceiver.
	#_coverageTracker7511470_
		coverAll:
			{30 to: 35}
		evaluating: [
			receiver1 print:
				(#_coverageTracker7511470_
					cover: (37 to: 45)
					declaredAt: (37 to: 45)
					by: numerator) ]
		thatSends: #print:
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker7511470_
		coverAll:
			{50 to: 57}
		evaluating: [
			receiver2 nextPut:
				(#_coverageTracker7511470_
					coverAll:
						{59 to: 60}
					byLiteralOrPseudoVariable: $/) ]
		thatSends: #nextPut:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker7511470_
		coverAll:
			{65 to: 70}
		evaluating: [
			receiver3 print:
				(#_coverageTracker7511470_
					cover: (72 to: 82)
					declaredAt: (72 to: 82)
					by: denominator) ]
		thatSends: #print:
		to: receiver3 ] value ] value.! !
!Behavior method!
isOne
	#_coverageTracker7511476_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker7511476_
		cover: (10 to: 14)
		declaredAt: (10 to: 14)
		by: value.
	#_coverageTracker7511476_
		coverAll:
			{16 to: 16}
		evaluating: [
			receiver1 =
				(#_coverageTracker7511476_
					coverAll:
						{17 to: 18}
					byLiteralOrPseudoVariable: 1) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
with: aValue
	"Esta verificacion esta puesta por si se equivocan y quieren crear un Entero pasando otra cosa que un Integer - Hernan"
	#_coverageTracker7511478_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ [ | receiver1 |
	receiver1 _ #_coverageTracker7511478_
		cover: (137 to: 142)
		declaredAt: (7 to: 12)
		by: aValue.
	#_coverageTracker7511478_
		coverAll:
			{144 to: 152}
		evaluating: [ receiver1 isInteger ]
		thatSends: #isInteger
		to: receiver1 ] value.
	#_coverageTracker7511478_
		coverAll:
			{154 to: 161}
		evaluating: [
			receiver3 ifFalse: [
				[ | receiver2 |
				receiver2 _ #_coverageTracker7511478_
					coverAll:
						{166 to: 169}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker7511478_
					coverAll:
						{171 to: 176}
					evaluating: [
						receiver2 error:
							(#_coverageTracker7511478_
								coverAll:
									{178 to: 204}
								byLiteralOrPseudoVariable: 'aValue debe ser anInteger') ]
					thatSends: #error:
					to: receiver2 ] value ]]
		thatSends: #ifFalse:
		to: receiver3 ] value.
	^ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ #_coverageTracker7511478_
		coverAll:
			{212 to: 215}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker7511478_
		coverAll:
			{217 to: 219}
		evaluating: [ receiver4 new ]
		thatSends: #new
		to: receiver4 ] value.
	#_coverageTracker7511478_
		coverAll:
			{221 to: 234}
		evaluating: [
			receiver5 initalizeWith:
				(#_coverageTracker7511478_
					cover: (236 to: 241)
					declaredAt: (7 to: 12)
					by: aValue) ]
		thatSends: #initalizeWith:
		to: receiver5 ] value.! !
!Behavior method!
hash
	#_coverageTracker7511494_ markAsExecuted.
	^ [ | receiver4 |
	receiver4 _ [ | receiver3 |
	receiver3 _ [ | receiver1 |
	receiver1 _ #_coverageTracker7511494_
		cover: (10 to: 18)
		declaredAt: (10 to: 18)
		by: numerator.
	#_coverageTracker7511494_
		coverAll:
			{20 to: 23}
		evaluating: [ receiver1 hash ]
		thatSends: #hash
		to: receiver1 ] value.
	#_coverageTracker7511494_
		coverAll:
			{25 to: 25}
		evaluating: [
			receiver3 /
				[ | receiver2 |
				receiver2 _ #_coverageTracker7511494_
					cover: (27 to: 37)
					declaredAt: (27 to: 37)
					by: denominator.
				#_coverageTracker7511494_
					coverAll:
						{39 to: 42}
					evaluating: [ receiver2 hash ]
					thatSends: #hash
					to: receiver2 ] value ]
		thatSends: #/
		to: receiver3 ] value.
	#_coverageTracker7511494_
		coverAll:
			{45 to: 48}
		evaluating: [ receiver4 hash ]
		thatSends: #hash
		to: receiver4 ] value.! !
!Behavior method!
initalizeWith: aValue
	#_coverageTracker7511499_ markAsExecuted.
	#_coverageTracker7511499_
		cover: (25 to: 29)
		declaredAt: (25 to: 29)
		by:
			(value _ #_coverageTracker7511499_
				cover: (34 to: 39)
				declaredAt: (16 to: 21)
				by: aValue).! !
!Behavior method!
negativeFibonacciErrorDescription
	#_coverageTracker7511501_ markAsExecuted.
	^ #_coverageTracker7511501_
		coverAll:
			{38 to: 97}
		byLiteralOrPseudoVariable: ' Fibonacci no est definido aqu para Enteros Negativos!!!!!!'.! !
!Behavior method!
+ anAdder
	#_coverageTracker7511505_ markAsExecuted.
	[ | receiver8 |
	receiver8 _ [ | receiver1 |
	receiver1 _ #_coverageTracker7511505_
		cover: (14 to: 20)
		declaredAt: (3 to: 9)
		by: anAdder.
	#_coverageTracker7511505_
		coverAll:
			{22 to: 30}
		evaluating: [
			receiver1 isKindOf:
				(#_coverageTracker7511505_
					coverAll:
						{32 to: 37}
					by: Entero) ]
		thatSends: #isKindOf:
		to: receiver1 ] value.
	#_coverageTracker7511505_
		coverAll:
			{40 to: 46}
		evaluating: [ receiver8 ifTrue: [ ^ [ | receiver7 |
				receiver7 _ #_coverageTracker7511505_
					coverAll:
						{53 to: 60}
					by: Fraccion.
				#_coverageTracker7511505_
					coverAll:
						{62 to: 66. 114 to: 118}
					evaluating: [
						receiver7
							with:
								[ | receiver5 |
								receiver5 _ [ | receiver3 |
								receiver3 _ #_coverageTracker7511505_
									cover: (69 to: 75)
									declaredAt: (3 to: 9)
									by: anAdder.
								#_coverageTracker7511505_
									coverAll:
										{77 to: 77}
									evaluating: [
										receiver3 *
											[ | receiver2 |
											receiver2 _ #_coverageTracker7511505_
												coverAll:
													{79 to: 82}
												byLiteralOrPseudoVariable: self.
											#_coverageTracker7511505_
												coverAll:
													{84 to: 94}
												evaluating: [ receiver2 denominator ]
												thatSends: #denominator
												to: receiver2 ] value ]
									thatSends: #*
									to: receiver3 ] value.
								#_coverageTracker7511505_
									coverAll:
										{96 to: 96}
									evaluating: [
										receiver5 +
											[ | receiver4 |
											receiver4 _ #_coverageTracker7511505_
												coverAll:
													{98 to: 101}
												byLiteralOrPseudoVariable: self.
											#_coverageTracker7511505_
												coverAll:
													{103 to: 111}
												evaluating: [ receiver4 numerator ]
												thatSends: #numerator
												to: receiver4 ] value ]
									thatSends: #+
									to: receiver5 ] value
							over:
								[ | receiver6 |
								receiver6 _ #_coverageTracker7511505_
									coverAll:
										{120 to: 123}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker7511505_
									coverAll:
										{125 to: 135}
									evaluating: [ receiver6 denominator ]
									thatSends: #denominator
									to: receiver6 ] value ]
					thatSends: #with:over:
					to: receiver7 ] value ]]
		thatSends: #ifTrue:
		to: receiver8 ] value.
	[ | receiver18 |
	receiver18 _ [ | receiver9 |
	receiver9 _ #_coverageTracker7511505_
		cover: (144 to: 150)
		declaredAt: (3 to: 9)
		by: anAdder.
	#_coverageTracker7511505_
		coverAll:
			{152 to: 160}
		evaluating: [
			receiver9 isKindOf:
				(#_coverageTracker7511505_
					coverAll:
						{162 to: 169}
					by: Fraccion) ]
		thatSends: #isKindOf:
		to: receiver9 ] value.
	#_coverageTracker7511505_
		coverAll:
			{172 to: 178}
		evaluating: [
			receiver18 ifTrue: [ | newNumerator newDenominator |
				#_coverageTracker7511505_
					cover: (218 to: 229)
					declaredAt: (186 to: 197)
					by:
						(newNumerator _ [ | receiver14 |
						receiver14 _ [ | receiver11 |
						receiver11 _ #_coverageTracker7511505_
							cover: (235 to: 243)
							declaredAt: (235 to: 243)
							by: numerator.
						#_coverageTracker7511505_
							coverAll:
								{245 to: 245}
							evaluating: [
								receiver11 *
									[ | receiver10 |
									receiver10 _ #_coverageTracker7511505_
										cover: (247 to: 253)
										declaredAt: (3 to: 9)
										by: anAdder.
									#_coverageTracker7511505_
										coverAll:
											{255 to: 265}
										evaluating: [ receiver10 denominator ]
										thatSends: #denominator
										to: receiver10 ] value ]
							thatSends: #*
							to: receiver11 ] value.
						#_coverageTracker7511505_
							coverAll:
								{268 to: 268}
							evaluating: [
								receiver14 +
									[ | receiver13 |
									receiver13 _ #_coverageTracker7511505_
										cover: (271 to: 281)
										declaredAt: (271 to: 281)
										by: denominator.
									#_coverageTracker7511505_
										coverAll:
											{283 to: 283}
										evaluating: [
											receiver13 *
												[ | receiver12 |
												receiver12 _ #_coverageTracker7511505_
													cover: (285 to: 291)
													declaredAt: (3 to: 9)
													by: anAdder.
												#_coverageTracker7511505_
													coverAll:
														{293 to: 301}
													evaluating: [ receiver12 numerator ]
													thatSends: #numerator
													to: receiver12 ] value ]
										thatSends: #*
										to: receiver13 ] value ]
							thatSends: #+
							to: receiver14 ] value).
				#_coverageTracker7511505_
					cover: (307 to: 320)
					declaredAt: (199 to: 212)
					by:
						(newDenominator _ [ | receiver16 |
						receiver16 _ #_coverageTracker7511505_
							cover: (325 to: 335)
							declaredAt: (271 to: 281)
							by: denominator.
						#_coverageTracker7511505_
							coverAll:
								{337 to: 337}
							evaluating: [
								receiver16 *
									[ | receiver15 |
									receiver15 _ #_coverageTracker7511505_
										cover: (339 to: 345)
										declaredAt: (3 to: 9)
										by: anAdder.
									#_coverageTracker7511505_
										coverAll:
											{347 to: 357}
										evaluating: [ receiver15 denominator ]
										thatSends: #denominator
										to: receiver15 ] value ]
							thatSends: #*
							to: receiver16 ] value).
				^ [ | receiver17 |
				receiver17 _ #_coverageTracker7511505_
					cover: (363 to: 374)
					declaredAt: (186 to: 197)
					by: newNumerator.
				#_coverageTracker7511505_
					coverAll:
						{376 to: 376}
					evaluating: [
						receiver17 /
							(#_coverageTracker7511505_
								cover: (378 to: 391)
								declaredAt: (199 to: 212)
								by: newDenominator) ]
					thatSends: #/
					to: receiver17 ] value ]]
		thatSends: #ifTrue:
		to: receiver18 ] value.! !
!Behavior method!
isNegative
	#_coverageTracker7511540_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker7511540_
		cover: (15 to: 19)
		declaredAt: (15 to: 19)
		by: value.
	#_coverageTracker7511540_
		coverAll:
			{21 to: 21}
		evaluating: [
			receiver1 <
				(#_coverageTracker7511540_
					coverAll:
						{22 to: 23}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #<
		to: receiver1 ] value.! !
!Behavior method!
canNotDivideByZeroErrorDescription
	#_coverageTracker7511542_ markAsExecuted.
	^ #_coverageTracker7511542_
		coverAll:
			{39 to: 71}
		byLiteralOrPseudoVariable: 'No se puede dividir por cero!!!!!!'.! !
!Behavior method!
denominator
	#_coverageTracker7511542_ markAsExecuted.
	^ #_coverageTracker7511542_
		cover: (17 to: 27)
		declaredAt: (17 to: 27)
		by: denominator.! !
!Behavior method!
invalidNumberTypeErrorDescription
	#_coverageTracker7511544_ markAsExecuted.
	^ #_coverageTracker7511544_
		coverAll:
			{39 to: 66}
		byLiteralOrPseudoVariable: 'Tipo de nmero invlido!!!!!!'.! !
!Behavior method!
- aSubtrahend
	| newNumerator newDenominator |
	#_coverageTracker7511546_ markAsExecuted.
	#_coverageTracker7511546_
		cover: (51 to: 62)
		declaredAt: (19 to: 30)
		by:
			(newNumerator _ [ | receiver5 |
			receiver5 _ [ | receiver2 |
			receiver2 _ #_coverageTracker7511546_
				cover: (68 to: 76)
				declaredAt: (68 to: 76)
				by: numerator.
			#_coverageTracker7511546_
				coverAll:
					{78 to: 78}
				evaluating: [
					receiver2 *
						[ | receiver1 |
						receiver1 _ #_coverageTracker7511546_
							cover: (80 to: 90)
							declaredAt: (3 to: 13)
							by: aSubtrahend.
						#_coverageTracker7511546_
							coverAll:
								{92 to: 102}
							evaluating: [ receiver1 denominator ]
							thatSends: #denominator
							to: receiver1 ] value ]
				thatSends: #*
				to: receiver2 ] value.
			#_coverageTracker7511546_
				coverAll:
					{105 to: 105}
				evaluating: [
					receiver5 -
						[ | receiver4 |
						receiver4 _ #_coverageTracker7511546_
							cover: (108 to: 118)
							declaredAt: (108 to: 118)
							by: denominator.
						#_coverageTracker7511546_
							coverAll:
								{120 to: 120}
							evaluating: [
								receiver4 *
									[ | receiver3 |
									receiver3 _ #_coverageTracker7511546_
										cover: (122 to: 132)
										declaredAt: (3 to: 13)
										by: aSubtrahend.
									#_coverageTracker7511546_
										coverAll:
											{134 to: 142}
										evaluating: [ receiver3 numerator ]
										thatSends: #numerator
										to: receiver3 ] value ]
							thatSends: #*
							to: receiver4 ] value ]
				thatSends: #-
				to: receiver5 ] value).
	#_coverageTracker7511546_
		cover: (147 to: 160)
		declaredAt: (32 to: 45)
		by:
			(newDenominator _ [ | receiver7 |
			receiver7 _ #_coverageTracker7511546_
				cover: (165 to: 175)
				declaredAt: (108 to: 118)
				by: denominator.
			#_coverageTracker7511546_
				coverAll:
					{177 to: 177}
				evaluating: [
					receiver7 *
						[ | receiver6 |
						receiver6 _ #_coverageTracker7511546_
							cover: (179 to: 189)
							declaredAt: (3 to: 13)
							by: aSubtrahend.
						#_coverageTracker7511546_
							coverAll:
								{191 to: 201}
							evaluating: [ receiver6 denominator ]
							thatSends: #denominator
							to: receiver6 ] value ]
				thatSends: #*
				to: receiver7 ] value).
	^ [ | receiver8 |
	receiver8 _ #_coverageTracker7511546_
		cover: (207 to: 218)
		declaredAt: (19 to: 30)
		by: newNumerator.
	#_coverageTracker7511546_
		coverAll:
			{220 to: 220}
		evaluating: [
			receiver8 /
				(#_coverageTracker7511546_
					cover: (222 to: 235)
					declaredAt: (32 to: 45)
					by: newDenominator) ]
		thatSends: #/
		to: receiver8 ] value.! !
!Behavior method!
with: aDividend over: aDivisor
	| greatestCommonDivisor numerator denominator |
	#_coverageTracker7511560_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker7511560_
		cover: (84 to: 91)
		declaredAt: (23 to: 30)
		by: aDivisor.
	#_coverageTracker7511560_
		coverAll:
			{93 to: 98}
		evaluating: [ receiver1 isZero ]
		thatSends: #isZero
		to: receiver1 ] value.
	#_coverageTracker7511560_
		coverAll:
			{100 to: 106}
		evaluating: [
			receiver4 ifTrue: [
				[ | receiver3 |
				receiver3 _ #_coverageTracker7511560_
					coverAll:
						{110 to: 113}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker7511560_
					coverAll:
						{115 to: 120}
					evaluating: [
						receiver3 error:
							[ | receiver2 |
							receiver2 _ #_coverageTracker7511560_
								coverAll:
									{122 to: 125}
								byLiteralOrPseudoVariable: self.
							#_coverageTracker7511560_
								coverAll:
									{127 to: 160}
								evaluating: [ receiver2 canNotDivideByZeroErrorDescription ]
								thatSends: #canNotDivideByZeroErrorDescription
								to: receiver2 ] value ]
					thatSends: #error:
					to: receiver3 ] value ]]
		thatSends: #ifTrue:
		to: receiver4 ] value.
	[ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ #_coverageTracker7511560_
		cover: (166 to: 174)
		declaredAt: (7 to: 15)
		by: aDividend.
	#_coverageTracker7511560_
		coverAll:
			{176 to: 181}
		evaluating: [ receiver5 isZero ]
		thatSends: #isZero
		to: receiver5 ] value.
	#_coverageTracker7511560_
		coverAll:
			{183 to: 189}
		evaluating: [ receiver6 ifTrue: [ ^ #_coverageTracker7511560_
					cover: (194 to: 202)
					declaredAt: (7 to: 15)
					by: aDividend ]]
		thatSends: #ifTrue:
		to: receiver6 ] value.
	[ | receiver11 |
	receiver11 _ [ | receiver7 |
	receiver7 _ #_coverageTracker7511560_
		cover: (209 to: 216)
		declaredAt: (23 to: 30)
		by: aDivisor.
	#_coverageTracker7511560_
		coverAll:
			{218 to: 227}
		evaluating: [ receiver7 isNegative ]
		thatSends: #isNegative
		to: receiver7 ] value.
	#_coverageTracker7511560_
		coverAll:
			{229 to: 235}
		evaluating: [ receiver11 ifTrue: [ ^ [ | receiver10 |
				receiver10 _ [ | receiver8 |
				receiver8 _ #_coverageTracker7511560_
					cover: (239 to: 247)
					declaredAt: (7 to: 15)
					by: aDividend.
				#_coverageTracker7511560_
					coverAll:
						{249 to: 255}
					evaluating: [ receiver8 negated ]
					thatSends: #negated
					to: receiver8 ] value.
				#_coverageTracker7511560_
					coverAll:
						{257 to: 257}
					evaluating: [
						receiver10 /
							[ | receiver9 |
							receiver9 _ #_coverageTracker7511560_
								cover: (259 to: 266)
								declaredAt: (23 to: 30)
								by: aDivisor.
							#_coverageTracker7511560_
								coverAll:
									{268 to: 274}
								evaluating: [ receiver9 negated ]
								thatSends: #negated
								to: receiver9 ] value ]
					thatSends: #/
					to: receiver10 ] value ]]
		thatSends: #ifTrue:
		to: receiver11 ] value.
	#_coverageTracker7511560_
		cover: (280 to: 300)
		declaredAt: (36 to: 56)
		by:
			(greatestCommonDivisor _ [ | receiver12 |
			receiver12 _ #_coverageTracker7511560_
				cover: (305 to: 313)
				declaredAt: (7 to: 15)
				by: aDividend.
			#_coverageTracker7511560_
				coverAll:
					{315 to: 340}
				evaluating: [
					receiver12 greatestCommonDivisorWith:
						(#_coverageTracker7511560_
							cover: (342 to: 349)
							declaredAt: (23 to: 30)
							by: aDivisor) ]
				thatSends: #greatestCommonDivisorWith:
				to: receiver12 ] value).
	#_coverageTracker7511560_
		cover: (353 to: 361)
		declaredAt: (58 to: 66)
		by:
			(numerator _ [ | receiver13 |
			receiver13 _ #_coverageTracker7511560_
				cover: (366 to: 374)
				declaredAt: (7 to: 15)
				by: aDividend.
			#_coverageTracker7511560_
				coverAll:
					{376 to: 377}
				evaluating: [
					receiver13 //
						(#_coverageTracker7511560_
							cover: (379 to: 399)
							declaredAt: (36 to: 56)
							by: greatestCommonDivisor) ]
				thatSends: #//
				to: receiver13 ] value).
	#_coverageTracker7511560_
		cover: (403 to: 413)
		declaredAt: (68 to: 78)
		by:
			(denominator _ [ | receiver14 |
			receiver14 _ #_coverageTracker7511560_
				cover: (418 to: 425)
				declaredAt: (23 to: 30)
				by: aDivisor.
			#_coverageTracker7511560_
				coverAll:
					{427 to: 428}
				evaluating: [
					receiver14 //
						(#_coverageTracker7511560_
							cover: (430 to: 450)
							declaredAt: (36 to: 56)
							by: greatestCommonDivisor) ]
				thatSends: #//
				to: receiver14 ] value).
	[ | receiver16 |
	receiver16 _ [ | receiver15 |
	receiver15 _ #_coverageTracker7511560_
		cover: (455 to: 465)
		declaredAt: (68 to: 78)
		by: denominator.
	#_coverageTracker7511560_
		coverAll:
			{467 to: 471}
		evaluating: [ receiver15 isOne ]
		thatSends: #isOne
		to: receiver15 ] value.
	#_coverageTracker7511560_
		coverAll:
			{473 to: 479}
		evaluating: [ receiver16 ifTrue: [ ^ #_coverageTracker7511560_
					cover: (484 to: 492)
					declaredAt: (58 to: 66)
					by: numerator ]]
		thatSends: #ifTrue:
		to: receiver16 ] value.
	^ [ | receiver18 |
	receiver18 _ [ | receiver17 |
	receiver17 _ #_coverageTracker7511560_
		coverAll:
			{500 to: 503}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker7511560_
		coverAll:
			{505 to: 507}
		evaluating: [ receiver17 new ]
		thatSends: #new
		to: receiver17 ] value.
	#_coverageTracker7511560_
		coverAll:
			{509 to: 523. 535 to: 539}
		evaluating: [
			receiver18
				initializeWith:
					(#_coverageTracker7511560_
						cover: (525 to: 533)
						declaredAt: (58 to: 66)
						by: numerator)
				over:
					(#_coverageTracker7511560_
						cover: (541 to: 551)
						declaredAt: (68 to: 78)
						by: denominator) ]
		thatSends: #initializeWith:over:
		to: receiver18 ] value.! !
!Behavior method!
fibonacci
	| one two |
	#_coverageTracker7511599_ markAsExecuted.
	#_coverageTracker7511599_
		cover: (27 to: 29)
		declaredAt: (15 to: 17)
		by:
			(one _ [ | receiver1 |
			receiver1 _ #_coverageTracker7511599_
				coverAll:
					{34 to: 39}
				by: Entero.
			#_coverageTracker7511599_
				coverAll:
					{41 to: 45}
				evaluating: [
					receiver1 with:
						(#_coverageTracker7511599_
							coverAll:
								{47 to: 47}
							byLiteralOrPseudoVariable: 1) ]
				thatSends: #with:
				to: receiver1 ] value).
	#_coverageTracker7511599_
		cover: (51 to: 53)
		declaredAt: (19 to: 21)
		by:
			(two _ [ | receiver2 |
			receiver2 _ #_coverageTracker7511599_
				coverAll:
					{58 to: 63}
				by: Entero.
			#_coverageTracker7511599_
				coverAll:
					{65 to: 69}
				evaluating: [
					receiver2 with:
						(#_coverageTracker7511599_
							coverAll:
								{71 to: 71}
							byLiteralOrPseudoVariable: 2) ]
				thatSends: #with:
				to: receiver2 ] value).
	[ | receiver6 |
	receiver6 _ [ | receiver3 |
	receiver3 _ #_coverageTracker7511599_
		coverAll:
			{76 to: 79}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker7511599_
		coverAll:
			{81 to: 90}
		evaluating: [ receiver3 isNegative ]
		thatSends: #isNegative
		to: receiver3 ] value.
	#_coverageTracker7511599_
		coverAll:
			{92 to: 98}
		evaluating: [
			receiver6 ifTrue: [
				[ | receiver5 |
				receiver5 _ #_coverageTracker7511599_
					coverAll:
						{101 to: 104}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker7511599_
					coverAll:
						{106 to: 111}
					evaluating: [
						receiver5 error:
							[ | receiver4 |
							receiver4 _ #_coverageTracker7511599_
								coverAll:
									{113 to: 118}
								by: Entero.
							#_coverageTracker7511599_
								coverAll:
									{120 to: 152}
								evaluating: [ receiver4 negativeFibonacciErrorDescription ]
								thatSends: #negativeFibonacciErrorDescription
								to: receiver4 ] value ]
					thatSends: #error:
					to: receiver5 ] value ]]
		thatSends: #ifTrue:
		to: receiver6 ] value.
	[ | receiver10 |
	receiver10 _ [ | receiver9 |
	receiver9 _ [ | receiver7 |
	receiver7 _ #_coverageTracker7511599_
		coverAll:
			{159 to: 162}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker7511599_
		coverAll:
			{164 to: 169}
		evaluating: [ receiver7 isZero ]
		thatSends: #isZero
		to: receiver7 ] value.
	#_coverageTracker7511599_
		coverAll:
			{171 to: 173}
		evaluating: [
			receiver9 or: [
				[ | receiver8 |
				receiver8 _ #_coverageTracker7511599_
					coverAll:
						{176 to: 179}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker7511599_
					coverAll:
						{181 to: 185}
					evaluating: [ receiver8 isOne ]
					thatSends: #isOne
					to: receiver8 ] value ]]
		thatSends: #or:
		to: receiver9 ] value.
	#_coverageTracker7511599_
		coverAll:
			{189 to: 195}
		evaluating: [ receiver10 ifTrue: [ ^ #_coverageTracker7511599_
					cover: (199 to: 201)
					declaredAt: (15 to: 17)
					by: one ]]
		thatSends: #ifTrue:
		to: receiver10 ] value.
	^ [ | receiver15 |
	receiver15 _ [ | receiver12 |
	receiver12 _ [ | receiver11 |
	receiver11 _ #_coverageTracker7511599_
		coverAll:
			{210 to: 213}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker7511599_
		coverAll:
			{215 to: 215}
		evaluating: [
			receiver11 -
				(#_coverageTracker7511599_
					cover: (217 to: 219)
					declaredAt: (15 to: 17)
					by: one) ]
		thatSends: #-
		to: receiver11 ] value.
	#_coverageTracker7511599_
		coverAll:
			{222 to: 230}
		evaluating: [ receiver12 fibonacci ]
		thatSends: #fibonacci
		to: receiver12 ] value.
	#_coverageTracker7511599_
		coverAll:
			{232 to: 232}
		evaluating: [
			receiver15 +
				[ | receiver14 |
				receiver14 _ [ | receiver13 |
				receiver13 _ #_coverageTracker7511599_
					coverAll:
						{235 to: 238}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker7511599_
					coverAll:
						{240 to: 240}
					evaluating: [
						receiver13 -
							(#_coverageTracker7511599_
								cover: (242 to: 244)
								declaredAt: (19 to: 21)
								by: two) ]
					thatSends: #-
					to: receiver13 ] value.
				#_coverageTracker7511599_
					coverAll:
						{247 to: 255}
					evaluating: [ receiver14 fibonacci ]
					thatSends: #fibonacci
					to: receiver14 ] value ]
		thatSends: #+
		to: receiver15 ] value.! !
!Behavior method!
greatestCommonDivisorWith: anEntero
	#_coverageTracker7511620_ markAsExecuted.
	^ [ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker7511620_
		coverAll:
			{40 to: 43}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker7511620_
		coverAll:
			{45 to: 49}
		evaluating: [ receiver1 class ]
		thatSends: #class
		to: receiver1 ] value.
	#_coverageTracker7511620_
		coverAll:
			{51 to: 55}
		evaluating: [
			receiver4 with:
				[ | receiver3 |
				receiver3 _ #_coverageTracker7511620_
					cover: (58 to: 62)
					declaredAt: (58 to: 62)
					by: value.
				#_coverageTracker7511620_
					coverAll:
						{64 to: 67}
					evaluating: [
						receiver3 gcd:
							[ | receiver2 |
							receiver2 _ #_coverageTracker7511620_
								cover: (69 to: 76)
								declaredAt: (28 to: 35)
								by: anEntero.
							#_coverageTracker7511620_
								coverAll:
									{78 to: 89}
								evaluating: [ receiver2 integerValue ]
								thatSends: #integerValue
								to: receiver2 ] value ]
					thatSends: #gcd:
					to: receiver3 ] value ]
		thatSends: #with:
		to: receiver4 ] value.! !
!Behavior method!
invalidNumberType
	#_coverageTracker7511624_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ #_coverageTracker7511624_
		coverAll:
			{21 to: 24}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker7511624_
		coverAll:
			{26 to: 31}
		evaluating: [
			receiver3 error:
				[ | receiver2 |
				receiver2 _ [ | receiver1 |
				receiver1 _ #_coverageTracker7511624_
					coverAll:
						{33 to: 36}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker7511624_
					coverAll:
						{38 to: 42}
					evaluating: [ receiver1 class ]
					thatSends: #class
					to: receiver1 ] value.
				#_coverageTracker7511624_
					coverAll:
						{44 to: 76}
					evaluating: [ receiver2 invalidNumberTypeErrorDescription ]
					thatSends: #invalidNumberTypeErrorDescription
					to: receiver2 ] value ]
		thatSends: #error:
		to: receiver3 ] value.! !
!Behavior method!
// aDivisor
	#_coverageTracker7511634_ markAsExecuted.
	^ [ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker7511634_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker7511634_
		coverAll:
			{21 to: 25}
		evaluating: [ receiver1 class ]
		thatSends: #class
		to: receiver1 ] value.
	#_coverageTracker7511634_
		coverAll:
			{27 to: 31}
		evaluating: [
			receiver4 with:
				[ | receiver3 |
				receiver3 _ #_coverageTracker7511634_
					cover: (33 to: 37)
					declaredAt: (33 to: 37)
					by: value.
				#_coverageTracker7511634_
					coverAll:
						{39 to: 40}
					evaluating: [
						receiver3 //
							[ | receiver2 |
							receiver2 _ #_coverageTracker7511634_
								cover: (42 to: 49)
								declaredAt: (4 to: 11)
								by: aDivisor.
							#_coverageTracker7511634_
								coverAll:
									{51 to: 62}
								evaluating: [ receiver2 integerValue ]
								thatSends: #integerValue
								to: receiver2 ] value ]
					thatSends: #//
					to: receiver3 ] value ]
		thatSends: #with:
		to: receiver4 ] value.! !
!Behavior method!
= anObject
	#_coverageTracker7511639_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ [ | receiver2 |
	receiver2 _ #_coverageTracker7511639_
		cover: (16 to: 23)
		declaredAt: (3 to: 10)
		by: anObject.
	#_coverageTracker7511639_
		coverAll:
			{25 to: 33}
		evaluating: [
			receiver2 isKindOf:
				[ | receiver1 |
				receiver1 _ #_coverageTracker7511639_
					coverAll:
						{35 to: 38}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker7511639_
					coverAll:
						{40 to: 44}
					evaluating: [ receiver1 class ]
					thatSends: #class
					to: receiver1 ] value ]
		thatSends: #isKindOf:
		to: receiver2 ] value.
	#_coverageTracker7511639_
		coverAll:
			{47 to: 50}
		evaluating: [
			receiver5 and: [
				[ | receiver4 |
				receiver4 _ #_coverageTracker7511639_
					cover: (54 to: 58)
					declaredAt: (54 to: 58)
					by: value.
				#_coverageTracker7511639_
					coverAll:
						{60 to: 60}
					evaluating: [
						receiver4 =
							[ | receiver3 |
							receiver3 _ #_coverageTracker7511639_
								cover: (62 to: 69)
								declaredAt: (3 to: 10)
								by: anObject.
							#_coverageTracker7511639_
								coverAll:
									{71 to: 82}
								evaluating: [ receiver3 integerValue ]
								thatSends: #integerValue
								to: receiver3 ] value ]
					thatSends: #=
					to: receiver4 ] value ]]
		thatSends: #and:
		to: receiver5 ] value.! !
!Behavior method!
negated
	#_coverageTracker7511645_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ #_coverageTracker7511645_
		coverAll:
			{12 to: 15}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker7511645_
		coverAll:
			{17 to: 17}
		evaluating: [
			receiver2 *
				[ | receiver1 |
				receiver1 _ #_coverageTracker7511645_
					coverAll:
						{20 to: 25}
					by: Entero.
				#_coverageTracker7511645_
					coverAll:
						{27 to: 31}
					evaluating: [
						receiver1 with:
							(#_coverageTracker7511645_
								coverAll:
									{33 to: 34}
								byLiteralOrPseudoVariable: -1) ]
					thatSends: #with:
					to: receiver1 ] value ]
		thatSends: #*
		to: receiver2 ] value.! !
!Behavior method!
/ aDivisor
	#_coverageTracker7511649_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ [ | receiver1 |
	receiver1 _ #_coverageTracker7511649_
		cover: (15 to: 22)
		declaredAt: (3 to: 10)
		by: aDivisor.
	#_coverageTracker7511649_
		coverAll:
			{24 to: 32}
		evaluating: [
			receiver1 isKindOf:
				(#_coverageTracker7511649_
					coverAll:
						{34 to: 39}
					by: Entero) ]
		thatSends: #isKindOf:
		to: receiver1 ] value.
	#_coverageTracker7511649_
		coverAll:
			{42 to: 48}
		evaluating: [ receiver3 ifTrue: [ ^ [ | receiver2 |
				receiver2 _ #_coverageTracker7511649_
					coverAll:
						{52 to: 59}
					by: Fraccion.
				#_coverageTracker7511649_
					coverAll:
						{61 to: 65. 72 to: 76}
					evaluating: [
						receiver2
							with:
								(#_coverageTracker7511649_
									coverAll:
										{67 to: 70}
									byLiteralOrPseudoVariable: self)
							over:
								(#_coverageTracker7511649_
									cover: (78 to: 85)
									declaredAt: (3 to: 10)
									by: aDivisor) ]
					thatSends: #with:over:
					to: receiver2 ] value ]]
		thatSends: #ifTrue:
		to: receiver3 ] value.
	[ | receiver9 |
	receiver9 _ [ | receiver4 |
	receiver4 _ #_coverageTracker7511649_
		cover: (91 to: 98)
		declaredAt: (3 to: 10)
		by: aDivisor.
	#_coverageTracker7511649_
		coverAll:
			{100 to: 108}
		evaluating: [
			receiver4 isKindOf:
				(#_coverageTracker7511649_
					coverAll:
						{110 to: 117}
					by: Fraccion) ]
		thatSends: #isKindOf:
		to: receiver4 ] value.
	#_coverageTracker7511649_
		coverAll:
			{119 to: 125}
		evaluating: [ receiver9 ifTrue: [ ^ [ | receiver8 |
				receiver8 _ #_coverageTracker7511649_
					coverAll:
						{129 to: 136}
					by: Fraccion.
				#_coverageTracker7511649_
					coverAll:
						{138 to: 142. 172 to: 176}
					evaluating: [
						receiver8
							with:
								[ | receiver6 |
								receiver6 _ #_coverageTracker7511649_
									coverAll:
										{144 to: 147}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker7511649_
									coverAll:
										{149 to: 149}
									evaluating: [
										receiver6 *
											[ | receiver5 |
											receiver5 _ #_coverageTracker7511649_
												cover: (151 to: 158)
												declaredAt: (3 to: 10)
												by: aDivisor.
											#_coverageTracker7511649_
												coverAll:
													{160 to: 170}
												evaluating: [ receiver5 denominator ]
												thatSends: #denominator
												to: receiver5 ] value ]
									thatSends: #*
									to: receiver6 ] value
							over:
								[ | receiver7 |
								receiver7 _ #_coverageTracker7511649_
									cover: (178 to: 185)
									declaredAt: (3 to: 10)
									by: aDivisor.
								#_coverageTracker7511649_
									coverAll:
										{187 to: 195}
									evaluating: [ receiver7 numerator ]
									thatSends: #numerator
									to: receiver7 ] value ]
					thatSends: #with:over:
					to: receiver8 ] value ]]
		thatSends: #ifTrue:
		to: receiver9 ] value.! !
!Behavior method!
initializeWith: aNumerator over: aDenominator
	"Estas precondiciones estan por si se comenten errores en la implementacion - Hernan"
	#_coverageTracker7511667_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ [ | receiver1 |
	receiver1 _ #_coverageTracker7511667_
		cover: (136 to: 145)
		declaredAt: (17 to: 26)
		by: aNumerator.
	#_coverageTracker7511667_
		coverAll:
			{147 to: 152}
		evaluating: [ receiver1 isZero ]
		thatSends: #isZero
		to: receiver1 ] value.
	#_coverageTracker7511667_
		coverAll:
			{154 to: 160}
		evaluating: [
			receiver3 ifTrue: [
				[ | receiver2 |
				receiver2 _ #_coverageTracker7511667_
					coverAll:
						{164 to: 167}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker7511667_
					coverAll:
						{169 to: 174}
					evaluating: [
						receiver2 error:
							(#_coverageTracker7511667_
								coverAll:
									{176 to: 207}
								byLiteralOrPseudoVariable: 'una fraccion no puede ser cero') ]
					thatSends: #error:
					to: receiver2 ] value ]]
		thatSends: #ifTrue:
		to: receiver3 ] value.
	[ | receiver6 |
	receiver6 _ [ | receiver4 |
	receiver4 _ #_coverageTracker7511667_
		cover: (213 to: 224)
		declaredAt: (34 to: 45)
		by: aDenominator.
	#_coverageTracker7511667_
		coverAll:
			{226 to: 230}
		evaluating: [ receiver4 isOne ]
		thatSends: #isOne
		to: receiver4 ] value.
	#_coverageTracker7511667_
		coverAll:
			{232 to: 238}
		evaluating: [
			receiver6 ifTrue: [
				[ | receiver5 |
				receiver5 _ #_coverageTracker7511667_
					coverAll:
						{242 to: 245}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker7511667_
					coverAll:
						{247 to: 252}
					evaluating: [
						receiver5 error:
							(#_coverageTracker7511667_
								coverAll:
									{254 to: 321}
								byLiteralOrPseudoVariable: 'una fraccion no puede tener denominador 1 porque sino es un entero') ]
					thatSends: #error:
					to: receiver5 ] value ]]
		thatSends: #ifTrue:
		to: receiver6 ] value.
	#_coverageTracker7511667_
		cover: (328 to: 336)
		declaredAt: (328 to: 336)
		by:
			(numerator _ #_coverageTracker7511667_
				cover: (341 to: 350)
				declaredAt: (17 to: 26)
				by: aNumerator).
	#_coverageTracker7511667_
		cover: (354 to: 364)
		declaredAt: (354 to: 364)
		by:
			(denominator _ #_coverageTracker7511667_
				cover: (369 to: 380)
				declaredAt: (34 to: 45)
				by: aDenominator).! !
!Behavior method!
isZero
	#_coverageTracker7511680_ markAsExecuted.
	^ #_coverageTracker7511680_
		coverAll:
			{11 to: 15}
		byLiteralOrPseudoVariable: false.! !
!Behavior method!
- aSubtrahend
	#_coverageTracker7511682_ markAsExecuted.
	[ | receiver6 |
	receiver6 _ [ | receiver1 |
	receiver1 _ #_coverageTracker7511682_
		cover: (18 to: 28)
		declaredAt: (3 to: 13)
		by: aSubtrahend.
	#_coverageTracker7511682_
		coverAll:
			{30 to: 38}
		evaluating: [
			receiver1 isKindOf:
				(#_coverageTracker7511682_
					coverAll:
						{40 to: 45}
					by: Entero) ]
		thatSends: #isKindOf:
		to: receiver1 ] value.
	#_coverageTracker7511682_
		coverAll:
			{48 to: 54}
		evaluating: [ receiver6 ifTrue: [ ^ [ | receiver5 |
				receiver5 _ [ | receiver2 |
				receiver2 _ #_coverageTracker7511682_
					coverAll:
						{58 to: 61}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker7511682_
					coverAll:
						{63 to: 67}
					evaluating: [ receiver2 class ]
					thatSends: #class
					to: receiver2 ] value.
				#_coverageTracker7511682_
					coverAll:
						{69 to: 73}
					evaluating: [
						receiver5 with:
							[ | receiver4 |
							receiver4 _ #_coverageTracker7511682_
								cover: (75 to: 79)
								declaredAt: (75 to: 79)
								by: value.
							#_coverageTracker7511682_
								coverAll:
									{81 to: 81}
								evaluating: [
									receiver4 -
										[ | receiver3 |
										receiver3 _ #_coverageTracker7511682_
											cover: (83 to: 93)
											declaredAt: (3 to: 13)
											by: aSubtrahend.
										#_coverageTracker7511682_
											coverAll:
												{95 to: 106}
											evaluating: [ receiver3 integerValue ]
											thatSends: #integerValue
											to: receiver3 ] value ]
								thatSends: #-
								to: receiver4 ] value ]
					thatSends: #with:
					to: receiver5 ] value ]]
		thatSends: #ifTrue:
		to: receiver6 ] value.
	[ | receiver15 |
	receiver15 _ [ | receiver7 |
	receiver7 _ #_coverageTracker7511682_
		cover: (112 to: 122)
		declaredAt: (3 to: 13)
		by: aSubtrahend.
	#_coverageTracker7511682_
		coverAll:
			{124 to: 132}
		evaluating: [
			receiver7 isKindOf:
				(#_coverageTracker7511682_
					coverAll:
						{134 to: 141}
					by: Fraccion) ]
		thatSends: #isKindOf:
		to: receiver7 ] value.
	#_coverageTracker7511682_
		coverAll:
			{144 to: 150}
		evaluating: [ receiver15 ifTrue: [ ^ [ | receiver14 |
				receiver14 _ #_coverageTracker7511682_
					coverAll:
						{154 to: 161}
					by: Fraccion.
				#_coverageTracker7511682_
					coverAll:
						{163 to: 167. 233 to: 237}
					evaluating: [
						receiver14
							with:
								[ | receiver12 |
								receiver12 _ [ | receiver10 |
								receiver10 _ [ | receiver8 |
								receiver8 _ #_coverageTracker7511682_
									coverAll:
										{170 to: 173}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker7511682_
									coverAll:
										{175 to: 179}
									evaluating: [ receiver8 value ]
									thatSends: #value
									to: receiver8 ] value.
								#_coverageTracker7511682_
									coverAll:
										{181 to: 181}
									evaluating: [
										receiver10 *
											[ | receiver9 |
											receiver9 _ #_coverageTracker7511682_
												cover: (183 to: 193)
												declaredAt: (3 to: 13)
												by: aSubtrahend.
											#_coverageTracker7511682_
												coverAll:
													{195 to: 205}
												evaluating: [ receiver9 denominator ]
												thatSends: #denominator
												to: receiver9 ] value ]
									thatSends: #*
									to: receiver10 ] value.
								#_coverageTracker7511682_
									coverAll:
										{208 to: 208}
									evaluating: [
										receiver12 -
											[ | receiver11 |
											receiver11 _ #_coverageTracker7511682_
												cover: (210 to: 220)
												declaredAt: (3 to: 13)
												by: aSubtrahend.
											#_coverageTracker7511682_
												coverAll:
													{222 to: 230}
												evaluating: [ receiver11 numerator ]
												thatSends: #numerator
												to: receiver11 ] value ]
									thatSends: #-
									to: receiver12 ] value
							over:
								[ | receiver13 |
								receiver13 _ #_coverageTracker7511682_
									cover: (241 to: 251)
									declaredAt: (3 to: 13)
									by: aSubtrahend.
								#_coverageTracker7511682_
									coverAll:
										{253 to: 263}
									evaluating: [ receiver13 denominator ]
									thatSends: #denominator
									to: receiver13 ] value ]
					thatSends: #with:over:
					to: receiver14 ] value ]]
		thatSends: #ifTrue:
		to: receiver15 ] value.! !
!Behavior method!
integerValue
	"Usamos integerValue en vez de value para que no haya problemas con el mensaje value implementado en Object - Hernan"
	#_coverageTracker7511704_ markAsExecuted.
	^ #_coverageTracker7511704_
		cover: (137 to: 141)
		declaredAt: (137 to: 141)
		by: value.! !
!Behavior method!
printOn: aStream
	#_coverageTracker7511706_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker7511706_
		cover: (20 to: 26)
		declaredAt: (10 to: 16)
		by: aStream.
	#_coverageTracker7511706_
		coverAll:
			{28 to: 33}
		evaluating: [
			receiver1 print:
				(#_coverageTracker7511706_
					cover: (35 to: 39)
					declaredAt: (35 to: 39)
					by: value) ]
		thatSends: #print:
		to: receiver1 ] value.! !
!Behavior method!
hash
	#_coverageTracker7511715_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker7511715_
		cover: (9 to: 13)
		declaredAt: (9 to: 13)
		by: value.
	#_coverageTracker7511715_
		coverAll:
			{15 to: 18}
		evaluating: [ receiver1 hash ]
		thatSends: #hash
		to: receiver1 ] value.! !
!Behavior method!
= anObject
	#_coverageTracker7511717_ markAsExecuted.
	^ [ | receiver8 |
	receiver8 _ [ | receiver2 |
	receiver2 _ #_coverageTracker7511717_
		cover: (16 to: 23)
		declaredAt: (3 to: 10)
		by: anObject.
	#_coverageTracker7511717_
		coverAll:
			{25 to: 33}
		evaluating: [
			receiver2 isKindOf:
				[ | receiver1 |
				receiver1 _ #_coverageTracker7511717_
					coverAll:
						{35 to: 38}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker7511717_
					coverAll:
						{40 to: 44}
					evaluating: [ receiver1 class ]
					thatSends: #class
					to: receiver1 ] value ]
		thatSends: #isKindOf:
		to: receiver2 ] value.
	#_coverageTracker7511717_
		coverAll:
			{47 to: 50}
		evaluating: [
			receiver8 and: [
				[ | receiver7 |
				receiver7 _ [ | receiver4 |
				receiver4 _ #_coverageTracker7511717_
					cover: (55 to: 63)
					declaredAt: (55 to: 63)
					by: numerator.
				#_coverageTracker7511717_
					coverAll:
						{65 to: 65}
					evaluating: [
						receiver4 *
							[ | receiver3 |
							receiver3 _ #_coverageTracker7511717_
								cover: (67 to: 74)
								declaredAt: (3 to: 10)
								by: anObject.
							#_coverageTracker7511717_
								coverAll:
									{76 to: 86}
								evaluating: [ receiver3 denominator ]
								thatSends: #denominator
								to: receiver3 ] value ]
					thatSends: #*
					to: receiver4 ] value.
				#_coverageTracker7511717_
					coverAll:
						{89 to: 89}
					evaluating: [
						receiver7 =
							[ | receiver6 |
							receiver6 _ #_coverageTracker7511717_
								cover: (92 to: 102)
								declaredAt: (92 to: 102)
								by: denominator.
							#_coverageTracker7511717_
								coverAll:
									{104 to: 104}
								evaluating: [
									receiver6 *
										[ | receiver5 |
										receiver5 _ #_coverageTracker7511717_
											cover: (106 to: 113)
											declaredAt: (3 to: 10)
											by: anObject.
										#_coverageTracker7511717_
											coverAll:
												{115 to: 123}
											evaluating: [ receiver5 numerator ]
											thatSends: #numerator
											to: receiver5 ] value ]
								thatSends: #*
								to: receiver6 ] value ]
					thatSends: #=
					to: receiver7 ] value ]]
		thatSends: #and:
		to: receiver8 ] value.! !
!Behavior method!
isOne
	#_coverageTracker7511731_ markAsExecuted.
	^ #_coverageTracker7511731_
		coverAll:
			{10 to: 14}
		byLiteralOrPseudoVariable: false.! !
!Behavior method!
isNegative
	#_coverageTracker7511733_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker7511733_
		cover: (15 to: 23)
		declaredAt: (15 to: 23)
		by: numerator.
	#_coverageTracker7511733_
		coverAll:
			{25 to: 25}
		evaluating: [
			receiver1 <
				(#_coverageTracker7511733_
					coverAll:
						{26 to: 27}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #<
		to: receiver1 ] value.! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:08:52'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:08:58'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:09:05'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:09:10'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:09:16'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:09:16'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:09:16'!
ERROR!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:09:31' prior: 50659116 overrides: 50655974!
- aSubtrahend

	(aSubtrahend isKindOf: Entero) ifTrue: [^self class with: value - aSubtrahend integerValue].
	(aSubtrahend isKindOf: Fraccion) ifTrue: [^Fraccion with: (self  * aSubtrahend denominator  - aSubtrahend numerator) over: 	(aSubtrahend denominator )].! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:09:38'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:09:38'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:09:38'!
ERROR!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:10:25'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:10:25'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:10:25'!
ERROR!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:11:15' prior: 50656173 overrides: 50655974!
- aSubtrahend
	(aSubtrahend isKindOf: Fraccion) ifTrue: [
	| newNumerator newDenominator |

	newNumerator := (numerator * aSubtrahend denominator) - (denominator * aSubtrahend numerator).
	newDenominator := denominator * aSubtrahend denominator.

	^newNumerator / newDenominator].
! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:16:45' prior: 50661881 overrides: 50655974!
- aSubtrahend
	(aSubtrahend isKindOf: Entero) ifTrue: [].
	(aSubtrahend isKindOf: Fraccion) ifTrue: [
	| newNumerator newDenominator |

	newNumerator := (numerator * aSubtrahend denominator) - (denominator * aSubtrahend numerator).
	newDenominator := denominator * aSubtrahend denominator.

	^newNumerator / newDenominator].
! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:17:26' prior: 50661894 overrides: 50655974!
- aSubtrahend
	(aSubtrahend isKindOf: Entero) ifTrue: [^Fraccion with: (aSubtrahend  * self denominator  - self numerator) over: 	(self denominator )].
	(aSubtrahend isKindOf: Fraccion) ifTrue: [
	| newNumerator newDenominator |

	newNumerator := (numerator * aSubtrahend denominator) - (denominator * aSubtrahend numerator).
	newDenominator := denominator * aSubtrahend denominator.

	^newNumerator / newDenominator].
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:17:31'!
FAILURE!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:17:31'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:17:31'!
FAILURE!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:19:51' prior: 50661908 overrides: 50655974!
- aSubtrahend
	(aSubtrahend isKindOf: Entero) ifTrue: [^Fraccion with: ( self numerator - aSubtrahend  * self denominator) over: 	(self denominator )].
	(aSubtrahend isKindOf: Fraccion) ifTrue: [
	| newNumerator newDenominator |

	newNumerator := (numerator * aSubtrahend denominator) - (denominator * aSubtrahend numerator).
	newDenominator := denominator * aSubtrahend denominator.

	^newNumerator / newDenominator].
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:19:53'!
FAILURE!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:19:53'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:19:53'!
FAILURE!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:20:34'!
FAILURE!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:20:34'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:20:34'!
FAILURE!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:21:26'!
FAILURE!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:21:26'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:21:26'!
FAILURE!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:23:30'!
FAILURE!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:23:30'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:23:30'!
FAILURE!

a := Fraccion with: 1 over: 5.!

a := Fraccion with: 1 over: 5.!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:25:50' prior: 50662065 overrides: 50655974!
- aSubtrahend
	(aSubtrahend isKindOf: Entero) ifTrue: [^Fraccion with: ( numerator - aSubtrahend  * denominator) over: 	(self denominator )].
	(aSubtrahend isKindOf: Fraccion) ifTrue: [
	| newNumerator newDenominator |

	newNumerator := (numerator * aSubtrahend denominator) - (denominator * aSubtrahend numerator).
	newDenominator := denominator * aSubtrahend denominator.

	^newNumerator / newDenominator].
! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:25:53' prior: 50662642 overrides: 50655974!
- aSubtrahend
	(aSubtrahend isKindOf: Entero) ifTrue: [^Fraccion with: ( numerator - aSubtrahend  * denominator) over: 	(denominator )].
	(aSubtrahend isKindOf: Fraccion) ifTrue: [
	| newNumerator newDenominator |

	newNumerator := (numerator * aSubtrahend denominator) - (denominator * aSubtrahend numerator).
	newDenominator := denominator * aSubtrahend denominator.

	^newNumerator / newDenominator].
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:25:56'!
FAILURE!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:25:56'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:25:56'!
FAILURE!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:26:17' prior: 50662659 overrides: 50655974!
- aSubtrahend
	(aSubtrahend isKindOf: Entero) ifTrue: [^Fraccion with: ( numerator - (aSubtrahend  * denominator)) over: 	(denominator )].
	(aSubtrahend isKindOf: Fraccion) ifTrue: [
	| newNumerator newDenominator |

	newNumerator := (numerator * aSubtrahend denominator) - (denominator * aSubtrahend numerator).
	newDenominator := denominator * aSubtrahend denominator.

	^newNumerator / newDenominator].
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:26:20'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:26:23'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:26:23'!
PASSED!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:43:56'!
m: anAdder

	(anAdder isKindOf: Entero) ifTrue: [^self class with: value + anAdder integerValue].	
	(anAdder isKindOf: Fraccion) ifTrue: [^Fraccion with: (self * anAdder  denominator + anAdder numerator) over: anAdder denominator ].
! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:44:27'!
m: anAdder

	(anAdder isKindOf: Entero) ifTrue: 
		[^Fraccion with: (anAdder * self denominator + self numerator) over: self denominator].
		
	(anAdder isKindOf: Fraccion) ifTrue:
		 [| newNumerator newDenominator |
		newNumerator := (numerator * anAdder denominator) + (denominator * anAdder numerator).
		newDenominator := denominator * anAdder denominator.
		^newNumerator / newDenominator ].! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:45:34' prior: 50657126 overrides: 50655970!
+ anAdder
	anAdder m: self
	
	"(anAdder isKindOf: Entero) ifTrue: [^self class with: value + anAdder integerValue].	
	(anAdder isKindOf: Fraccion) ifTrue: [^Fraccion with: (self * anAdder  denominator + anAdder numerator) over: anAdder denominator ].
	"
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:46:36'!
sumateAEntero: primerEntero

	^ value + primerEntero
	
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:46:41' prior: 50663140!
sumateAEntero: primerEntero

	^ value + primerEntero integerValue 
	
! !

!methodRemoval: Entero #m: stamp: 'MS 9/12/2023 15:46:59'!
m: anAdder

	(anAdder isKindOf: Entero) ifTrue: [^self class with: value + anAdder integerValue].	
	(anAdder isKindOf: Fraccion) ifTrue: [^Fraccion with: (self * anAdder  denominator + anAdder numerator) over: anAdder denominator ].
!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:47:07' prior: 50663129 overrides: 50655970!
+ anAdder
	anAdder sumateAEntero: self
	
	"(anAdder isKindOf: Entero) ifTrue: [^self class with: value + anAdder integerValue].	
	(anAdder isKindOf: Fraccion) ifTrue: [^Fraccion with: (self * anAdder  denominator + anAdder numerator) over: anAdder denominator ].
	"
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:47:12' prior: 50663160 overrides: 50655970!
+ anAdder
	anAdder sumateAEntero: self
	
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:47:42' prior: 50663113!
m: anAdder
	^Fraccion with: (anAdder * self denominator + self numerator) over: self denominator.
		
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:47:48'!
sumateAEntero: anAdder
	^Fraccion with: (anAdder * self denominator + self numerator) over: self denominator.
		
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:48:06' prior: 50663183!
sumateAEntero: primerSumandoEntero
	^Fraccion with: (primerSumandoEntero self denominator + self numerator) over: self denominator.
		
	! !

!methodRemoval: Fraccion #m: stamp: 'MS 9/12/2023 15:48:16'!
m: anAdder
	^Fraccion with: (anAdder * self denominator + self numerator) over: self denominator.
		
	!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:49:08'!
FAILURE!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:49:08'!
FAILURE!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:49:08'!
ERROR!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:49:08'!
FAILURE!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:49:08'!
FAILURE!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:49:08'!
FAILURE!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:49:08'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:49:16'!
FAILURE!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:50:59' prior: 50663145!
sumateAEntero: primerEntero

	^ value + primerEntero integerValue.
	
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:51:04'!
FAILURE!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:51:04'!
FAILURE!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:51:04'!
ERROR!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:51:04'!
FAILURE!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:51:04'!
FAILURE!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:51:04'!
FAILURE!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:51:04'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:51:10'!
FAILURE!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:51:27' prior: 50663172 overrides: 50655970!
+ anAdder
	^anAdder sumateAEntero: self
	
	! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:51:29'!
FAILURE!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:51:29'!
ERROR!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:51:29'!
ERROR!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:51:29'!
ERROR!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:51:29'!
ERROR!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:51:29'!
ERROR!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:51:29'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:51:29'!
PASSED!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:51:39' prior: 50663488 overrides: 50655970!
+ anAdder
	
	^anAdder sumateAEntero: self
	
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:51:44' prior: 50663629 overrides: 50655970!
+ anAdder
	
	^anAdder sumateAEntero: self.
	
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:52:02' prior: 50663342!
sumateAEntero: primerSumandoEntero

	^ value + primerSumandoEntero integerValue.
	
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:52:06'!
FAILURE!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:52:06'!
ERROR!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:52:06'!
ERROR!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:52:06'!
ERROR!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:52:06'!
ERROR!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:52:06'!
ERROR!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:52:06'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:52:08'!
FAILURE!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:52:42' prior: 50663640!
sumateAEntero: primerSumandoEntero

	^ Entero with: (value + primerSumandoEntero integerValue).
	
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:52:46'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:52:46'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:52:46'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:52:46'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:52:46'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:52:46'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:52:46'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:52:46'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:52:46'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:52:46'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:52:46'!
ERROR!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:52:47'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:52:47'!
ERROR!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:53:14' prior: 50663785!
sumateAEntero: primerSumandoEntero

	^ Entero with: (value + primerSumandoEntero integerValue).
	
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:53:18'!
ERROR!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:53:18'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:53:18'!
ERROR!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:54:03' prior: 50663190!
sumateAEntero: primerSumandoEntero
	^Fraccion with: (primerSumandoEntero * self denominator + self numerator) over: self denominator.
		
	! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 15:54:08'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 15:54:08'!
PASSED!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:56:35'!
multiplicateAEntero: aMultiplier
	aMultiplier multiplicateAEntero: self
	
	"(aMultiplier isKindOf: Entero) ifTrue: [^self class with: value * aMultiplier integerValue].
	(aMultiplier isKindOf: Fraccion) ifTrue: [^Fraccion with: (self * aMultiplier numerator)  over: aMultiplier denominator ].	"! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:57:10' prior: 50664220!
multiplicateAEntero: primerEnteroAMultiplicar
	^self class with: value * primerEnteroAMultiplicar integerValue
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:57:29' prior: 50664233!
multiplicateAEntero: primerEnteroAMultiplicar
	^self class with: (value * primerEnteroAMultiplicar integerValue)
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:58:09' prior: 50658221 overrides: 50655965!
* aMultiplier

	^ aMultiplier  multiplicateAEntero: self! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:59:31'!
multiplicateAEntero: primerEnteroAMultiplicas! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:59:31' prior: 50664253!
multiplicateAEntero: primerEnteroAMultiplica! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 15:59:32' prior: 50664258!
multiplicateAEntero: primerEnteroAMultiplicar! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:00:38' prior: 50664263!
multiplicateAEntero: primerEnteroAMultiplicar
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:01:00' prior: 50664268!
multiplicateAEntero: primerEnteroAMultiplicar
	^(numerator * primerEnteroAMultiplicar )/(denominator)! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:03:01' prior: 50657635 overrides: 50655970!
+ anAdder
	^ anAdder sumateAFraccion: self
	"(anAdder isKindOf: Entero) ifTrue: 
		[^Fraccion with: (anAdder * self denominator + self numerator) over: self denominator].
		
	(anAdder isKindOf: Fraccion) ifTrue:
		 [| newNumerator newDenominator |
		newNumerator := (numerator * anAdder denominator) + (denominator * anAdder numerator).
		newDenominator := denominator * anAdder denominator.
		^newNumerator / newDenominator ]."! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:03:18'!
sumateAFraccion: primerSumandoFraccion
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:03:51' prior: 50664296!
sumateAFraccion: primerSumandoFraccion
	| newNumerator newDenominator |
		newNumerator := (numerator * primerSumandoFraccion denominator) + (denominator * primerSumandoFraccion numerator).
		newDenominator := denominator * primerSumandoFraccion denominator.
		^newNumerator / newDenominator! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:04:19'!
sumateAFraccion: primerSumandoFraccion
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:05:16' prior: 50664313!
sumateAFraccion: primerSumandoFraccion
	^Fraccion with: (value * primerSumandoFraccion denominator + primerSumandoFraccion numerator) over: primerSumandoFraccion denominator! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:06:24' prior: 50664280 overrides: 50655970!
+ anAdder
	^ anAdder sumateAFraccion: self
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:09:10'!
multiplicateAFraccion: primerEnteroAMultiplicar
	^(numerator * primerEnteroAMultiplicar )/(denominator)! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:09:27' prior: 50658368 overrides: 50655965!
* aMultiplier
	^aMultiplier multiplicateAFraccion: self
	
	
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:09:49' prior: 50664339 overrides: 50655965!
* aMultiplier
	^aMultiplier multiplicateAFraccion: self
	"
	(aMultiplier isKindOf: Entero) ifTrue: [^(numerator * aMultiplier)/(denominator)].
	(aMultiplier isKindOf: Fraccion) ifTrue: [^(numerator * aMultiplier numerator) / (denominator * aMultiplier denominator) ].	
	"
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:10:18' prior: 50664332!
multiplicateAFraccion: primerEnteroAMultiplicar
	^(numerator * primerEnteroAMultiplicar numerator) / (denominator * primerEnteroAMultiplicar denominator) ! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:10:54'!
multiplicateAFraccion: primerFraccionAMultiplicar
	
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:11:46' prior: 50664365!
multiplicateAFraccion: primerFraccionAMultiplicar
	^(primerFraccionAMultiplicar numerator * self) / primerFraccionAMultiplicar denominator
	
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:11:51' prior: 50664370!
multiplicateAFraccion: primerFraccionAMultiplicar
	^(primerFraccionAMultiplicar numerator * self) / (primerFraccionAMultiplicar denominator)
	
	! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 16:12:08'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 16:12:08'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 16:12:08'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 16:12:08'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 16:12:08'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 16:12:08'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:12:08'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 16:12:08'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 16:12:08'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:12:08'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 16:12:08'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:12:08'!
ERROR!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 16:12:09'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:12:09'!
ERROR!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:13:23' prior: 50664318!
sumateAFraccion: primerSumandoFraccion
	^Fraccion with: ((value * primerSumandoFraccion denominator) + primerSumandoFraccion numerator) over: primerSumandoFraccion denominator! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:13:26'!
ERROR!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 16:13:26'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:13:26'!
ERROR!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:14:14' prior: 50664525!
sumateAFraccion: primerSumandoFraccion
	^Fraccion with: ((self * primerSumandoFraccion denominator) + primerSumandoFraccion numerator) over: primerSumandoFraccion denominator! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 16:14:17'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 16:14:17'!
PASSED!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:14:55' prior: 50661590 overrides: 50655974!
- aSubtrahend

"
	(aSubtrahend isKindOf: Entero) ifTrue: [^self class with: value - aSubtrahend integerValue].
	(aSubtrahend isKindOf: Fraccion) ifTrue: [^Fraccion with: (self  * aSubtrahend denominator  - aSubtrahend numerator) over: 	(aSubtrahend denominator )].
"! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:14:56' prior: 50664819 overrides: 50655974!
- aSubtrahend
	
"
	(aSubtrahend isKindOf: Entero) ifTrue: [^self class with: value - aSubtrahend integerValue].
	(aSubtrahend isKindOf: Fraccion) ifTrue: [^Fraccion with: (self  * aSubtrahend denominator  - aSubtrahend numerator) over: 	(aSubtrahend denominator )].
"! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:15:48'!
restateAEntero: primerSumandoEntero

	^ Entero with: (value + primerSumandoEntero integerValue).
	
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:15:52' prior: 50664842!
restateAEntero: primerSumandoEntero

	^ Entero with: (value - primerSumandoEntero integerValue).
	
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:16:01'!
restateAFraccion: primerSumandoFraccion
	^Fraccion with: ((self * primerSumandoFraccion denominator) + primerSumandoFraccion numerator) over: primerSumandoFraccion denominator! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:16:05' prior: 50664855!
restateAFraccion: primerSumandoFraccion
	^Fraccion with: ((self * primerSumandoFraccion denominator) - primerSumandoFraccion numerator) over: primerSumandoFraccion denominator! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:16:26' prior: 50664831 overrides: 50655974!
- aSubtrahend
	^ aSubtrahend restateAEntero: self
"
	(aSubtrahend isKindOf: Entero) ifTrue: [^self class with: value - aSubtrahend integerValue].
	(aSubtrahend isKindOf: Fraccion) ifTrue: [^Fraccion with: (self  * aSubtrahend denominator  - aSubtrahend numerator) over: 	(aSubtrahend denominator )].
"! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:16:45'!
restateAEntero: primerSumandoEntero
	^Fraccion with: (primerSumandoEntero * self denominator + self numerator) over: self denominator.
		
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:16:50' prior: 50664886!
restateAEntero: primerSumandoEntero
	^Fraccion with: (primerSumandoEntero * self denominator - self numerator) over: self denominator.
		
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:17:03'!
restateAFraccion: primerSumandoFraccion
	| newNumerator newDenominator |
		newNumerator := (numerator * primerSumandoFraccion denominator) + (denominator * primerSumandoFraccion numerator).
		newDenominator := denominator * primerSumandoFraccion denominator.
		^newNumerator / newDenominator! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:17:11' prior: 50664901!
restateAFraccion: primerSumandoFraccion
	| newNumerator newDenominator |
		newNumerator := (numerator * primerSumandoFraccion denominator) - (denominator * primerSumandoFraccion numerator).
		newDenominator := denominator * primerSumandoFraccion denominator.
		^newNumerator / newDenominator! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:18:17' prior: 50664894!
restateAEntero: primerSumandoEntero
	^Fraccion with: ( numerator - (primerSumandoEntero  * denominator)) over: 	(denominator )! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:18:39' prior: 50662815 overrides: 50655974!
- aSubtrahend
	^aSubtrahend restateAFraccion: self! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:18:42'!
FAILURE!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 16:18:42'!
ERROR!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 16:18:42'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 16:18:42'!
PASSED!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:19:33' prior: 50664849!
restateAEntero: primerSumandoEntero

	^self class with: value - primerSumandoEntero integerValue
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:19:35'!
FAILURE!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 16:19:35'!
ERROR!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 16:19:35'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:19:40'!
FAILURE!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:20:00'!
FAILURE!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 16:20:00'!
ERROR!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 16:20:00'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:20:01'!
FAILURE!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:20:33' prior: 50665076!
restateAEntero: primerSumandoEntero

	^self class with: primerSumandoEntero integerValue - value
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:20:35'!
FAILURE!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:20:35'!
FAILURE!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:20:35'!
FAILURE!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:20:35'!
FAILURE!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 16:20:35'!
FAILURE!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 16:20:35'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 16:20:35'!
PASSED!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:21:02' prior: 50664864!
restateAFraccion: primerSumandoFraccion
	^Fraccion with: (primerSumandoFraccion numerator - (self * primerSumandoFraccion denominator)) over: primerSumandoFraccion denominator! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:21:32' prior: 50664927!
restateAEntero: primerSumandoEntero
	^Fraccion with: ((primerSumandoEntero  * denominator) - numerator ) over: 	(denominator )! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:21:44' prior: 50664914!
restateAFraccion: primerSumandoFraccion
	| newNumerator newDenominator |
		newNumerator := (denominator * primerSumandoFraccion numerator) - (numerator * primerSumandoFraccion denominator). 
		newDenominator := denominator * primerSumandoFraccion denominator.
		^newNumerator / newDenominator! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 16:21:48'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 16:21:48'!
PASSED!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:22:38' prior: 50658651 overrides: 50655979!
/ aDivisor
	"^aDivisor dividiteAEntero: self"
	"
	(aDivisor isKindOf: Entero) ifTrue: [^Fraccion with: self over: aDivisor].
	(aDivisor isKindOf: Fraccion)ifTrue: [^Fraccion with: self * aDivisor denominator over: aDivisor numerator].
	"! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:23:02'!
dividiteAEntero: enteroADividir

	
	
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:23:43' prior: 50665679!
dividiteAEntero: enteroADividir
	^Fraccion with: enteroADividir over: self
	
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:24:12'!
dividiteAFraccion: fraccionADividir
	"^Fraccion with:  over: self"
	
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:25:24' prior: 50665689!
dividiteAFraccion: fraccionADividir
	^Fraccion with:  fraccionADividir denominator over: (fraccionADividir numerator * self)
	
! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:26:20'!
dividiteAEntero: primerEnteroADividir
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:30:42' prior: 50665702!
dividiteAEntero: primerEnteroADividir
	^Fraccion with: primerEnteroADividir * denominator over: numerator
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:30:58' prior: 50665669 overrides: 50655979!
/ aDivisor
	^aDivisor dividiteAEntero: self
	"
	(aDivisor isKindOf: Entero) ifTrue: [^Fraccion with: self over: aDivisor].
	(aDivisor isKindOf: Fraccion)ifTrue: [^Fraccion with: self * aDivisor denominator over: aDivisor numerator].
	"! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:31:24' prior: 50658969 overrides: 50655979!
/ aDivisor
	^aDivisor dividiteAFraccion: self
	"
	(aDivisor isKindOf: Fraccion) ifTrue: [^(numerator * aDivisor denominator) / (denominator * aDivisor numerator)].
	(aDivisor isKindOf: Entero) ifTrue: [^Fraccion with: self numerator over: self denominator * aDivisor].
	"! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:31:41'!
dividiteAFraccion: primerEnteroADividir
	^Fraccion with: primerEnteroADividir * denominator over: numerator
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:32:22' prior: 50665738!
dividiteAFraccion: primerEnteroADividir
	^(primerEnteroADividir numerator * denominator) / (primerEnteroADividir denominator * numerator)
	! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:32:31'!
FAILURE!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 16:32:31'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:32:31'!
FAILURE!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:33:14' prior: 50665695!
dividiteAFraccion: fraccionADividir
	^Fraccion with:  fraccionADividir numerator over: (fraccionADividir denominator * self)
	
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 16:33:15'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 16:33:16'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 16:43:44'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 16:43:44'!
PASSED!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:46:29' prior: 50665714 overrides: 50655979!
/ aDivisor
	^aDivisor dividiteAEntero: self
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:47:55' prior: 50665504!
restateAFraccion: primerRestandoFraccion
	^Fraccion with: (primerRestandoFraccion numerator - (self * primerRestandoFraccion denominator)) over: primerRestandoFraccion denominator! !
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:48:10' prior: 50665361!
restateAEntero: primerRestandoEntero

	^self class with: primerRestandoEntero integerValue - value
! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:48:35' prior: 50665707!
dividiteAEntero: enteroADividir
	^Fraccion with: enteroADividir * denominator over: numerator
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:49:07' prior: 50665745!
dividiteAFraccion: fraccionADividir
	^(fraccionADividir numerator * denominator) / (fraccionADividir denominator * numerator)
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:49:38' prior: 50664273!
multiplicateAEntero: enteroAMultiplicar
	^(numerator * enteroAMultiplicar )/(denominator)! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:49:54' prior: 50664357!
multiplicateAFraccion: fraccionAMultiplicar
	^(numerator * fraccionAMultiplicar numerator) / (denominator * fraccionAMultiplicar denominator) ! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:50:09' prior: 50665513!
restateAEntero: primerRestandoEntero
	^Fraccion with: ((primerRestandoEntero  * denominator) - numerator ) over: 	(denominator )! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 16:50:39' prior: 50665520!
restateAFraccion: primerRestandoFraccion
	| newNumerator newDenominator |
		newNumerator := (denominator * primerRestandoFraccion numerator) - (numerator * primerRestandoFraccion denominator). 
		newDenominator := denominator * primerRestandoFraccion denominator.
		^newNumerator / newDenominator! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/12/2023 16:50:47'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/12/2023 16:50:47'!
PASSED!
!Entero methodsFor: 'arithmetic operations' stamp: 'MS 9/12/2023 18:01:44' prior: 50666186!
restateAEntero: primerRestandoEntero

	^Entero with: primerRestandoEntero integerValue - value
! !

----STARTUP---- (13 September 2023 11:14:09) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/ClasesDeInge1/02-Numeros/Numero-Exercise.st----!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test07FraccionAddsWithFraccionCorrectly stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test08FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test09AparentFraccionesAreEqual stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test10AddingFraccionesCanReturnAnEntero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test11MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test12AFraccionCanNotBeZero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test13AFraccionCanNotBeOne stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/13/2023 11:17:25'!
ERROR!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/13/2023 11:17:25'!
ERROR!

!testRun: #NumeroTest #test14NegationOfEnteroIsCorrect stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/13/2023 11:17:25'!
ERROR!

!testRun: #NumeroTest #test15NegationOfFraccionIsCorrect stamp: 'MS 9/13/2023 11:17:25'!
FAILURE!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/13/2023 11:17:25'!
ERROR!

!testRun: #NumeroTest #test16SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test17SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/13/2023 11:17:25'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/13/2023 11:17:25'!
ERROR!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/13/2023 11:17:25'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/13/2023 11:17:25'!
ERROR!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/13/2023 11:17:25'!
PASSED!

!classRemoval: #Fraccion stamp: 'MS 9/13/2023 11:18:03'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Entero stamp: 'MS 9/13/2023 11:18:04'!
Numero subclass: #Entero
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Numero stamp: 'MS 9/13/2023 11:18:04'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #NumeroTest stamp: 'MS 9/13/2023 11:18:04'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

----End fileIn of /home/martin/Desktop/Inge1/ClasesDeInge1/02-Numeros/Numero-Ej.st----!

!classRemoval: #Fraccion stamp: 'MS 9/13/2023 11:18:31'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Entero stamp: 'MS 9/13/2023 11:18:31'!
Numero subclass: #Entero
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Numero stamp: 'MS 9/13/2023 11:18:31'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #NumeroTest stamp: 'MS 9/13/2023 11:18:31'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

----End fileIn of /home/martin/Desktop/Inge1/ClasesDeInge1/02-Numeros/Numeros-Ejercicio.st----!

!classRemoval: #Fraccion stamp: 'MS 9/13/2023 11:19:38'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Entero stamp: 'MS 9/13/2023 11:19:38'!
Numero subclass: #Entero
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Numero stamp: 'MS 9/13/2023 11:19:38'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #NumeroTest stamp: 'MS 9/13/2023 11:19:38'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

----End fileIn of /home/martin/Desktop/Inge1/ClasesDeInge1/02-Numeros/Numero-Exercise.st----!

----STARTUP---- (13 September 2023 11:22:50) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/Repo/Inge1_Santesteban_Segre/02-Numeros/Numero-Exercise.st----!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'MS 9/13/2023 11:26:04'!
PASSED!

----STARTUP---- (17 September 2023 17:33:22) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Stack-Exercise.st----!

Object subclass: #NameOfSubclass
	instanceVariableNames: 'collection'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NameOfSubclass category: 'Stack-Exercise' stamp: 'MS 9/17/2023 17:38:48'!
Object subclass: #NameOfSubclass
	instanceVariableNames: 'collection'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #NameOfSubclass stamp: 'MS 9/17/2023 17:39:53'!
Object subclass: #NameOfSubclass
	instanceVariableNames: 'collection'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: 'Stack-Exercise' stamp: 'MS 9/17/2023 17:41:08'!
Object subclass: #OOStack
	instanceVariableNames: 'collection'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'MS 9/17/2023 17:41:04' overrides: 16920235!
initialize
	collection := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:41:48'!
isEmpty
	^collection isEmpty! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:42:25'!
push: anElement
	^collection add: anElement! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:42:41'!
top
	^collection last! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:43:41'!
pop
	| lastElement |
	lastElement := collection last.
	collection remove.
	^lastElement
	! !

----End fileIn of /home/martin/Desktop/Inge1/linux64/linux64/Packages/TerseGuide.pck.st----!
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:44:53' prior: 50669551!
pop
	| lastElement |
	lastElement := collection last.
	collection removeLast.
	^lastElement
	! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:45:29' prior: 50672477!
pop
	"| lastElement |"
	"lastElement := collection last."
	^collection removeLast.
	"^lastElement"
	! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:46:01' overrides: 16901663!
size
	^collection size! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'MS 9/17/2023 17:46:11'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'MS 9/17/2023 17:46:11'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'MS 9/17/2023 17:46:11'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'MS 9/17/2023 17:46:11'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'MS 9/17/2023 17:46:11'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'MS 9/17/2023 17:46:11'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'MS 9/17/2023 17:46:11'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'MS 9/17/2023 17:46:11'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'MS 9/17/2023 17:46:11'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'MS 9/17/2023 17:46:11'!
FAILURE!
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:46:33' prior: 50672483!
pop
	^collection removeLast.
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'MS 9/17/2023 17:46:44'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'MS 9/17/2023 17:46:44'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'MS 9/17/2023 17:46:44'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'MS 9/17/2023 17:46:44'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'MS 9/17/2023 17:46:44'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'MS 9/17/2023 17:46:44'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'MS 9/17/2023 17:46:44'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'MS 9/17/2023 17:46:44'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'MS 9/17/2023 17:46:44'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'MS 9/17/2023 17:46:44'!
FAILURE!
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:48:30' prior: 50672526!
pop
	self isEmpty ifTrue: [self error: self class stackEmptyErrorDescription.]
	! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:48:49' prior: 50672563!
pop
	self isEmpty ifTrue: [self error: self class stackEmptyErrorDescription.]
	^collection removeLast.
	! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:48:52' prior: 50672569!
pop
	self isEmpty ifTrue: [self error: self class stackEmptyErrorDescription.].
	^collection removeLast.
	! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:49:19' prior: 50669548!
top
	self isEmpty ifTrue: [self error: self class stackEmptyErrorDescription.].
	^collection last! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'MS 9/17/2023 17:49:32'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'MS 9/17/2023 17:49:32'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'MS 9/17/2023 17:49:32'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'MS 9/17/2023 17:49:32'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'MS 9/17/2023 17:49:32'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'MS 9/17/2023 17:49:32'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'MS 9/17/2023 17:49:32'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'MS 9/17/2023 17:49:32'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'MS 9/17/2023 17:49:32'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'MS 9/17/2023 17:49:32'!
PASSED!

Object subclass: #StackBase
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #StackBase category: 'Stack-Exercise' stamp: 'MS 9/17/2023 17:51:27'!
Object subclass: #StackBase
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #StackBase
	instanceVariableNames: 'bottomElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #StackBase category: 'Stack-Exercise' stamp: 'MS 9/17/2023 17:52:12'!
Object subclass: #StackBase
	instanceVariableNames: 'bottomElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #StackElement
	instanceVariableNames: 'bottomElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #StackElement category: 'Stack-Exercise' stamp: 'MS 9/17/2023 17:52:49'!
Object subclass: #StackElement
	instanceVariableNames: 'bottomElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #StackElement
	instanceVariableNames: 'nextElement previousElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #StackElement category: 'Stack-Exercise' stamp: 'MS 9/17/2023 17:53:32'!
Object subclass: #StackElement
	instanceVariableNames: 'nextElement previousElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #StackElement
	instanceVariableNames: 'upperElement lowerElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #StackElement category: 'Stack-Exercise' stamp: 'MS 9/17/2023 17:53:57'!
Object subclass: #StackElement
	instanceVariableNames: 'upperElement lowerElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #OOStack
	instanceVariableNames: 'topElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: 'Stack-Exercise' stamp: 'MS 9/17/2023 17:55:48'!
Object subclass: #OOStack
	instanceVariableNames: 'topElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #StackElement
	instanceVariableNames: 'lowerElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #StackElement category: 'Stack-Exercise' stamp: 'MS 9/17/2023 17:56:22'!
Object subclass: #StackElement
	instanceVariableNames: 'lowerElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'MS 9/17/2023 17:57:16' prior: 50669536 overrides: 16920235!
initialize
	topElement := StackBase new! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:57:51' prior: 50669540!
isEmpty
	^topElement isEmpty! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:58:12' prior: 50672489 overrides: 16901663!
size
	^topElement size! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:58:27' prior: 50672581!
top
	^topElement top! !

Object subclass: #StackElement
	instanceVariableNames: 'lowerElement value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #StackElement category: 'Stack-Exercise' stamp: 'MS 9/17/2023 17:58:55'!
Object subclass: #StackElement
	instanceVariableNames: 'lowerElement value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:59:13' prior: 50672575!
pop
	^topElement pop
	! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 17:59:25' prior: 50669544!
push: anElement
	^topElement push: anElement! !
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:00:38'!
isEmpty
	^true! !
!StackElement methodsFor: 'operations' stamp: 'MS 9/17/2023 18:01:06'!
isEmpty
	^false! !
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:01:21' overrides: 16901663!
size
	^0! !
!StackElement methodsFor: 'operations' stamp: 'MS 9/17/2023 18:01:48' overrides: 16901663!
size
	^ 1 + lowerElement size! !
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:04:37'!
top
	^ self error: 'no tontito'! !

OOStack subclass: #StackBase
	instanceVariableNames: 'bottomElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #StackBase category: 'Stack-Exercise' stamp: 'MS 9/17/2023 18:04:53'!
OOStack subclass: #StackBase
	instanceVariableNames: 'bottomElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStack subclass: #StackElement
	instanceVariableNames: 'lowerElement value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #StackElement category: 'Stack-Exercise' stamp: 'MS 9/17/2023 18:05:11'!
OOStack subclass: #StackElement
	instanceVariableNames: 'lowerElement value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:08:23' prior: 50672756 overrides: 50672717!
top
	^ self class stackEmptyErrorDescription ! !
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:08:31' overrides: 50672733!
pop
	^ self class stackEmptyErrorDescription ! !
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:08:50' overrides: 50672737!
push: anElement
^ self class stackEmptyErrorDescription ! !
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:11:05' prior: 50672795 overrides: 50672737!
push: anElement
	^anElement! !
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:11:10' prior: 50672801 overrides: 50672737!
push: anElement
	! !
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:12:21' prior: 50672806 overrides: 50672737!
push: anElement
	StackElement initializeWith: anElement over: self! !
!StackElement class methodsFor: 'initialization' stamp: 'MS 9/17/2023 18:13:51'!
initializeWith: value over: lowerElement
	^self new initializeWith: value over: lowerElement.! !
!StackElement methodsFor: 'initialization' stamp: 'MS 9/17/2023 18:14:45'!
initializeWith: aValue over: aLowerElement
	value:= aValue
	! !
!StackElement methodsFor: 'initialization' stamp: 'MS 9/17/2023 18:15:18' prior: 50672821!
initializeWith: aValue over: aLowerElement
	value:= aValue.
	lowerElement := aLowerElement.
	! !
!StackElement methodsFor: 'initialization' stamp: 'MS 9/17/2023 18:15:28' prior: 50672826!
initializeWith: aValue over: aLowerElement
	value:= aValue.
	lowerElement := aLowerElement.
	
	! !
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:16:18' prior: 50672810 overrides: 50672737!
push: anElement
	StackElement initializeWith: anElement over: self! !
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:16:22' prior: 50672839 overrides: 50672737!
push: anElement
	StackElement initializeWith: anElement over: self.! !
!StackElement class methodsFor: 'initialization' stamp: 'MS 9/17/2023 18:16:31' prior: 50672815!
initializeWith: value over: lowerElement
	^self new initializeWith: value over: lowerElement.! !
!StackElement methodsFor: 'initialization' stamp: 'MS 9/17/2023 18:16:59'!
initializeWith: aValue Over: aLowerElement
	value:= aValue.
	lowerElement := aLowerElement.
	
	! !
!StackElement class methodsFor: 'initialization' stamp: 'MS 9/17/2023 18:16:59'!
initializeWith: value Over: lowerElement
	^self new initializeWith: value over: lowerElement.! !
!StackElement class methodsFor: 'as yet unclassified' stamp: 'MS 9/17/2023 18:16:59' prior: 50672851!
initializeWith: value over: lowerElement
	^self new initializeWith: value Over: lowerElement.! !
!StackElement class methodsFor: 'as yet unclassified' stamp: 'MS 9/17/2023 18:16:59' prior: 50672863!
initializeWith: value Over: lowerElement
	^self new initializeWith: value Over: lowerElement.! !

!methodRemoval: StackElement #initializeWith:over: stamp: 'MS 9/17/2023 18:16:59'!
initializeWith: aValue over: aLowerElement
	value:= aValue.
	lowerElement := aLowerElement.
	
	!

!methodRemoval: StackElement class #initializeWith:over: stamp: 'MS 9/17/2023 18:16:59'!
initializeWith: value over: lowerElement
	^self new initializeWith: value Over: lowerElement.!
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:17:31' prior: 50672845 overrides: 50672737!
push: anElement
	StackElement initializeWith: anElement Over: self.! !
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:18:27' prior: 50672895 overrides: 50672737!
push: anElement
	bottomElement := StackElement initializeWith: anElement Over: self.! !
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:19:26' prior: 50672901 overrides: 50672737!
push: anElement
	StackElement initializeWith: anElement Over: self.! !

OOStack subclass: #StackBase
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #StackBase category: 'Stack-Exercise' stamp: 'MS 9/17/2023 18:19:32'!
OOStack subclass: #StackBase
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:19:57' prior: 50672907 overrides: 50672737!
push: anElement
	^StackElement initializeWith: anElement Over: self.
	! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 18:21:04' prior: 50672737!
push: anElement
	topElement := topElement push: anElement
	^topElement ! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 18:21:24' prior: 50672929!
push: anElement
	topElement := topElement push: anElement! !
!StackElement methodsFor: 'operations' stamp: 'MS 9/17/2023 18:24:33' overrides: 50672717!
top
	^value! !
!StackElement methodsFor: 'operations' stamp: 'MS 9/17/2023 18:24:48' prior: 50672939 overrides: 50672717!
top
	^ value! !
!StackElement methodsFor: 'operations' stamp: 'MS 9/17/2023 18:24:52' overrides: 50672733!
pop
	^ value! !
!StackElement methodsFor: 'operations' stamp: 'MS 9/17/2023 18:25:03' prior: 50672947 overrides: 50672733!
pop
	^lowerElement! !
!StackElement methodsFor: 'operations' stamp: 'MS 9/17/2023 18:25:11' overrides: 50672934!
push: anElement
	^lowerElement! !
!StackElement methodsFor: 'operations' stamp: 'MS 9/17/2023 18:26:03' prior: 50672955 overrides: 50672934!
push: anElement
	^self class initializeWith: anElement Over: self! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 18:30:04' prior: 50672733!
pop
	^topElement pop
	! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 18:31:32' prior: 50672965!
pop
	^topElement pop
	! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 18:32:34' prior: 50672969!
pop
	|value|
	value := topElement top.
	topElement pop.
	^value
	! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 18:32:41' prior: 50672973!
pop
	|value|
	value := topElement top.
	topElement := topElement pop.
	^value
	! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 18:33:34' prior: 50672978!
pop
	|value|
	value := topElement top.
	topElement := topElement pop.
	^value
	! !

!methodRemoval: StackBase #push: stamp: 'MS 9/17/2023 18:36:21'!
push: anElement
	^StackElement initializeWith: anElement Over: self.
	!

!methodRemoval: StackElement #push: stamp: 'MS 9/17/2023 18:36:27'!
push: anElement
	^self class initializeWith: anElement Over: self!
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 18:37:05' prior: 50672934!
push: anElement
	topElement := StackElement initializeWith: anElement  over: topElement .! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 18:37:10' prior: 50672998!
push: anElement
	topElement := StackElement initializeWith: anElement  Over: topElement .! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 18:37:14' prior: 50673004!
push: anElement
	topElement := StackElement initializeWith: anElement Over: topElement .! !
!StackElement methodsFor: 'operations' stamp: 'MS 9/17/2023 18:37:54' prior: 50672943 overrides: 50672717!
top
	^value! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 18:38:47' prior: 50672717!
top
	^topElement value! !
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:38:54' overrides: 16902254!
value
	^ self class stackEmptyErrorDescription ! !

!methodRemoval: StackBase #top stamp: 'MS 9/17/2023 18:39:00'!
top
	^ self class stackEmptyErrorDescription !
!StackElement methodsFor: 'operations' stamp: 'MS 9/17/2023 18:39:20' overrides: 16902254!
value
	^value! !

!methodRemoval: StackElement #top stamp: 'MS 9/17/2023 18:39:20'!
top
	^value!
!StackBase methodsFor: 'operations' stamp: 'MS 9/17/2023 18:39:54'!
lowerElement
	^ self class stackEmptyErrorDescription ! !

!methodRemoval: StackBase #pop stamp: 'MS 9/17/2023 18:39:59'!
pop
	^ self class stackEmptyErrorDescription !
!StackElement methodsFor: 'operations' stamp: 'MS 9/17/2023 18:40:08'!
lowerElement
	^lowerElement! !

!methodRemoval: StackElement #pop stamp: 'MS 9/17/2023 18:40:12'!
pop
	^lowerElement!
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 18:40:39' prior: 50672984!
pop
	|value|
	value := topElement value.
	topElement := topElement pop.
	^value
	! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 18:40:50' prior: 50673054!
pop
	|value|
	value := topElement value.
	topElement := topElement lowerElement.
	^value
	! !

!classRemoval: #SentenceFinderByPrefix stamp: 'MS 9/17/2023 19:10:51'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #StackElement stamp: 'MS 9/17/2023 19:10:51'!
OOStack subclass: #StackElement
	instanceVariableNames: 'lowerElement value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #StackBase stamp: 'MS 9/17/2023 19:10:51'!
OOStack subclass: #StackBase
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'MS 9/17/2023 19:10:51'!
Object subclass: #OOStack
	instanceVariableNames: 'topElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'MS 9/17/2023 19:10:52'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'MS 9/17/2023 19:10:52'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

----End fileIn of /home/martin/Downloads/Stack-Exercise.st----!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'MS 9/17/2023 19:11:12'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'MS 9/17/2023 19:11:12'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'MS 9/17/2023 19:11:12'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'MS 9/17/2023 19:11:12'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'MS 9/17/2023 19:11:12'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'MS 9/17/2023 19:11:12'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'MS 9/17/2023 19:11:12'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'MS 9/17/2023 19:11:12'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'MS 9/17/2023 19:11:12'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'MS 9/17/2023 19:11:12'!
PASSED!
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:14:39'!
find: unStack! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:14:42' prior: 50673413!
find: aStack! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:15:02'!
findPrefix: aPrefix in: aStack! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:15:07' prior: 50673421!
findPrefix: aPrefix in: aStack
	! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:17:43' prior: 50673426!
findPrefix: aPrefix in: aStack
	aPrefix isEmpty ifTrue: [self error: 'prefijo vacio'.].! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:17:44' prior: 50673431!
findPrefix: aPrefix in: aStack
	aPrefix isEmpty ifTrue: [self error: 'prefijo vacio'.].
	! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:22:22' prior: 50673437!
findPrefix: aPrefix in: aStack
	aPrefix isEmpty ifTrue: [self error: 'prefijo vacio'.].
	! !

String browseClassHierarchy !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:23:46' prior: 50673443!
findPrefix: aPrefix in: aStack
	aPrefix isEmpty ifTrue: [self error: 'prefijo vacio'.].
	
	! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:24:44' prior: 50673450!
findPrefix: aPrefix in: aStack
	| aString |
	aPrefix isEmpty ifTrue: [self error: 'prefijo vacio'.].
	aString := aStack top.	
	! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:26:40' prior: 50673456!
findPrefix: aPrefix in: aStack
	| aString |
	aPrefix isEmpty ifTrue: [self error: 'prefijo vacio'.].
	aString := aStack top.	
	aString is: aPrefix substringAt: 0! !

'holanda'is: 'hola' substringAt: 0!

'holanda'is: 'hola' substringAt: 0!

'holanda'is: 'hola' substringAt: 0!

'holanda'is: 'hola' substringAt: 0!

'holanda'is: 'hola' substringAt: 0!

'holanda' is: 'hola' substringAt: 0!

'holanda' is: '' substringAt: 0 !

'hola' is: 'holanda' substringAt: 0  !

'holanda ' is: 'hola' substringAt: 0!

'holanda ' is: 'hola' substringAt: 1!

'cacaholanda ' is: 'hola' substringAt: 1!

'cacaholanda ' is: 'hola' substringAt: 4!

'cacaholanda ' is: 'hola' substringAt: 5!
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:29:54' prior: 50673464!
findPrefix: aPrefix in: aStack
	| aString |
	aPrefix isEmpty ifTrue: [self error: 'prefijo vacio'.].
	aString := aStack top.	
	aString is: aPrefix substringAt: 1.! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:32:57' prior: 50673488!
findPrefix: aPrefix in: aStack
	| aString |
	aPrefix isEmpty ifTrue: [self error: 'prefijo vacio'.].
	aString := aStack pop.	
	(aString is: aPrefix substringAt: 1) ifTrue: [^self findPrefix: aPrefix in: aStack add aString].! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:34:22' prior: 50673497!
findPrefix: aPrefix in: aStack
	| aString newStack|
	newStack := aStack.
	aPrefix isEmpty ifTrue: [self error: 'prefijo vacio'.].
	aString := newStack pop.	
	(aString is: aPrefix substringAt: 1) ifTrue: [^self findPrefix: aPrefix in: aStack add aString].! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 19:35:20'!
test01_nonEmptyString! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 19:37:24' prior: 50673519!
test01_nonEmptyString
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aStack push: ''.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 19:38:36' prior: 50673523!
test01_nonEmptyString
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aStack push: ''.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	
! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:39:15'!
findSentencesIn: aStack withPrefix: aPrefix
	| aString newStack|
	newStack := aStack.
	aPrefix isEmpty ifTrue: [self error: 'prefijo vacio'.].
	aString := newStack pop.	
	(aString is: aPrefix substringAt: 1) ifTrue: [^self findPrefix: aPrefix in: aStack add aString].! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 19:39:52' prior: 50673532!
test01_nonEmptyString
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aStack push: ''.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.
	
	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 19:40:29' prior: 50673552!
test01_nonEmptyString
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aStack push: ''.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.
	
	
	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 19:46:29' prior: 50673563!
test01_nonEmptyString
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aStack push: ''.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.
	self
		should: [aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: 'busqueda con string vacio']
	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 19:46:34' prior: 50673574!
test01_nonEmptyString
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aStack push: ''.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.
	self
		should: [aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: 'busqueda con string vacio'.].
	
! !

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 19:46:39'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 19:46:39'!
ERROR!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 19:47:07' prior: 50673591!
test01_nonEmptyString
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aStack push: ''.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.
	self
		should: [aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: ''.].
	
! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:47:48' prior: 50673540!
findSentencesIn: aStack withPrefix: aPrefix
	| aString newStack|
	newStack := aStack.
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	aString := newStack pop.	
	(aString is: aPrefix substringAt: 1) ifTrue: [^self findPrefix: aPrefix in: aStack add aString].! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 19:48:00' prior: 50673614!
test01_nonEmptyString
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aStack push: ''.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.
	self
		should: [aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: 'v'.].
	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 19:48:02' prior: 50673642!
test01_nonEmptyString
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aStack push: ''.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.
	self
		should: [aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: 'Search with empty prefix.'.].
	
! !

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 19:48:09'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 19:48:09'!
ERROR!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 19:48:36' prior: 50673658!
test01_nonEmptyString
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aStack push: ''.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	self
		should: [aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: 'Search with empty prefix.'.].
	
! !

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 19:48:40'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 19:52:15'!
test02_succesfulFindOnStackWithOneElement
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aStack push: 'hola'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'hola'.

	
! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:53:37' prior: 50673630!
findSentencesIn: aStack withPrefix: aPrefix
	| aString newStack|
	newStack := aStack.
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	aStack isEmpty ifTrue: [^OrderedCollection new].
	aString := newStack pop.	
	(aString is: aPrefix substringAt: 1) ifTrue: [^self findPrefix: aPrefix in: aStack add aString].! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:55:13' prior: 50673710!
findSentencesIn: aStack withPrefix: aPrefix
	| aString newStack|
	newStack := aStack.
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	aStack isEmpty ifTrue: [^OrderedCollection new]
				ifFalse: [aString := newStack pop.	
					     (aString is: aPrefix substringAt: 1) ifTrue: [^(self findSentencesIn: aStack withPrefix: aPrefix) add: aString].].! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:56:58' prior: 50673724!
findSentencesIn: aStack withPrefix: aPrefix
	| aString newStack pasoInductivo|
	newStack := aStack.
	pasoInductivo := (self findSentencesIn: aStack withPrefix: aPrefix) .
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	aStack isEmpty ifTrue: [^OrderedCollection new]
				 ifFalse: [aString := newStack pop.	
					     (aString is: aPrefix substringAt: 1) ifTrue: [^(self findSentencesIn: aStack withPrefix: aPrefix) add: aString].].! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:57:22' prior: 50673739!
findSentencesIn: aStack withPrefix: aPrefix
	| aString newStack pasoInductivo|
	newStack := aStack.
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	pasoInductivo := (self findSentencesIn: aStack withPrefix: aPrefix) .
	aStack isEmpty ifTrue: [^OrderedCollection new]
				 ifFalse: [aString := newStack pop.	
					     (aString is: aPrefix substringAt: 1) ifTrue: [^pasoInductivo add: aString].].! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:57:35' prior: 50673757!
findSentencesIn: aStack withPrefix: aPrefix
	| aString newStack pasoInductivo|
	newStack := aStack.
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	pasoInductivo := (self findSentencesIn: aStack withPrefix: aPrefix) .
	aStack isEmpty ifTrue: [^OrderedCollection new]
				 ifFalse: [aString := newStack pop.	
					     (aString is: aPrefix substringAt: 1) ifTrue: [^pasoInductivo add: aString] ifFalse:[^pasoInductivo].].! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:57:51' prior: 50673774!
findSentencesIn: aStack withPrefix: aPrefix
	| aString newStack pasoInductivo|
	newStack := aStack.
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	aStack isEmpty ifTrue: [^OrderedCollection new]
				 ifFalse: [aString := newStack pop.	 pasoInductivo := (self findSentencesIn: aStack withPrefix: aPrefix) .
					     (aString is: aPrefix substringAt: 1) ifTrue: [^pasoInductivo add: aString] ifFalse:[^pasoInductivo].].! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:58:49' prior: 50673791!
findSentencesIn: aStack withPrefix: aPrefix
	| aString newStack pasoInductivo|
	newStack := aStack.
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	aStack isEmpty ifTrue: [^OrderedCollection new].
	aString := newStack pop.	
	pasoInductivo := (self findSentencesIn: aStack withPrefix: aPrefix) .
	(aString is: aPrefix substringAt: 1) ifTrue: [^pasoInductivo add: aString.] 
	^pasoInductivo! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 19:59:01' prior: 50673808!
findSentencesIn: aStack withPrefix: aPrefix
	| aString newStack pasoInductivo|
	newStack := aStack.
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	aStack isEmpty ifTrue: [^OrderedCollection new].
	aString := newStack pop.	
	pasoInductivo := (self findSentencesIn: aStack withPrefix: aPrefix) .
	(aString is: aPrefix substringAt: 1) ifTrue: [^pasoInductivo add: aString.].
	^pasoInductivo! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 19:59:15'!
test02_succesfulFindOnStackWithOnlyPrefix
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aStack push: 'hola'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'hola'.

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:01:02' prior: 50673840!
test02_succesfulFindOnStackWithOnlyPrefix
	| aStack aSentenceFinderByPrefix anOrderedCollection|
	aStack := OOStack new.
	aStack push: 'hola'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	anOrderedCollection := aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = (OrderedCollection new) add: 'hola').

	
! !

!methodRemoval: SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOneElement stamp: 'MS 9/17/2023 20:01:26'!
test02_succesfulFindOnStackWithOneElement
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aStack push: 'hola'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'hola'.

	
!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:01:42'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:01:42'!
ERROR!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:02:14' prior: 50673852!
test02_succesfulFindOnStackWithOnlyPrefix
	| aStack aSentenceFinderByPrefix anOrderedCollection|
	aStack := OOStack new.
	aStack push: 'hola'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	anOrderedCollection := aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = ((OrderedCollection new) add: 'hola')).

	
! !

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:02:18'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:02:38'!
test02_succesfulFindOnStackWithOneWord
	| aStack aSentenceFinderByPrefix anOrderedCollection|
	aStack := OOStack new.
	aStack push: 'hola'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	anOrderedCollection := aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = ((OrderedCollection new) add: 'hola')).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:02:43'!
test03_succesfulFindOnStackWithOneWord
	| aStack aSentenceFinderByPrefix anOrderedCollection|
	aStack := OOStack new.
	aStack push: 'hola'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	anOrderedCollection := aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = ((OrderedCollection new) add: 'hola')).

	
! !

!methodRemoval: SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 20:02:51'!
test02_succesfulFindOnStackWithOneWord
	| aStack aSentenceFinderByPrefix anOrderedCollection|
	aStack := OOStack new.
	aStack push: 'hola'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	anOrderedCollection := aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = ((OrderedCollection new) add: 'hola')).

	
!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:02:58' prior: 50673920!
test03_succesfulFindOnStackWithOneWord
	| aStack aSentenceFinderByPrefix anOrderedCollection|
	aStack := OOStack new.
	aStack push: 'hola'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	anOrderedCollection := aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'holanda'.
	self assert: (anOrderedCollection = ((OrderedCollection new) add: 'hola')).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:03:16'!
test04_failedFindOnStackWithOneWord
	| aStack aSentenceFinderByPrefix anOrderedCollection|
	aStack := OOStack new.
	aStack push: 'hola'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	anOrderedCollection := aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'hol'.
	self assert: (anOrderedCollection = ((OrderedCollection new) add: 'hola')).

	
! !

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:03:21'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 20:03:25'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 20:03:25'!
FAILURE!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:04:09' prior: 50673950!
test03_succesfulFindOnStackWithOneWord
	| aStack aSentenceFinderByPrefix anOrderedCollection|
	aStack := OOStack new.
	aStack push: 'hola'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	anOrderedCollection := aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'holanda'.
	self assert: (anOrderedCollection = ((OrderedCollection new) add: 'holanda')).

	
! !

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 20:04:13'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 20:04:13'!
FAILURE!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:04:33' prior: 50673991!
test03_succesfulFindOnStackWithOneWord
	| aStack aSentenceFinderByPrefix anOrderedCollection|
	aStack := OOStack new.
	aStack push: 'holanda'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	anOrderedCollection := aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = ((OrderedCollection new) add: 'holanda')).

	
! !

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 20:04:36'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:05:12' prior: 50673965!
test04_failedFindOnStackWithOneWord
	| aStack aSentenceFinderByPrefix anOrderedCollection|
	aStack := OOStack new.
	aStack push: 'honduras'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	anOrderedCollection := aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/17/2023 20:05:15'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:06:13'!
test05_failedFindOnEmptyStack
	| aStack aSentenceFinderByPrefix anOrderedCollection|
	aStack := OOStack new.
	aStack push: 'honduras'.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	anOrderedCollection := aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:06:28' prior: 50674051!
test05_failedFindOnEmptyStack
	| aStack aSentenceFinderByPrefix anOrderedCollection|
	aStack := OOStack new.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	anOrderedCollection := aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/17/2023 20:06:47'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:07:09' prior: 50673681!
test01_nonEmptyString
	| aStack aSentenceFinderByPrefix|
	aStack := OOStack new.
	aSentenceFinderByPrefix := SentenceFinderByPrefix new.
	self
		should: [aSentenceFinderByPrefix findSentencesIn: aStack withPrefix: ''.]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: 'Search with empty prefix.'.].
	
! !

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 20:07:17'!
PASSED!

!methodRemoval: SentenceFinderByPrefix #findPrefix:in: stamp: 'MS 9/17/2023 20:07:30'!
findPrefix: aPrefix in: aStack
	| aString newStack|
	newStack := aStack.
	aPrefix isEmpty ifTrue: [self error: 'prefijo vacio'.].
	aString := newStack pop.	
	(aString is: aPrefix substringAt: 1) ifTrue: [^self findPrefix: aPrefix in: aStack add aString].!
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 20:09:19'!
stackToOrderedCollection: aStack! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 20:10:04' prior: 50674111!
stackToOrderedCollection: aStack
" Este metodo lo ponemos en esta clase en lugar de en OOStack debido a que el enunciado pide que no se modifique OOStack."
! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 20:15:05' prior: 50674116!
stackToOrderedCollection: aStack
	" Este metodo lo ponemos en esta clase en lugar de en OOStack debido a que el enunciado pide que no se modifique OOStack."
	| stackElementsAsCollection |
	stackElementsAsCollection  := OrderedCollection new.
	aStack size timesRepeat: [stackElementsAsCollection add: aStack pop].! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 20:30:08' prior: 50673824!
findSentencesIn: aStack withPrefix: aPrefix
	| validSentences reversedStack |
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	validSentences := OrderedCollection  new.
	reversedStack  := OOStack new. 
	aStack size timesRepeat: [ |aString | 
		aString := aStack pop.
		(aString is: aPrefix substringAt: 1) ifTrue:[validSentences add: aString.].
		reversedStack push: aString. 
	].
	reversedStack size timesRepeat: [
		aStack push: reversedStack pop.
	]
	! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 20:30:19' prior: 50674138!
findSentencesIn: aStack withPrefix: aPrefix
	| validSentences reversedStack |
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	validSentences := OrderedCollection  new.
	reversedStack  := OOStack new. 
	aStack size timesRepeat: [ |aString | 
		aString := aStack pop.
		(aString is: aPrefix substringAt: 1) ifTrue:[validSentences add: aString.].
		reversedStack push: aString. 
	].
	reversedStack size timesRepeat: [
		aStack push: reversedStack pop.
	]
	^validSentences ! !

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 20:30:25'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:30:25'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 20:30:25'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/17/2023 20:30:25'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/17/2023 20:30:25'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:30:38'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:30:38'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:31:18'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:31:18'!
ERROR!
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 20:31:46' prior: 50674156!
findSentencesIn: aStack withPrefix: aPrefix
	| validSentences reversedStack |
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	validSentences := OrderedCollection  new.
	reversedStack  := OOStack new. 
	aStack size timesRepeat: [ |aString | 
		aString := aStack pop.
		(aString is: aPrefix substringAt: 1) ifTrue:[validSentences add: aString.].
		reversedStack push: aString. 
	].
	reversedStack size timesRepeat: [
		aStack push: reversedStack pop.
	].
	^validSentences ! !

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 20:31:58'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:31:58'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 20:31:58'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/17/2023 20:31:58'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/17/2023 20:31:58'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:32:04'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:34:10'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:34:10'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:34:29'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:34:29'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:34:47'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:34:47'!
FAILURE!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:38:54' overrides: 16961394!
setUp! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:39:08' prior: 50674272 overrides: 16961394!
setUp! !

TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptyStack orderedCollectioWithHola'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: 'Stack-Exercise' stamp: 'MS 9/17/2023 20:40:03'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptyStack orderedCollectioWithHola'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:40:43' prior: 50674276 overrides: 16961394!
setUp
orderedCollectioWithHola  := OrderedCollection new add: 'hola'.
emptyStack := OOStack new.! !

TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptyStack orderedCollectioWithHola sentenceFinderByPrefix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: 'Stack-Exercise' stamp: 'MS 9/17/2023 20:41:21'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptyStack orderedCollectioWithHola sentenceFinderByPrefix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:41:41' prior: 50674295 overrides: 16961394!
setUp
orderedCollectioWithHola  := OrderedCollection new add: 'hola'.
emptyStack := OOStack new.
sentenceFinderByPrefix := SentenceFinderByPrefix new.! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:41:44' prior: 50674319 overrides: 16961394!
setUp
	orderedCollectioWithHola  := OrderedCollection new add: 'hola'.
	emptyStack := OOStack new.
	sentenceFinderByPrefix := SentenceFinderByPrefix new.! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:42:22' prior: 50674328 overrides: 16961394!
setUp
	orderedCollectioWithHola  := (OrderedCollection new).
	orderedCollectioWithHola add: 'hola'.
	emptyStack := OOStack new.
	sentenceFinderByPrefix := SentenceFinderByPrefix new.! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:42:30' prior: 50674337 overrides: 16961394!
setUp
	orderedCollectioWithHola  := (OrderedCollection new).
	orderedCollectioWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:43:06' prior: 50674083!
test01_nonEmptyString
	self
		should: [sentenceFinderByPrefix findSentencesIn: emptyStack withPrefix: ''.]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: 'Search with empty prefix.'.].
	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:45:28' prior: 50673886!
test02_succesfulFindOnStackWithOnlyPrefix
	|anOrderedCollection|

	emptyStack push: 'hola'.
	anOrderedCollection := 	sentenceFinderByPrefix findSentencesIn: emptyStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = orderedCollectioWithHola).

	
! !

TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptyStack orderedCollectionWithHola sentenceFinderByPrefix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: 'Stack-Exercise' stamp: 'MS 9/17/2023 20:45:33'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptyStack orderedCollectionWithHola sentenceFinderByPrefix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:45:44' prior: 50674367!
test02_succesfulFindOnStackWithOnlyPrefix
	|anOrderedCollection|

	emptyStack push: 'hola'.
	anOrderedCollection := 	sentenceFinderByPrefix findSentencesIn: emptyStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = orderedCollectionWithHola).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:47:23' prior: 50674014!
test03_succesfulFindOnStackWithOneWord
	| aSentenceFinderByPrefix anOrderedCollection|

	emptyStack push: 'hola'.
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: emptyStack withPrefix: 'ho'.
	self assert: (anOrderedCollection = orderedCollectionWithHola).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:47:40' prior: 50674407!
test03_succesfulFindOnStackWithOneWord
	| anOrderedCollection |

	emptyStack push: 'hola'.
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: emptyStack withPrefix: 'ho'.
	self assert: (anOrderedCollection = orderedCollectionWithHola).

	
! !

TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptyStack orderedCollectionWithHola sentenceFinderByPrefix stackWithHola'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: 'Stack-Exercise' stamp: 'MS 9/17/2023 20:48:08'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptyStack orderedCollectionWithHola sentenceFinderByPrefix stackWithHola'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:48:44' prior: 50674347 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:48:59' prior: 50674395!
test02_succesfulFindOnStackWithOnlyPrefix
	|anOrderedCollection|

	anOrderedCollection := 	sentenceFinderByPrefix findSentencesIn: stackWithHola withPrefix: 'hola'.
	self assert: (anOrderedCollection = orderedCollectionWithHola).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:49:07' prior: 50674419!
test03_succesfulFindOnStackWithOneWord
	| anOrderedCollection |

	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: stackWithHola withPrefix: 'ho'.
	self assert: (anOrderedCollection = orderedCollectionWithHola).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:50:03' prior: 50674033!
test04_failedFindOnStackWithOneWord
	| anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: stackWithHola withPrefix: 'Hi'.
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:51:33' prior: 50674066!
test05_failedFindOnEmptyStack
	| aStack aSentenceFinderByPrefix anOrderedCollection|
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: emptyStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:51:45' prior: 50674492!
test05_failedFindOnEmptyStack
	|  anOrderedCollection |
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: emptyStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:51:48' prior: 50674503!
test05_failedFindOnEmptyStack
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: emptyStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:52:12' prior: 50674513!
test05_failedFindOnEmptyStack
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: emptyStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 20:52:43' prior: 50674523!
test05_failedFindOnEmptyStack
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: emptyStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 20:52:56'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 20:52:56'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 20:52:56'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/17/2023 20:52:56'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/17/2023 20:52:56'!
PASSED!
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 21:06:53' prior: 50674208!
findSentencesIn: aStack withPrefix: aPrefix
	| aString validSentences |
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	
	aStack isEmpty ifTrue: [^OrderedCollection  new.].
	aString := aStack pop.
	validSentences := self findSentencesIn: aStack withPrefix: aPrefix. 
	(aString is: aPrefix substringAt: 1) ifTrue:[validSentences add: aString.].
	aStack push: aString. 
	^validSentences
	
	"
	validSentences := OrderedCollection  new.
	reversedStack  := OOStack new. 
	aStack size timesRepeat: [ |aString | 
		aString := aStack pop.
		(aString is: aPrefix substringAt: 1) ifTrue:[validSentences add: aString.].
		reversedStack push: aString. 
	].
	reversedStack size timesRepeat: [
		aStack push: reversedStack pop.
	].
	^validSentences 
	"! !

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 21:07:08'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 21:07:08'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 21:07:08'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/17/2023 21:07:08'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/17/2023 21:07:08'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:07:29'!
test06_succesfulFindOnBigStack
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: emptyStack withPrefix: 'hola'.
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !

TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptyStack orderedCollectionWithHola sentenceFinderByPrefix stackWithHola bigStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: 'Stack-Exercise' stamp: 'MS 9/17/2023 21:07:58'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptyStack orderedCollectionWithHola sentenceFinderByPrefix stackWithHola bigStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:08:28' prior: 50674448 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack push: 'hola'.
	bigStack push: 'holanda'
	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:08:41' prior: 50674635 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack push: 'hola'.
	bigStack push: 'holanda'.
	bigStack push: 'holandez'
	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:09:49' prior: 50674650 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack push:  'winter is coming'.
	bigStack push:  'winning is everything'.
	bigStack push:  'The winds of Winter'.  
	bigStack push:  'Winter is here'
	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:09:57' prior: 50674666 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack push:  'winter is coming'.
	bigStack push:  'winning is everything'.
	bigStack push:  'The winds of Winter'.  
	bigStack push:  'Winter is here'.
	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:10:31' prior: 50674684 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack push:  'winter is coming'.
	bigStack push:  'winning is everything'.
	bigStack push:  'The winds of Winter'.  
	bigStack push:  'Winter is here'.
	bigStack push:  'wind'.	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:10:57' prior: 50674702 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack push:  'winter is coming'.
	bigStack push:  'winning is everything'.
	bigStack push:  'The winds of Winter'.  
	bigStack push:  'Winter is here'.
	bigStack push:  'Summer sucks'.  
	bigStack push:  'wind'.	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:11:20' prior: 50674721 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack push:  'winter is coming'.
	bigStack push:  'winning is everything'.
	bigStack push:  'The winds of Winter'.  
	bigStack push:  'Winter is here'.
	bigStack push:  'Summer sucks'.  
	bigStack push:  'wind'.	
	
	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:11:39' prior: 50674606!
test06_succesfulFindOnBigStack
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:12:07' prior: 50674760!
test06_succesfulFindOnBigStack
	|  anOrderedCollection sentences |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:13:21' prior: 50674770!
test06_succesfulFindOnBigStack
	|  anOrderedCollection sentences |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' add: 'winning is everything' add:  'wind'.
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:13:39' prior: 50674782!
test06_succesfulFindOnBigStack
	|  anOrderedCollection sentences |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: (anOrderedCollection = OrderedCollection new).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:13:56' prior: 50674796!
test06_succesfulFindOnBigStack
	|  anOrderedCollection sentences |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: (anOrderedCollection = sentences).

	
! !

!testRun: #SentenceFinderByPrefixTest #test06_succesfulFindOnBigStack stamp: 'MS 9/17/2023 21:14:23'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:14:36'!
test07_failedFindOnBigStack
	|  anOrderedCollection sentences |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: (anOrderedCollection = sentences).

	
! !

!classDefinition: #SentenceFinderByPrefixTest category: 'Stack-Exercise' stamp: 'MS 9/17/2023 21:15:31'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptyStack orderedCollectionWithHola sentenceFinderByPrefix stackWithHola bigStack emptyCollection'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:15:28' prior: 50674827!
test07_failedFindOnBigStack
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (anOrderedCollection = emptyCollection).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:15:58' prior: 50674741 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	emptyCollection := OrderedCollection new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack push:  'winter is coming'.
	bigStack push:  'winning is everything'.
	bigStack push:  'The winds of Winter'.  
	bigStack push:  'Winter is here'.
	bigStack push:  'Summer sucks'.  
	bigStack push:  'wind'.	
	
	! !

!testRun: #SentenceFinderByPrefixTest #test07_failedFindOnBigStack stamp: 'MS 9/17/2023 21:16:01'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:16:41'!
test08_stacksRemainsTheSameAfterFindByPrefix
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (anOrderedCollection = emptyCollection).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:17:24' prior: 50674887!
test08_stacksRemainsTheSameAfterFindByPrefix
	|  anOrderedCollection originalStack|
	
	originalStack := bigStack.
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = emptyCollection).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:17:34' prior: 50674898!
test08_stacksRemainsTheSameAfterFindByPrefix
	|  anOrderedCollection originalStack|
	
	originalStack := bigStack.
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = originalStack ).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:17:35' prior: 50674910!
test08_stacksRemainsTheSameAfterFindByPrefix
	|  anOrderedCollection originalStack|
	
	originalStack := bigStack.
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = originalStack).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:17:48' prior: 50674922!
test08_stacksRemainsTheSameAfterFindByPrefix
	|  originalStack|
	
	originalStack := bigStack.
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = originalStack).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:17:52' prior: 50674934!
test08_stacksRemainsTheSameAfterFindByPrefix
	|  originalStack |
	
	originalStack := bigStack.
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = originalStack).

	
! !

!testRun: #SentenceFinderByPrefixTest #test08_stacksRemainsTheSameAfterFindByPrefix stamp: 'MS 9/17/2023 21:17:55'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:18:28'!
test08_stackRemainsTheSameAfterFindByPrefix
	|  originalStack |
	
	originalStack := bigStack.
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = originalStack).

	
! !

!methodRemoval: SentenceFinderByPrefixTest #test08_stacksRemainsTheSameAfterFindByPrefix stamp: 'MS 9/17/2023 21:18:28'!
test08_stacksRemainsTheSameAfterFindByPrefix
	|  originalStack |
	
	originalStack := bigStack.
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = originalStack).

	
!

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 21:19:13'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 21:19:13'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 21:19:13'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/17/2023 21:19:13'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/17/2023 21:19:13'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06_succesfulFindOnBigStack stamp: 'MS 9/17/2023 21:19:13'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07_failedFindOnBigStack stamp: 'MS 9/17/2023 21:19:13'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test08_stackRemainsTheSameAfterFindByPrefix stamp: 'MS 9/17/2023 21:19:13'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:20:02' prior: 50674863 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	emptyCollection := OrderedCollection new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack push:  'winter is coming' ;
	push:  'winning is everything' ;
	push:  'The winds of Winter' ; 
	push:  'Winter is here' ;
	push:  'Summer sucks'  ;
	push:  'wind'.
	
	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:21:19' prior: 50675008 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	emptyCollection := OrderedCollection new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack push:  'winter is coming' ;
        push:  'winning is everything' ;
	push:  'The winds of Winter' ; 
	push:  'Winter is here' ;
	push:  'Summer sucks'  ;
	push:  'wind'.
	
	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:21:28' prior: 50675028 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	emptyCollection := OrderedCollection new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack push:  'winter is coming' ;
        			push:  'winning is everything' ;
			push:  'The winds of Winter' ; 
			push:  'Winter is here' ;
			push:  'Summer sucks'  ;
			push:  'wind'.
	
	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:21:40' prior: 50675048 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	emptyCollection := OrderedCollection new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack  push:  'winter is coming' ;
        			push:  'winning is everything' ;
			push:  'The winds of Winter' ; 
			push:  'Winter is here' ;
			push:  'Summer sucks'  ;
			push:  'wind'.
	
	! !

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 21:21:52'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 21:21:52'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 21:21:52'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/17/2023 21:21:52'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/17/2023 21:21:52'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06_succesfulFindOnBigStack stamp: 'MS 9/17/2023 21:21:52'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07_failedFindOnBigStack stamp: 'MS 9/17/2023 21:21:52'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test08_stackRemainsTheSameAfterFindByPrefix stamp: 'MS 9/17/2023 21:21:52'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:22:55'!
test07_failedFindOnBigStackBecauseOfCasing
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (anOrderedCollection = emptyCollection).

	
! !

!methodRemoval: SentenceFinderByPrefixTest #test07_failedFindOnBigStack stamp: 'MS 9/17/2023 21:22:55'!
test07_failedFindOnBigStack
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (anOrderedCollection = emptyCollection).

	
!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:23:03' prior: 50675117!
test07_failedFindOnBigStackBecauseOfCasing
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Win'.
	self assert: (anOrderedCollection = emptyCollection).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:23:22'!
test07_failedFindOnBigStackBecauseOfCaseSensivity
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Win'.
	self assert: (anOrderedCollection = emptyCollection).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:24:23'!
test07_failedFindOnBigStackBecauseOfLowerCase
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Win'.
	self assert: (anOrderedCollection = emptyCollection).

	
! !

!methodRemoval: SentenceFinderByPrefixTest #test07_failedFindOnBigStackBecauseOfCaseSensivity stamp: 'MS 9/17/2023 21:24:38'!
test07_failedFindOnBigStackBecauseOfCaseSensivity
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Win'.
	self assert: (anOrderedCollection = emptyCollection).

	
!

!methodRemoval: SentenceFinderByPrefixTest #test07_failedFindOnBigStackBecauseOfCasing stamp: 'MS 9/17/2023 21:24:43'!
test07_failedFindOnBigStackBecauseOfCasing
	|  anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Win'.
	self assert: (anOrderedCollection = emptyCollection).

	
!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:25:02' prior: 50675069 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	emptyCollection := OrderedCollection new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack  push:  'winter is coming' ;
        			push:  'winning is everything' ;
			push:  'The winds of Winter' ; 
			push:  'Summer sucks'  ;
			push:  'wind'.
	
	! !

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 21:25:22'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 21:25:22'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 21:25:22'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/17/2023 21:25:22'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/17/2023 21:25:22'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06_succesfulFindOnBigStack stamp: 'MS 9/17/2023 21:25:22'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07_failedFindOnBigStackBecauseOfLowerCase stamp: 'MS 9/17/2023 21:25:22'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test08_stackRemainsTheSameAfterFindByPrefix stamp: 'MS 9/17/2023 21:25:22'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:25:54'!
test08_stackRemainsTheSameAfterFailedFindByPrefix
	|  originalStack |
	
	originalStack := bigStack.
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = originalStack).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:26:08'!
test08_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack |
	
	originalStack := bigStack.
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = originalStack).

	
! !

!methodRemoval: SentenceFinderByPrefixTest #test08_stackRemainsTheSameAfterFindByPrefix stamp: 'MS 9/17/2023 21:26:08'!
test08_stackRemainsTheSameAfterFindByPrefix
	|  originalStack |
	
	originalStack := bigStack.
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = originalStack).

	
!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:26:15'!
test09_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack |
	
	originalStack := bigStack.
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = originalStack).

	
! !

!methodRemoval: SentenceFinderByPrefixTest #test08_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 21:26:15'!
test08_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack |
	
	originalStack := bigStack.
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = originalStack).

	
!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:27:45' prior: 50675270!
test09_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack sentences anOrderedCollection |
	
	originalStack := bigStack.
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: (bigStack = originalStack).

	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: (anOrderedCollection = sentences).
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:29:17' prior: 50675292!
test09_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack sentences anOrderedCollection |
	
	originalStack := bigStack.
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: ((bigStack = originalStack) and:(sentences = anOrderedCollection)).


! !

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 21:29:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 21:29:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 21:29:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/17/2023 21:29:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/17/2023 21:29:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06_succesfulFindOnBigStack stamp: 'MS 9/17/2023 21:29:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07_failedFindOnBigStackBecauseOfLowerCase stamp: 'MS 9/17/2023 21:29:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test08_stackRemainsTheSameAfterFailedFindByPrefix stamp: 'MS 9/17/2023 21:29:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 21:29:53'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:30:33' prior: 50675315!
test09_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack sentences anOrderedCollection |
	
	originalStack := bigStack.
	bigStack pop.
	"anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: ((bigStack = originalStack) and:(sentences = anOrderedCollection))."
	self assert: ((bigStack = originalStack)).


! !

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 21:30:43'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 21:30:49'!
PASSED!

!classDefinition: #SentenceFinderByPrefixTest category: 'Stack-Exercise' stamp: 'MS 9/17/2023 21:31:54'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptyStack orderedCollectionWithHola sentenceFinderByPrefix stackWithHola bigStack emptyCollection bigStack2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:31:52' prior: 50675191 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	emptyCollection := OrderedCollection new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack  push:  'winter is coming' ;
        			push:  'winning is everything' ;
			push:  'The winds of Winter' ; 
			push:  'Summer sucks'  ;
			push:  'wind'.
	
	bigStack2 := OOStack new. 
	bigStack2 push:  'winter is coming' ;
        		  	push:  'winning is everything' ;
			push:  'The winds of Winter' ; 
			push:  'Summer sucks'  ;
			push:  'wind'.
	
	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:32:25' prior: 50675404 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	emptyCollection := OrderedCollection new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack  push:  'winter is coming' ;
        			push:  'winning is everything' ;
			push:  'The winds of Winter' ; 
			push:  'Summer sucks'  ;
			push:  'wind'.
	
	bigStack2 := OOStack new.                    "existe un copy recursivo?"
	bigStack2 push:  'winter is coming' ;
        		  	push:  'winning is everything' ;
			push:  'The winds of Winter' ; 
			push:  'Summer sucks'  ;
			push:  'wind'.
	
	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:37:52' prior: 50675430 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	emptyCollection := OrderedCollection new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack  push:  'winter is coming' ;
        			push:  'winning is everything' ;
			push:  'The winds of Winter' ; 
			push:  'Summer sucks'  ;
			push:  'wind'.
	
	bigStack2 := bigStack copy. 
	"bigStack2 := OOStack new.                   
	bigStack2 push:  'winter is coming' ;
        		  	push:  'winning is everything' ;
			push:  'The winds of Winter' ; 
			push:  'Summer sucks'  ;
			push:  'wind'."
	
	! !

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 21:38:02'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:38:15' prior: 50675365!
test09_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack sentences anOrderedCollection |
	
	originalStack := bigStack.
	bigStack pop.
	"anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: ((bigStack = originalStack) and:(sentences = anOrderedCollection))."
	self assert: ((bigStack = bigStack2)).


! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 21:38:21' prior: 50675488!
test09_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack sentences anOrderedCollection |
	"
	originalStack := bigStack.
	bigStack pop.
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: ((bigStack = originalStack) and:(sentences = anOrderedCollection))."
	self assert: ((bigStack = bigStack2)).


! !

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 21:38:25'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 21:38:25'!
FAILURE!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:18:00' prior: 50675457 overrides: 16961394!
setUp
	orderedCollectionWithHola  := (OrderedCollection new).
	orderedCollectionWithHola add: 'hola'.
	
	emptyStack := OOStack new.
	
	emptyCollection := OrderedCollection new.
	
	sentenceFinderByPrefix := SentenceFinderByPrefix new.
	
	stackWithHola := OOStack new.
	stackWithHola push: 'hola'.
	
	bigStack := OOStack new. 
	bigStack  push:  'winter is coming' ;
        			push:  'winning is everything' ;
			push:  'The winds of Winter' ; 
			push:  'Summer sucks'  ;
			push:  'wind'.
	

	bigStack2 := OOStack new.                   
	bigStack2 push:  'winter is coming' ;
        		  	push:  'winning is everything' ;
			push:  'The winds of Winter' ; 
			push:  'Summer sucks'  ;
			push:  'wind'.
	
	! !

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:18:16'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:18:16'!
FAILURE!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'MS 9/17/2023 22:20:45'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'MS 9/17/2023 22:20:45'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'MS 9/17/2023 22:20:45'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'MS 9/17/2023 22:20:45'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'MS 9/17/2023 22:20:45'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'MS 9/17/2023 22:20:45'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'MS 9/17/2023 22:20:45'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'MS 9/17/2023 22:20:45'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'MS 9/17/2023 22:20:45'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'MS 9/17/2023 22:20:45'!
PASSED!
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 22:24:20' overrides: 16901772!
= aStack
"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 22:24:24' prior: 50675601 overrides: 16901772!
= aStack
"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 22:32:08' prior: 50675608 overrides: 16901772!
= aStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual top1 top2|
	allElementsAreEqual := true.
	
	((aStack isKindOf: self class) and: (aStack size = self size)) ifTrue: [
		top1 := self pop.
		top2 := aStack pop.
		allElementsAreEqual  := self = aStack  and: top1 value = top2 value.
		self push: top1.
		aStack push: top2.	
		].! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 22:32:34' prior: 50675615 overrides: 16901772!
= aStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual top1 top2|
	allElementsAreEqual := true.
	
	((aStack isKindOf: self class) and: (aStack size = self size)) ifTrue: [
		top1 := self pop.
		top2 := aStack pop.
		allElementsAreEqual  := self = aStack  and: top1 value = top2 value.
		self push: top1.
		aStack push: top2.	
	].

	^allElementsAreEqual ! !
!OOStack methodsFor: 'operations' stamp: 'MS 9/17/2023 22:32:40' prior: 50675631 overrides: 16901772!
= aStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual top1 top2|
	allElementsAreEqual := true.
	
	((aStack isKindOf: self class) and: (aStack size = self size)) ifTrue: [
		top1 := self pop.
		top2 := aStack pop.
		allElementsAreEqual  := (self = aStack)  and: top1 value = top2 value.
		self push: top1.
		aStack push: top2.	
	].

	^allElementsAreEqual ! !

!methodRemoval: OOStack #= stamp: 'MS 9/17/2023 22:33:52'!
= aStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual top1 top2|
	allElementsAreEqual := true.
	
	((aStack isKindOf: self class) and: (aStack size = self size)) ifTrue: [
		top1 := self pop.
		top2 := aStack pop.
		allElementsAreEqual  := (self = aStack)  and: top1 value = top2 value.
		self push: top1.
		aStack push: top2.	
	].

	^allElementsAreEqual !

!methodRemoval: SentenceFinderByPrefix #stackToOrderedCollection: stamp: 'MS 9/17/2023 22:34:30'!
stackToOrderedCollection: aStack
	" Este metodo lo ponemos en esta clase en lugar de en OOStack debido a que el enunciado pide que no se modifique OOStack."
	| stackElementsAsCollection |
	stackElementsAsCollection  := OrderedCollection new.
	aStack size timesRepeat: [stackElementsAsCollection add: aStack pop].!
!SentenceFinderByPrefixTest methodsFor: 'stackAuxiliaryOperationsForTesting' stamp: 'MS 9/17/2023 22:35:06'!
equalToStack: aStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual top1 top2|
	allElementsAreEqual := true.
	
	((aStack isKindOf: self class) and: (aStack size = self size)) ifTrue: [
		top1 := self pop.
		top2 := aStack pop.
		allElementsAreEqual  := (self = aStack)  and: top1 value = top2 value.
		self push: top1.
		aStack push: top2.	
	].

	^allElementsAreEqual ! !
!SentenceFinderByPrefixTest methodsFor: 'stackAuxiliaryOperationsForTesting' stamp: 'MS 9/17/2023 22:36:54'!
thisStack: fstStack isEqualToThisStack: sndStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual top1 top2|
	allElementsAreEqual := true.
	
	((sndStack isKindOf: fstStack class) and: (sndStack size = fstStack size)) ifTrue: [
		top1 := fstStack pop.
		top2 := sndStack pop.
		allElementsAreEqual  := (fstStack = sndStack)  and: top1 value = top2 value.
		fstStack push: top1.
		sndStack push: top2.	
	].

	^allElementsAreEqual ! !
!SentenceFinderByPrefixTest methodsFor: 'stackAuxiliaryOperationsForTesting' stamp: 'MS 9/17/2023 22:37:03' prior: 50675711!
thisStack: fstStack isEqualToThisStack: sndStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual top1 top2|
	allElementsAreEqual := true.
	
	((sndStack isKindOf: fstStack class) and: (sndStack size = fstStack size)) ifTrue: [
		top1 := fstStack pop.
		top2 := sndStack pop.
		allElementsAreEqual  := (fstStack = sndStack)  and: (top1 value = top2 value).
		fstStack push: top1.
		sndStack push: top2.	
	].

	^allElementsAreEqual ! !
!SentenceFinderByPrefixTest methodsFor: 'stackAuxiliaryOperationsForTesting' stamp: 'MS 9/17/2023 22:37:56' prior: 50675731!
thisStack: fstStack isEqualToThisStack: sndStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual fstTop sndTop|
	allElementsAreEqual := true.
	
	((sndStack isKindOf: fstStack class) and: (sndStack size = fstStack size)) ifTrue: [
		fstTop := fstStack pop.
		sndTop := sndStack pop.
		allElementsAreEqual  := (fstStack = sndStack)  and: (fstTop value = sndTop value).
		fstStack push: fstTop.
		sndStack push: sndTop.
	].

	^allElementsAreEqual ! !
!SentenceFinderByPrefixTest methodsFor: 'stackAuxiliaryOperationsForTesting' stamp: 'MS 9/17/2023 22:38:11' prior: 50675751!
thisStack: fstStack isEqualToThisStack: sndStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual |
	allElementsAreEqual := true.
	
	((sndStack isKindOf: fstStack class) and: (sndStack size = fstStack size)) ifTrue: [
		| fstTop sndTop |
		fstTop := fstStack pop.
		sndTop := sndStack pop.
		allElementsAreEqual  := (fstStack = sndStack)  and: (fstTop value = sndTop value).
		fstStack push: fstTop.
		sndStack push: sndTop.
	].

	^allElementsAreEqual ! !

!methodRemoval: SentenceFinderByPrefixTest #equalToStack: stamp: 'MS 9/17/2023 22:38:46'!
equalToStack: aStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual top1 top2|
	allElementsAreEqual := true.
	
	((aStack isKindOf: self class) and: (aStack size = self size)) ifTrue: [
		top1 := self pop.
		top2 := aStack pop.
		allElementsAreEqual  := (self = aStack)  and: top1 value = top2 value.
		self push: top1.
		aStack push: top2.	
	].

	^allElementsAreEqual !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:39:10' prior: 50675507!
test09_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack sentences anOrderedCollection |
	"
	originalStack := bigStack.
	bigStack pop.
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: ((bigStack = originalStack) and:(sentences = anOrderedCollection))."
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack ).


! !

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:39:21'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:39:21'!
FAILURE!
!SentenceFinderByPrefixTest methodsFor: 'stackAuxiliaryOperationsForTesting' stamp: 'MS 9/17/2023 22:42:34' prior: 50675771!
thisStack: fstStack isEqualToThisStack: sndStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual |
	allElementsAreEqual := true.
	
	((sndStack isKindOf: fstStack class) and: (sndStack size = fstStack size)) ifTrue: [
		| fstTop sndTop |
		fstTop := fstStack pop.
		sndTop := sndStack pop.
		allElementsAreEqual  := (self thisStack: fstStack isEqualToThisStack: sndStack)  and: (fstTop value = sndTop value).
		fstStack push: fstTop.
		sndStack push: sndTop.
	].

	^allElementsAreEqual ! !
!SentenceFinderByPrefixTest methodsFor: 'stackAuxiliaryOperationsForTesting' stamp: 'MS 9/17/2023 22:43:23' prior: 50675836!
thisStack: fstStack isEqualToThisStack: sndStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual |
	allElementsAreEqual := (sndStack isKindOf: fstStack class) and: (sndStack size = fstStack size).
	
	allElementsAreEqual ifTrue: [
		| fstTop sndTop |
		fstTop := fstStack pop.
		sndTop := sndStack pop.
		allElementsAreEqual  := (self thisStack: fstStack isEqualToThisStack: sndStack)  and: (fstTop value = sndTop value).
		fstStack push: fstTop.
		sndStack push: sndTop.
	].

	^allElementsAreEqual ! !

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:43:34'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:43:34'!
ERROR!
!SentenceFinderByPrefixTest methodsFor: 'stackAuxiliaryOperationsForTesting' stamp: 'MS 9/17/2023 22:44:46' prior: 50675858!
thisStack: fstStack isEqualToThisStack: sndStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual |
	allElementsAreEqual := (sndStack isKindOf: fstStack class) and: (sndStack size = fstStack size).

	(allElementsAreEqual and: fstStack size > 0) ifTrue: [
		| fstTop sndTop |
		fstTop := fstStack pop.
		sndTop := sndStack pop.
		allElementsAreEqual  := (self thisStack: fstStack isEqualToThisStack: sndStack)  and: (fstTop value = sndTop value).
		fstStack push: fstTop.
		sndStack push: sndTop.
	].

	^allElementsAreEqual ! !

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:45:01'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:45:01'!
ERROR!
!SentenceFinderByPrefixTest methodsFor: 'stackAuxiliaryOperationsForTesting' stamp: 'MS 9/17/2023 22:46:02' prior: 50675888!
thisStack: fstStack isEqualToThisStack: sndStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual |
	allElementsAreEqual := (sndStack isKindOf: fstStack class) and: (sndStack size = fstStack size).

	(allElementsAreEqual and: (fstStack size > 0)) ifTrue: [
		| fstTop sndTop |
		fstTop := fstStack pop.
		sndTop := sndStack pop.
		allElementsAreEqual  := (self thisStack: fstStack isEqualToThisStack: sndStack)  and: (fstTop value = sndTop value).
		fstStack push: fstTop.
		sndStack push: sndTop.
	].

	^allElementsAreEqual ! !

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:46:06'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:46:06'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:48:06'!
ERROR!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:49:33' prior: 50675807!
test09_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack sentences anOrderedCollection |
	"
	originalStack := bigStack.
	bigStack pop.
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: ((bigStack = originalStack) and:(sentences = anOrderedCollection))."
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2 ).


! !

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:49:43'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'stackAuxiliaryOperationsForTesting' stamp: 'MS 9/17/2023 22:50:40' prior: 50675919!
thisStack: fstStack isEqualToThisStack: sndStack
	"Definimos esta operacion para poder testear prolijamente en SentenceFinderByPrefixTest"
	| allElementsAreEqual |
	fstStack = sndStack ifTrue: [^true].
	allElementsAreEqual := (sndStack isKindOf: fstStack class) and: (sndStack size = fstStack size).

	(allElementsAreEqual and: (fstStack size > 0)) ifTrue: [
		| fstTop sndTop |
		fstTop := fstStack pop.
		sndTop := sndStack pop.
		allElementsAreEqual  := (self thisStack: fstStack isEqualToThisStack: sndStack)  and: (fstTop value = sndTop value).
		fstStack push: fstTop.
		sndStack push: sndTop.
	].

	^allElementsAreEqual ! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:50:53' prior: 50675953!
test09_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack sentences anOrderedCollection |
	"
	originalStack := bigStack.
	bigStack pop.
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: ((bigStack = originalStack) and:(sentences = anOrderedCollection))."
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack ).


! !

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:51:06'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:51:11' prior: 50676001!
test09_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack sentences anOrderedCollection |
	"
	originalStack := bigStack.
	bigStack pop.
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: ((bigStack = originalStack) and:(sentences = anOrderedCollection))."
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2 ).


! !

!testRun: #SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:51:18'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:52:39'!
test10_stackEqualitySuccesful
	
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack ).


! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:52:51'!
test11_stackEqualityFailed
	
	self deny: (self thisStack: bigStack isEqualToThisStack: bigStack2 ).


! !

!testRun: #SentenceFinderByPrefixTest #test11_stackEqualityFailed stamp: 'MS 9/17/2023 22:52:54'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test11_stackEqualityFailed stamp: 'MS 9/17/2023 22:52:54'!
FAILURE!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:53:21'!
test11_differentStacksEqualitySuccesful
	
	self deny: (self thisStack: bigStack isEqualToThisStack: bigStack2 ).


! !

!methodRemoval: SentenceFinderByPrefixTest #test11_stackEqualityFailed stamp: 'MS 9/17/2023 22:53:31'!
test11_stackEqualityFailed
	
	self deny: (self thisStack: bigStack isEqualToThisStack: bigStack2 ).


!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:53:45'!
test10_sameStackEqualitySuccesful
	
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack ).


! !

!methodRemoval: SentenceFinderByPrefixTest #test10_stackEqualitySuccesful stamp: 'MS 9/17/2023 22:53:51'!
test10_stackEqualitySuccesful
	
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack ).


!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:54:06' prior: 50676068!
test11_differentStacksEqualitySuccesful
	
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2 ).


! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:54:18'!
test12_differentStacksEqualityFailed
	
	self assert: (self thisStack: bigStack isEqualToThisStack: emptyStack ).


! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:54:25' prior: 50676102!
test12_differentStacksEqualityFailed
	
	self deny: (self thisStack: bigStack isEqualToThisStack: emptyStack ).


! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:55:13' prior: 50676081!
test10_sameStackEqualitySuccesful
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack ).


! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:55:52'!
test11_stackRemainsTheSameAfterFailedFindByPrefix
	|  originalStack |
	
	originalStack := bigStack.
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = originalStack).

	
! !

!methodRemoval: SentenceFinderByPrefixTest #test08_stackRemainsTheSameAfterFailedFindByPrefix stamp: 'MS 9/17/2023 22:55:52'!
test08_stackRemainsTheSameAfterFailedFindByPrefix
	|  originalStack |
	
	originalStack := bigStack.
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (bigStack = originalStack).

	
!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:56:01'!
test12_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack sentences anOrderedCollection |
	"
	originalStack := bigStack.
	bigStack pop.
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: ((bigStack = originalStack) and:(sentences = anOrderedCollection))."
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2 ).


! !

!methodRemoval: SentenceFinderByPrefixTest #test09_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 22:56:01'!
test09_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  originalStack sentences anOrderedCollection |
	"
	originalStack := bigStack.
	bigStack pop.
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: ((bigStack = originalStack) and:(sentences = anOrderedCollection))."
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2 ).


!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:56:13'!
test08_sameStackEqualitySuccesful
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack ).


! !

!methodRemoval: SentenceFinderByPrefixTest #test10_sameStackEqualitySuccesful stamp: 'MS 9/17/2023 22:56:13'!
test10_sameStackEqualitySuccesful
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack ).


!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:56:21'!
test09_differentStacksEqualitySuccesful
	
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2 ).


! !

!methodRemoval: SentenceFinderByPrefixTest #test11_differentStacksEqualitySuccesful stamp: 'MS 9/17/2023 22:56:21'!
test11_differentStacksEqualitySuccesful
	
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2 ).


!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:56:37'!
test10_differentStacksEqualityFailed
	
	self deny: (self thisStack: bigStack isEqualToThisStack: emptyStack ).


! !

!methodRemoval: SentenceFinderByPrefixTest #test12_differentStacksEqualityFailed stamp: 'MS 9/17/2023 22:56:37'!
test12_differentStacksEqualityFailed
	
	self deny: (self thisStack: bigStack isEqualToThisStack: emptyStack ).


!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:57:27' prior: 50676123!
test11_stackRemainsTheSameAfterFailedFindByPrefix
	|  originalStack |
	
	originalStack := bigStack.
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:57:35' prior: 50676225!
test11_stackRemainsTheSameAfterFailedFindByPrefix
	
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'Windows'.
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2).

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 22:59:05' prior: 50676144!
test12_stackRemainsTheSameAfterSuccesfulFindByPrefix
	|  sentences anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assert: ((self thisStack: bigStack isEqualToThisStack: bigStack2) and:(sentences = anOrderedCollection)).
	


! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:00:09' prior: 50676246!
test12_stackRemainsTheSameAfterSuccesfulFindByPrefix
	
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'win'.
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2).
	


! !

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 23:00:21'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 23:00:21'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 23:00:21'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/17/2023 23:00:21'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/17/2023 23:00:21'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06_succesfulFindOnBigStack stamp: 'MS 9/17/2023 23:00:21'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07_failedFindOnBigStackBecauseOfLowerCase stamp: 'MS 9/17/2023 23:00:21'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test08_sameStackEqualitySuccesful stamp: 'MS 9/17/2023 23:00:21'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test09_differentStacksEqualitySuccesful stamp: 'MS 9/17/2023 23:00:21'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test10_differentStacksEqualityFailed stamp: 'MS 9/17/2023 23:00:21'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test11_stackRemainsTheSameAfterFailedFindByPrefix stamp: 'MS 9/17/2023 23:00:21'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test12_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 23:00:21'!
PASSED!
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 23:02:33' prior: 50674561!
findSentencesIn: aStack withPrefix: aPrefix
	| aString validSentences |
	aPrefix isEmpty ifTrue: [self error: 'Search with empty prefix.'.].
	
	aStack isEmpty ifTrue: [^OrderedCollection  new.].
	aString := aStack pop.
	validSentences := self findSentencesIn: aStack withPrefix: aPrefix. 
	(aString is: aPrefix substringAt: 1) ifTrue:[validSentences add: aString.].
	aStack push: aString. 
	^validSentences
	
	! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 23:02:52'!
validPrefix: aPrefix
	! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 23:03:34' prior: 50676333!
validPrefix: aPrefix
	aPrefix isEmpty ifTrue: [self error: self class emptyPrefixError.].! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 23:05:23' prior: 50676337!
validPrefix: aPrefix
	aPrefix isEmpty ifTrue: [self error: self class emptyPrefixError.].
	(aPrefix detect: [:character | character = ' ' asSymbol.]) isEmpty ifTrue: [self error: self class emptyPrefixError.].! !

'caca' detect: [:character | character = ' ' asSymbol.]!

'caca' detect: [:character | character isSeparator.]!

'cac a' detect: [:character | character isSeparator.]!

'cac a' detect: [:character | character isSeparator.]!

'cac a' detect: [:character | character isSeparator.]!

'cac a' detect: [:character | character isSeparator.]!

'cac a' detect: [:character | character isSeparator.]!

 $ "20" .!

 $ "20" .!

 $ "20" .!

 $ "20" .!

'cac a' allSatisfy: [:character | character isSeparator not.] !

'cac a' allSatisfy: [:character | character isSeparator not.] !

'caca' allSatisfy: [:character | character isSeparator not.]  !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 23:09:04' prior: 50676343!
validPrefix: aPrefix
	aPrefix isEmpty ifTrue: [self error: self class emptyPrefixError.].
	(aPrefix allSatisfy: [:character | character isSeparator not.]) ifTrue: [self error: self class emptyPrefixError.].! !

self class emptyPrefixError!
!ClassDescription methodsFor: 'errorMessages' stamp: 'MS 9/17/2023 23:10:35'!
emptyPrefixError
	self shouldBeImplemented.! !
!ClassDescription methodsFor: 'errorMessages' stamp: 'MS 9/17/2023 23:11:22' prior: 50676383!
emptyPrefixError
	^'The prefix is empty!!'.! !

self class emptyPrefixError!

!methodRemoval: ClassDescription #emptyPrefixError stamp: 'MS 9/17/2023 23:14:32'!
emptyPrefixError
	^'The prefix is empty!!'.!
!SentenceFinderByPrefix class methodsFor: 'error messages' stamp: 'MS 9/17/2023 23:15:46'!
emptyPrefixError
	^'The prefix is empty!!'! !
!SentenceFinderByPrefix class methodsFor: 'error messages' stamp: 'MS 9/17/2023 23:16:12'!
spacesInPrefixError
	^'The prefix contains spaces!!'! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 23:16:49' prior: 50676373!
validPrefix: aPrefix
	aPrefix isEmpty ifTrue: [self error: self class emptyPrefixError.].
	(aPrefix allSatisfy: [:character | character isSeparator not.]) ifTrue: [self error: self class spacesInPrefixError .].! !

'caca,' allSatisfy: [:character | character isSeparator not.]   !

'caca' allSatisfy: [:character | character isSeparator not.] !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 23:19:51' prior: 50676317!
findSentencesIn: aStack withPrefix: aPrefix
	| aString validSentences |
	self validPrefix: aPrefix.
	
	aStack isEmpty ifTrue: [^OrderedCollection  new.].
	aString := aStack pop.
	validSentences := self findSentencesIn: aStack withPrefix: aPrefix. 
	(aString is: aPrefix substringAt: 1) ifTrue:[validSentences add: aString.].
	aStack push: aString. 
	^validSentences
	
	! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 23:20:13' prior: 50676422!
findSentencesIn: aStack withPrefix: aPrefix
	| aString validSentences |
	self validPrefix: aPrefix.
	aStack isEmpty ifTrue: [^OrderedCollection  new.].
	aString := aStack pop.
	validSentences := self findSentencesIn: aStack withPrefix: aPrefix. 
	(aString is: aPrefix substringAt: 1) ifTrue:[validSentences add: aString.].
	aStack push: aString. 
	^validSentences
	
	! !
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 23:20:15' prior: 50676437!
findSentencesIn: aStack withPrefix: aPrefix
	| aString validSentences |
	
	self validPrefix: aPrefix.
	aStack isEmpty ifTrue: [^OrderedCollection  new.].
	aString := aStack pop.
	validSentences := self findSentencesIn: aStack withPrefix: aPrefix. 
	(aString is: aPrefix substringAt: 1) ifTrue:[validSentences add: aString.].
	aStack push: aString. 
	^validSentences
	
	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:22:41'!
test011_prefixWithSpacesFails
	
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'wi n'.
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2).
	


! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:23:50' prior: 50676467!
test011_prefixWithSpacesFails

	self
		should: [sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'wi n'.]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: 'Prefix contains spaces!!'.].


! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:24:24'!
test01_1_prefixWithSpacesFails

	self
		should: [sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'wi n'.]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: 'Prefix contains spaces!!'.].


! !

!methodRemoval: SentenceFinderByPrefixTest #test01_1_prefixWithSpacesFails stamp: 'MS 9/17/2023 23:24:34'!
test01_1_prefixWithSpacesFails

	self
		should: [sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'wi n'.]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: 'Prefix contains spaces!!'.].


!

!testRun: #SentenceFinderByPrefixTest #test011_prefixWithSpacesFails stamp: 'MS 9/17/2023 23:24:54'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test011_prefixWithSpacesFails stamp: 'MS 9/17/2023 23:24:54'!
FAILURE!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:26:06' prior: 50676476!
test011_prefixWithSpacesFails

	self
		should: [sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: 'wi n'.]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: SentenceFinderByPrefix spacesInPrefixError .].


! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:26:17' prior: 50674356!
test01_nonEmptyString
	self
		should: [sentenceFinderByPrefix findSentencesIn: emptyStack withPrefix: ''.]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: SentenceFinderByPrefix emptyPrefixError .].
	
! !

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 23:26:21'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test011_prefixWithSpacesFails stamp: 'MS 9/17/2023 23:26:24'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test011_prefixWithSpacesFails stamp: 'MS 9/17/2023 23:26:24'!
FAILURE!

!testRun: #SentenceFinderByPrefixTest #test011_prefixWithSpacesFails stamp: 'MS 9/17/2023 23:26:42'!
FAILURE!
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 23:28:17' prior: 50676408!
validPrefix: aPrefix
	aPrefix isEmpty ifTrue: [self error: self class emptyPrefixError.].
	(aPrefix allSatisfy: [:character | character isSeparator not.]) ifFalse: [self error: self class spacesInPrefixError .].! !

!testRun: #SentenceFinderByPrefixTest #test011_prefixWithSpacesFails stamp: 'MS 9/17/2023 23:28:24'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test011_prefixWithSpacesFails stamp: 'MS 9/17/2023 23:28:30'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 23:28:30'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 23:28:30'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 23:28:30'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/17/2023 23:28:30'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/17/2023 23:28:30'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06_succesfulFindOnBigStack stamp: 'MS 9/17/2023 23:28:30'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07_failedFindOnBigStackBecauseOfLowerCase stamp: 'MS 9/17/2023 23:28:30'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test08_sameStackEqualitySuccesful stamp: 'MS 9/17/2023 23:28:30'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test09_differentStacksEqualitySuccesful stamp: 'MS 9/17/2023 23:28:30'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test10_differentStacksEqualityFailed stamp: 'MS 9/17/2023 23:28:30'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test11_stackRemainsTheSameAfterFailedFindByPrefix stamp: 'MS 9/17/2023 23:28:30'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test12_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 23:28:30'!
PASSED!

!methodRemoval: SentenceFinderByPrefix #find: stamp: 'MS 9/17/2023 23:30:00'!
find: aStack!
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'MS 9/17/2023 23:41:29' prior: 50676452!
findSentencesIn: aStack withPrefix: aPrefix
	| aString validSentences |
	
	self validPrefix: aPrefix.
	
	aStack isEmpty ifTrue: [^OrderedCollection  new.].
	aString := aStack pop.
	validSentences := self findSentencesIn: aStack withPrefix: aPrefix. 
	(aString is: aPrefix substringAt: 1) ifTrue:[validSentences add: aString.].
	aStack push: aString. 
	^validSentences
	
	! !

!testRun: #SentenceFinderByPrefixTest #test011_prefixWithSpacesFails stamp: 'MS 9/17/2023 23:41:33'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 23:41:33'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 23:41:33'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 23:41:33'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/17/2023 23:41:33'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/17/2023 23:41:33'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06_succesfulFindOnBigStack stamp: 'MS 9/17/2023 23:41:33'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07_failedFindOnBigStackBecauseOfLowerCase stamp: 'MS 9/17/2023 23:41:33'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test08_sameStackEqualitySuccesful stamp: 'MS 9/17/2023 23:41:33'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test09_differentStacksEqualitySuccesful stamp: 'MS 9/17/2023 23:41:33'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test10_differentStacksEqualityFailed stamp: 'MS 9/17/2023 23:41:33'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test11_stackRemainsTheSameAfterFailedFindByPrefix stamp: 'MS 9/17/2023 23:41:33'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test12_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 23:41:33'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:45:00'!
assertExpectedOutput: aCollectionOfValidSentences ofSentenceFinderByPrefixWithStack: aStackOfSentences andPrefix: aPrefix
	| anOrderedCollection |

	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: stackWithHola withPrefix: 'ho'.
	self assert: (anOrderedCollection = orderedCollectionWithHola).
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:46:34'!
assertExpectedOutput: aCollectionOfValidSentences withStackOfSentences: aStackOfSentences andPrefix: aPrefix
	| anOrderedCollection |

	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: aStackOfSentences withPrefix: aPrefix.
	self assert: (anOrderedCollection = aCollectionOfValidSentences).
! !

!methodRemoval: SentenceFinderByPrefixTest #assertExpectedOutput:ofSentenceFinderByPrefixWithStack:andPrefix: stamp: 'MS 9/17/2023 23:46:41'!
assertExpectedOutput: aCollectionOfValidSentences ofSentenceFinderByPrefixWithStack: aStackOfSentences andPrefix: aPrefix
	| anOrderedCollection |

	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: stackWithHola withPrefix: 'ho'.
	self assert: (anOrderedCollection = orderedCollectionWithHola).
!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:47:46' prior: 50674459!
test02_succesfulFindOnStackWithOnlyPrefix
	
	self assertExpectedOutput: orderedCollectionWithHola withStackOfSentences: stackWithHola andPrefix: 'hola'.
	
! !

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 23:47:52'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:48:34' prior: 50674470!
test03_succesfulFindOnStackWithOneWord

	self assertExpectedOutput: orderedCollectionWithHola withStackOfSentences: stackWithHola andPrefix: 'ho'.
	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:49:23' prior: 50674481!
test04_failedFindOnStackWithOneWord
	| anOrderedCollection |
	
	anOrderedCollection := sentenceFinderByPrefix findSentencesIn: stackWithHola withPrefix: 'Hi'.
	self assert: (anOrderedCollection = OrderedCollection new).

	self assertExpectedOutput: emptyCollection withStackOfSentences: stackWithHola andPrefix: 'Hi'.
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:49:26' prior: 50676740!
test04_failedFindOnStackWithOneWord
	

	self assertExpectedOutput: emptyCollection withStackOfSentences: stackWithHola andPrefix: 'Hi'.
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:49:27' prior: 50676754!
test04_failedFindOnStackWithOneWord

	self assertExpectedOutput: emptyCollection withStackOfSentences: stackWithHola andPrefix: 'Hi'.
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:50:09' prior: 50674533!
test05_failedFindOnEmptyStack

	self assertExpectedOutput: emptyCollection withStackOfSentences: emptyStack andPrefix: 'hola'.
	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:51:01' prior: 50674810!
test06_succesfulFindOnBigStack
	| sentences |
	
	sentences := OrderedCollection new. 
	sentences add: 'winter is coming' ; add: 'winning is everything' ; add:  'wind'.
	self assertExpectedOutput: sentences withStackOfSentences: bigStack andPrefix: 'win'.

	
! !

!testRun: #SentenceFinderByPrefixTest #test06_succesfulFindOnBigStack stamp: 'MS 9/17/2023 23:51:05'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:51:34' prior: 50675158!
test07_failedFindOnBigStackBecauseOfLowerCase
	
	self assertExpectedOutput: emptyCollection withStackOfSentences: bigStack andPrefix: 'Win'.

	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:51:41' prior: 50676184!
test08_sameStackEqualitySuccesful

	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack ).


! !

!testRun: #SentenceFinderByPrefixTest #test011_prefixWithSpacesFails stamp: 'MS 9/17/2023 23:53:17'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/17/2023 23:53:17'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/17/2023 23:53:17'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/17/2023 23:53:18'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/17/2023 23:53:18'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/17/2023 23:53:18'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06_succesfulFindOnBigStack stamp: 'MS 9/17/2023 23:53:18'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07_failedFindOnBigStackBecauseOfLowerCase stamp: 'MS 9/17/2023 23:53:18'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test08_sameStackEqualitySuccesful stamp: 'MS 9/17/2023 23:53:18'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test09_differentStacksEqualitySuccesful stamp: 'MS 9/17/2023 23:53:18'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test10_differentStacksEqualityFailed stamp: 'MS 9/17/2023 23:53:18'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test11_stackRemainsTheSameAfterFailedFindByPrefix stamp: 'MS 9/17/2023 23:53:18'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test12_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/17/2023 23:53:18'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'stackAuxiliaryOperationsForTesting' stamp: 'MS 9/17/2023 23:59:07'!
bigStackRemainsTheSameUsingPrefix: aPrefix
! !
!SentenceFinderByPrefixTest methodsFor: 'stackAuxiliaryOperationsForTesting' stamp: 'MS 9/17/2023 23:59:24' prior: 50676856!
bigStackRemainsTheSameUsingPrefix: aPrefix
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: aPrefix.
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2).
	! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:59:47' prior: 50676236!
test11_stackRemainsTheSameAfterFailedFindByPrefix
	
	self bigStackRemainsTheSameUsingPrefix: 'Windows'.


	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/17/2023 23:59:56' prior: 50676263!
test12_stackRemainsTheSameAfterSuccesfulFindByPrefix
	
	self bigStackRemainsTheSameUsingPrefix: 'win'.
	


! !
!SentenceFinderByPrefixTest methodsFor: 'stackAuxiliaryOperationsForTesting' stamp: 'MS 9/18/2023 00:00:04'!
bigStackRemainsTheSameAfterUsingPrefix: aPrefix
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: aPrefix.
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2).
	! !

!methodRemoval: SentenceFinderByPrefixTest #bigStackRemainsTheSameUsingPrefix: stamp: 'MS 9/18/2023 00:00:09'!
bigStackRemainsTheSameUsingPrefix: aPrefix
	sentenceFinderByPrefix findSentencesIn: bigStack withPrefix: aPrefix.
	self assert: (self thisStack: bigStack isEqualToThisStack: bigStack2).
	!
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/18/2023 00:00:15' prior: 50676872!
test11_stackRemainsTheSameAfterFailedFindByPrefix
	
	self bigStackRemainsTheSameAfterUsingPrefix: 'Windows'.


	
! !
!SentenceFinderByPrefixTest methodsFor: 'testing' stamp: 'MS 9/18/2023 00:00:20' prior: 50676879!
test12_stackRemainsTheSameAfterSuccesfulFindByPrefix
	
	self bigStackRemainsTheSameAfterUsingPrefix: 'win'.
	


! !

!testRun: #SentenceFinderByPrefixTest #test011_prefixWithSpacesFails stamp: 'MS 9/18/2023 00:00:34'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test01_nonEmptyString stamp: 'MS 9/18/2023 00:00:34'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02_succesfulFindOnStackWithOnlyPrefix stamp: 'MS 9/18/2023 00:00:34'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03_succesfulFindOnStackWithOneWord stamp: 'MS 9/18/2023 00:00:34'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04_failedFindOnStackWithOneWord stamp: 'MS 9/18/2023 00:00:34'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05_failedFindOnEmptyStack stamp: 'MS 9/18/2023 00:00:34'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06_succesfulFindOnBigStack stamp: 'MS 9/18/2023 00:00:34'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07_failedFindOnBigStackBecauseOfLowerCase stamp: 'MS 9/18/2023 00:00:34'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test08_sameStackEqualitySuccesful stamp: 'MS 9/18/2023 00:00:34'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test09_differentStacksEqualitySuccesful stamp: 'MS 9/18/2023 00:00:34'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test10_differentStacksEqualityFailed stamp: 'MS 9/18/2023 00:00:34'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test11_stackRemainsTheSameAfterFailedFindByPrefix stamp: 'MS 9/18/2023 00:00:34'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test12_stackRemainsTheSameAfterSuccesfulFindByPrefix stamp: 'MS 9/18/2023 00:00:34'!
PASSED!

----STARTUP---- (18 September 2023 00:04:55) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/Repo/Inge1_Santesteban_Segre/03-Stack/Stack-Exercise.st----!

----STARTUP---- (22 September 2023 22:14:19) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/ISW1-2022-1C-Parcial-1.st----!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'MS 9/22/2023 22:15:23'!
PASSED!

FormulaOneCar subclass: #FormulaOneCarWithTurboActive
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

FormulaOneCar subclass: #FormulaOneCarWithTurboActive
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneCarWithTurboActive category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/22/2023 22:24:49'!
FormulaOneCar subclass: #FormulaOneCarWithTurboActive
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneCarWithTurboActive methodsFor: 'turbo' stamp: 'MS 9/22/2023 22:25:05' overrides: 50677519!
activateTurbo

	turboActivated ifTrue: [ self error: self turboAlreadyActivatedErrorDescription ].
	
	currentSector activateTurboTo: self.
! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/22/2023 22:25:05' prior: 50677519!
activateTurbo

	self subclassResponsibility! !

FormulaOneCar subclass: #FormulaOneCarWithTurboNotActive
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneCarWithTurboNotActive category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/22/2023 22:27:33'!
FormulaOneCar subclass: #FormulaOneCarWithTurboNotActive
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneCarWithTurboNotActive methodsFor: 'no messages' stamp: 'MS 9/22/2023 22:28:58' overrides: 50678072!
activateTurbo

	turboActivated ifTrue: [ self error: self turboAlreadyActivatedErrorDescription ].
	
	currentSector activateTurboTo: self.! !
!FormulaOneCarWithTurboActive methodsFor: 'turbo' stamp: 'MS 9/22/2023 22:29:38' prior: 50678064 overrides: 50678072!
activateTurbo

	self error: super turboAlreadyActivatedErrorDescription.
! !
!FormulaOneCarWithTurboNotActive methodsFor: 'as yet unclassified' stamp: 'MS 9/22/2023 22:29:50' prior: 50678092 overrides: 50678072!
activateTurbo

	currentSector activateTurboTo: self.! !

----End fileIn of /home/martin/Downloads/Numero-Exercise.st----!

x := Entero new.!

| x |
x := Entero new.!

x := Entero initalizeSubClasifiedWith: 0.!

| x |
x := Entero initalizeSubClasifiedWith: 0.!

| x |
x := Entero initalizeSubClasifiedWith: 0.
x value.!

| x |
x := Entero initalizeSubClasifiedWith: 5.
x value.!

x!

| x |
x := Entero initalizeSubClasifiedWith: 5.
x value.!

x!

| x |
x := Entero initalizeSubClasifiedWith: 5.
x value.!

x!

x!

| x |
x := Entero initalizeSubClasifiedWith: 5.
x value.!

x !

x!

Entero initalizeSubClasifiedWith: 5.!

Entero initalizeSubClasifiedWith: 0!

Entero initalizeSubClasifiedWith: 0!

Entero initalizeSubClasifiedWith: -5!
!FormulaOneCarWithTurboActive methodsFor: 'turbo' stamp: 'MS 9/22/2023 22:38:18' prior: 50678101 overrides: 50678072!
activateTurbo

	self error: self turboAlreadyActivatedErrorDescription.
! !
!FormulaOneCar class methodsFor: 'instance creation' stamp: 'MS 9/22/2023 22:50:18' prior: 50677562!
drivenBy: aDriver 

	^FormulaOneCarWithTurboNotActive initializeDrivenBy: aDriver ! !
!FormulaOneCarWithTurboNotActive methodsFor: 'initialization' stamp: 'MS 9/22/2023 22:51:12' overrides: 50677475!
initializeDrivenBy: aDriver 

	driver _ aDriver.
	turboActivated _ false.
	turboActivations _ 0.
	speed _ 0*kilometer/hour.
	traveledDistance _ 0.
	! !

!methodRemoval: FormulaOneCar #initializeDrivenBy: stamp: 'MS 9/22/2023 22:51:12'!
initializeDrivenBy: aDriver 

	driver _ aDriver.
	turboActivated _ false.
	turboActivations _ 0.
	speed _ 0*kilometer/hour.
	traveledDistance _ 0.
	!
!FormulaOneCarWithTurboNotActive methodsFor: 'initialization' stamp: 'MS 9/22/2023 22:51:36' prior: 50678994!
initializeDrivenBy: aDriver 

	driver := aDriver.
	turboActivations := 0.
	speed := 0*kilometer/hour.
	traveledDistance := 0.
	! !
!FormulaOneCarWithTurboActive methodsFor: 'turbo-private' stamp: 'MS 9/22/2023 22:54:22' overrides: 50677547!
activateTurboInSectorWithTurbo
	
	turboActivated _ true.
	turboActivations _ turboActivations + 1 ! !
!FormulaOneCarWithTurboNotActive methodsFor: 'turbo-private' stamp: 'MS 9/22/2023 22:54:22' overrides: 50677547!
activateTurboInSectorWithTurbo
	
	turboActivated _ true.
	turboActivations _ turboActivations + 1 ! !
!FormulaOneCar methodsFor: 'turbo-private' stamp: 'MS 9/22/2023 22:54:22' prior: 50677547!
activateTurboInSectorWithTurbo

	self subclassResponsibility! !

!methodRemoval: FormulaOneCarWithTurboActive #activateTurboInSectorWithTurbo stamp: 'MS 9/22/2023 22:54:33'!
activateTurboInSectorWithTurbo
	
	turboActivated _ true.
	turboActivations _ turboActivations + 1 !
!FormulaOneCarWithTurboNotActive methodsFor: 'turbo-private' stamp: 'MS 9/22/2023 22:54:41' prior: 50679025 overrides: 50679032!
activateTurboInSectorWithTurbo
	
	turboActivations := turboActivations + 1 ! !
!FormulaOneCarWithTurboNotActive methodsFor: 'turbo-private' stamp: 'MS 9/22/2023 23:06:37' prior: 50679045 overrides: 50679032!
activateTurboInSectorWithTurbo
	
	turboActivations := turboActivations + 1.
	"^FormulaOneCarWithTurboActive drivenBy: driver  withSpeed: speed andDistance: "! !
!FormulaOneCarWithTurboActive methodsFor: 'nil' stamp: 'MS 9/22/2023 23:08:55'!
initializeDrivenBy: aDriver withSpeed: aNum andTurboActivations: aNUmber andTravelledDistance: aDistance! !
!FormulaOneCarWithTurboNotActive methodsFor: 'turbo-private' stamp: 'MS 9/22/2023 23:10:33' prior: 50679052 overrides: 50679032!
activateTurboInSectorWithTurbo
	
	turboActivations := turboActivations + 1.
	^FormulaOneCarWithTurboActive initializeDrivenBy: driver withSpeed: speed andTurboActivations:  turboActivations andTravelledDistance: traveledDistance.! !
!FormulaOneCarWithTurboActive methodsFor: 'as yet unclassified' stamp: 'MS 9/22/2023 23:11:18' prior: 50679060!
initializeDrivenBy: aDriver withSpeed: aNum andTurboActivations: aNUmber andTravelledDistance: aDistance
	driver := aDriver.
	speed := aNum.
	turboActivations := aNUmber.
	traveledDistance := aDistance.! !
!FormulaOneCarWithTurboActive methodsFor: 'turbo' stamp: 'MS 9/22/2023 23:13:56' overrides: 50677526!
deactivateTurbo
	
	turboActivated ifFalse: [ self error: self turboAlreadydeActivatedErrorDescription ].
	
	turboActivated _ false! !
!FormulaOneCarWithTurboNotActive methodsFor: 'turbo' stamp: 'MS 9/22/2023 23:13:56' overrides: 50677526!
deactivateTurbo
	
	turboActivated ifFalse: [ self error: self turboAlreadydeActivatedErrorDescription ].
	
	turboActivated _ false! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/22/2023 23:13:56' prior: 50677526!
deactivateTurbo

	self subclassResponsibility! !
!FormulaOneCarWithTurboActive methodsFor: 'testing' stamp: 'MS 9/22/2023 23:14:02' overrides: 50677538!
isTurboActivated
	
	^turboActivated! !
!FormulaOneCarWithTurboNotActive methodsFor: 'testing' stamp: 'MS 9/22/2023 23:14:02' overrides: 50677538!
isTurboActivated
	
	^turboActivated! !
!FormulaOneCar methodsFor: 'testing' stamp: 'MS 9/22/2023 23:14:02' prior: 50677538!
isTurboActivated

	self subclassResponsibility! !
!FormulaOneCar methodsFor: 'as yet unclassified' stamp: 'MS 9/22/2023 23:15:09'!
initializeDrivenBy: aDriver withSpeed: aNum andTurboActivations: aNUmber andTravelledDistance: aDistance
	driver := aDriver.
	speed := aNum.
	turboActivations := aNUmber.
	traveledDistance := aDistance.! !

!methodRemoval: FormulaOneCarWithTurboActive #initializeDrivenBy:withSpeed:andTurboActivations:andTravelledDistance: stamp: 'MS 9/22/2023 23:15:09'!
initializeDrivenBy: aDriver withSpeed: aNum andTurboActivations: aNUmber andTravelledDistance: aDistance
	driver := aDriver.
	speed := aNum.
	turboActivations := aNUmber.
	traveledDistance := aDistance.!
!FormulaOneCarWithTurboNotActive methodsFor: 'turbo' stamp: 'MS 9/22/2023 23:15:58' prior: 50679097 overrides: 50679104!
deactivateTurbo
	
	self error: self turboAlreadydeActivatedErrorDescription.! !
!FormulaOneCarWithTurboNotActive methodsFor: 'turbo' stamp: 'MS 9/22/2023 23:16:09' prior: 50679145 overrides: 50679104!
deactivateTurbo
	
	self error: self turboAlreadydeActivatedErrorDescription.! !
!FormulaOneCarWithTurboActive methodsFor: 'turbo' stamp: 'MS 9/22/2023 23:19:35' prior: 50679089 overrides: 50679104!
deactivateTurbo
	
	^FormulaOneCarWithTurboNotActive new initializeDrivenBy: driver withSpeed: speed andTurboActivations: turboActivations andTravelledDistance: traveledDistance.! !
!FormulaOneCarWithTurboActive methodsFor: 'testing' stamp: 'MS 9/22/2023 23:19:45' prior: 50679109 overrides: 50679118!
isTurboActivated
	
	^true! !
!FormulaOneCarWithTurboNotActive methodsFor: 'testing' stamp: 'MS 9/22/2023 23:20:14' prior: 50679114 overrides: 50679118!
isTurboActivated
	
	^False! !
!FormulaOneCarWithTurboNotActive methodsFor: 'testing' stamp: 'MS 9/22/2023 23:20:16' prior: 50679174 overrides: 50679118!
isTurboActivated
	
	^false! !
!FormulaOneCarWithTurboActive methodsFor: 'moving' stamp: 'MS 9/22/2023 23:21:20' overrides: 50677497!
speed

	turboActivated ifTrue: [
		turboActivations = 1 ifTrue: [ ^ speed * 12 / 10 ].
		turboActivations = 2 ifTrue: [ ^ speed * 11 / 10 ].
		turboActivations = 3 ifTrue: [ ^ speed * 105 / 100 ].
	].

	^speed! !
!FormulaOneCarWithTurboNotActive methodsFor: 'moving' stamp: 'MS 9/22/2023 23:21:20' overrides: 50677497!
speed

	turboActivated ifTrue: [
		turboActivations = 1 ifTrue: [ ^ speed * 12 / 10 ].
		turboActivations = 2 ifTrue: [ ^ speed * 11 / 10 ].
		turboActivations = 3 ifTrue: [ ^ speed * 105 / 100 ].
	].

	^speed! !
!FormulaOneCar methodsFor: 'moving' stamp: 'MS 9/22/2023 23:21:20' prior: 50677497!
speed

	self subclassResponsibility! !
!FormulaOneCarWithTurboActive methodsFor: 'moving' stamp: 'MS 9/22/2023 23:21:40' prior: 50679184 overrides: 50679204!
speed
	turboActivations = 1 ifTrue: [ ^ speed * 12 / 10 ].
	turboActivations = 2 ifTrue: [ ^ speed * 11 / 10 ].
	turboActivations = 3 ifTrue: [ ^ speed * 105 / 100 ].
! !
!FormulaOneCarWithTurboNotActive methodsFor: 'moving' stamp: 'MS 9/22/2023 23:21:51' prior: 50679194 overrides: 50679204!
speed
	^speed! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'MS 9/22/2023 23:22:06'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'MS 9/22/2023 23:22:06'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'MS 9/22/2023 23:22:06'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'MS 9/22/2023 23:22:06'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'MS 9/22/2023 23:22:06'!
ERROR!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'MS 9/22/2023 23:22:29'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/22/2023 23:22:31'!
ERROR!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/22/2023 23:22:31'!
ERROR!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/22/2023 23:22:48'!
ERROR!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/22/2023 23:22:48'!
ERROR!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/22/2023 23:23:13'!
ERROR!
!FormulaOneCar class methodsFor: 'instance creation' stamp: 'MS 9/22/2023 23:24:51' prior: 50678987!
drivenBy: aDriver 

	^FormulaOneCarWithTurboNotActive new initializeDrivenBy: aDriver ! !

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/22/2023 23:25:54'!
PASSED!

Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/22/2023 23:26:02'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'MS 9/22/2023 23:26:08'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'MS 9/22/2023 23:26:10'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/22/2023 23:26:12'!
ERROR!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/22/2023 23:26:12'!
ERROR!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/22/2023 23:26:31'!
ERROR!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/22/2023 23:26:31'!
ERROR!
!FormulaOneCar methodsFor: 'as yet unclassified' stamp: 'MS 9/22/2023 23:37:12'!
setDrivenBy: aDriver withSpeed: aNum andTurboActivations: aNUmber andTravelledDistance: aDistance
	driver := aDriver.
	speed := aNum.
	turboActivations := aNUmber.
	traveledDistance := aDistance.! !
!FormulaOneCar class methodsFor: 'nil' stamp: 'MS 9/22/2023 23:38:53'!
initializeDrivenBy: driver withSpeed: Speed andTurboActivations: turboActivations andTravelledDistance: traveledDistance
	^self new setDrivenBy: driver withSpeed: Speed andTurboActivations: turboActivations  andTravelledDistance: traveledDistance.! !
!FormulaOneCarWithTurboActive methodsFor: 'turbo' stamp: 'MS 9/22/2023 23:39:08' prior: 50679159 overrides: 50679104!
deactivateTurbo
	
	^FormulaOneCarWithTurboNotActive initializeDrivenBy: driver withSpeed: speed andTurboActivations: turboActivations andTravelledDistance: traveledDistance.! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'MS 9/22/2023 23:39:23'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/22/2023 23:39:25'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'MS 9/22/2023 23:39:28'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'MS 9/22/2023 23:39:30'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/22/2023 23:39:32'!
FAILURE!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/22/2023 23:39:32'!
FAILURE!

FormulaOneCarWithTurboActive initializeDrivenBy: driver withSpeed: speed andTurboActivations:  turboActivations andTravelledDistance: traveledDistance.!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/22/2023 23:42:26'!
FAILURE!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/22/2023 23:42:26'!
FAILURE!

!classDefinition: #Turbo category: #'Kernel-Objects' stamp: 'MS 9/23/2023 00:13:37'!
Object subclass: #Turbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Objects'!

Turbo subclass: #ActiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #ActiveTurbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:13:37'!
Turbo subclass: #ActiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

----STARTUP---- (23 September 2023 00:13:52) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/ISW1-2022-1C-Parcial-1.st----!

Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turbo traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:14:16'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turbo traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Object subclass: #Trurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Trurbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:14:48'!
Object subclass: #Trurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Object subclass: #Turbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Turbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:14:53'!
Object subclass: #Turbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Trurbo stamp: 'MS 9/23/2023 00:15:04'!
Object subclass: #Trurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Turbo subclass: #ActiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #ActiveTurbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:15:33'!
Turbo subclass: #ActiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Turbo subclass: #InactiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #InactiveTurbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:16:06'!
Turbo subclass: #InactiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/23/2023 00:16:38' prior: 50677519!
activateTurbo
	turbo activate.
	"turboActivated ifTrue: [ self error: self turboAlreadyActivatedErrorDescription ].
	
	currentSector activateTurboTo: self."
! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/23/2023 00:16:42' prior: 50678023!
activateTurbo
	turbo activate.
	
	"turboActivated ifTrue: [ self error: self turboAlreadyActivatedErrorDescription ].
	
	currentSector activateTurboTo: self."
! !
!Turbo methodsFor: 'no messages' stamp: 'MS 9/23/2023 00:17:00'!
activate! !
!Turbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:17:01' prior: 50678039!
activate
	! !
!Turbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:17:18' prior: 50678043!
activate
	! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:17:32' overrides: 50678047!
activate
	! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:17:32' overrides: 50678047!
activate
	! !
!Turbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:17:32' prior: 50678047!
activate

	self subclassResponsibility! !

----End fileIn of /home/martin/Desktop/ISW1-2022-1C-Parcial-1-Resolucion.st----!

----STARTUP---- (23 September 2023 00:21:58) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/ISW1-2022-1C-Parcial-1.st----!

Object subclass: #Turbo
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Turbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:22:52'!
Object subclass: #Turbo
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Turbo subclass: #ActiveTurbo
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Turbo subclass: #ActiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #ActiveTurbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:23:19'!
Turbo subclass: #ActiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Object subclass: #TurboStatus
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboStatus category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:23:25'!
Object subclass: #TurboStatus
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

TurboStatus subclass: #ActiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #ActiveTurbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:23:35'!
TurboStatus subclass: #ActiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Turbo stamp: 'MS 9/23/2023 00:23:42'!
Object subclass: #Turbo
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

TurboStatus subclass: #InactiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #InactiveTurbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:23:59'!
TurboStatus subclass: #InactiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/23/2023 00:24:14' prior: 50677519!
activateTurbo
	turboActivated ifTrue: [ self error: self turboAlreadyActivatedErrorDescription ].
	
	currentSector activateTurboTo: self.
! !

Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turbo traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:24:22'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turbo traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/23/2023 00:24:44' prior: 50678030!
activateTurbo
	turbo activate.
	
	"turboActivated ifTrue: [ self error: self turboAlreadyActivatedErrorDescription ].
	
	currentSector activateTurboTo: self."
! !
!ActiveTurbo methodsFor: 'nil' stamp: 'MS 9/23/2023 00:24:57'!
activate! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:24:59' prior: 50678062!
activate
	! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:25:47' prior: 50678066!
activate! !
!ActiveTurbo class methodsFor: 'no messages' stamp: 'MS 9/23/2023 00:25:54'!
turboAlreadyActivatedErrorDescription
	
	^'Turbo already activated'! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:26:12' prior: 50678070!
activate
	^self error: self class turboAlreadyActivatedErrorDescription.! !

ActiveTurbo new activate!
!InactiveTurbo methodsFor: 'no messages' stamp: 'MS 9/23/2023 00:26:48'!
active! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:26:51' prior: 50678085!
active
	! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:26:56'!
activate
	! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:27:35' prior: 50678092!
activate
	
	! !

Object subclass: #TurboStatus
	instanceVariableNames: 'numberOfActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboStatus category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:27:47'!
Object subclass: #TurboStatus
	instanceVariableNames: 'numberOfActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:28:17' prior: 50678096!
activate
	numberOfActivations := numberOfActivations  + 1. 
	
	! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:28:58' prior: 50678113!
activate
	numberOfActivations := numberOfActivations  + 1. 
	^ ActiveTurbo initializeWith: numberOfActivations.
	
	! !
!ActiveTurbo class methodsFor: 'nil' stamp: 'MS 9/23/2023 00:29:11'!
initializeWith: aNumber! !
!ActiveTurbo class methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:29:36' prior: 50678125!
initializeWith: aNumber
	^ self new setNumberOfActivations: aNumber! !
!ActiveTurbo methodsFor: 'nil' stamp: 'MS 9/23/2023 00:30:03'!
setNumberOfActivations: aNumber
	numberOfActivations := aNumber.! !

!methodRemoval: InactiveTurbo #active stamp: 'MS 9/23/2023 00:30:18'!
active
	!
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/23/2023 00:32:56' prior: 50678054!
activateTurbo
	turbo activateTurbo.
	
	"turboActivated ifTrue: [ self error: self turboAlreadyActivatedErrorDescription ].
	
	currentSector activateTurboTo: self."
! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:33:04'!
activateTurbo
	^self error: self class turboAlreadyActivatedErrorDescription.! !

!methodRemoval: ActiveTurbo #activate stamp: 'MS 9/23/2023 00:33:07'!
activate
	^self error: self class turboAlreadyActivatedErrorDescription.!
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:33:13'!
activateTurbo
	numberOfActivations := numberOfActivations  + 1. 
	^ ActiveTurbo initializeWith: numberOfActivations.
	
	! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:33:15' prior: 50678160!
activateTurbo
	numberOfActivations := numberOfActivations  + 1. 
	^ ActiveTurbo initializeWith: numberOfActivations.
	
	! !

Object subclass: #TurboStatus
	instanceVariableNames: 'numberOfActivations formulaOneCar'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboStatus category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 00:34:32'!
Object subclass: #TurboStatus
	instanceVariableNames: 'numberOfActivations formulaOneCar'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!methodRemoval: InactiveTurbo #activate stamp: 'MS 9/23/2023 00:34:47'!
activate
	numberOfActivations := numberOfActivations  + 1. 
	^ ActiveTurbo initializeWith: numberOfActivations.
	
	!
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/23/2023 00:36:47' prior: 50678142!
activateTurbo
	turbo activateTurbo.
	
! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:37:08' prior: 50678167!
activateTurbo

	"numberOfActivations := numberOfActivations  + 1. 
	^ ActiveTurbo initializeWith: numberOfActivations."
	
	! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:37:09' prior: 50678199!
activateTurbo
	
	"numberOfActivations := numberOfActivations  + 1. 
	^ ActiveTurbo initializeWith: numberOfActivations."
	
	! !
!FormulaOneCar methodsFor: 'turbo-private' stamp: 'MS 9/23/2023 00:38:17' prior: 50677547!
activateTurboInSectorWithTurbo

	currentSector activateTurboTo: self.
	turboActivations := turboActivations + 1 ! !
!FormulaOneCar methodsFor: 'turbo-private' stamp: 'MS 9/23/2023 00:38:50' prior: 50678213!
activateTurboInSectorWithTurbo

	turboActivations := turboActivations + 1 ! !

!methodRemoval: FormulaOneCar #activateTurboInSectorWithTurbo stamp: 'MS 9/23/2023 00:38:54'!
activateTurboInSectorWithTurbo

	turboActivations := turboActivations + 1 !
!FormulaOneCar methodsFor: 'nil' stamp: 'MS 9/23/2023 00:39:29'!
activateTurboInSectorWithTurbo! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/23/2023 00:42:45' prior: 50678194!
activateTurbo
	turbo checkValidActivation.
	
	currentSector activateTurboTo: self.
	
! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:43:17'!
checkValidActivation
	^self error: self class turboAlreadyActivatedErrorDescription.! !

!methodRemoval: ActiveTurbo #activateTurbo stamp: 'MS 9/23/2023 00:43:17'!
activateTurbo
	^self error: self class turboAlreadyActivatedErrorDescription.!
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:43:48'!
checkValidActivation! !
!FormulaOneCar methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:44:33' prior: 50678230!
activateTurboInSectorWithTurbo
	turbo activate.! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:45:32' prior: 50678206!
activateTurbo
	numberOfActivations := numberOfActivations  + 1. 
	^ ActiveTurbo initializeWith: numberOfActivations.
	
	! !
!TurboStatus methodsFor: 'no messages' stamp: 'MS 9/23/2023 00:47:11'!
checkValidActivation
	self subclass responsability! !
!TurboStatus methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:48:05' prior: 50678267!
checkValidActivation
	^self error: 'subclass responsability'! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/23/2023 00:49:31' prior: 50677526!
deactivateTurbo
	turbo deactivate.
	! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:49:41'!
deactivate
	! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:50:39'!
activate
	^self checkValidActivation! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:51:06'!
deactivate
	^self checkValidInactivation! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:51:37'!
checkValidInactivation
	^self error: self class ! !
!InactiveTurbo class methodsFor: 'no messages' stamp: 'MS 9/23/2023 00:51:59'!
turboAlreadydeActivatedErrorDescription
	
	^'Turbo is already deactivated'! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:52:16'!
checkValidDeactivation
	^self error: self class ! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:52:25' prior: 50678302!
checkValidDeactivation
	^self error: self class turboAlreadydeActivatedErrorDescription ! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:52:48'!
checkValidDeactivation
	! !

!methodRemoval: InactiveTurbo #checkValidInactivation stamp: 'MS 9/23/2023 00:52:56'!
checkValidInactivation
	^self error: self class !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:53:03' prior: 50678288!
deactivate
	^self checkValidDeactivation! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:53:46' prior: 50678281!
deactivate
	^InactiveTurbo initializeWith: numberOfActivations 
	! !
!InactiveTurbo class methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:54:23'!
initializeWith: numberOfActivations
	^self new setNumberOfActivations! !
!InactiveTurbo methodsFor: 'nil' stamp: 'MS 9/23/2023 00:54:59'!
setNumberOfActivations: aNumberOfActivations
	numberOfActivations := aNumberOfActivations ! !
!InactiveTurbo class methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:56:47'!
initializeWith: numberOfActivations of: aCar
	^self new setNumberOfActivations: numberOfActivations  ofCar: aCar! !

!methodRemoval: InactiveTurbo #setNumberOfActivations: stamp: 'MS 9/23/2023 00:56:59'!
setNumberOfActivations: aNumberOfActivations
	numberOfActivations := aNumberOfActivations !
!InactiveTurbo methodsFor: 'nil' stamp: 'MS 9/23/2023 00:57:45'!
setNumberOfActivations: aNumberOfActivations  ofCar: aCar
	numberOfActivations := aNumberOfActivations .
	formulaOneCar := aCar.! !

!methodRemoval: InactiveTurbo class #initializeWith: stamp: 'MS 9/23/2023 00:57:59'!
initializeWith: numberOfActivations
	^self new setNumberOfActivations!
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:58:23' prior: 50678327!
deactivate
	^InactiveTurbo initializeWith: numberOfActivations of: formulaOneCar 
	! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:58:36' prior: 50678260!
activateTurbo
	numberOfActivations := numberOfActivations  + 1. 
	^ ActiveTurbo initializeWith: numberOfActivations of: formulaOneCar .
	
	! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:58:53'!
setNumberOfActivations: aNumber of: aCar
	numberOfActivations := aNumber.
	formulaOneCar := aCar.! !

!methodRemoval: ActiveTurbo #setNumberOfActivations: stamp: 'MS 9/23/2023 00:58:57'!
setNumberOfActivations: aNumber
	numberOfActivations := aNumber.!
!ActiveTurbo class methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 00:59:11'!
initializeWith: aNumber of: aCar
	^ self new setNumberOfActivations: aNumber of: aCar! !

!methodRemoval: ActiveTurbo class #initializeWith: stamp: 'MS 9/23/2023 00:59:25'!
initializeWith: aNumber
	^ self new setNumberOfActivations: aNumber!
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 01:00:12'!
activate
	numberOfActivations := numberOfActivations  + 1. 
	^ ActiveTurbo initializeWith: numberOfActivations of: formulaOneCar .
	
	! !

!methodRemoval: InactiveTurbo #activateTurbo stamp: 'MS 9/23/2023 01:00:17'!
activateTurbo
	numberOfActivations := numberOfActivations  + 1. 
	^ ActiveTurbo initializeWith: numberOfActivations of: formulaOneCar .
	
	!
!FormulaOneCar methodsFor: 'initialization' stamp: 'MS 9/23/2023 01:02:27' prior: 50677475!
initializeDrivenBy: aDriver 

	driver := aDriver.
	turboActivations := 0.
	speed := 0*kilometer/hour.
	traveledDistance := 0.
	! !
!FormulaOneCar methodsFor: 'initialization' stamp: 'MS 9/23/2023 01:02:56' prior: 50678417!
initializeDrivenBy: aDriver 

	driver := aDriver.
	turboActivations := 0.
	speed := 0*kilometer/hour.
	traveledDistance := 0.
	turbo := InactiveTurbo initializeWith: 0 of: self 
	! !
!FormulaOneCar methodsFor: 'testing' stamp: 'MS 9/23/2023 01:03:31' prior: 50677538!
isTurboActivated
	
	^turbo isActive! !
!ActiveTurbo methodsFor: 'nil' stamp: 'MS 9/23/2023 01:03:42'!
isActive
	^true! !
!InactiveTurbo methodsFor: 'nil' stamp: 'MS 9/23/2023 01:03:58'!
isActive
	^false! !
!FormulaOneCar methodsFor: 'moving' stamp: 'MS 9/23/2023 01:06:57' prior: 50677497!
speed

	"turboActivated ifTrue: [
		turboActivations = 1 ifTrue: [ ^ speed * 12 / 10 ].
		turboActivations = 2 ifTrue: [ ^ speed * 11 / 10 ].
		turboActivations = 3 ifTrue: [ ^ speed * 105 / 100 ].
	]."

	^speed * turbo bonification.! !
!ActiveTurbo methodsFor: 'nil' stamp: 'MS 9/23/2023 01:07:08'!
bonification
	! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 01:07:50' prior: 50678454!
bonification
	numberOfActivations = 1 ifTrue: [ ^ 12 / 10 ].
	numberOfActivations = 2 ifTrue: [ ^ 11 / 10 ].
	numberOfActivations = 3 ifTrue: [ ^ 105 / 100 ].! !
!InactiveTurbo methodsFor: 'nil' stamp: 'MS 9/23/2023 01:08:09'!
bonification
	^1! !
!FormulaOneCar methodsFor: 'moving' stamp: 'MS 9/23/2023 01:08:26' prior: 50678444!
speed

	^speed * turbo bonification.! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'MS 9/23/2023 01:08:40'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/23/2023 01:08:43'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'MS 9/23/2023 01:08:48'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'MS 9/23/2023 01:08:51'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:08:53'!
FAILURE!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:08:53'!
FAILURE!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:08:58'!
FAILURE!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:08:58'!
FAILURE!
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/23/2023 01:10:22' prior: 50678255!
activateTurboInSectorWithTurbo
	turbo := turbo activate.! !

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:10:36'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:10:39'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'MS 9/23/2023 01:10:43'!
PASSED!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'MS 9/23/2023 01:10:46'!
ERROR!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'MS 9/23/2023 01:10:46'!
ERROR!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'MS 9/23/2023 01:10:46'!
ERROR!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'MS 9/23/2023 01:10:46'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'MS 9/23/2023 01:10:58'!
ERROR!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'MS 9/23/2023 01:10:58'!
ERROR!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'MS 9/23/2023 01:11:02'!
ERROR!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'MS 9/23/2023 01:11:02'!
ERROR!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'MS 9/23/2023 01:11:02'!
ERROR!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'MS 9/23/2023 01:11:02'!
PASSED!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'MS 9/23/2023 01:12:12'!
ERROR!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'MS 9/23/2023 01:12:12'!
ERROR!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'MS 9/23/2023 01:12:12'!
ERROR!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'MS 9/23/2023 01:12:12'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'MS 9/23/2023 01:12:15'!
ERROR!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'MS 9/23/2023 01:12:35'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'MS 9/23/2023 01:13:07'!
ERROR!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'MS 9/23/2023 01:13:07'!
ERROR!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'MS 9/23/2023 01:14:10'!
ERROR!
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/23/2023 01:14:33' prior: 50678277!
deactivateTurbo
	turbo := turbo deactivate.
	! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'MS 9/23/2023 01:14:37'!
ERROR!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'MS 9/23/2023 01:14:37'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'MS 9/23/2023 01:14:37'!
ERROR!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'MS 9/23/2023 01:14:46'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'MS 9/23/2023 01:14:55'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'MS 9/23/2023 01:15:00'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'MS 9/23/2023 01:15:04'!
ERROR!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'MS 9/23/2023 01:15:04'!
ERROR!
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 01:16:05' prior: 50678458!
bonification
	numberOfActivations = 1 ifTrue: [ ^ 12 / 10 ].
	numberOfActivations = 2 ifTrue: [ ^ 11 / 10 ].
	numberOfActivations = 3 ifTrue: [ ^ 105 / 100 ].
	^1! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'MS 9/23/2023 01:16:09'!
PASSED!

----STARTUP---- (23 September 2023 01:19:00) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/ISW1-2022-1C-Parcial-1-Resolucion.st----!

----STARTUP---- (23 September 2023 01:24:22) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/ISW1-2022-1C-Parcial-1-Resolucion.st----!

----STARTUP---- (23 September 2023 14:48:58) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/Repo/Inge1_Santesteban_Segre/01-CodigoRepetido/CodigoRepetido-Ejercicio.st----!

----End fileIn of /home/martin/Desktop/Inge1/Repo/Inge1_Santesteban_Segre/00-NumerosNaturales/NumerosNaturales.st----!

I!

I!

I!

I!

 I .!

I!

III previous!

IIII previous !

IIII next!

IIIII!

----End fileIn of /home/martin/Downloads/ISW1-2021-2C-1erParcial.st----!
!City methodsFor: 'nil' stamp: 'MS 9/23/2023 15:32:23' overrides: 16920235!
initialize
	zones  := OrderedCollection new.
	services  := OrderedCollection new.
	! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 15:32:36'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:32:44' prior: 50681329!
addService: aService 

	services add: aService.! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:32:49' prior: 50681335!
addZone: aZone

	aZone type = #Residential ifTrue: [
		self energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	aZone type = #Commertial ifTrue: [
		self energyAvailable < (2 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (8 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		
		self hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	].

	aZone type = #Industrial ifTrue: [
		self energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (10 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	zones add: aZone.
! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:32:56' prior: 50681370!
energyConsumption
	
	| index total |
	
	
	index := 1.
	total := 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone := zones at: index.
		zone type = #Residential ifTrue: [ total := total + ((5 * ep) * zone getNumberOfCells) ].	
		zone type = #Commertial ifTrue: [ total := total +((8 * ep) * zone getNumberOfCells) ].	
		zone type = #Industrial ifTrue: [ total := total + ((10 * ep) * zone getNumberOfCells) ].	
		index := index + 1.
	].

	^ total.! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:33:05' prior: 50681388!
energyProduced
	
	| index total |
	
	index := 1.
	total := 0 * ep.
	
	[index <= services size] whileTrue: [ | service |
		service := services at: index.
		service type = #SolarPlant ifTrue: [ total := total + (500 * ep)].	
		index := index + 1.
	].

	^ total.! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:33:28' prior: 50681401!
hasResidentialZones

	| index |
	zones isEmpty ifTrue: [ ^ false ].

	index := 1.
	
	[index <= zones size] whileTrue: [ | zone |
		zone := zones at: index.
		zone type = #Residential ifTrue: [ ^ true].	
		index := index + 1.
	].

	^ false.
! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 15:33:34'!
PASSED!

City new!

City new!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:39:31' prior: 50681438!
waterProduced
	| index total |
	
	
	index := 1.
	total := 0.
	
	[index <= services size] whileTrue: [ | service |
		service := services at: index.
		service type = #WaterTower ifTrue: [ total := total + (200 * wp)].	
		index := index + 1.
	].

	^ total.! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:39:37' prior: 50681420!
waterConsumption
	
	| index total |
	
	
	index := 1.
	total := 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone := zones at: index.
		zone type = #Residential ifTrue: [ total := total + ((9 * wp) * zone getNumberOfCells) ].	
		zone type = #Commertial ifTrue: [ total := total + ((2 * wp) * zone getNumberOfCells) ].	
		zone type = #Industrial ifTrue: [ total := total + ((10 * wp) * zone getNumberOfCells) ].	
		index := index + 1.
	].

	^ total.! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:39:42' prior: 50681450!
zones

	^ zones.
! !

!classRenamed: #Zone as: #ZoneTypes stamp: 'MS 9/23/2023 15:41:36'!
Smalltalk renameClassNamed: #Zone as: #ZoneTypes!
!CityTest methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:41:36' prior: 50680992!
residentialZone

	^ ZoneTypes withType: #Residential! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:41:36' prior: 50680988!
industrialZone

	^ ZoneTypes withType: #Industrial! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:41:36' prior: 50680984!
commertialZone

	^ ZoneTypes withType: #Commertial! !

ZoneTypes subclass: #Residential
	instanceVariableNames: 'type numberOfCells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

ZoneTypes subclass: #Residential
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #Residential category: 'ISW1-2021-2C-1erParcial' stamp: 'MS 9/23/2023 15:42:19'!
ZoneTypes subclass: #Residential
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

ZoneTypes subclass: #Commercial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #Commercial category: 'ISW1-2021-2C-1erParcial' stamp: 'MS 9/23/2023 15:42:47'!
ZoneTypes subclass: #Commercial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

ZoneTypes subclass: #Industrial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #Industrial category: 'ISW1-2021-2C-1erParcial' stamp: 'MS 9/23/2023 15:42:52'!
ZoneTypes subclass: #Industrial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:44:12' prior: 50681660!
addZone: aZone
	"aZone addTo: self"
	aZone type = #Residential ifTrue: [
		self energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	aZone type = #Commertial ifTrue: [
		self energyAvailable < (2 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (8 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		
		self hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	].

	aZone type = #Industrial ifTrue: [
		self energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (10 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	zones add: aZone.
! !
!Commercial methodsFor: 'nil' stamp: 'MS 9/23/2023 15:44:22'!
addTo: aCity! !
!Industrial methodsFor: 'no messages' stamp: 'MS 9/23/2023 15:44:31'!
addTo: aCity! !
!Residential methodsFor: 'nil' stamp: 'MS 9/23/2023 15:44:41'!
addTo: aCity! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:44:58' prior: 50681922!
addZone: aZone
	aZone addTo: self.
	
	aZone type = #Residential ifTrue: [
		self energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	aZone type = #Commertial ifTrue: [
		self energyAvailable < (2 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (8 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		
		self hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	].

	aZone type = #Industrial ifTrue: [
		self energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (10 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	zones add: aZone.
! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:45:08' prior: 50681961!
addZone: aZone
	aZone addTo: self.
	"
	aZone type = #Residential ifTrue: [
		self energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	aZone type = #Commertial ifTrue: [
		self energyAvailable < (2 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (8 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		
		self hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	].

	aZone type = #Industrial ifTrue: [
		self energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (10 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	]."

	zones add: aZone.
! !
!Commercial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:46:02' prior: 50681951!
addTo: aCity
	aCity energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	^aCity addCommercialZone: self.! !
!Residential methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:47:38' prior: 50681957!
addTo: aCity
	aCity energyAvailable < (2 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (8 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].	
	aCity hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].! !
!Industrial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:48:29' prior: 50681954!
addTo: aCity
	aCity energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (10 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].! !
!Industrial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:48:38' prior: 50682045!
addTo: aCity
	aCity energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (10 * wp)  ifTrue: [ self error: City cannotAddZoneErrorDescription ].! !

!classRenamed: #Commercial as: #Commertial stamp: 'MS 9/23/2023 15:50:29'!
Smalltalk renameClassNamed: #Commercial as: #Commertial!
!CityTest methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:50:30' prior: 50681876!
commertialZone

	^ ZoneTypes withType: #Commertial! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:50:30' prior: 50681840!
waterConsumption
	
	| index total |
	
	
	index := 1.
	total := 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone := zones at: index.
		zone type = #Residential ifTrue: [ total := total + ((9 * wp) * zone getNumberOfCells) ].	
		zone type = #Commertial ifTrue: [ total := total + ((2 * wp) * zone getNumberOfCells) ].	
		zone type = #Industrial ifTrue: [ total := total + ((10 * wp) * zone getNumberOfCells) ].	
		index := index + 1.
	].

	^ total.! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:50:30' prior: 50681689!
energyConsumption
	
	| index total |
	
	
	index := 1.
	total := 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone := zones at: index.
		zone type = #Residential ifTrue: [ total := total + ((5 * ep) * zone getNumberOfCells) ].	
		zone type = #Commertial ifTrue: [ total := total +((8 * ep) * zone getNumberOfCells) ].	
		zone type = #Industrial ifTrue: [ total := total + ((10 * ep) * zone getNumberOfCells) ].	
		index := index + 1.
	].

	^ total.! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:52:54'!
addValidZone: aZone
	zones add: aZone.! !
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:53:09' prior: 50682021!
addTo: aCity
	aCity energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	^aCity addValidZone: self! !
!Industrial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:53:26' prior: 50682055!
addTo: aCity
	aCity energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (10 * wp)  ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity addValidZone: self! !
!Residential methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:53:37' prior: 50682032!
addTo: aCity
	aCity energyAvailable < (2 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (8 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].	
	aCity hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	aCity addValidZone: self.! !
!Industrial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:53:44' prior: 50682125!
addTo: aCity
	aCity energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (10 * wp)  ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity addValidZone: self.! !
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:53:52' prior: 50682114!
addTo: aCity
	aCity energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	^aCity addValidZone: self.! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 15:54:01' prior: 50681991!
addZone: aZone
	aZone addTo: self.
! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 15:54:11'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 15:54:11'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 15:54:11'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 15:54:11'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 15:54:11'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 15:54:11'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:54:11'!
FAILURE!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:54:11'!
FAILURE!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:54:11'!
FAILURE!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 15:54:11'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 15:54:11'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 15:54:11'!
ERROR!
!ZoneTypes methodsFor: 'initialization' stamp: 'MS 9/23/2023 15:56:22' prior: 50681517!
initializeWithType: aZoneType 

	aZoneType = Commertial ifTrue: [^Commertial new].
	aZoneType = Industrial ifTrue: [^Industrial new].
	aZoneType = Residential ifTrue: [^Residential new].! !
!ZoneTypes methodsFor: 'initialization' stamp: 'MS 9/23/2023 15:56:41' prior: 50682274!
initializeWithType: aZoneType 

	aZoneType = #Commertial ifTrue: [^Commertial new].
	aZoneType = #Industrial ifTrue: [^Industrial new].
	aZoneType = #Residential ifTrue: [^Residential new].! !
!Residential methodsFor: 'accessing' stamp: 'MS 9/23/2023 15:57:27' overrides: 50681531!
type
	
	^ type! !
!Commertial methodsFor: 'accessing' stamp: 'MS 9/23/2023 15:57:27' overrides: 50681531!
type
	
	^ type! !
!Industrial methodsFor: 'accessing' stamp: 'MS 9/23/2023 15:57:27' overrides: 50681531!
type
	
	^ type! !
!ZoneTypes methodsFor: 'accessing' stamp: 'MS 9/23/2023 15:57:27' prior: 50681531!
type

	self subclassResponsibility! !
!Commertial methodsFor: 'accessing' stamp: 'MS 9/23/2023 15:57:37' prior: 50682296 overrides: 50682304!
type
	
	^ #Commertial! !
!Industrial methodsFor: 'accessing' stamp: 'MS 9/23/2023 15:57:45' prior: 50682300 overrides: 50682304!
type
	
	^ #Industrial! !
!Residential methodsFor: 'accessing' stamp: 'MS 9/23/2023 15:57:52' prior: 50682292 overrides: 50682304!
type
	
	^ #Residential! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 15:57:55'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 15:57:55'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 15:57:55'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 15:57:55'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 15:57:55'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 15:57:55'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 15:57:55'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 15:57:55'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 15:57:55'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 15:57:55'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 15:57:55'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 15:57:55'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 15:58:51'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 15:58:51'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 15:58:51'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 15:58:51'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 15:58:51'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 15:58:51'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 15:58:51'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 15:58:51'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 15:58:51'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 15:58:51'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 15:58:51'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 15:58:51'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 15:59:42'!
ERROR!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:01:09'!
ERROR!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:01:50'!
ERROR!
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:04:55' prior: 50682161!
addTo: aCity
	aCity energyAvailable < (2 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (8 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].	
	aCity hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	^aCity addValidZone: self.! !
!Residential methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:05:04' prior: 50682136!
addTo: aCity
	aCity energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity addValidZone: self.! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:05:16'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:05:19'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:05:20'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:05:20'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:05:20'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:05:20'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:05:20'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:05:20'!
PASSED!
!ZoneTypes methodsFor: 'nil' stamp: 'MS 9/23/2023 16:10:03'!
zoneEnergyConsuption: aZone
	self subclassResponsibility .! !
!Residential methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:10:14' overrides: 50682755!
zoneEnergyConsuption: aZone
	self subclassResponsibility .! !
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:10:14' overrides: 50682755!
zoneEnergyConsuption: aZone
	self subclassResponsibility .! !
!Industrial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:10:14' overrides: 50682755!
zoneEnergyConsuption: aZone
	self subclassResponsibility .! !
!ZoneTypes methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:10:14' prior: 50682755!
zoneEnergyConsuption: aZone

	self subclassResponsibility! !
!Residential methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:10:59' prior: 50682761 overrides: 50682776!
zoneEnergyConsuption: aZone
	^ (5 * ep) * self getNumberOfCells.! !
!Residential methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:11:08'!
zoneEnergyConsuption
	^ (5 * ep) * self getNumberOfCells.! !

!methodRemoval: Residential #zoneEnergyConsuption: stamp: 'MS 9/23/2023 16:11:13'!
zoneEnergyConsuption: aZone
	^ (5 * ep) * self getNumberOfCells.!
!ZoneTypes methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:11:27'!
zoneEnergyConsuption

	self subclassResponsibility! !

!methodRemoval: ZoneTypes #zoneEnergyConsuption: stamp: 'MS 9/23/2023 16:11:32'!
zoneEnergyConsuption: aZone

	self subclassResponsibility!
!Residential methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:11:39' prior: 50682787 overrides: 50682796!
zoneEnergyConsuption

	self subclassResponsibility! !
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:11:39' overrides: 50682796!
zoneEnergyConsuption

	self subclassResponsibility! !
!Industrial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:11:39' overrides: 50682796!
zoneEnergyConsuption

	self subclassResponsibility! !
!ZoneTypes methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:11:39' prior: 50682796!
zoneEnergyConsuption

	self subclassResponsibility! !

!methodRemoval: Commertial #zoneEnergyConsuption: stamp: 'MS 9/23/2023 16:11:45'!
zoneEnergyConsuption: aZone
	self subclassResponsibility .!
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:11:54' prior: 50682811 overrides: 50682821!
zoneEnergyConsuption

	^ (8 * ep) * self getNumberOfCells.
	! !

!methodRemoval: Industrial #zoneEnergyConsuption: stamp: 'MS 9/23/2023 16:11:58'!
zoneEnergyConsuption: aZone
	self subclassResponsibility .!
!Industrial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:12:05' prior: 50682816 overrides: 50682821!
zoneEnergyConsuption

	^ (10 * ep) * self getNumberOfCells.! !
!Residential methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:12:13' prior: 50682806 overrides: 50682821!
zoneEnergyConsuption

	^ (5 * ep) * self getNumberOfCells.! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:12:52' prior: 50682092!
energyConsumption
	
	| index total |
	
	
	index := 1.
	total := 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone := zones at: index.
		total := total + zone energyConsumption.
		index := index + 1.
	].

	^ total.! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:12:58'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:12:58'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:12:58'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:12:58'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:12:58'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:12:58'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:12:58'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:12:58'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:12:58'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:12:58'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:12:58'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:12:58'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:14:03' prior: 50682853!
energyConsumption
	
	| index total |
	
	
	index := 1.
	total := 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone := zones at: index.
		total := total + zone zoneEnergyConsumption.
		index := index + 1.
	].

	^ total.! !
!ZoneTypes methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:14:26'!
zoneEnergyConsumption

	self subclassResponsibility! !
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:14:26' overrides: 50682972!
zoneEnergyConsumption

	^ (8 * ep) * self getNumberOfCells.
	! !
!Industrial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:14:26' overrides: 50682972!
zoneEnergyConsumption

	^ (10 * ep) * self getNumberOfCells.! !
!Residential methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:14:26' overrides: 50682972!
zoneEnergyConsumption

	^ (5 * ep) * self getNumberOfCells.! !

!methodRemoval: ZoneTypes #zoneEnergyConsuption stamp: 'MS 9/23/2023 16:14:26'!
zoneEnergyConsuption

	self subclassResponsibility!

!methodRemoval: Commertial #zoneEnergyConsuption stamp: 'MS 9/23/2023 16:14:26'!
zoneEnergyConsuption

	^ (8 * ep) * self getNumberOfCells.
	!

!methodRemoval: Industrial #zoneEnergyConsuption stamp: 'MS 9/23/2023 16:14:26'!
zoneEnergyConsuption

	^ (10 * ep) * self getNumberOfCells.!

!methodRemoval: Residential #zoneEnergyConsuption stamp: 'MS 9/23/2023 16:14:26'!
zoneEnergyConsuption

	^ (5 * ep) * self getNumberOfCells.!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:14:37'!
PASSED!

----End fileIn of /home/martin/Desktop/Inge1/linux64/linux64/Packages/TerseGuide.pck.st----!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:16:13' prior: 50682962!
energyConsumption
	
	^ zones inject: 0 into: [:sum :zone | sum + zone zoneEnergyConsumption].
	"	
	| index total |

	index := 1.
	total := 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone := zones at: index.
		total := total + zone zoneEnergyConsumption.
		index := index + 1.
	].

	^ total."! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:16:31'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:16:41' prior: 50686031!
energyConsumption
	
	^ zones inject: 0 into: [:sum :zone | sum + zone zoneEnergyConsumption].
	! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:24:03' prior: 50681718!
hasResidentialZones

	^ zones anySatisfy: [:zone | zone type = #Residential]
	"
	| index |
	zones isEmpty ifTrue: [ ^ false ].

	index := 1.
	
	[index <= zones size] whileTrue: [ | zone |
		zone := zones at: index.
		zone type = #Residential ifTrue: [ ^ true].	
		index := index + 1.
	].

	^ false."
! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:24:06'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:24:26' prior: 50686149!
hasResidentialZones

	^ zones anySatisfy: [:zone | zone type = #Residential]
	
! !
!ZoneTypes methodsFor: 'nil' stamp: 'MS 9/23/2023 16:25:04'!
zoneWaterConsumption
! !
!Residential methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:25:11' overrides: 50686266!
zoneWaterConsumption
! !
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:25:11' overrides: 50686266!
zoneWaterConsumption
! !
!Industrial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:25:11' overrides: 50686266!
zoneWaterConsumption
! !
!ZoneTypes methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:25:11' prior: 50686266!
zoneWaterConsumption

	self subclassResponsibility! !
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:25:17' prior: 50686274 overrides: 50686282!
zoneWaterConsumption
	! !
!Residential methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:25:51' prior: 50686270 overrides: 50686282!
zoneWaterConsumption
	^((9 * wp) * self getNumberOfCells)! !
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:26:23' prior: 50686288 overrides: 50686282!
zoneWaterConsumption
	^((2 * wp) * self getNumberOfCells)! !
!Industrial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:26:35' prior: 50686278 overrides: 50686282!
zoneWaterConsumption
	^((10 * wp) * self getNumberOfCells)! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:27:39' prior: 50682074!
waterConsumption
	
	^zones inject: 0 into:[:sum :zone | sum + zone zoneWaterConsumption.] ! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:27:49'!
PASSED!

Service subclass: #Power
	instanceVariableNames: 'type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

Object subclass: #Service
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #Service category: 'ISW1-2021-2C-1erParcial' stamp: 'MS 9/23/2023 16:28:49'!
Object subclass: #Service
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

Object subclass: #Service
	instanceVariableNames: 'type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #Service category: 'ISW1-2021-2C-1erParcial' stamp: 'MS 9/23/2023 16:28:58'!
Object subclass: #Service
	instanceVariableNames: 'type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

Service subclass: #Power
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #Power category: 'ISW1-2021-2C-1erParcial' stamp: 'MS 9/23/2023 16:29:08'!
Service subclass: #Power
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

Service subclass: #Water
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #Water category: 'ISW1-2021-2C-1erParcial' stamp: 'MS 9/23/2023 16:29:19'!
Service subclass: #Water
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!
!Water methodsFor: 'nil' stamp: 'MS 9/23/2023 16:30:31' overrides: 50681489!
type
	^#WaterTower! !
!Power methodsFor: 'no messages' stamp: 'MS 9/23/2023 16:30:49' overrides: 50681489!
type
	^#SolarPlants! !
!Service methodsFor: 'accessing' stamp: 'MS 9/23/2023 16:30:58' prior: 50681489!
type
	
	^self subclassResponsibility ! !
!Service methodsFor: 'nil' stamp: 'MS 9/23/2023 16:32:27'!
waterProduced
	! !
!Service methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:32:32'!
energyProduced
	! !
!Power methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:32:37' overrides: 50686481!
energyProduced
	! !
!Water methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:32:37' overrides: 50686481!
energyProduced
	! !
!Service methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:32:37' prior: 50686481!
energyProduced

	self subclassResponsibility! !
!Power methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:32:44' overrides: 50686478!
waterProduced
	! !
!Water methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:32:44' overrides: 50686478!
waterProduced
	! !
!Service methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:32:44' prior: 50686478!
waterProduced

	self subclassResponsibility! !
!Power methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:32:53' prior: 50686498 overrides: 50686506!
waterProduced
	^0 * wp
	! !
!Power methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:33:10' prior: 50686485 overrides: 50686493!
energyProduced
	^500 * ep
	! !
!Water methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:33:17' prior: 50686489 overrides: 50686493!
energyProduced
	^0 * ep! !
!Water methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:33:24' prior: 50686502 overrides: 50686506!
waterProduced
	^ 200 * wp! !
!Service methodsFor: 'nil' stamp: 'MS 9/23/2023 16:33:36' prior: 50686474!
type! !
!Service methodsFor: 'accessing' stamp: 'MS 9/23/2023 16:33:58' prior: 50686530!
type
	self subclassResponsibility.! !
!Service methodsFor: 'initialization' stamp: 'MS 9/23/2023 16:35:18' prior: 50681485!
initializeWithType: aServiceType 

	aServiceType = #WaterTower ifTrue: [^Water new.].
	aServiceType = #SolarPlant ifTrue: [^Power new.].! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:36:20' prior: 50681707!
energyProduced

	^services inject: 0 into: [:sum :service | sum + service energyProduced.].
	"
	| index total |
	
	index := 1.
	total := 0 * ep.
	
	[index <= services size] whileTrue: [ | service |
		service := services at: index.
		service type = #SolarPlant ifTrue: [ total := total + (500 * ep)].	
		index := index + 1.
	].

	^ total."! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:36:43' prior: 50681829!
waterProduced
	^services inject: 0 into: [:sum :service | sum + service waterProduced.].
	"
	| index total |
	
	
	index := 1.
	total := 0.
	
	[index <= services size] whileTrue: [ | service |
		service := services at: index.
		service type = #WaterTower ifTrue: [ total := total + (200 * wp)].	
		index := index + 1.
	].

	^ total."! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:36:46'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:36:53' prior: 50686559!
waterProduced
	^services inject: 0 into: [:sum :service | sum + service waterProduced.].
	! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:37:02' prior: 50686545!
energyProduced

	^services inject: 0 into: [:sum :service | sum + service energyProduced.].
! !
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:39:49' prior: 50682533!
addTo: aCity
	aCity checkAvailableEnergy: 2 andAvailableWater: 8.
	aCity energyAvailable < (2 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (8 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].	
	aCity hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	^aCity addValidZone: self.! !
!City methodsFor: 'nil' stamp: 'MS 9/23/2023 16:40:34'!
hasAvailableEnergie: energieLevels andAvailableWater: waterLevels! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:40:56'!
checkAvailableEnergie: energieLevels andAvailableWater: waterLevels! !

!methodRemoval: City #hasAvailableEnergie:andAvailableWater: stamp: 'MS 9/23/2023 16:40:56'!
hasAvailableEnergie: energieLevels andAvailableWater: waterLevels!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:41:49' prior: 50686703!
checkAvailableEnergie: energieLevels andAvailableWater: waterLevels
	^ ( self energyAvailable < energieLevels ) and:  (self waterAvailable < waterLevels ).! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:42:21' prior: 50686713!
checkAvailableEnergie: energieLevels andAvailableWater: waterLevels
	^ ( self energyAvailable < energieLevels * ep ) and:  (self waterAvailable < waterLevels * wp).! !
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:43:34' prior: 50686684!
addTo: aCity
	(aCity checkAvailableEnergy: 2 andAvailableWater: 8) ifFalse: [ self error: City cannotAddZoneErrorDescription ].
	aCity hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	^aCity addValidZone: self.! !
!Industrial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:43:54' prior: 50682150!
addTo: aCity
	(aCity checkAvailableEnergy: 10 andAvailableWater: 10) ifFalse: [ self error: City cannotAddZoneErrorDescription ].
	aCity addValidZone: self.! !
!Residential methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:44:07' prior: 50682547!
addTo: aCity
	(aCity checkAvailableEnergy: 5 andAvailableWater: 9) ifFalse: [ self error: City cannotAddZoneErrorDescription ].
	aCity addValidZone: self.! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:44:44'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:44:44'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:44:44'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:44:44'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:44:44'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:44:44'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:44:44'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:44:44'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:44:44'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:44:44'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:44:44'!
ERROR!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:44:44'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:44:44'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:44:44'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:44:44'!
FAILURE!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:44:44'!
FAILURE!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:44:44'!
FAILURE!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:44:44'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:44:44'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:44:44'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:44:45'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:44:45'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:44:45'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:44:45'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:44:45'!
ERROR!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:45:30'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:45:30'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:45:30'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:45:30'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:45:30'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:45:30'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:45:30'!
FAILURE!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:45:30'!
FAILURE!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:45:30'!
FAILURE!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:45:30'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:45:30'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:45:30'!
ERROR!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:45:54'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:45:54'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:45:54'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:45:54'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:45:54'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:45:54'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:45:54'!
FAILURE!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:45:54'!
FAILURE!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:45:54'!
FAILURE!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:45:54'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:45:54'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:45:54'!
ERROR!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:46:00'!
ERROR!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:46:00'!
ERROR!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:46:34'!
checkAvailableEnergy: energieLevels andAvailableWater: waterLevels
	^ ( self energyAvailable < energieLevels * ep ) and:  (self waterAvailable < waterLevels * wp).! !

!methodRemoval: City #checkAvailableEnergie:andAvailableWater: stamp: 'MS 9/23/2023 16:46:39'!
checkAvailableEnergie: energieLevels andAvailableWater: waterLevels
	^ ( self energyAvailable < energieLevels * ep ) and:  (self waterAvailable < waterLevels * wp).!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:46:45'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:46:45'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:46:45'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:46:45'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:46:45'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:46:45'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:46:45'!
FAILURE!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:46:45'!
FAILURE!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:46:45'!
FAILURE!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:46:45'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:46:45'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:46:45'!
ERROR!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:46:51'!
ERROR!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:47:21' prior: 50687062!
checkAvailableEnergy: energieLevels andAvailableWater: waterLevels
	^ ( self energyAvailable < (energieLevels * ep) ) and:  (self waterAvailable < (waterLevels * wp)).! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:47:24'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:47:24'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:47:24'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:47:24'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:47:24'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:47:24'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:47:24'!
FAILURE!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:47:24'!
FAILURE!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:47:24'!
FAILURE!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:47:24'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:47:24'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:47:24'!
ERROR!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:47:27'!
ERROR!
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:48:30' prior: 50686730!
addTo: aCity
	(aCity checkAvailableEnergy: 2 andAvailableWater: 8) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	^aCity addValidZone: self.! !
!Industrial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:48:37' prior: 50686741!
addTo: aCity
	(aCity checkAvailableEnergy: 10 andAvailableWater: 10) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity addValidZone: self.! !
!Residential methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:48:44' prior: 50686749!
addTo: aCity
	(aCity checkAvailableEnergy: 5 andAvailableWater: 9) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity addValidZone: self.! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 16:48:47'!
PASSED!
!Service methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 16:49:43' prior: 50686533!
type

	self subclassResponsibility! !
!ZoneTypes methodsFor: 'nil' stamp: 'MS 9/23/2023 16:50:37'!
addTo: aCity
	self subclassResponsibility.! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 17:03:06' prior: 50686143!
energyConsumption
	
	^ zones sum: [:zone | zone zoneEnergyConsumption].
	! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 17:03:12'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 17:03:12'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 17:03:12'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 17:03:12'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:03:12'!
FAILURE!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:03:12'!
FAILURE!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:03:12'!
FAILURE!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 17:03:12'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 17:03:12'!
ERROR!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 17:04:12' prior: 50687430!
energyConsumption
	
	^ zones inject: 0 into: [:sum :zone | sum + zone zoneEnergyConsumption].
	! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 17:04:14'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 17:06:34' prior: 50687535!
energyConsumption
	^ zones sum: [:zone | zone zoneEnergyConsumption].
	"^ zones inject: 0 into: [:sum :zone | sum + zone zoneEnergyConsumption]."
	! !
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 17:06:39' prior: 50687641!
energyConsumption
	^ zones sum: [:zone | zone zoneEnergyConsumption].
	
	"^ zones inject: 0 into: [:sum :zone | sum + zone zoneEnergyConsumption]."
	! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 17:06:43'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 17:06:43'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 17:06:43'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 17:06:43'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:06:43'!
FAILURE!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:06:43'!
FAILURE!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:06:43'!
FAILURE!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 17:06:43'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 17:06:43'!
ERROR!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 17:08:00' prior: 50687649!
energyConsumption
	zones ifEmpty: [^0].
	^ zones sum: [:zone | zone zoneEnergyConsumption].
	
	"^ zones inject: 0 into: [:sum :zone | sum + zone zoneEnergyConsumption]."
	! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 17:08:03'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 17:08:03'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 17:08:03'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 17:08:03'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 17:08:03'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 17:08:03'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 17:08:03'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 17:08:03'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 17:08:03'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 17:08:03'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 17:08:03'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 17:08:03'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 17:08:04'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 17:08:04'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:08:04'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:08:04'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:08:04'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 17:08:04'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 17:08:04'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 17:08:04'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 17:08:04'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 17:08:04'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 17:08:04'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 17:08:04'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 17:08:04'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 17:08:22' prior: 50687756!
energyConsumption

	^ zones inject: 0 into: [:sum :zone | sum + zone zoneEnergyConsumption].
	! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'MS 9/23/2023 17:19:29'!
PASSED!
!Commertial methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 17:19:44' prior: 50686299 overrides: 50686282!
zoneWaterConsumption

	^((2 * wp) * self getNumberOfCells)! !

----End fileIn of /home/martin/Desktop/ISW1-2022-1C-Parcial-1.st----!

----End fileIn of /home/martin/Desktop/ISW1-2022-1C-Parcial-1-Resolucion.st----!

----STARTUP---- (23 September 2023 17:57:25) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Downloads/ISW1-2021-2C-1erParcial.st----!

----STARTUP---- (23 September 2023 18:00:34) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/ISW1-2022-1C-Parcial-1.st----!

Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turbo traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 18:01:46'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turbo traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/23/2023 18:02:28' prior: 50680748!
activateTurbo
	turbo activate.
	
	"turbo ifTrue: [ self error: self turboAlreadyActivatedErrorDescription ].
	
	currentSector activateTurboTo: self."
! !

Object subclass: #Turbo
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Turbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 18:02:53'!
Object subclass: #Turbo
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Turbo subclass: #ActiveTurbo
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Turbo subclass: #ActiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #ActiveTurbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 18:03:09'!
Turbo subclass: #ActiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Turbo subclass: #InactiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #InactiveTurbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'MS 9/23/2023 18:03:14'!
Turbo subclass: #InactiveTurbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!Turbo methodsFor: 'nil' stamp: 'MS 9/23/2023 18:03:34'!
activate
	! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 18:03:37' overrides: 50681249!
activate
	! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 18:03:37' overrides: 50681249!
activate
	! !
!Turbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 18:03:37' prior: 50681249!
activate

	self subclassResponsibility! !

!methodRemoval: Turbo #activate stamp: 'MS 9/23/2023 18:06:07'!
activate

	self subclassResponsibility!
!Turbo methodsFor: 'nil' stamp: 'MS 9/23/2023 18:06:14'!
activate: aCar! !
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 18:06:18' overrides: 50681268!
activate: aCar! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 18:06:18' overrides: 50681268!
activate: aCar! !
!Turbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 18:06:18' prior: 50681268!
activate: aCar

	self subclassResponsibility! !

!methodRemoval: ActiveTurbo #activate stamp: 'MS 9/23/2023 18:06:22'!
activate
	!

!methodRemoval: InactiveTurbo #activate stamp: 'MS 9/23/2023 18:06:25'!
activate
	!
!ActiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 18:06:51' prior: 50681272 overrides: 50681280!
activate: aCar
	^ aCar activateActiveTurbo.! !
!InactiveTurbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 18:07:04' prior: 50681276 overrides: 50681280!
activate: aCar
	^aCar activateInactiveTurbo.! !
!FormulaOneCar methodsFor: 'nil' stamp: 'MS 9/23/2023 18:07:38'!
activateActiveTurbo
	^self error: self turboAlreadydeActivatedErrorDescription ! !
!FormulaOneCar methodsFor: 'nil' stamp: 'MS 9/23/2023 18:08:52'!
activateInactiveTurbo
	currentSector activateTurboTo: self.! !
!Turbo methodsFor: 'nil' stamp: 'MS 9/23/2023 18:09:19' overrides: 16920235!
initialize
	InactiveTurbo new.! !
!Turbo methodsFor: 'as yet unclassified' stamp: 'MS 9/23/2023 18:09:23' prior: 50681311 overrides: 16920235!
initialize
	^InactiveTurbo new.! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'MS 9/23/2023 18:09:32' prior: 50681199!
activateTurbo
	turbo activate.
	
! !
!FormulaOneCar methodsFor: 'initialization' stamp: 'MS 9/23/2023 18:10:06' prior: 50680704!
initializeDrivenBy: aDriver 

	driver := aDriver.
	turboActivations := 0.
	speed := 0*kilometer/hour.
	traveledDistance := 0.
	turbo := Turbo new.
	! !

----STARTUP---- (24 September 2023 12:29:32) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Downloads/ISW1-2023-1C-Parcial-1.st----!

Object subclass: #Mecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Mecha category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 12:41:01'!
Object subclass: #Mecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mecha subclass: #Widia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Widia category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 12:41:11'!
Mecha subclass: #Widia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mecha subclass: #Diamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Diamante category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 12:41:18'!
Mecha subclass: #Diamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mecha subclass: #Soft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Soft category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 12:41:32'!
Mecha subclass: #Soft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRenamed: #Diamante as: #MechaDeDiamante stamp: 'MS 9/24/2023 12:41:54'!
Smalltalk renameClassNamed: #Diamante as: #MechaDeDiamante!
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:41:54' prior: 50681774!
darGolpeDeTaladro
		
	self sinMecha ifTrue: [self error: 'No puede perforar'].

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.

	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaDeDiamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #MechaDeDiamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
			^self ].
		mechaPuesta = #MechaDeDiamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:41:54' prior: 50681854!
ponerMechaDiamante
	mechaPuesta := #MechaDeDiamante! !

!classRenamed: #Soft as: #MechaSoft stamp: 'MS 9/24/2023 12:42:10'!
Smalltalk renameClassNamed: #Soft as: #MechaSoft!
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:42:10' prior: 50681858!
ponerMechaSoft
	mechaPuesta := #MechaSoft! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:42:10' prior: 50681984!
darGolpeDeTaladro
		
	self sinMecha ifTrue: [self error: 'No puede perforar'].

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.

	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaDeDiamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #MechaDeDiamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
			^self ].
		mechaPuesta = #MechaDeDiamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !

!classRenamed: #Widia as: #MechaDeWidia stamp: 'MS 9/24/2023 12:42:19'!
Smalltalk renameClassNamed: #Widia as: #MechaDeWidia!
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:42:19' prior: 50682039!
darGolpeDeTaladro
		
	self sinMecha ifTrue: [self error: 'No puede perforar'].

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.

	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaDeWidia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaDeDiamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self ].
		mechaPuesta = #MechaDeWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #MechaDeDiamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi'  ].
		mechaPuesta = #MechaDeWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
			^self ].
		mechaPuesta = #MechaDeDiamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:42:19' prior: 50681862!
ponerMechaWidia
	mechaPuesta := #MechaDeWidia! !

!classRenamed: #MechaDeDiamante as: #MechaDiamante stamp: 'MS 9/24/2023 12:42:32'!
Smalltalk renameClassNamed: #MechaDeDiamante as: #MechaDiamante!
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:42:33' prior: 50682085!
darGolpeDeTaladro
		
	self sinMecha ifTrue: [self error: 'No puede perforar'].

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.

	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaDeWidia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaDiamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self ].
		mechaPuesta = #MechaDeWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #MechaDiamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi'  ].
		mechaPuesta = #MechaDeWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
			^self ].
		mechaPuesta = #MechaDiamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:42:33' prior: 50682025!
ponerMechaDiamante
	mechaPuesta := #MechaDiamante! !

!classRenamed: #MechaDeWidia as: #MechaWidia stamp: 'MS 9/24/2023 12:42:39'!
Smalltalk renameClassNamed: #MechaDeWidia as: #MechaWidia!
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:42:39' prior: 50682137!
darGolpeDeTaladro
		
	self sinMecha ifTrue: [self error: 'No puede perforar'].

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.

	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaWidia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaDiamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self ].
		mechaPuesta = #MechaWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #MechaDiamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi'  ].
		mechaPuesta = #MechaWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
			^self ].
		mechaPuesta = #MechaDiamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:42:39' prior: 50682127!
ponerMechaWidia
	mechaPuesta := #MechaWidia! !

Mecha subclass: #MechaRota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #MechaRota category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 12:43:17'!
Mecha subclass: #MechaRota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!Mecha methodsFor: 'nil' stamp: 'MS 9/24/2023 12:43:51'!
mechaEstaRota! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:43:55' overrides: 50682245!
mechaEstaRota! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:43:55' overrides: 50682245!
mechaEstaRota! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:43:55' overrides: 50682245!
mechaEstaRota! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:43:55' overrides: 50682245!
mechaEstaRota! !
!Mecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:43:55' prior: 50682245!
mechaEstaRota

	self subclassResponsibility! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:44:03' prior: 50682253 overrides: 50682265!
mechaEstaRota
	^false! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:44:09' prior: 50682261 overrides: 50682265!
mechaEstaRota
	^true! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:44:12' prior: 50682276 overrides: 50682265!
mechaEstaRota
	^true! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:44:17' prior: 50682257 overrides: 50682265!
mechaEstaRota
	^false! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:44:23' prior: 50682249 overrides: 50682265!
mechaEstaRota
	^false! !
!Perforadora methodsFor: 'accessing' stamp: 'MS 9/24/2023 12:44:35' prior: 50681827!
conMechaRota

	^mechaPuesta estaRota! !
!Mecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:44:54'!
estaRota

	self subclassResponsibility! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:44:54' overrides: 50682299!
estaRota
	^false! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:44:54' overrides: 50682299!
estaRota
	^true! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:44:54' overrides: 50682299!
estaRota
	^false! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:44:54' overrides: 50682299!
estaRota
	^false! !

!methodRemoval: Mecha #mechaEstaRota stamp: 'MS 9/24/2023 12:44:54'!
mechaEstaRota

	self subclassResponsibility!

!methodRemoval: MechaDiamante #mechaEstaRota stamp: 'MS 9/24/2023 12:44:54'!
mechaEstaRota
	^false!

!methodRemoval: MechaRota #mechaEstaRota stamp: 'MS 9/24/2023 12:44:54'!
mechaEstaRota
	^true!

!methodRemoval: MechaSoft #mechaEstaRota stamp: 'MS 9/24/2023 12:44:54'!
mechaEstaRota
	^false!

!methodRemoval: MechaWidia #mechaEstaRota stamp: 'MS 9/24/2023 12:44:54'!
mechaEstaRota
	^false!

Mecha subclass: #sinMecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mecha subclass: #SinMecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #SinMecha category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 12:48:36'!
Mecha subclass: #SinMecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!SinMecha methodsFor: 'nil' stamp: 'MS 9/24/2023 12:48:51' overrides: 50682299!
estaRota
	^false! !
!Perforadora methodsFor: 'accessing' stamp: 'MS 9/24/2023 12:50:09' prior: 50681835!
sinMecha

	^mechaPuesta sinMecha! !
!Mecha methodsFor: 'nil' stamp: 'MS 9/24/2023 12:50:15'!
sinMecha! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:50:21' overrides: 50682358!
sinMecha! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:50:21' overrides: 50682358!
sinMecha! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:50:21' overrides: 50682358!
sinMecha! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:50:21' overrides: 50682358!
sinMecha! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:50:21' overrides: 50682358!
sinMecha! !
!Mecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:50:21' prior: 50682358!
sinMecha

	self subclassResponsibility! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:50:26' prior: 50682366 overrides: 50682382!
sinMecha
	^false! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:50:38' prior: 50682374 overrides: 50682382!
sinMecha
	^false! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:50:45' prior: 50682370 overrides: 50682382!
sinMecha
	^false! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:50:50' prior: 50682397 overrides: 50682382!
sinMecha
	^false! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:51:02' prior: 50682362 overrides: 50682382!
sinMecha
	^false! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 12:51:06' prior: 50682378 overrides: 50682382!
sinMecha
	^true! !
!Perforadora methodsFor: 'colocar mecha' stamp: 'MS 9/24/2023 12:53:27' prior: 50682179!
ponerMechaDiamante
	mechaPuesta := Mecha de: #Diamante! !
!Perforadora methodsFor: 'colocar mecha' stamp: 'MS 9/24/2023 12:54:05' prior: 50682034!
ponerMechaSoft
	mechaPuesta := Mecha de: #MechaSoft! !
!Perforadora methodsFor: 'colocar mecha' stamp: 'MS 9/24/2023 12:54:38' prior: 50682416!
ponerMechaDiamante
	mechaPuesta := Mecha deTipo: #Diamante! !
!Perforadora methodsFor: 'colocar mecha' stamp: 'MS 9/24/2023 12:54:50' prior: 50682421!
ponerMechaSoft
	mechaPuesta := Mecha deTipo: #Soft! !
!Perforadora methodsFor: 'colocar mecha' stamp: 'MS 9/24/2023 12:55:00' prior: 50682230!
ponerMechaWidia
	mechaPuesta := Mecha deTipo: #Widia! !
!Mecha class methodsFor: 'nil' stamp: 'MS 9/24/2023 12:57:10'!
deTipo: unTipoDeMecha
	unTipoDeMecha  = #Diamante ifTrue: [^MechaDiamante new.].
	unTipoDeMecha  = #Widia ifTrue: [^MechaWidia new.].
	unTipoDeMecha  = #Soft ifTrue: [^MechaSoft new.].! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 12:57:49'!
FAILURE!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 12:57:49'!
ERROR!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 12:57:49'!
FAILURE!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 12:57:49'!
FAILURE!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 12:57:49'!
ERROR!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 12:57:49'!
ERROR!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 12:57:49'!
FAILURE!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 12:57:49'!
ERROR!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 12:57:49'!
ERROR!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 12:57:49'!
FAILURE!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 12:57:49'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 12:57:49'!
FAILURE!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 12:57:49'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 12:57:49'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 12:57:49'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 12:57:49'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 12:57:49'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 12:57:49'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 12:57:49'!
PASSED!
!Perforadora methodsFor: 'initialization' stamp: 'MS 9/24/2023 13:02:34' prior: 50681814!
initializeSobreSuelo: capasDeSueloAExcavarInicialmente

	capasDeSueloDebajo := capasDeSueloAExcavarInicialmente.
	vecesQueGolpeoCapaActual := 0.
	container := OrderedCollection new.
	mechaPuesta := Mecha deTipo: #sinMecha! !
!Mecha class methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 13:02:56' prior: 50682440!
deTipo: unTipoDeMecha
	unTipoDeMecha  = #Diamante ifTrue: [^MechaDiamante new.].
	unTipoDeMecha  = #Widia ifTrue: [^MechaWidia new.].
	unTipoDeMecha  = #Soft ifTrue: [^MechaSoft new.].
	unTipoDeMecha  = #sinMecha ifTrue: [^SinMecha new.].! !
!Mecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 13:04:07' prior: 50682299!
estaRota

	^false! !
!Mecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 13:04:13' prior: 50682382!
sinMecha

	^false! !

!methodRemoval: MechaDiamante #estaRota stamp: 'MS 9/24/2023 13:04:24'!
estaRota
	^false!

!methodRemoval: MechaDiamante #sinMecha stamp: 'MS 9/24/2023 13:04:28'!
sinMecha
	^false!

!methodRemoval: MechaRota #sinMecha stamp: 'MS 9/24/2023 13:04:35'!
sinMecha
	^false!

!methodRemoval: MechaSoft #estaRota stamp: 'MS 9/24/2023 13:04:39'!
estaRota
	^false!

!methodRemoval: MechaSoft #sinMecha stamp: 'MS 9/24/2023 13:04:42'!
sinMecha
	^false!

!methodRemoval: MechaWidia #estaRota stamp: 'MS 9/24/2023 13:04:45'!
estaRota
	^false!

!methodRemoval: MechaWidia #sinMecha stamp: 'MS 9/24/2023 13:04:49'!
sinMecha
	^false!

!methodRemoval: SinMecha #estaRota stamp: 'MS 9/24/2023 13:04:53'!
estaRota
	^false!

CapaDeSuelo subclass: #SueloArenoso
	instanceVariableNames: 'tipo resistencia altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

CapaDeSuelo subclass: #SueloArenoso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #SueloArenoso category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 13:16:40'!
CapaDeSuelo subclass: #SueloArenoso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

CapaDeSuelo subclass: #SueloDeTierra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #SueloDeTierra category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 13:16:45'!
CapaDeSuelo subclass: #SueloDeTierra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

CapaDeSuelo subclass: #SueloDeConcreto
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #SueloDeConcreto category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 13:16:57'!
CapaDeSuelo subclass: #SueloDeConcreto
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!SueloArenoso methodsFor: 'accessing' stamp: 'MS 9/24/2023 13:19:18' overrides: 50681704!
tipo

	^tipo! !
!SueloDeTierra methodsFor: 'accessing' stamp: 'MS 9/24/2023 13:19:18' overrides: 50681704!
tipo

	^tipo! !
!SueloDeConcreto methodsFor: 'accessing' stamp: 'MS 9/24/2023 13:19:18' overrides: 50681704!
tipo

	^tipo! !
!CapaDeSuelo methodsFor: 'accessing' stamp: 'MS 9/24/2023 13:19:18' prior: 50681704!
tipo

	self subclassResponsibility! !
!SueloArenoso methodsFor: 'accessing' stamp: 'MS 9/24/2023 13:19:25' prior: 50682619 overrides: 50682631!
tipo

	^#Arenoso! !
!SueloDeConcreto methodsFor: 'accessing' stamp: 'MS 9/24/2023 13:19:33' prior: 50682627 overrides: 50682631!
tipo

	^#Concreto! !
!SueloDeTierra methodsFor: 'accessing' stamp: 'MS 9/24/2023 13:19:40' prior: 50682623 overrides: 50682631!
tipo

	^#Tierra! !
!SueloArenoso methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:21:32' overrides: 50681665!
esArenoso
	^tipo = #Arenoso! !
!SueloDeTierra methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:21:32' overrides: 50681665!
esArenoso
	^tipo = #Arenoso! !
!SueloDeConcreto methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:21:32' overrides: 50681665!
esArenoso
	^tipo = #Arenoso! !
!CapaDeSuelo methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:21:32' prior: 50681665!
esArenoso

	self subclassResponsibility! !
!SueloArenoso methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:21:40' prior: 50682649 overrides: 50682661!
esArenoso
	^true! !

Object subclass: #CapaDeSuelo
	instanceVariableNames: 'tipo resistencia altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #CapaDeSuelo category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 13:23:28'!
Object subclass: #CapaDeSuelo
	instanceVariableNames: 'tipo resistencia altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!SueloDeTierra methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:23:41' prior: 50682653 overrides: 50682661!
esArenoso
	^false! !
!SueloDeConcreto methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:23:45' prior: 50682657 overrides: 50682661!
esArenoso
	^false! !
!SueloArenoso methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:16' overrides: 50681668!
esConcreto
	^tipo = #Concreto! !
!SueloDeTierra methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:16' overrides: 50681668!
esConcreto
	^tipo = #Concreto! !
!SueloDeConcreto methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:16' overrides: 50681668!
esConcreto
	^tipo = #Concreto! !
!CapaDeSuelo methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:16' prior: 50681668!
esConcreto

	self subclassResponsibility! !
!SueloArenoso methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:21' overrides: 50681672!
esTierra
	^tipo = #Tierra! !
!SueloDeTierra methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:21' overrides: 50681672!
esTierra
	^tipo = #Tierra! !
!SueloDeConcreto methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:21' overrides: 50681672!
esTierra
	^tipo = #Tierra! !
!CapaDeSuelo methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:21' prior: 50681672!
esTierra

	self subclassResponsibility! !
!SueloArenoso methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:30' prior: 50682692 overrides: 50682704!
esConcreto
	^false! !
!SueloArenoso methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:34' prior: 50682709 overrides: 50682721!
esTierra
	^false! !
!SueloDeConcreto methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:41' prior: 50682700 overrides: 50682704!
esConcreto
	^true! !
!SueloDeConcreto methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:46' prior: 50682717 overrides: 50682721!
esTierra
	^false! !
!SueloDeTierra methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:52' prior: 50682713 overrides: 50682721!
esTierra
	^true! !
!SueloDeTierra methodsFor: 'tipo' stamp: 'MS 9/24/2023 13:24:57' prior: 50682696 overrides: 50682704!
esConcreto
	^false! !
!CapaDeSuelo class methodsFor: 'instance creation' stamp: 'MS 9/24/2023 13:26:29' prior: 50681725!
arenoso

	^SueloArenoso new.! !
!CapaDeSuelo class methodsFor: 'instance creation' stamp: 'MS 9/24/2023 13:27:08' prior: 50681729!
concretoConResistencia: resistencia 

	^SueloDeConcreto conResistencia: resistencia ! !
!SueloDeConcreto class methodsFor: 'nil' stamp: 'MS 9/24/2023 13:28:13'!
conResistencia: unaResistencia
	^self new initializeConResistencia: unaResistencia! !
!SueloDeConcreto methodsFor: 'nil' stamp: 'MS 9/24/2023 13:28:33'!
initializeConResistencia: unaResistencia
	resistencia := unaResistencia.! !
!CapaDeSuelo class methodsFor: 'instance creation' stamp: 'MS 9/24/2023 13:29:10' prior: 50681735!
tierra

	^SueloDeTierra new.! !

!methodRemoval: CapaDeSuelo #initializeArenoso stamp: 'MS 9/24/2023 13:29:33'!
initializeArenoso
	
	tipo := #Arenoso.
	altura := nil.!

!methodRemoval: CapaDeSuelo #initializeConcretoConResistencia: stamp: 'MS 9/24/2023 13:29:36'!
initializeConcretoConResistencia: resistenciaInicial 

	resistencia := resistenciaInicial.
	tipo := #Concreto.
	altura := nil.!

!methodRemoval: CapaDeSuelo #initializeTierra stamp: 'MS 9/24/2023 13:29:39'!
initializeTierra
	
	tipo := #Tierra.
	altura := nil.!
!SueloArenoso methodsFor: 'scan' stamp: 'MS 9/24/2023 13:30:24' overrides: 50681707!
scan

	self esArenoso ifTrue: [ ^ 7 ].
	self esTierra ifTrue: [ ^ 10 ].
	^ 50. ! !
!SueloDeTierra methodsFor: 'scan' stamp: 'MS 9/24/2023 13:30:24' overrides: 50681707!
scan

	self esArenoso ifTrue: [ ^ 7 ].
	self esTierra ifTrue: [ ^ 10 ].
	^ 50. ! !
!SueloDeConcreto methodsFor: 'scan' stamp: 'MS 9/24/2023 13:30:24' overrides: 50681707!
scan

	self esArenoso ifTrue: [ ^ 7 ].
	self esTierra ifTrue: [ ^ 10 ].
	^ 50. ! !
!CapaDeSuelo methodsFor: 'scan' stamp: 'MS 9/24/2023 13:30:24' prior: 50681707!
scan

	self subclassResponsibility! !
!SueloArenoso methodsFor: 'scan' stamp: 'MS 9/24/2023 13:30:34' prior: 50682792 overrides: 50682810!
scan

	^ 7! !
!SueloDeConcreto methodsFor: 'scan' stamp: 'MS 9/24/2023 13:30:42' prior: 50682804 overrides: 50682810!
scan

	^ 50. ! !
!SueloDeTierra methodsFor: 'scan' stamp: 'MS 9/24/2023 13:30:51' prior: 50682798 overrides: 50682810!
scan

	^10 ! !
!Perforadora methodsFor: 'excavation' stamp: 'MS 9/24/2023 14:34:04' prior: 50682188!
darGolpeDeTaladro
	
	"	
	self sinMecha ifTrue: [self error: 'No puede perforar'].

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.

	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaWidia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaDiamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self ].
		mechaPuesta = #MechaWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #MechaDiamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi'  ].
		mechaPuesta = #MechaWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
			^self ].
		mechaPuesta = #MechaDiamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'MS 9/24/2023 14:35:07' prior: 50682827!
darGolpeDeTaladro
	(capasDeSueloDebajo  first) taladrar: self
	
	"	
	self sinMecha ifTrue: [self error: 'No puede perforar'].

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.

	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaWidia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaDiamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self ].
		mechaPuesta = #MechaWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #MechaDiamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi'  ].
		mechaPuesta = #MechaWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
			^self ].
		mechaPuesta = #MechaDiamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!CapaDeSuelo methodsFor: 'nil' stamp: 'MS 9/24/2023 14:36:05'!
taladrar: unaPerforadora! !
!SueloArenoso methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:36:19' overrides: 50682912!
taladrar: unaPerforadora! !
!SueloDeTierra methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:36:19' overrides: 50682912!
taladrar: unaPerforadora! !
!SueloDeConcreto methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:36:19' overrides: 50682912!
taladrar: unaPerforadora! !
!CapaDeSuelo methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:36:19' prior: 50682912!
taladrar: unaPerforadora

	self subclassResponsibility! !
!SueloArenoso methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:36:49' prior: 50682916 overrides: 50682930!
taladrar: unaPerforadora
	^unaPerforadora taladrarSueloArenoso.! !
!SueloDeConcreto methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:37:07' prior: 50682926 overrides: 50682930!
taladrar: unaPerforadora
	^unaPerforadora  taladrarSueloDeConcreto.! !
!SueloDeTierra methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:37:22' prior: 50682921 overrides: 50682930!
taladrar: unaPerforadora
	^unaPerforadora taladrarSueloDeTierra.! !
!Perforadora methodsFor: 'nil' stamp: 'MS 9/24/2023 14:37:58'!
taladrarSueloDeTierra: sueloDeTierra! !
!SueloArenoso methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:38:24' prior: 50682936 overrides: 50682930!
taladrar: unaPerforadora
	^unaPerforadora taladrarSueloArenoso: self.! !
!SueloDeConcreto methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:38:37' prior: 50682942 overrides: 50682930!
taladrar: unaPerforadora
	^unaPerforadora  taladrarSueloDeConcreto: self.! !
!SueloDeTierra methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:38:43' prior: 50682948 overrides: 50682930!
taladrar: unaPerforadora
	^unaPerforadora taladrarSueloDeTierra: self.! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:39:06'!
taladrarSueloArenoso: sueloDeTierra! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:39:17'!
taladrarSueloDeConcreto: sueloDeTierra! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:39:24' prior: 50682976!
taladrarSueloArenoso: sueloDeArena! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:39:32' prior: 50682980!
taladrarSueloDeConcreto: sueloDeConcreto! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:39:38' prior: 50682985!
taladrarSueloArenoso: sueloArenoso! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:45:39' prior: 50682995!
taladrarSueloArenoso: sueloArenoso
	mechaPuesta taladrarSueloArenoso! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:48:06' prior: 50683000!
taladrarSueloArenoso: sueloArenoso
	mechaPuesta taladrarSueloArenoso: self.! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:48:22' prior: 50682990!
taladrarSueloDeConcreto: sueloDeConcreto
	mechaPuesta taladrarSueloDeConcreto: self.! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:48:24' prior: 50683012!
taladrarSueloDeConcreto: sueloDeConcreto
	^mechaPuesta taladrarSueloDeConcreto: self.! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:48:29' prior: 50683006!
taladrarSueloArenoso: sueloArenoso
	^mechaPuesta taladrarSueloArenoso: self.! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:48:43' prior: 50682953!
taladrarSueloDeTierra: sueloDeTierra
	^mechaPuesta taladrarSueloDeTierra: self.! !
!Mecha methodsFor: 'nil' stamp: 'MS 9/24/2023 14:49:15'!
taladrarSueloArenoso: unaPerforadora! !
!Mecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:21'!
taladrarSueloDeTierra: unaPerforadora! !
!Mecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:27'!
taladrarSueloDeConcreto: unaPerforadora! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:35' overrides: 50683035!
taladrarSueloArenoso: unaPerforadora! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:35' overrides: 50683035!
taladrarSueloArenoso: unaPerforadora! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:35' overrides: 50683035!
taladrarSueloArenoso: unaPerforadora! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:35' overrides: 50683035!
taladrarSueloArenoso: unaPerforadora! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:35' overrides: 50683035!
taladrarSueloArenoso: unaPerforadora! !
!Mecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:35' prior: 50683035!
taladrarSueloArenoso: unaPerforadora

	self subclassResponsibility! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:39' overrides: 50683043!
taladrarSueloDeConcreto: unaPerforadora! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:39' overrides: 50683043!
taladrarSueloDeConcreto: unaPerforadora! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:39' overrides: 50683043!
taladrarSueloDeConcreto: unaPerforadora! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:39' overrides: 50683043!
taladrarSueloDeConcreto: unaPerforadora! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:39' overrides: 50683043!
taladrarSueloDeConcreto: unaPerforadora! !
!Mecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:39' prior: 50683043!
taladrarSueloDeConcreto: unaPerforadora

	self subclassResponsibility! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:43' overrides: 50683039!
taladrarSueloDeTierra: unaPerforadora! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:43' overrides: 50683039!
taladrarSueloDeTierra: unaPerforadora! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:43' overrides: 50683039!
taladrarSueloDeTierra: unaPerforadora! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:43' overrides: 50683039!
taladrarSueloDeTierra: unaPerforadora! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:43' overrides: 50683039!
taladrarSueloDeTierra: unaPerforadora! !
!Mecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:49:43' prior: 50683039!
taladrarSueloDeTierra: unaPerforadora

	self subclassResponsibility! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:50:22' prior: 50683058 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	^unaPerforadora pasarAProximaCapa! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:50:53' prior: 50683120 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora
	^unaPerforadora! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:52:57' prior: 50683141 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	^unaPerforadora taladrarSueloArenosoConMechasoft.! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:53:19' prior: 50683089 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora
	^unaPerforadora taladrarSueloDeConcretoConMechaSoft.! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:53:27' prior: 50683153 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	^unaPerforadora taladrarSueloArenosoConMechaSoft.! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:53:43' prior: 50683147 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora
	^unaPerforadora taladrarSueloDeTierraConMechaSoft.! !
!Perforadora methodsFor: 'nil' stamp: 'MS 9/24/2023 14:54:05'!
taladrarSueloDeTierraConMechaSoft! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:54:13'!
taladrarSueloArenosoConMechaSoft! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:54:23'!
taladrarSueloDeConcretoConMechaSoft! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:55:02'!
taladrarSueloArenosoConMechaDiamante! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:55:06'!
taladrarSueloArenosoConMechaWidia! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:55:14'!
taladrarSueloDeConcretoConMechaDiamante! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:55:18' prior: 50683187!
taladrarSueloDeConcretoConMechaSoft! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:55:20'!
taladrarSueloDeConcretoConMechaWidia! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:55:29'!
taladrarSueloDeTierraConMechaDiamante! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:55:33'!
taladrarSueloDeTierraConMechaWidia! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:56:02' prior: 50683183!
taladrarSueloArenosoConMechaSoft
	^self pasarAProximaCapa! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:56:30' prior: 50683179!
taladrarSueloDeTierraConMechaSoft
	^self! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:57:59' prior: 50683204!
taladrarSueloDeConcretoConMechaSoft
	 mechaPuesta := MechaRota new.
	 self error: 'Se rompi'! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:58:02' prior: 50683231!
taladrarSueloDeConcretoConMechaSoft
	 mechaPuesta := MechaRota new.
	 self error: 'Se rompi'.! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:58:38' prior: 50683195!
taladrarSueloArenosoConMechaWidia
	^self pasarAProximaCapa! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 14:59:22' prior: 50683216!
taladrarSueloDeTierraConMechaWidia
	vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
	^self ! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:00:16' prior: 50683208!
taladrarSueloDeConcretoConMechaWidia
	vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
	^self ! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:01:58' prior: 50683191!
taladrarSueloArenosoConMechaDiamante
	 mechaPuesta := MechaRota new.
	 self error: 'Se rompi'.! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:02:49' prior: 50683212!
taladrarSueloDeTierraConMechaDiamante
	^self pasarAProximaCapa! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:04:04' prior: 50683199!
taladrarSueloDeConcretoConMechaDiamante
	vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
	capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
	^vecesQueGolpeoCapaActual! !
!Perforadora methodsFor: 'excavation' stamp: 'MS 9/24/2023 15:04:25' prior: 50682869!
darGolpeDeTaladro
	^(capasDeSueloDebajo  first) taladrar: self.
	
	"	
	self sinMecha ifTrue: [self error: 'No puede perforar'].

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.

	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaWidia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaDiamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self ].
		mechaPuesta = #MechaWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #MechaDiamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi'  ].
		mechaPuesta = #MechaWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
			^self ].
		mechaPuesta = #MechaDiamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'MS 9/24/2023 15:04:51' prior: 50683289!
darGolpeDeTaladro
	^(capasDeSueloDebajo  first) taladrar: self.
	
	
	"	
	self sinMecha ifTrue: [self error: 'No puede perforar'].

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.

	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaWidia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #MechaDiamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ ^self ].
		mechaPuesta = #MechaWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #MechaDiamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #MechaSoft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi'  ].
		mechaPuesta = #MechaWidia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
			^self ].
		mechaPuesta = #MechaDiamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:05:27' prior: 50683063 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	^ self error: 'No puede taladrar'! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:05:36' prior: 50683094 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora
	^ self error: 'No puede taladrar'! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:05:39' prior: 50683125 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora
	^ self error: 'No puede taladrar'! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:05:49' prior: 50683068 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	^ self error: 'No puede taladrar'! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:05:59' prior: 50683394 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	^ self error: 'No hay una mecha puesta!!'! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:06:14' prior: 50683400 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	^ self error: 'No hay una mecha puesta!!'
	! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:06:18' prior: 50683099 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora
	^ self error: 'No hay una mecha puesta!!'! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:06:22' prior: 50683130 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora
	^ self error: 'No hay una mecha puesta!!'! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 15:06:30'!
FAILURE!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 15:06:30'!
FAILURE!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 15:06:30'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 15:06:30'!
FAILURE!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 15:06:30'!
FAILURE!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:06:30'!
FAILURE!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 15:06:30'!
FAILURE!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 15:06:30'!
FAILURE!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 15:06:30'!
FAILURE!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 15:06:30'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 15:06:30'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:06:30'!
FAILURE!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 15:06:30'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 15:06:30'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 15:06:30'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 15:06:30'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 15:06:30'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 15:06:30'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 15:06:30'!
PASSED!

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 15:07:09'!
FAILURE!
!Perforadora methodsFor: 'initialization' stamp: 'MS 9/24/2023 15:08:04' prior: 50682525!
initializeSobreSuelo: capasDeSueloAExcavarInicialmente

	capasDeSueloDebajo := capasDeSueloAExcavarInicialmente.
	vecesQueGolpeoCapaActual := 0.
	container := OrderedCollection new.
	mechaPuesta := Mecha deTipo: #sinMecha.! !
!CapaDeSuelo methodsFor: 'comparing' stamp: 'MS 9/24/2023 15:15:26' prior: 50681676 overrides: 16901772!
= unaCapaDeSuelo

	^(unaCapaDeSuelo isKindOf: self class) and: [resistencia = unaCapaDeSuelo resistencia]! !

Object subclass: #CapaDeSuelo
	instanceVariableNames: 'resistencia altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #CapaDeSuelo category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 15:15:34'!
Object subclass: #CapaDeSuelo
	instanceVariableNames: 'resistencia altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 15:15:54'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 15:15:54'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 15:15:54'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 15:15:54'!
FAILURE!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 15:15:54'!
FAILURE!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:15:54'!
FAILURE!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 15:15:54'!
FAILURE!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 15:15:54'!
FAILURE!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 15:15:54'!
FAILURE!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 15:15:54'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 15:15:54'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:15:54'!
FAILURE!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 15:15:54'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 15:15:54'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 15:15:54'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 15:15:54'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 15:15:54'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 15:15:54'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 15:15:54'!
PASSED!
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:18:11' prior: 50683265!
taladrarSueloArenosoConMechaDiamante
	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	 mechaPuesta := MechaRota new.
	 self error: 'Se rompi'.! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:18:14' prior: 50683614!
taladrarSueloArenosoConMechaDiamante
	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	mechaPuesta := MechaRota new.
	self error: 'Se rompi'.! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:18:19' prior: 50683221!
taladrarSueloArenosoConMechaSoft
	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	^self pasarAProximaCapa! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:18:26' prior: 50683245!
taladrarSueloArenosoConMechaWidia
	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	^self pasarAProximaCapa! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:18:30' prior: 50683278!
taladrarSueloDeConcretoConMechaDiamante
	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
	capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
	^vecesQueGolpeoCapaActual! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:18:36' prior: 50683238!
taladrarSueloDeConcretoConMechaSoft
	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	 mechaPuesta := MechaRota new.
	 self error: 'Se rompi'.! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:18:40' prior: 50683257!
taladrarSueloDeConcretoConMechaWidia
	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompi' ].
	^self ! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:18:44' prior: 50683272!
taladrarSueloDeTierraConMechaDiamante
	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	^self pasarAProximaCapa! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:18:48' prior: 50683226!
taladrarSueloDeTierraConMechaSoft
	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	^self! !
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:18:52' prior: 50683250!
taladrarSueloDeTierraConMechaWidia
	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
	^self ! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 15:18:55'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 15:18:55'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 15:18:55'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 15:18:55'!
FAILURE!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 15:18:55'!
FAILURE!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:18:55'!
FAILURE!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 15:18:55'!
FAILURE!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 15:18:55'!
FAILURE!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 15:18:55'!
FAILURE!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 15:18:55'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 15:18:55'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:18:55'!
FAILURE!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 15:18:55'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 15:18:55'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 15:18:55'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 15:18:55'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 15:18:55'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 15:18:56'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 15:18:56'!
PASSED!
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:19:31' prior: 50683048 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	^unaPerforadora taladrarSueloArenosoConMechaWidia .! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:19:33' prior: 50683774 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	^unaPerforadora taladrarSueloArenosoConMechaWidia.! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:19:44' prior: 50683079 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora
	^unaPerforadora  taladrarSueloDeConcretoConMechaWidia.! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:19:55' prior: 50683110 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora
	^unaPerforadora  taladrarSueloDeTierraConMechaWidia.! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:20:31' prior: 50683084 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora
	^unaPerforadora taladrarSueloDeConcretoConMechaDiamante.! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:20:57' prior: 50683115 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora
	^unaPerforadora taladrarSueloDeTierraConMechaDiamante.! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:21:11' prior: 50683053 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	^unaPerforadora taladrarSueloArenosoConMechaDiamante.! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:21:13'!
ERROR!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:21:13'!
FAILURE!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 15:21:13'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 15:21:27'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 15:21:29'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 15:21:32'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 15:21:34'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 15:21:36'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 15:21:39'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 15:21:41'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 15:21:43'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 15:21:45'!
PASSED!

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:21:47'!
ERROR!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:21:47'!
FAILURE!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 15:21:47'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:22:03'!
ERROR!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:22:03'!
ERROR!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:22:36'!
ERROR!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:22:36'!
ERROR!

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:33:29'!
ERROR!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:33:29'!
FAILURE!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 15:33:29'!
PASSED!

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:33:59'!
ERROR!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:33:59'!
FAILURE!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 15:33:59'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:36:09'!
ERROR!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:36:46'!
ERROR!
!Perforadora methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:37:52' prior: 50683665!
taladrarSueloDeConcretoConMechaWidia
	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := MechaRota new. self error: 'Se rompi' ].
	^self ! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:37:58'!
FAILURE!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 15:37:58'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:37:58'!
FAILURE!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:38:12'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 15:38:14'!
PASSED!

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 15:38:20'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 15:38:20'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 15:38:20'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 15:38:20'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 15:38:20'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:38:20'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 15:38:20'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 15:38:20'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 15:38:20'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 15:38:20'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 15:38:20'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:38:20'!
FAILURE!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 15:38:21'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 15:38:21'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 15:38:21'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 15:38:21'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 15:38:21'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 15:38:21'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 15:38:21'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:38:21'!
FAILURE!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:38:27'!
FAILURE!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:38:27'!
FAILURE!
!SinMecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:38:55' prior: 50683407 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	^ self error: 'No puede perforar'
	! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:39:02' prior: 50683414 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora
	^ self error: 'No puede perforar'! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:39:09' prior: 50683421 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora
	^ self error: 'No puede perforar'! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 15:39:11'!
PASSED!

Object subclass: #Perforadora
	instanceVariableNames: 'tipoDeSuelo mechaPuesta capasDeSueloDebajo container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Perforadora category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 15:39:31'!
Object subclass: #Perforadora
	instanceVariableNames: 'tipoDeSuelo mechaPuesta capasDeSueloDebajo container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Object subclass: #Mecha
	instanceVariableNames: 'usos'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Mecha category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 15:39:39'!
Object subclass: #Mecha
	instanceVariableNames: 'usos'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:39:57' prior: 50683816 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	usos := usos +1.
	^unaPerforadora taladrarSueloArenosoConMechaDiamante.! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:40:11' prior: 50683802 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora
	usos := usos + 1.
	^unaPerforadora taladrarSueloDeConcretoConMechaDiamante.! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:40:17' prior: 50683809 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora
	usos := usos + 1.
	^unaPerforadora taladrarSueloDeTierraConMechaDiamante.! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:40:23' prior: 50683376 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	usos := usos + 1.
	^ self error: 'No puede taladrar'! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:40:27' prior: 50683382 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora
	usos := usos + 1.
	^ self error: 'No puede taladrar'! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:40:32' prior: 50683388 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora
	usos := usos + 1.
	^ self error: 'No puede taladrar'! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:40:37' prior: 50683167 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	usos := usos + 1.
	^unaPerforadora taladrarSueloArenosoConMechaSoft.! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:40:55' prior: 50683160 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora
	usos := usos + 1.
	^unaPerforadora taladrarSueloDeConcretoConMechaSoft.! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:40:58' prior: 50683174 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora
	usos := usos + 1.
	^unaPerforadora taladrarSueloDeTierraConMechaSoft.! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:41:03' prior: 50683781 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora
	usos := usos + 1.
	^unaPerforadora taladrarSueloArenosoConMechaWidia.! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:41:06' prior: 50683788 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora
	usos := usos + 1.
	^unaPerforadora  taladrarSueloDeConcretoConMechaWidia.! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:41:09' prior: 50683795 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora
	usos := usos + 1.
	^unaPerforadora  taladrarSueloDeTierraConMechaWidia.! !

Object subclass: #Mecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Mecha category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 15:42:05'!
Object subclass: #Mecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:42:10' prior: 50684489 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora

	^unaPerforadora taladrarSueloArenosoConMechaDiamante.! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:42:13' prior: 50684497 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora

	^unaPerforadora taladrarSueloDeConcretoConMechaDiamante.! !
!MechaDiamante methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:42:16' prior: 50684505 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora

	^unaPerforadora taladrarSueloDeTierraConMechaDiamante.! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:42:20' prior: 50684513 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora

	^ self error: 'No puede taladrar'! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:42:23' prior: 50684520 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora

	^ self error: 'No puede taladrar'! !
!MechaRota methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:42:26' prior: 50684527 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora

	^ self error: 'No puede taladrar'! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:42:30' prior: 50684541 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora

	^unaPerforadora taladrarSueloDeConcretoConMechaSoft.! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:42:33' prior: 50684549 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora
	^unaPerforadora taladrarSueloDeTierraConMechaSoft.! !
!MechaSoft methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:42:37' prior: 50684534 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora

	^unaPerforadora taladrarSueloArenosoConMechaSoft.! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:42:41' prior: 50684565 overrides: 50683104!
taladrarSueloDeConcreto: unaPerforadora

	^unaPerforadora  taladrarSueloDeConcretoConMechaWidia.! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:42:44' prior: 50684573 overrides: 50683135!
taladrarSueloDeTierra: unaPerforadora

	^unaPerforadora  taladrarSueloDeTierraConMechaWidia.! !
!MechaWidia methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 15:42:48' prior: 50684557 overrides: 50683073!
taladrarSueloArenoso: unaPerforadora

	^unaPerforadora taladrarSueloArenosoConMechaWidia.! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 15:42:54'!
PASSED!

Object subclass: #Perforadora
	instanceVariableNames: 'vecesQueGolpeoCapaActual tipoDeSuelo mechaPuesta capasDeSueloDebajo container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Perforadora category: 'ISW1-2023-1C-Parcial-1' stamp: 'MS 9/24/2023 15:44:01'!
Object subclass: #Perforadora
	instanceVariableNames: 'vecesQueGolpeoCapaActual tipoDeSuelo mechaPuesta capasDeSueloDebajo container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 16:04:01'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 16:04:01'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'MS 9/24/2023 16:04:47' prior: 50681866!
calcularProfundidadDelSuelo
	
	"| acc ix |

	acc := 0.
	ix := 1.
	
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	].

	^ acc."
	
	 ! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:04:50'!
FAILURE!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 16:04:50'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:04:50'!
FAILURE!
!CapaDeSuelo methodsFor: 'initialization' stamp: 'MS 9/24/2023 16:07:29' overrides: 16920235!
initialize
	altura := 0.! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:07:35'!
FAILURE!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 16:07:35'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:07:35'!
FAILURE!
!Perforadora methodsFor: 'scan' stamp: 'MS 9/24/2023 16:07:51' prior: 50684840!
calcularProfundidadDelSuelo
	
	
	| acc ix |

	acc := 0.
	ix := 1.
	
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	].

	^ acc.
	
	 ! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 16:07:58'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 16:07:58'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'MS 9/24/2023 16:09:00' prior: 50685015!
calcularProfundidadDelSuelo
	
	^ capasDeSueloDebajo inject: 0  into: [:capa :altura | capa altura + altura].
	"| acc ix |

	acc := 0.
	ix := 1.
	
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	].

	^ acc."
	
	 ! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:09:04'!
ERROR!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 16:09:04'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:09:04'!
ERROR!
!Perforadora methodsFor: 'scan' stamp: 'MS 9/24/2023 16:09:21' prior: 50685103!
calcularProfundidadDelSuelo
	
	^ capasDeSueloDebajo inject: 0  into: [:altura :capa | capa altura + altura].
	"| acc ix |

	acc := 0.
	ix := 1.
	
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	].

	^ acc."
	
	 ! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 16:09:24'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 16:09:24'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'MS 9/24/2023 16:09:33' prior: 50685197!
calcularProfundidadDelSuelo
	
	^ capasDeSueloDebajo inject: 0  into: [:altura :capa | capa altura + altura].

	
	 ! !
!Perforadora methodsFor: 'scan' stamp: 'MS 9/24/2023 16:16:14' prior: 50681878!
calcularProfundidadDelSueloHasta: tipoDeCapa
	^ capasDeSueloDebajo inject: 0 into: [:suma :capa | (capa scan = tipoDeCapa scan) ifTrue: [ ^suma]. suma + capa scan.].
"	
	| valor acc ix |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	ix := 1.
	
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		
		valor = capa scan ifTrue: [ ^ acc ].
		
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	].

	^ acc."
	
	 ! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 16:16:17'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:16:17'!
ERROR!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 16:16:17'!
ERROR!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 16:16:17'!
ERROR!
!Perforadora methodsFor: 'scan' stamp: 'MS 9/24/2023 16:17:02' prior: 50685294!
calcularProfundidadDelSueloHasta: tipoDeCapa
	^ capasDeSueloDebajo inject: 0 into: [:suma :capa | (capa scan = tipoDeCapa scan) ifTrue: [ ^suma]. suma + capa scan.].
"	
	| valor acc ix |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	ix := 1.
	
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		
		valor = capa scan ifTrue: [ ^ acc ].
		
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	].

	^ acc."
	
	 ! !
!Perforadora methodsFor: 'scan' stamp: 'MS 9/24/2023 16:20:32' prior: 50685392!
calcularProfundidadDelSueloHasta: tipoDeCapa
	^ capasDeSueloDebajo inject: 0 into: [:suma :capa | (capa scan = tipoDeCapa scan) ifTrue: [^suma.]. suma + capa scan.].
"	
	| valor acc ix |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	ix := 1.
	
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		
		valor = capa scan ifTrue: [ ^ acc ].
		
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	].

	^ acc."
	
	 ! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 16:20:37'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:20:37'!
ERROR!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 16:20:37'!
ERROR!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 16:20:37'!
ERROR!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:21:02'!
ERROR!
!Perforadora methodsFor: 'scan' stamp: 'MS 9/24/2023 16:24:37' prior: 50685415!
calcularProfundidadDelSueloHasta: tipoDeCapa

	| acc |
	acc := 0.
	capasDeSueloDebajo do: [:capa| (capa scan = tipoDeCapa scan) ifTrue: [^acc]. acc := acc + capa scan.].
	^acc
"	
	| valor acc ix |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	ix := 1.
	
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		
		valor = capa scan ifTrue: [ ^ acc ].
		
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	].

	^ acc."
	
	 ! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 16:24:39'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:24:39'!
ERROR!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 16:24:39'!
ERROR!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 16:24:39'!
ERROR!

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 16:24:53'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:24:53'!
ERROR!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 16:24:53'!
ERROR!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 16:24:53'!
ERROR!
!Perforadora methodsFor: 'scan' stamp: 'MS 9/24/2023 16:26:38' prior: 50685518!
calcularProfundidadDelSueloHasta: tipoDeCapa

	| acc value |
	acc := 0.

	capasDeSueloDebajo do: [:capa| (capa scan = tipoDeCapa scan) ifTrue: [^acc]. acc := acc + capa scan.].
	^acc
"	
	| valor acc ix |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	ix := 1.
	
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		
		valor = capa scan ifTrue: [ ^ acc ].
		
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	].

	^ acc."
	
	 ! !
!Perforadora methodsFor: 'scan' stamp: 'MS 9/24/2023 16:29:25' prior: 50685692!
calcularProfundidadDelSueloHasta: tipoDeCapa

	| acc |
	acc := 0.

	capasDeSueloDebajo do: [:capa| (capa tipo = tipoDeCapa) ifTrue: [^acc]. acc := acc + capa scan.].
	^acc
"	
	| valor acc ix |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	ix := 1.
	
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		
		valor = capa scan ifTrue: [ ^ acc ].
		
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	].

	^ acc."
	
	 ! !

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:29:42'!
PASSED!

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:29:46'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 16:29:46'!
FAILURE!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 16:29:46'!
FAILURE!
!Perforadora methodsFor: 'scan' stamp: 'MS 9/24/2023 16:30:24' prior: 50685716!
calcularProfundidadDelSueloHasta: tipoDeCapa

	| acc |
	acc := 0.
	capasDeSueloDebajo do: [:capa| (capa tipo = tipoDeCapa) ifTrue: [^acc]. acc := acc + capa altura.].
	^acc

	 ! !

!testRun: #TestDePerforacin #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test12NoPuedePerforarSinMecha stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test13PuedeCalcularProfundidadDelSuelo stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test14PuedeContarLasCapasDeTipoArenoso stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test15PuedeContarLasCapasDeTipoTierra stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test16PuedeContarLasCapasDeTipoConcreto stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 16:30:26'!
PASSED!

!testRun: #TestDePerforacin #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'MS 9/24/2023 16:30:26'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'MS 9/24/2023 16:35:22' prior: 50685819!
calcularProfundidadDelSueloHasta: tipoDeCapa

	| acc |
	acc := 0.
	capasDeSueloDebajo do: [:capa| (capa scan = tipoDeCapa scan) ifTrue: [^acc]. acc := acc + capa altura.].
	^acc

	 ! !
!TestDePerforacin methodsFor: 'test' stamp: 'MS 9/24/2023 16:35:59' prior: 50681591!
test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 0 equals: (excavadora calcularProfundidadDelSueloHasta: CapaDeSuelo arenoso ).

	! !

!testRun: #TestDePerforacin #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'MS 9/24/2023 16:36:02'!
PASSED!
!TestDePerforacin methodsFor: 'test' stamp: 'MS 9/24/2023 16:36:12' prior: 50681606!
test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 2 equals: (excavadora calcularProfundidadDelSueloHasta: CapaDeSuelo tierra).

	! !

!testRun: #TestDePerforacin #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'MS 9/24/2023 16:36:15'!
PASSED!
!TestDePerforacin methodsFor: 'test' stamp: 'MS 9/24/2023 16:36:44' prior: 50685932!
test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 2 equals: (excavadora calcularProfundidadDelSueloHasta: #Tierra).

	! !
!TestDePerforacin methodsFor: 'test' stamp: 'MS 9/24/2023 16:36:53' prior: 50685912!
test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 0 equals: (excavadora calcularProfundidadDelSueloHasta: #Arenoso).

	! !

----STARTUP---- (24 September 2023 17:49:40) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/linux64/linux64/ISW1-2023-1C-Parcial-1-Solucion.st----!

----End fileIn of /home/martin/Downloads/ISW1-2021-1C-1erParcial-11Parcial.st----!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 18:14:33'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 18:14:33'!
PASSED!
!Robot methodsFor: 'initialization' stamp: 'MS 9/24/2023 18:14:52' prior: 50682750!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.
	weapons  := OrderedCollection new.

	! !
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:14:59' prior: 50682769!
addWeapon: aWeapon

	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:15:00' prior: 50683073!
addWeapon: aWeapon
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:15:05' prior: 50682781!
includesWeapon: aWeapon 

	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:15:09' prior: 50682787!
includesWeaponOfType: aWeaponType

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:15:13' prior: 50682794!
removeWeapon: aWeapon 


	weapons remove: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:15:14' prior: 50683106!
removeWeapon: aWeapon 

	weapons remove: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:15:18' prior: 50682800!
totalSpeedImpact

	| total index |

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:15:23' prior: 50682813!
totalWeaponWeight

	| total index |

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:15:26' prior: 50682825!
weaponsCount

	^ weapons size 	! !
!Robot methodsFor: 'attacking' stamp: 'MS 9/24/2023 18:15:43' prior: 50682759!
attack: aVictim with: aWeapon

	(weapons includes: aWeapon) 
		ifTrue: [ aWeapon attack: aVictim by: self ]
		ifFalse: [ self signalCanNotAttackWithWeaponNotBelongingToRobot ]! !
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:16:55' prior: 50683128!
totalWeaponWeight

	^weapons inject: 0 into: [:suma :weapon | suma + weapon weight].! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 18:16:58'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 18:16:58'!
PASSED!
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:18:31' prior: 50683116!
totalSpeedImpact
	^weapons inject: 0 into: [:suma :weapon | (weapon weight > (10 * kilogram)) ifTrue: [suma + weapon weight.].]
"
	| total index |

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total."! !
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:18:33' prior: 50683222!
totalSpeedImpact
	^weapons inject: 0 into: [:suma :weapon | (weapon weight > (10 * kilogram)) ifTrue: [suma + weapon weight.].].
"
	| total index |

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total."! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 18:18:36'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 18:18:36'!
ERROR!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 18:18:36'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 18:18:36'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 18:18:36'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 18:18:36'!
ERROR!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 18:18:36'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 18:18:36'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 18:18:36'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 18:18:36'!
ERROR!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 18:18:36'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 18:18:36'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 18:18:36'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 18:18:36'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 18:18:36'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 18:18:36'!
ERROR!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 18:18:36'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 18:18:36'!
PASSED!
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:19:00' prior: 50683238!
totalSpeedImpact
	^weapons inject: 0 into: [:suma :weapon | (weapon weight > (10 * kilogram)) ifTrue: [suma + weapon speedImpact .].].
"
	| total index |

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total."! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 18:19:02'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 18:19:02'!
PASSED!
!Robot methodsFor: 'weapons' stamp: 'MS 9/24/2023 18:19:10' prior: 50683320!
totalSpeedImpact
	^weapons inject: 0 into: [:suma :weapon | (weapon weight > (10 * kilogram)) ifTrue: [suma + weapon speedImpact .].].
! !

Weapon subclass: #Aluminum3000
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

Weapon subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Aluminum3000 category: 'ISW1-2021-1C-1erParcial' stamp: 'MS 9/24/2023 18:20:16'!
Weapon subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'MS 9/24/2023 18:20:25'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'MS 9/24/2023 18:20:29'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'MS 9/24/2023 18:20:37'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Aluminum3000 stamp: 'MS 9/24/2023 18:20:50'!
Weapon subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 18:21:20' prior: 50682924!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	"type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]."! !
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 18:21:37' prior: 50683469!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 18:21:40'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 18:21:40'!
PASSED!
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 18:52:18' prior: 50683510!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		anAttacker attack: aVictim with: self.
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]! !
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 18:52:36' prior: 50683617!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]! !
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 18:52:37' prior: 50683659!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]! !
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 18:53:41' prior: 50683700!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim attackedBy: anAttacker with: self.
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]! !
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 18:55:42' prior: 50683741!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 18:55:45'!
PASSED!

Robot subclass: #Aluminum3000
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Aluminum3000 category: 'ISW1-2021-1C-1erParcial' stamp: 'MS 9/24/2023 18:56:17'!
Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TankRover category: 'ISW1-2021-1C-1erParcial' stamp: 'MS 9/24/2023 18:56:24'!
Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 18:59:21' prior: 50683783!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		" aVictim getAttackedWithClawBy: "
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]! !
!Robot methodsFor: 'nil' stamp: 'MS 9/24/2023 18:59:33'!
getAttackedWithClawBy: anAttacker! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 18:59:39' overrides: 50683960!
getAttackedWithClawBy: anAttacker! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 18:59:39' overrides: 50683960!
getAttackedWithClawBy: anAttacker! !
!Robot methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 18:59:39' prior: 50683960!
getAttackedWithClawBy: anAttacker

	self subclassResponsibility! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:00:42' prior: 50683965 overrides: 50683974!
getAttackedWithClawBy: anAttacker
	self life: self life - (25 * year).
	"usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self]."! !
!Claw methodsFor: 'type' stamp: 'MS 9/24/2023 19:05:59' overrides: 50682964!
type
	
	^type! !
!HSBlaster methodsFor: 'type' stamp: 'MS 9/24/2023 19:05:59' overrides: 50682964!
type
	
	^type! !
!TurboLaserCannon methodsFor: 'type' stamp: 'MS 9/24/2023 19:05:59' overrides: 50682964!
type
	
	^type! !
!Weapon methodsFor: 'type' stamp: 'MS 9/24/2023 19:05:59' prior: 50682964!
type

	self subclassResponsibility! !
!Claw methodsFor: 'type' stamp: 'MS 9/24/2023 19:06:09' prior: 50683987 overrides: 50683998!
type
	
	^#Claw! !
!HSBlaster methodsFor: 'type' stamp: 'MS 9/24/2023 19:06:15' prior: 50683991 overrides: 50683998!
type
	
	^#HSBlaster! !
!TurboLaserCannon methodsFor: 'type' stamp: 'MS 9/24/2023 19:06:26' prior: 50683995 overrides: 50683998!
type
	
	^#TurboLaserCannon! !

Object subclass: #Weapon
	instanceVariableNames: 'weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'MS 9/24/2023 19:06:34'!
Object subclass: #Weapon
	instanceVariableNames: 'weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:06:37'!
ERROR!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:06:37'!
ERROR!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:06:37'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:06:37'!
ERROR!
!Weapon methodsFor: 'initialization' stamp: 'MS 9/24/2023 19:08:05'!
initializeWithWeight: aWeight andSpeedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Weapon class methodsFor: 'instance creation' stamp: 'MS 9/24/2023 19:09:50' prior: 50682975!
ofType: aWeaponType

	aWeaponType = #Claw ifTrue: [ ^Claw
		initializeWithWeight: 10 * kilogram andSpeedImpact: 5 * kilometer / hour ].
	aWeaponType = #HSBlaster ifTrue: [ ^ HSBlaster 
		initializeWithWeight: 20 * kilogram andSpeedImpact: 10 * kilometer / hour ].
	aWeaponType = #TurboLaserCannon ifTrue: [^ self new 
		initializeType: aWeaponType weight: 40 * kilogram speedImpact: 15 * kilometer / hour ].

	self error: 'Invalid Weapon Type'! !
!Weapon class methodsFor: 'instance creation' stamp: 'MS 9/24/2023 19:10:12' prior: 50684102!
ofType: aWeaponType

	aWeaponType = #Claw ifTrue: [ ^Claw
		initializeWithWeight: 10 * kilogram andSpeedImpact: 5 * kilometer / hour ].
	aWeaponType = #HSBlaster ifTrue: [ ^ HSBlaster 
		initializeWithWeight: 20 * kilogram andSpeedImpact: 10 * kilometer / hour ].
	aWeaponType = #TurboLaserCannon ifTrue: [^ TurboLaserCannon
		initializeWithWeight: 40 * kilogram andSpeedImpact: 15 * kilometer / hour ].

	self error: 'Invalid Weapon Type'! !
!Claw class methodsFor: 'nil' stamp: 'MS 9/24/2023 19:10:59'!
initializeWithWeight: aWeight andSpeedImpact: aSpeedImpact
	^self new initializeWithWeight: aWeight andSpeedImpact: aSpeedImpact ! !
!HSBlaster class methodsFor: 'no messages' stamp: 'MS 9/24/2023 19:12:01'!
initializeWithWeight: aWeight andSpeedImpact: aSpeedImpact
	^self new initializeWithWeight: aWeight andSpeedImpact: aSpeedImpact ! !
!TurboLaserCannon class methodsFor: 'nil' stamp: 'MS 9/24/2023 19:12:08'!
initializeWithWeight: aWeight andSpeedImpact: aSpeedImpact
	^self new initializeWithWeight: aWeight andSpeedImpact: aSpeedImpact ! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:12:18'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:12:18'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:12:18'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:12:18'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:12:18'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:12:18'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:12:18'!
FAILURE!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:12:18'!
FAILURE!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:12:18'!
FAILURE!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:12:18'!
FAILURE!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:12:18'!
FAILURE!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:12:18'!
FAILURE!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:12:18'!
FAILURE!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:12:18'!
FAILURE!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:12:18'!
FAILURE!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:12:18'!
FAILURE!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:12:18'!
FAILURE!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:12:18'!
FAILURE!

Weapon ofType: #Claw!

Weapon ofType: #Claw!

Weapon ofType: #TurboLaserCannon!

Weapon ofType: #TurboLaserCannon!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:13:09'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:13:09'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:13:09'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:13:09'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:13:09'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:13:09'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:13:09'!
FAILURE!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:13:09'!
FAILURE!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:13:09'!
FAILURE!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:13:09'!
FAILURE!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:13:09'!
FAILURE!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:13:09'!
FAILURE!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:13:09'!
FAILURE!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:13:09'!
FAILURE!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:13:09'!
FAILURE!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:13:09'!
FAILURE!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:13:09'!
FAILURE!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:13:09'!
FAILURE!
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 19:14:30' prior: 50683919!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	self type = #Claw ifTrue: [
		" aVictim getAttackedWithClawBy: "
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	self type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	self type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:14:32'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:14:32'!
PASSED!
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 19:15:51' prior: 50684293!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	self type = #Claw ifTrue: [
		" aVictim getAttackedWithClaw: self By: anAttacker "
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	self type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	self type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:16:45'!
getAttackedWithClaw: aClaw By: anAttacker 
	self life: self life - (25 * year).
	aClaw = 2 ifTrue: [ anAttacker removeWeapon: aClaw].! !

!methodRemoval: Aluminum3000 #getAttackedWithClawBy: stamp: 'MS 9/24/2023 19:16:54'!
getAttackedWithClawBy: anAttacker
	self life: self life - (25 * year).
	"usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self]."!

!methodRemoval: TankRover #getAttackedWithClawBy: stamp: 'MS 9/24/2023 19:17:08'!
getAttackedWithClawBy: anAttacker!
!TankRover methodsFor: 'no messages' stamp: 'MS 9/24/2023 19:17:17'!
getAttackedWithClaw: aClaw By: anAttacker ! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:17:51' prior: 50684461!
getAttackedWithClaw: aClaw By: anAttacker 
	self life: self life - (5 * year).
	anAttacker removeWeapon: aClaw.! !
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 19:18:47' prior: 50684401!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	self type = #Claw ifTrue: [
		 aVictim getAttackedWithClaw: self By: anAttacker.
	].

	self type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	self type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:18:49'!
ERROR!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:18:49'!
ERROR!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:18:49'!
ERROR!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:18:49'!
ERROR!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:18:49'!
PASSED!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:19:15'!
ERROR!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:19:15'!
ERROR!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:19:15'!
ERROR!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:19:15'!
ERROR!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:19:15'!
PASSED!

Object subclass: #Robot
	instanceVariableNames: ' life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'MS 9/24/2023 19:21:31'!
Object subclass: #Robot
	instanceVariableNames: 'life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Robot methodsFor: 'initialization' stamp: 'MS 9/24/2023 19:21:51'!
initializeWithLife: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight


	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.
	weapons  := OrderedCollection new.

	! !
!Robot methodsFor: 'initialization' stamp: 'MS 9/24/2023 19:21:52' prior: 50684652!
initializeWithLife: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.
	weapons  := OrderedCollection new.

	! !

!methodRemoval: Robot #initializeType:life:speed:maxWeaponWeight: stamp: 'MS 9/24/2023 19:21:58'!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.
	weapons  := OrderedCollection new.

	!
!Robot class methodsFor: 'instance creation' stamp: 'MS 9/24/2023 19:24:39' prior: 50682882!
ofType: aRobotType

	aRobotType = #Aluminum3000 ifTrue: [ ^Aluminum3000 initializeWithLife:  100 * year 
		speed: 90 * kilometer / hour 
		maxWeaponWeight:50 * kilogram. ].
	aRobotType = #TankRover ifTrue: [ ^ TankRover initializeWithLife: 100 * year 
		speed:  40 * kilometer / hour
		maxWeaponWeight: 200 * kilogram.
		].

	self error: 'Invalid Robot Type'! !
!Aluminum3000 class methodsFor: 'nil' stamp: 'MS 9/24/2023 19:26:54'!
initializeWithLife:  years 		speed: speedNumber		maxWeaponWeight: weight
	^self new initializeWithLife: years speed: speedNumber maxWeaponWeight: weight.! !
!TankRover class methodsFor: 'nil' stamp: 'MS 9/24/2023 19:27:03'!
initializeWithLife:  years 		speed: speedNumber		maxWeaponWeight: weight
	^self new initializeWithLife: years speed: speedNumber maxWeaponWeight: weight.! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:27:21'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:27:21'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:27:21'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:27:21'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:27:21'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:27:21'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:27:21'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:27:21'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:27:21'!
FAILURE!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:27:21'!
FAILURE!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:27:21'!
FAILURE!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:27:21'!
FAILURE!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:27:21'!
FAILURE!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:27:21'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:27:21'!
FAILURE!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:27:21'!
FAILURE!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:27:21'!
FAILURE!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:27:21'!
FAILURE!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:27:38'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:27:38'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:27:38'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:27:38'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:27:38'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:27:38'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:27:38'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:27:38'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:27:38'!
FAILURE!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:27:38'!
FAILURE!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:27:38'!
FAILURE!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:27:38'!
FAILURE!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:27:38'!
FAILURE!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:27:38'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:27:38'!
FAILURE!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:27:38'!
FAILURE!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:27:38'!
FAILURE!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:27:38'!
FAILURE!
!Aluminum3000 methodsFor: 'type' stamp: 'MS 9/24/2023 19:28:08' overrides: 50682747!
type

	^ type	! !
!TankRover methodsFor: 'type' stamp: 'MS 9/24/2023 19:28:08' overrides: 50682747!
type

	^ type	! !
!Robot methodsFor: 'type' stamp: 'MS 9/24/2023 19:28:08' prior: 50682747!
type

	self subclassResponsibility! !
!Aluminum3000 methodsFor: 'type' stamp: 'MS 9/24/2023 19:28:20' prior: 50684843 overrides: 50684850!
type

	^ #Aluminum3000! !
!TankRover methodsFor: 'type' stamp: 'MS 9/24/2023 19:28:30' prior: 50684847 overrides: 50684850!
type

	^ #TankRover! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:28:34'!
FAILURE!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:28:34'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:28:34'!
FAILURE!
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:29:11' prior: 50684444!
getAttackedWithClaw: aClaw By: anAttacker 
	self life: self life - (25 * year).
	aClaw uses = 2 ifTrue: [ anAttacker removeWeapon: aClaw].! !
!Weapon methodsFor: 'nil' stamp: 'MS 9/24/2023 19:29:20'!
uses
	^usedTimes ! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:29:23'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:29:23'!
PASSED!
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 19:31:33' prior: 50684473!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	self type = #Claw ifTrue: [
		 aVictim getAttackedWithClaw: self By: anAttacker.
	].

	self type = #HSBlaster ifTrue: [
		"aVictim getAttackedWithHSBlaster: self By: anAttacker."
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	self type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]! !
!Robot methodsFor: 'nil' stamp: 'MS 9/24/2023 19:31:54'!
getAttackedWithHSBlaster: aHSBlaster By: anAttacker.! !
!Object methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:31:59'!
getAttackedWithHSBlaster: aHSBlaster By: anAttacker

	self subclassResponsibility! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:32:07' overrides: 50685045!
getAttackedWithHSBlaster: aHSBlaster By: anAttacker.! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:32:07' overrides: 50685045!
getAttackedWithHSBlaster: aHSBlaster By: anAttacker.! !
!Robot methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:32:07' prior: 50685045 overrides: 50685050!
getAttackedWithHSBlaster: aHSBlaster By: anAttacker

	self subclassResponsibility! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:33:36' prior: 50685056 overrides: 50685067!
getAttackedWithHSBlaster: aHSBlaster By: anAttacker.
	self life: self life - (5 * year).
	aHSBlaster uses ifTrue: [ 
		anAttacker removeWeapon: aHSBlaster.
		anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon)].! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:34:36' prior: 50685061 overrides: 50685067!
getAttackedWithHSBlaster: aHSBlaster By: anAttacker.
	self life: self life - (50 * year).
	self life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw)].! !
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 19:34:52' prior: 50685010!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	self type = #Claw ifTrue: [
		 aVictim getAttackedWithClaw: self By: anAttacker.
	].

	self type = #HSBlaster ifTrue: [
		aVictim getAttackedWithHSBlaster: self By: anAttacker.
	].

	self type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:34:57'!
ERROR!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:34:57'!
ERROR!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:34:57'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:34:57'!
PASSED!
!TankRover methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:35:32' prior: 50685085 overrides: 50685067!
getAttackedWithHSBlaster: aHSBlaster By: anAttacker.
	self life: self life - (50 * year).
	self life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw).].! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:35:34'!
ERROR!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:35:34'!
ERROR!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:35:34'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:35:34'!
PASSED!
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:35:55' prior: 50685074 overrides: 50685067!
getAttackedWithHSBlaster: aHSBlaster By: anAttacker.
	self life: self life - (5 * year).
	aHSBlaster uses = 5 ifTrue: [ 
		anAttacker removeWeapon: aHSBlaster.
		anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon)].! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:35:58'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:35:58'!
PASSED!
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 19:36:35' prior: 50685093!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	self type = #Claw ifTrue: [
		 aVictim getAttackedWithClaw: self By: anAttacker.
	].

	self type = #HSBlaster ifTrue: [
		aVictim getAttackedWithHSBlaster: self By: anAttacker.
	].

	self type = #TurboLaserCannon ifTrue: [
		"aVictim getAttackedWithTurboLaserCannon: self By: anAttacker."
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	]! !

!methodRemoval: Robot #getAttackedWithClawBy: stamp: 'MS 9/24/2023 19:37:11'!
getAttackedWithClawBy: anAttacker

	self subclassResponsibility!
!Robot methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:37:24'!
getAttackedWithClaw: aClaw By: anAttacker

	self subclassResponsibility! !
!Robot methodsFor: 'nil' stamp: 'MS 9/24/2023 19:37:58'!
getAttackedWithHTusboLaserCannon: aTurboLaserCannon By: anAttacker! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:38:03' overrides: 50685371!
getAttackedWithHTusboLaserCannon: aTurboLaserCannon By: anAttacker! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:38:03' overrides: 50685371!
getAttackedWithHTusboLaserCannon: aTurboLaserCannon By: anAttacker! !
!Robot methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:38:03' prior: 50685371!
getAttackedWithHTusboLaserCannon: aTurboLaserCannon By: anAttacker

	self subclassResponsibility! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:39:03' prior: 50685377 overrides: 50685388!
getAttackedWithHTusboLaserCannon: aTurboLaserCannon By: anAttacker
	self life: self life - (100 * year).
	aTurboLaserCannon uses = 10 ifTrue: [ anAttacker removeWeapon: self.].! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:40:13' prior: 50685383 overrides: 50685388!
getAttackedWithHTusboLaserCannon: aTurboLaserCannon By: anAttacker
	self life: self life - (100 * year).
	aTurboLaserCannon uses = 5 ifTrue: [ 
		anAttacker removeWeapon: aTurboLaserCannon.
		anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:40:23' prior: 50685395 overrides: 50685388!
getAttackedWithHTusboLaserCannon: aTurboLaserCannon By: anAttacker
	self life: self life - (100 * year).
	aTurboLaserCannon uses = 10 ifTrue: [ anAttacker removeWeapon: aTurboLaserCannon.].! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:40:25'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:40:25'!
PASSED!
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 19:40:57' prior: 50685336!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	self type = #Claw ifTrue: [
		 aVictim getAttackedWithClaw: self By: anAttacker.
	].

	self type = #HSBlaster ifTrue: [
		aVictim getAttackedWithHSBlaster: self By: anAttacker.
	].

	self type = #TurboLaserCannon ifTrue: [
		aVictim getAttackedWithTurboLaserCannon: self By: anAttacker.
	].
	! !
!Robot methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:41:18'!
getAttackedWithTurboLaserCannon: aTurboLaserCannon By: anAttacker

	self subclassResponsibility! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:41:18' overrides: 50685506!
getAttackedWithTurboLaserCannon: aTurboLaserCannon By: anAttacker
	self life: self life - (100 * year).
	aTurboLaserCannon uses = 10 ifTrue: [ anAttacker removeWeapon: aTurboLaserCannon.].! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:41:18' overrides: 50685506!
getAttackedWithTurboLaserCannon: aTurboLaserCannon By: anAttacker
	self life: self life - (100 * year).
	aTurboLaserCannon uses = 5 ifTrue: [ 
		anAttacker removeWeapon: aTurboLaserCannon.
		anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]! !

!methodRemoval: Robot #getAttackedWithHTusboLaserCannon:By: stamp: 'MS 9/24/2023 19:41:18'!
getAttackedWithHTusboLaserCannon: aTurboLaserCannon By: anAttacker

	self subclassResponsibility!

!methodRemoval: Aluminum3000 #getAttackedWithHTusboLaserCannon:By: stamp: 'MS 9/24/2023 19:41:18'!
getAttackedWithHTusboLaserCannon: aTurboLaserCannon By: anAttacker
	self life: self life - (100 * year).
	aTurboLaserCannon uses = 10 ifTrue: [ anAttacker removeWeapon: aTurboLaserCannon.].!

!methodRemoval: TankRover #getAttackedWithHTusboLaserCannon:By: stamp: 'MS 9/24/2023 19:41:18'!
getAttackedWithHTusboLaserCannon: aTurboLaserCannon By: anAttacker
	self life: self life - (100 * year).
	aTurboLaserCannon uses = 5 ifTrue: [ 
		anAttacker removeWeapon: aTurboLaserCannon.
		anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:41:28'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:41:28'!
PASSED!
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 19:42:43' prior: 50685492!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	"self usedToAttack: aVictim By: anAttacker."
	self type = #Claw ifTrue: [
		 aVictim getAttackedWithClaw: self By: anAttacker.
	].

	self type = #HSBlaster ifTrue: [
		aVictim getAttackedWithHSBlaster: self By: anAttacker.
	].

	self type = #TurboLaserCannon ifTrue: [
		aVictim getAttackedWithTurboLaserCannon: self By: anAttacker.
	].
	! !
!Weapon methodsFor: 'nil' stamp: 'MS 9/24/2023 19:43:42'!
usedToAttack: aVictim By: anAttacker! !
!Claw methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:43:46' overrides: 50685641!
usedToAttack: aVictim By: anAttacker! !
!HSBlaster methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:43:46' overrides: 50685641!
usedToAttack: aVictim By: anAttacker! !
!TurboLaserCannon methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:43:46' overrides: 50685641!
usedToAttack: aVictim By: anAttacker! !
!Weapon methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:43:46' prior: 50685641!
usedToAttack: aVictim By: anAttacker

	self subclassResponsibility! !
!Claw methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:44:09' prior: 50685646 overrides: 50685661!
usedToAttack: aVictim By: anAttacker
	aVictim getAttackedWithClaw: self  By: anAttacker.! !
!HSBlaster methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:44:58' prior: 50685651 overrides: 50685661!
usedToAttack: aVictim By: anAttacker
	aVictim getAttackedWithHSBlaster: self By: anAttacker.! !
!HSBlaster methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:45:08' prior: 50685674 overrides: 50685661!
usedToAttack: aVictim By: anAttacker
	^aVictim getAttackedWithHSBlaster: self By: anAttacker.! !
!Claw methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:45:16' prior: 50685667 overrides: 50685661!
usedToAttack: aVictim By: anAttacker
	^aVictim getAttackedWithClaw: self  By: anAttacker.! !
!TurboLaserCannon methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 19:45:33' prior: 50685656 overrides: 50685661!
usedToAttack: aVictim By: anAttacker
	^aVictim getAttackedWithTurboLaserCannon: self By: anAttacker! !
!Weapon methodsFor: 'attacking' stamp: 'MS 9/24/2023 19:45:49' prior: 50685626!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	self usedToAttack: aVictim By: anAttacker.
	
	! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:45:51'!
PASSED!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:46:51'!
PASSED!

!methodRemoval: Weapon #initializeType:weight:speedImpact: stamp: 'MS 9/24/2023 19:47:09'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:47:12'!
PASSED!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:49:56'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:49:56'!
PASSED!
!Robot class methodsFor: 'instance creation' stamp: 'MS 9/24/2023 19:53:29' prior: 50684681!
ofType: aRobotType

	aRobotType = #Aluminum3000 ifTrue: [ ^Aluminum3000 new initializeWithLife:  100 * year 
		speed: 90 * kilometer / hour 
		maxWeaponWeight:50 * kilogram. ].
	aRobotType = #TankRover ifTrue: [ ^ TankRover new initializeWithLife: 100 * year 
		speed:  40 * kilometer / hour
		maxWeaponWeight: 200 * kilogram.
		].

	self error: 'Invalid Robot Type'! !

!methodRemoval: Aluminum3000 class #initializeWithLife:speed:maxWeaponWeight: stamp: 'MS 9/24/2023 19:53:33'!
initializeWithLife:  years 		speed: speedNumber		maxWeaponWeight: weight
	^self new initializeWithLife: years speed: speedNumber maxWeaponWeight: weight.!

!methodRemoval: TankRover class #initializeWithLife:speed:maxWeaponWeight: stamp: 'MS 9/24/2023 19:53:37'!
initializeWithLife:  years 		speed: speedNumber		maxWeaponWeight: weight
	^self new initializeWithLife: years speed: speedNumber maxWeaponWeight: weight.!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 19:53:42'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 19:53:42'!
PASSED!
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'MS 9/24/2023 19:55:20'!
m

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (50 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'MS 9/24/2023 20:00:21'!
assertDamageTo: aVictim With: attackerWeapon By: attacker afterAttackIs: aDamageNumber

	attacker addWeapon: attackerWeapon.
	
	attacker attack: aVictim with: attackerWeapon.
	
	self assert: (100 * year) - (aDamageNumber * year) equals: aVictim life
	
	! !

!methodRemoval: RobotWarsTest #m stamp: 'MS 9/24/2023 20:00:27'!
m

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (50 * year) equals: attacked life
	
	!
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'MS 9/24/2023 20:01:40' prior: 50682494!
test07ClawReducesLifeOfAluminum3000By25
	
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	self assertDamageTo: attacked With: attackerWeapon  By: attacker  afterAttackIs: (25 * year).
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'MS 9/24/2023 20:01:54' prior: 50686092!
assertDamageTo: aVictim With: attackerWeapon By: attacker afterAttackIs: aDamageNumber

	attacker addWeapon: attackerWeapon.
	attacker attack: aVictim with: attackerWeapon.
	self assert: (100 * year) - (aDamageNumber * year) equals: aVictim life
	
	! !

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 20:02:36'!
FAILURE!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 20:02:36'!
FAILURE!
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'MS 9/24/2023 20:02:54' prior: 50686129!
assertDamageTo: aVictim With: attackerWeapon By: attacker afterAttackIs: aDamageNumber

	attacker addWeapon: attackerWeapon.
	attacker attack: aVictim with: attackerWeapon.
	self assert: (100 * year) - (aDamageNumber ) equals: aVictim life
	
	! !

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 20:02:57'!
PASSED!
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'MS 9/24/2023 20:03:11' prior: 50682508!
test08ClawReducesLifeOfTankRoverBy5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	self assertDamageTo: attacked With: attackerWeapon  By: attacker  afterAttackIs: (5 * year).
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'MS 9/24/2023 20:03:22' prior: 50682522!
test09HSBlasterReducesLifeOfAluminum3000By5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	self assertDamageTo: attacked With: attackerWeapon  By: attacker  afterAttackIs: (5 * year).
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'MS 9/24/2023 20:03:34' prior: 50682537!
test10HSBlasterReducesLifeOfTankRoverBy50

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster.
	self assertDamageTo: attacked With: attackerWeapon  By: attacker  afterAttackIs: (50 * year).
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'MS 9/24/2023 20:03:42' prior: 50682552!
test11TurboLaserCannonReducesLifeOfAluminum3000By100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	self assertDamageTo: attacked With: attackerWeapon  By: attacker  afterAttackIs: (100 * year).
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'MS 9/24/2023 20:03:54' prior: 50682567!
test12TurboLaserCannonReducesLifeOfTankRoverBy100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon.
	self assertDamageTo: attacked With: attackerWeapon  By: attacker  afterAttackIs: (100 * year).
	
	! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'MS 9/24/2023 20:03:58'!
PASSED!

----STARTUP---- (24 September 2023 20:24:21) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Downloads/ISW1-2021-1C-1erParcial-11Resolucion.st----!

----STARTUP---- (24 September 2023 21:00:44) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/linux64/linux64/ISW1-2023-1C-Parcial-1-Solucion.st----!

----End fileIn of /home/martin/Desktop/Inge1/linux64/linux64/ISW1-2023-1C-Parcial-1.st----!

----End fileIn of /home/martin/Desktop/ISW1-2022-1C-Parcial-1.st----!

----End fileIn of /home/martin/Downloads/ISW1-2020-2C-Parcial-Enunciado.st----!
!Backpack methodsFor: 'accessing' stamp: 'MS 9/24/2023 21:37:12' prior: 50685398!
totalWeight
	
	^container inject: 0 into: [:total :portableObject| total + portableObject weight.].
	"
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total."! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'MS 9/24/2023 21:37:14'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'MS 9/24/2023 21:37:14'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'MS 9/24/2023 21:38:29' prior: 50685386!
totalPoints
	^(container select: [:object | object doesItAddPoints]) sum: [:object | object points].
	"| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total."! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'MS 9/24/2023 21:38:31'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'MS 9/24/2023 21:38:31'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'MS 9/24/2023 21:38:32'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'MS 9/24/2023 21:38:32'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'MS 9/24/2023 21:38:32'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'MS 9/24/2023 21:38:32'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'MS 9/24/2023 21:38:32'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'MS 9/24/2023 21:38:32'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'MS 9/24/2023 21:38:32'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'MS 9/24/2023 21:38:32'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'MS 9/24/2023 21:38:32'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'MS 9/24/2023 21:38:32'!
ERROR!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'MS 9/24/2023 21:38:32'!
ERROR!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'MS 9/24/2023 21:38:32'!
ERROR!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'MS 9/24/2023 21:38:32'!
ERROR!
!Backpack methodsFor: 'accessing' stamp: 'MS 9/24/2023 21:43:20' prior: 50686046!
totalPoints
	^(container select: [:object | object doesItAddPoints]) inject: 0 into: [:total :object | total + object points].
	"| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total."! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'MS 9/24/2023 21:43:24'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'MS 9/24/2023 21:43:24'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'MS 9/24/2023 21:43:32' prior: 50685978!
totalWeight
	
	^container inject: 0 into: [:total :portableObject| total + portableObject weight.].
	! !
!Backpack methodsFor: 'accessing' stamp: 'MS 9/24/2023 21:43:36' prior: 50686115!
totalPoints
	^(container select: [:object | object doesItAddPoints]) inject: 0 into: [:total :object | total + object points].
	! !
!Backpack methodsFor: 'adding' stamp: 'MS 9/24/2023 21:44:48' prior: 50685424!
add: aPortableObject
	"aPortableObject addTo: self."
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!NoPointsPortableObject methodsFor: 'nil' stamp: 'MS 9/24/2023 21:45:42' overrides: 50685806!
addTo: aBackpack! !
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 21:45:43' prior: 50686214 overrides: 50685806!
addTo: aBackpack
	! !
!PointsPortableObject methodsFor: 'nil' stamp: 'MS 9/24/2023 21:45:52' overrides: 50685806!
addTo: aBackapack! !
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 21:46:44' prior: 50686219 overrides: 50685806!
addTo: aBackpack
	aBackpack assertWeightAdding: self tolerating: 0.
	aBackpack addToContainer: self.! !
!Backpack methodsFor: 'nil' stamp: 'MS 9/24/2023 21:47:13'!
addToContainer: anObject
	container add: anObject.! !
!PointsPortableObject methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 21:48:17' prior: 50686223 overrides: 50685806!
addTo: aBackpack
	aBackpack assertWeightAdding: self tolerating: 5.
	self assertPointsAdding: self.
	aBackpack addToContainer: self.! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'MS 9/24/2023 21:48:44'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'MS 9/24/2023 21:48:44'!
PASSED!
!Backpack methodsFor: 'adding' stamp: 'MS 9/24/2023 21:48:58' prior: 50686198!
add: aPortableObject
	aPortableObject addTo: self.
	! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'MS 9/24/2023 21:49:01'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'MS 9/24/2023 21:49:01'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'MS 9/24/2023 21:49:01'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'MS 9/24/2023 21:49:01'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'MS 9/24/2023 21:49:01'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'MS 9/24/2023 21:49:01'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'MS 9/24/2023 21:49:01'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'MS 9/24/2023 21:49:01'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'MS 9/24/2023 21:49:01'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'MS 9/24/2023 21:49:01'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'MS 9/24/2023 21:49:01'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'MS 9/24/2023 21:49:01'!
ERROR!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'MS 9/24/2023 21:49:01'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'MS 9/24/2023 21:49:01'!
ERROR!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'MS 9/24/2023 21:49:01'!
ERROR!
!PointsPortableObject methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 21:50:10' prior: 50686240 overrides: 50685806!
addTo: aBackpack
	aBackpack assertWeightAdding: self tolerating: 5.
	aBackpack assertPointsAdding: self.
	aBackpack addToContainer: self.! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'MS 9/24/2023 21:50:26'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'MS 9/24/2023 21:50:26'!
PASSED!
!Door methodsFor: 'testing' stamp: 'MS 9/24/2023 21:54:34' prior: 50685670!
isOpen

	^ state isOpen
! !
!Door methodsFor: 'playable character reactions' stamp: 'MS 9/24/2023 21:54:55' prior: 50685684 overrides: 50685637!
toBeClosedBy: aPlayableCharacter
	"state toBeClosedBy."
	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].! !

Door subclass: #ClosedState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #ClosedState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'MS 9/24/2023 21:55:23'!
Door subclass: #ClosedState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

Door subclass: #OpenedState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #OpenedState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'MS 9/24/2023 21:55:30'!
Door subclass: #OpenedState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

Door subclass: #KeyClosedState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #KeyClosedState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'MS 9/24/2023 21:55:53'!
Door subclass: #KeyClosedState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!ClosedState methodsFor: 'testing' stamp: 'MS 9/24/2023 21:55:59' overrides: 50686422!
isOpen

	^ state isOpen
! !
!OpenedState methodsFor: 'testing' stamp: 'MS 9/24/2023 21:55:59' overrides: 50686422!
isOpen

	^ state isOpen
! !
!KeyClosedState methodsFor: 'testing' stamp: 'MS 9/24/2023 21:55:59' overrides: 50686422!
isOpen

	^ state isOpen
! !
!Door methodsFor: 'testing' stamp: 'MS 9/24/2023 21:55:59' prior: 50686422!
isOpen

	self subclassResponsibility! !
!ClosedState methodsFor: 'testing' stamp: 'MS 9/24/2023 21:56:08' prior: 50686477 overrides: 50686489!
isOpen

	^ false
! !
!KeyClosedState methodsFor: 'testing' stamp: 'MS 9/24/2023 21:56:14' prior: 50686485 overrides: 50686489!
isOpen

	^ false
! !
!OpenedState methodsFor: 'testing' stamp: 'MS 9/24/2023 21:56:20' prior: 50686481 overrides: 50686489!
isOpen

	^ true
! !

DoorState subclass: #ClosedState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #ClosedState stamp: 'MS 9/24/2023 21:57:27'!
Door subclass: #ClosedState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #KeyClosedState stamp: 'MS 9/24/2023 21:57:39'!
Door subclass: #KeyClosedState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #OpenedState stamp: 'MS 9/24/2023 21:57:45'!
Door subclass: #OpenedState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

DoorState subclass: #Closed
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'MS 9/24/2023 21:58:17'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

DoorState subclass: #Closed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Closed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'MS 9/24/2023 21:58:53'!
DoorState subclass: #Closed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

DoorState subclass: #Opened
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Opened category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'MS 9/24/2023 21:58:57'!
DoorState subclass: #Opened
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

DoorState subclass: #KeyClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #KeyClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'MS 9/24/2023 21:59:03'!
DoorState subclass: #KeyClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Closed methodsFor: 'testing' stamp: 'MS 9/24/2023 21:59:11' overrides: 50685553!
isOpen

	self subclassResponsibility! !
!Opened methodsFor: 'testing' stamp: 'MS 9/24/2023 21:59:11' overrides: 50685553!
isOpen

	self subclassResponsibility! !
!KeyClosed methodsFor: 'testing' stamp: 'MS 9/24/2023 21:59:11' overrides: 50685553!
isOpen

	self subclassResponsibility! !
!DoorState methodsFor: 'testing' stamp: 'MS 9/24/2023 21:59:11' prior: 50685553!
isOpen

	self subclassResponsibility! !
!Closed methodsFor: 'testing' stamp: 'MS 9/24/2023 21:59:20' prior: 50686585 overrides: 50686597!
isOpen

	^false! !
!KeyClosed methodsFor: 'testing' stamp: 'MS 9/24/2023 21:59:28' prior: 50686593 overrides: 50686597!
isOpen

	^false! !
!Opened methodsFor: 'testing' stamp: 'MS 9/24/2023 21:59:34' prior: 50686589 overrides: 50686597!
isOpen

	^true.! !
!Door methodsFor: 'testing' stamp: 'MS 9/24/2023 22:00:01' prior: 50686489!
isOpen

	state isOpen! !
!Door methodsFor: 'testing' stamp: 'MS 9/24/2023 22:00:03' prior: 50686613!
isOpen

	state isOpen.! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 22:00:08'!
ERROR!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/24/2023 22:00:08'!
ERROR!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 22:00:08'!
ERROR!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/24/2023 22:00:08'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/24/2023 22:00:08'!
ERROR!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 22:00:08'!
ERROR!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/24/2023 22:00:08'!
ERROR!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/24/2023 22:00:08'!
ERROR!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/24/2023 22:00:08'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 22:00:08'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/24/2023 22:00:08'!
ERROR!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/24/2023 22:00:08'!
ERROR!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 22:00:45'!
ERROR!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/24/2023 22:00:45'!
ERROR!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 22:00:45'!
ERROR!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/24/2023 22:00:45'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/24/2023 22:00:45'!
ERROR!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 22:00:45'!
ERROR!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/24/2023 22:00:45'!
ERROR!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/24/2023 22:00:45'!
ERROR!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/24/2023 22:00:45'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 22:00:45'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/24/2023 22:00:45'!
ERROR!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/24/2023 22:00:45'!
ERROR!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 22:01:00'!
ERROR!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 22:01:18'!
ERROR!
!KeyClosed methodsFor: 'testing' stamp: 'MS 9/24/2023 22:01:42' prior: 50686606 overrides: 50686597!
isOpen

	^false.! !
!Closed methodsFor: 'testing' stamp: 'MS 9/24/2023 22:01:46' prior: 50686602 overrides: 50686597!
isOpen

	^false.! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 22:11:21'!
ERROR!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/24/2023 22:11:21'!
ERROR!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 22:11:21'!
ERROR!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/24/2023 22:11:21'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/24/2023 22:11:21'!
ERROR!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 22:11:21'!
ERROR!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/24/2023 22:11:21'!
ERROR!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/24/2023 22:11:21'!
ERROR!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/24/2023 22:11:21'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 22:11:21'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/24/2023 22:11:21'!
ERROR!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/24/2023 22:11:21'!
ERROR!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 23:19:15'!
ERROR!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/24/2023 23:19:15'!
ERROR!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:19:15'!
ERROR!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/24/2023 23:19:15'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/24/2023 23:19:15'!
ERROR!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:19:15'!
ERROR!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/24/2023 23:19:15'!
ERROR!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/24/2023 23:19:15'!
ERROR!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/24/2023 23:19:15'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 23:19:15'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/24/2023 23:19:15'!
ERROR!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/24/2023 23:19:15'!
ERROR!

!methodRemoval: Door #initializeWith: stamp: 'MS 9/24/2023 23:21:29'!
initializeWith: aDoorState

	state := aDoorState
!
!Door class methodsFor: 'instance creation' stamp: 'MS 9/24/2023 23:22:08' prior: 50685741!
closed

	| door |
	
	door := Door new.
	door initializeClosed.
	
	^ door.! !
!Door methodsFor: 'initialization' stamp: 'MS 9/24/2023 23:22:36'!
initializeClosed
	state := Closed new.! !
!Door methodsFor: 'initialization' stamp: 'MS 9/24/2023 23:22:43'!
initializeOpen
	state := Closed new.! !
!Door methodsFor: 'initialization' stamp: 'MS 9/24/2023 23:22:51' prior: 50686798!
initializeOpen
	state := Opened new.! !

!classDefinition: #KeyOpened category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'MS 9/24/2023 23:24:15'!
DoorState subclass: #KeyOpened
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door methodsFor: 'initialization' stamp: 'MS 9/24/2023 23:24:03'!
initializeOpen: aDoorState using: aKey

	state := KeyOpened new.
	key := aKey.
! !
!Door methodsFor: 'initialization' stamp: 'MS 9/24/2023 23:24:37'!
initializeClosed: aDoorState using: aKey

	state := aDoorState.
	key := aKey.
! !
!Door class methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:24:37' prior: 50685747!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeClosed: #KeyClosed using: aKey.
	
	^ door.! !

!methodRemoval: Door #initializeWith:using: stamp: 'MS 9/24/2023 23:24:37'!
initializeWith: aDoorState using: aKey

	state := aDoorState.
	key := aKey.
!
!Door methodsFor: 'initialization' stamp: 'MS 9/24/2023 23:24:46' prior: 50686819!
initializeClosed: aDoorState using: aKey

	state := KeyClosed new.
	key := aKey.
! !

DoorState subclass: #Open
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Open category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'MS 9/24/2023 23:24:59'!
DoorState subclass: #Open
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Open stamp: 'MS 9/24/2023 23:25:29'!
DoorState subclass: #Open
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!KeyOpened methodsFor: 'nil' stamp: 'MS 9/24/2023 23:25:43' overrides: 50686597!
isOpen
	^true.! !
!Door class methodsFor: 'instance creation' stamp: 'MS 9/24/2023 23:26:29' prior: 50685753!
opened

	| door |
	
	door := Door new.
	door initializeOpen.
	
	^ door.! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 23:26:50'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/24/2023 23:26:50'!
ERROR!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:26:50'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/24/2023 23:26:50'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/24/2023 23:26:50'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:26:50'!
FAILURE!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/24/2023 23:26:50'!
FAILURE!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/24/2023 23:26:50'!
FAILURE!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/24/2023 23:26:50'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 23:26:50'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/24/2023 23:26:50'!
ERROR!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/24/2023 23:26:50'!
FAILURE!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 23:27:31'!
FAILURE!

!classRenamed: #Opened as: #Open stamp: 'MS 9/24/2023 23:27:44'!
Smalltalk renameClassNamed: #Opened as: #Open!
!Door methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:27:44' prior: 50685708 overrides: 50685647!
toBeOpenedBy: aPlayableCharacter using: aKey

	(state == #Open) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ 
		(key == aKey) ifTrue: [ ^ state := #Open ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!Door methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:27:44' prior: 50686802!
initializeOpen
	state := Open new.! !
!Door methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:27:44' prior: 50685722 overrides: 50685653!
toBeUsedBy: aPlayableCharacter

	(state == #Open) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !
!Door methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:27:44' prior: 50685696 overrides: 50685642!
toBeOpenedBy: aPlayableCharacter

	(state == #Open) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Open ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!Door methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:27:44' prior: 50686427 overrides: 50685637!
toBeClosedBy: aPlayableCharacter
	"state toBeClosedBy."
	(state == #Open) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].! !

!classRenamed: #KeyOpened as: #KeyOpen stamp: 'MS 9/24/2023 23:28:04'!
Smalltalk renameClassNamed: #KeyOpened as: #KeyOpen!
!Door methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:28:04' prior: 50686814!
initializeOpen: aDoorState using: aKey

	state := KeyOpen new.
	key := aKey.
! !
!Door methodsFor: 'playable character reactions' stamp: 'MS 9/24/2023 23:28:50' prior: 50686946 overrides: 50685642!
toBeOpenedBy: aPlayableCharacter
	
	state open.
	"(state == #Open) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Open ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ]."! !
!Closed methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:29:06' overrides: 50685545!
open

	self subclassResponsibility! !
!Open methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:29:06' overrides: 50685545!
open

	self subclassResponsibility! !
!KeyClosed methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:29:06' overrides: 50685545!
open

	self subclassResponsibility! !
!KeyOpen methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:29:06' overrides: 50685545!
open

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:29:06' prior: 50685545!
open

	self subclassResponsibility! !
!Door methodsFor: 'playable character reactions' stamp: 'MS 9/24/2023 23:31:19' prior: 50686981 overrides: 50685642!
toBeOpenedBy: aPlayableCharacter
	
	state := state open.
	"(state == #Open) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Open ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ]."! !
!Open methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:31:35' prior: 50686996 overrides: 50687008!
open

	^Closed new.! !
!Open methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:31:59' prior: 50687025 overrides: 50687008!
open

	^self error: Door alreadyOpenedErrorDescription.! !
!Closed methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:32:11' prior: 50686992 overrides: 50687008!
open

	^Open new.! !
!KeyClosed methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:32:33' prior: 50687000 overrides: 50687008!
open

	^self error: Door closedWithKeyErrorDescription! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 23:32:36'!
ERROR!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/24/2023 23:32:36'!
ERROR!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:32:36'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/24/2023 23:32:36'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/24/2023 23:32:36'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:32:36'!
FAILURE!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/24/2023 23:32:36'!
ERROR!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/24/2023 23:32:36'!
FAILURE!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/24/2023 23:32:36'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 23:32:36'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/24/2023 23:32:36'!
ERROR!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/24/2023 23:32:36'!
FAILURE!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 23:34:04'!
ERROR!
!Door methodsFor: 'testing' stamp: 'MS 9/24/2023 23:35:12' prior: 50686617!
isOpen

	^state isOpen.! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 23:35:15'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/24/2023 23:35:15'!
FAILURE!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:35:15'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/24/2023 23:35:15'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/24/2023 23:35:15'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:35:15'!
FAILURE!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/24/2023 23:35:15'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/24/2023 23:35:15'!
FAILURE!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/24/2023 23:35:15'!
FAILURE!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 23:35:15'!
FAILURE!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/24/2023 23:35:15'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/24/2023 23:35:15'!
FAILURE!
!Door methodsFor: 'playable character reactions' stamp: 'MS 9/24/2023 23:35:46' prior: 50686958 overrides: 50685637!
toBeClosedBy: aPlayableCharacter
	state := state close.
	(state == #Open) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'MS 9/24/2023 23:35:53' prior: 50687127 overrides: 50685637!
toBeClosedBy: aPlayableCharacter
	state := state close.
	"
	(state == #Open) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	"! !
!Closed methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:36:02' overrides: 50685541!
close

	self subclassResponsibility! !
!Open methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:36:02' overrides: 50685541!
close

	self subclassResponsibility! !
!KeyClosed methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:36:02' overrides: 50685541!
close

	self subclassResponsibility! !
!KeyOpen methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:36:02' overrides: 50685541!
close

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:36:02' prior: 50685541!
close

	self subclassResponsibility! !
!Open methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:36:24' prior: 50687156 overrides: 50687169!
close

	^Closed new.! !
!Closed methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:37:08' prior: 50687152 overrides: 50687169!
close

	^self error: Door alreadyClosedErrorDescription! !
!KeyClosed methodsFor: 'door actions' stamp: 'MS 9/24/2023 23:37:30' prior: 50687161 overrides: 50687169!
close

	^self error: Door alreadyClosedErrorDescription ! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 23:37:32'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/24/2023 23:37:32'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:37:32'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/24/2023 23:37:32'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/24/2023 23:37:32'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:37:32'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/24/2023 23:37:32'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/24/2023 23:37:32'!
FAILURE!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/24/2023 23:37:32'!
FAILURE!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 23:37:32'!
FAILURE!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/24/2023 23:37:32'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/24/2023 23:37:32'!
FAILURE!
!Door methodsFor: 'playable character reactions' stamp: 'MS 9/24/2023 23:38:42' prior: 50686915 overrides: 50685647!
toBeOpenedBy: aPlayableCharacter using: aKey

	state := state openWith: aKey.
	"
	(state == #Open) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ 
		(key == aKey) ifTrue: [ ^ state := #Open ].
		self error: Door notCorrectKeyErrorDescription. 
	]
	"! !
!DoorState methodsFor: 'nil' stamp: 'MS 9/24/2023 23:38:55'!
openWith: aKey! !
!Closed methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:39:02' overrides: 50687242!
openWith: aKey! !
!Open methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:39:02' overrides: 50687242!
openWith: aKey! !
!KeyClosed methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:39:02' overrides: 50687242!
openWith: aKey! !
!KeyOpen methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:39:02' overrides: 50687242!
openWith: aKey! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:39:02' prior: 50687242!
openWith: aKey

	self subclassResponsibility! !
!Open methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:39:12' prior: 50687250 overrides: 50687262!
openWith: aKey
	^self error: Door alreadyOpenedErrorDescription! !
!Closed methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:39:53' prior: 50687246 overrides: 50687262!
openWith: aKey
	^self error: Door noNeedForAKeyErrorDescription! !

!classDefinition: #KeyClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'MS 9/24/2023 23:40:56'!
DoorState subclass: #KeyClosed
	instanceVariableNames: 'key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!KeyClosed methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:40:52' prior: 50687254 overrides: 50687262!
openWith: aKey
	(key == aKey) ifTrue: [ ^ Open new.].
	^self error: Door notCorrectKeyErrorDescription. ! !
!Door methodsFor: 'playable character reactions' stamp: 'MS 9/24/2023 23:41:14' prior: 50687013 overrides: 50685642!
toBeOpenedBy: aPlayableCharacter
	
	state := state open.
	! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 23:41:17'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/24/2023 23:41:17'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:41:17'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/24/2023 23:41:17'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/24/2023 23:41:17'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:41:17'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/24/2023 23:41:17'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/24/2023 23:41:17'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/24/2023 23:41:17'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 23:41:17'!
FAILURE!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/24/2023 23:41:17'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/24/2023 23:41:17'!
FAILURE!
!KeyClosed methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:42:47' prior: 50687287 overrides: 50687262!
openWith: aKey
	(key == aKey) ifTrue: [ ^ KeyOpen new.].
	^self error: Door notCorrectKeyErrorDescription. ! !
!KeyOpen methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:43:20' prior: 50687258 overrides: 50687262!
openWith: aKey
	^self error: Door alreadyOpenedErrorDescription.! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 23:43:45'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/24/2023 23:43:45'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:43:45'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/24/2023 23:43:45'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/24/2023 23:43:45'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:43:45'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/24/2023 23:43:45'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/24/2023 23:43:45'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/24/2023 23:43:45'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 23:43:45'!
FAILURE!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/24/2023 23:43:45'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/24/2023 23:43:45'!
FAILURE!
!KeyClosed methodsFor: 'nil' stamp: 'MS 9/24/2023 23:44:53'!
initializeWith: aKey
	key := aKey.! !
!Door methodsFor: 'initialization' stamp: 'MS 9/24/2023 23:45:58' prior: 50686836!
initializeClosed: aDoorState using: aKey

	state := KeyClosed newUsing: aKey.
	
! !
!Door class methodsFor: 'instance creation' stamp: 'MS 9/24/2023 23:48:23' prior: 50686789!
closed

	^self basicNew initializeClosed.! !
!Door class methodsFor: 'instance creation' stamp: 'MS 9/24/2023 23:48:50' prior: 50686825!
closedWith: aKey

	^self basicNew initializeKeyClosedUsing: aKey! !
!Door class methodsFor: 'instance creation' stamp: 'MS 9/24/2023 23:49:06' prior: 50686864!
opened

	^self basicNew initializeOpen.! !
!Door methodsFor: 'initialization' stamp: 'MS 9/24/2023 23:49:21'!
initializeKeyClosed: aDoorState using: aKey

	state := KeyClosed newUsing: aKey.
	
! !

!methodRemoval: Door #initializeClosed:using: stamp: 'MS 9/24/2023 23:49:21'!
initializeClosed: aDoorState using: aKey

	state := KeyClosed newUsing: aKey.
	
!

!methodRemoval: Door #initializeKeyClosed:using: stamp: 'MS 9/24/2023 23:49:35'!
initializeKeyClosed: aDoorState using: aKey

	state := KeyClosed newUsing: aKey.
	
!

!methodRemoval: Door #initializeOpen:using: stamp: 'MS 9/24/2023 23:49:39'!
initializeOpen: aDoorState using: aKey

	state := KeyOpen new.
	key := aKey.
!
!Door methodsFor: 'nil' stamp: 'MS 9/24/2023 23:50:14'!
initializeKeyClosedUsing: aKey
	state := KeyClosed newUsing: aKey.! !
!KeyClosed class methodsFor: 'nil' stamp: 'MS 9/24/2023 23:50:39'!
newUsing: aKey
	^self new initializeWith: aKey! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 23:51:24'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/24/2023 23:51:24'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:51:24'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/24/2023 23:51:24'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/24/2023 23:51:24'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:51:24'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/24/2023 23:51:24'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/24/2023 23:51:24'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/24/2023 23:51:24'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 23:51:24'!
FAILURE!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/24/2023 23:51:24'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/24/2023 23:51:24'!
FAILURE!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/24/2023 23:52:36'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/24/2023 23:52:36'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:52:36'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/24/2023 23:52:36'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/24/2023 23:52:36'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/24/2023 23:52:36'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/24/2023 23:52:36'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/24/2023 23:52:36'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/24/2023 23:52:36'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 23:52:36'!
FAILURE!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/24/2023 23:52:36'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/24/2023 23:52:36'!
FAILURE!
!DoorTest methodsFor: 'using' stamp: 'MS 9/24/2023 23:52:47' prior: 50685308!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen.! !

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 23:52:57'!
FAILURE!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 23:52:57'!
FAILURE!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 23:53:32'!
FAILURE!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/24/2023 23:53:32'!
FAILURE!
!Door methodsFor: 'playable character reactions' stamp: 'MS 9/24/2023 23:54:38' prior: 50686934 overrides: 50685653!
toBeUsedBy: aPlayableCharacter
	state := state open.
	"(state == #Open) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ]."! !
!Door methodsFor: 'playable character reactions' stamp: 'MS 9/24/2023 23:55:50' prior: 50687543 overrides: 50685653!
toBeUsedBy: aPlayableCharacter
	state := state usedBy: aPlayableCharacter.
	"(state == #Open) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ]."! !
!DoorState methodsFor: 'nil' stamp: 'MS 9/24/2023 23:56:09'!
usedBy: aPlayableCharacter! !
!Closed methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:56:17' overrides: 50687568!
usedBy: aPlayableCharacter! !
!Open methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:56:17' overrides: 50687568!
usedBy: aPlayableCharacter! !
!KeyOpen methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:56:17' overrides: 50687568!
usedBy: aPlayableCharacter! !
!KeyClosed methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:56:17' overrides: 50687568!
usedBy: aPlayableCharacter! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'MS 9/24/2023 23:56:17' prior: 50687568!
usedBy: aPlayableCharacter

	self subclassResponsibility! !

Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'MS 9/25/2023 00:00:27'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'MS 9/25/2023 00:00:35'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'MS 9/25/2023 00:00:53'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorState methodsFor: 'initialization' stamp: 'MS 9/25/2023 00:01:20' prior: 50685537!
initializeFor: aDoor

	door := aDoor.! !
!Door methodsFor: 'initialization' stamp: 'MS 9/25/2023 00:01:40' prior: 50686794!
initializeClosed
	state := Closed newFor: self.! !
!Door methodsFor: 'initialization' stamp: 'MS 9/25/2023 00:01:48' prior: 50686929!
initializeOpen
	state := Open newFor: self.! !
!Door methodsFor: 'initialization' stamp: 'MS 9/25/2023 00:02:43' prior: 50687640!
initializeOpen
	state := Open for: self.! !
!Door methodsFor: 'initialization' stamp: 'MS 9/25/2023 00:02:52' prior: 50687635!
initializeClosed
	state := Closed for: self.! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/25/2023 00:03:17'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/25/2023 00:03:17'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/25/2023 00:03:17'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/25/2023 00:03:17'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/25/2023 00:03:17'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/25/2023 00:03:17'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/25/2023 00:03:17'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/25/2023 00:03:17'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/25/2023 00:03:17'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/25/2023 00:03:17'!
FAILURE!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/25/2023 00:03:17'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:03:17'!
FAILURE!
!Closed methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 00:03:34' prior: 50687572 overrides: 50687588!
usedBy: aPlayableCharacter
	^door open.! !
!Open methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 00:03:41' prior: 50687576 overrides: 50687588!
usedBy: aPlayableCharacter
	^door closed! !
!Open methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 00:03:43' prior: 50687697 overrides: 50687588!
usedBy: aPlayableCharacter
	^door closed.! !
!Closed methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 00:04:17' prior: 50687692 overrides: 50687588!
usedBy: aPlayableCharacter
	^door toBeOpenedBy: aPlayableCharacter .! !
!Open methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 00:04:31' prior: 50687702 overrides: 50687588!
usedBy: aPlayableCharacter
	^door toBeClosedBy: aPlayableCharacter .! !
!KeyClosed methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 00:04:52' prior: 50687584 overrides: 50687588!
usedBy: aPlayableCharacter
	^door toBeOpenedBy: aPlayableCharacter.! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/25/2023 00:05:00'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/25/2023 00:05:00'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/25/2023 00:05:00'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/25/2023 00:05:00'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/25/2023 00:05:00'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/25/2023 00:05:00'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/25/2023 00:05:00'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/25/2023 00:05:00'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/25/2023 00:05:00'!
PASSED!
!Closed methodsFor: 'door actions' stamp: 'MS 9/25/2023 00:06:20' prior: 50687035 overrides: 50687008!
open

	^Open for: door.! !
!Open methodsFor: 'door actions' stamp: 'MS 9/25/2023 00:06:31' prior: 50687174 overrides: 50687169!
close

	^Closed for: door.! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/25/2023 00:06:34'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/25/2023 00:06:34'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/25/2023 00:06:34'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/25/2023 00:06:34'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/25/2023 00:06:34'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/25/2023 00:06:34'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/25/2023 00:06:34'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/25/2023 00:06:34'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/25/2023 00:06:34'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/25/2023 00:06:47'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/25/2023 00:06:50'!
PASSED!
!Door methodsFor: 'playable character reactions' stamp: 'MS 9/25/2023 00:08:05' prior: 50687556 overrides: 50685653!
toBeUsedBy: aPlayableCharacter
	state usedBy: aPlayableCharacter.
	"(state == #Open) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ]."! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/25/2023 00:08:12'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/25/2023 00:08:12'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/25/2023 00:08:12'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/25/2023 00:08:12'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/25/2023 00:08:12'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/25/2023 00:08:12'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/25/2023 00:08:12'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/25/2023 00:08:12'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/25/2023 00:08:12'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/25/2023 00:08:12'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/25/2023 00:08:12'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:08:12'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:08:12'!
FAILURE!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/25/2023 00:08:22'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/25/2023 00:08:25'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/25/2023 00:08:27'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:08:30'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:08:30'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:09:57'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:09:57'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:10:28'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:11:23'!
FAILURE!
!Door methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 00:12:55' prior: 50687432!
initializeKeyClosedUsing: aKey
	state := KeyClosed for: self ; newUsing: aKey.! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/25/2023 00:13:20'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/25/2023 00:13:20'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/25/2023 00:13:20'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/25/2023 00:13:20'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/25/2023 00:13:20'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/25/2023 00:13:20'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/25/2023 00:13:20'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/25/2023 00:13:20'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/25/2023 00:13:20'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/25/2023 00:13:20'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/25/2023 00:13:20'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:13:20'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:13:20'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/25/2023 00:13:31'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/25/2023 00:13:34'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/25/2023 00:13:36'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/25/2023 00:13:39'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/25/2023 00:13:42'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/25/2023 00:13:46'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/25/2023 00:13:48'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:13:51'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:13:51'!
FAILURE!
!Door methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 00:15:42' prior: 50687880!
initializeKeyClosedUsing: aKey
	state := (KeyClosed for: self) newUsing: aKey.! !

(KeyClosed for: self)!

(KeyClosed for: self)!
!Door methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 00:16:10' prior: 50687956!
initializeKeyClosedUsing: aKey
	state := (KeyClosed for: self) newUsing: aKey.! !

(KeyClosed for: self) newUsing: 'caca'.!
!Door methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 00:18:03' prior: 50687963!
initializeKeyClosedUsing: aKey
	state := (KeyClosed for: self) initializeWith: aKey.! !

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:18:13'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'MS 9/25/2023 00:18:16'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'MS 9/25/2023 00:18:16'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'MS 9/25/2023 00:18:16'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'MS 9/25/2023 00:18:16'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'MS 9/25/2023 00:18:16'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'MS 9/25/2023 00:18:16'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'MS 9/25/2023 00:18:16'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'MS 9/25/2023 00:18:16'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'MS 9/25/2023 00:18:16'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'MS 9/25/2023 00:18:16'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'MS 9/25/2023 00:18:16'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'MS 9/25/2023 00:18:16'!
PASSED!

----STARTUP---- (25 September 2023 11:40:17) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


ObjectBuilder create: #Peano
	collaboratorNames: ''
	in: 'DenotativeObject-Morph'
	!

!classDefinition: #Peano category: 'DenotativeObject-Morph' stamp: 'MS 9/25/2023 11:41:27'!
DenotativeObject subclass: #Peano
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-Morph'!

!classDefinition: 'Peano class' category: 'DenotativeObject-Morph' stamp: 'MS 9/25/2023 11:41:27'!
Peano class
	instanceVariableNames: ''!

!classRemoval: #Peano stamp: 'MS 9/25/2023 11:41:39'!
DenotativeObject subclass: #Peano
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-Morph'!

ObjectBuilder create: #anObject
	collaboratorNames: ''
	in: 'PeanoRepaso'
	!

!classDefinition: #anObject category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:41:55'!
DenotativeObject subclass: #anObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'anObject class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:41:55'!
anObject class
	instanceVariableNames: ''!

ObjectBuilder create: #I asChildOf: DenotativeObject collaboratorNames: '' in: 'PeanoRepaso'!

!classDefinition: #I category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:43:26'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'I class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:43:26'!
I class
	instanceVariableNames: ''!

!classRemoval: #anObject stamp: 'MS 9/25/2023 11:43:34'!
DenotativeObject subclass: #anObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

I
	collaboratorNames: 'next previous'
	in: 'PeanoRepaso'!

!classDefinition: 'I class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:43:40'!
I class
	instanceVariableNames: 'next previous'!

!classDefinition: #I category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:43:40'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'I class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:43:40'!
I class
	instanceVariableNames: 'next previous'!
!I class methodsFor: 'no messages' stamp: 'MS 9/25/2023 11:44:06'!
+ anAdder
	^anAdder next.! !
!I class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:44:15'!
- anAdder
	^anAdder previous.! !

ObjectBuilder create: #II asChildOf: DenotativeObject collaboratorNames: '' in: 'PeanoRepaso'!

!classDefinition: #II category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:44:48'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'II class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:44:48'!
II class
	instanceVariableNames: ''!

II
	collaboratorNames: 'next previous'
	in: 'PeanoRepaso'!

!classDefinition: 'II class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:44:53'!
II class
	instanceVariableNames: 'next previous'!

!classDefinition: #II category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:44:53'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'II class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:44:53'!
II class
	instanceVariableNames: 'next previous'!
!II class methodsFor: 'nil' stamp: 'MS 9/25/2023 11:45:29'!
+ anAdder
	^self previous + anAdder next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:45:36' prior: 50688128!
+ anAdder
	^previous + anAdder next.! !
!I class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:46:28'!
next
	^next! !
!I class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:46:40'!
previous 
	^previous! !
!I class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:47:14' prior: 50688140!
previous 
	^self error: 'Zero not supported.'! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:48:07'!
- anAdder
	^previous - anAdder previous.! !

I  next!

I previous!

I + I!

I + II!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:49:05'!
next
	^next! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:49:13'!
previous
	^previous! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:53:18' prior: 50688153!
next
	next ifNil: [^next :=  self createChildNamed: self name, 'I'.].
	^next! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:53:19' prior: 50688160!
next
	next ifNil: [^next := self createChildNamed: self name, 'I'.].
	^next! !

II next!

!classDefinition: #III category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:53:36'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'III class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:53:36'!
III class
	instanceVariableNames: ''!

III next!

!classDefinition: #IIII category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:53:41'!
III subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'IIII class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:53:41'!
IIII class
	instanceVariableNames: ''!

I + IIII!

!classDefinition: #IIIII category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:54:11'!
IIII subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'IIIII class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:54:11'!
IIIII class
	instanceVariableNames: ''!

II - I!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:55:05' prior: 50688148!
- anAdder
	anAdder = I ifTrue:[^previous].
	^previous - anAdder previous.! !

II - I!

III - I!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:55:40' prior: 50688166!
next
	next ifNil: [^next := self createChildNamed: self name, 'I'.].
	next previous: self.
	^next! !
!II class methodsFor: 'nil' stamp: 'MS 9/25/2023 11:55:57'!
previous: aNumber
	previous := aNumber! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:55:59' prior: 50688216!
previous: aNumber
	previous := aNumber.! !

!classRemoval: #IIIII stamp: 'MS 9/25/2023 11:56:09'!
IIII subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classRemoval: #IIII stamp: 'MS 9/25/2023 11:56:12'!
III subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classRemoval: #III stamp: 'MS 9/25/2023 11:56:16'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

II + II!

!classDefinition: #AnObsoleteIIII category: 'as yet unclassified' stamp: 'MS 9/25/2023 11:56:23'!
AnObsoleteIII subclass: #AnObsoleteIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'as yet unclassified'!

!classDefinition: 'AnObsoleteIIII class' category: 'as yet unclassified' stamp: 'MS 9/25/2023 11:56:23'!
AnObsoleteIIII class
	instanceVariableNames: ''!

II next!

II next!

!classDefinition: #III category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:56:47'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'III class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:56:47'!
III class
	instanceVariableNames: ''!

III - I!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:58:14' prior: 50688210!
next
	next ifNil: [next := self createChildNamed: self name, 'I'. 
			    next previous: self.].
	^next! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:58:20' prior: 50688266!
next
	next ifNil: [next := self createChildNamed: self name, 'I'. next previous: self.].
	^next! !

!classRemoval: #III stamp: 'MS 9/25/2023 11:58:26'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

II next!

!classDefinition: #III category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:58:40'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'III class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:58:40'!
III class
	instanceVariableNames: ''!

III - I!

III - II!

III - III!

III + II!

!classDefinition: #IIII category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:59:03'!
III subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'IIII class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:59:03'!
IIII class
	instanceVariableNames: ''!

!classDefinition: #IIIII category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:59:03'!
IIII subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'IIIII class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 11:59:03'!
IIIII class
	instanceVariableNames: ''!

IIIII previous!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 11:59:50' prior: 50688204!
- anAdder
	^anAdder sumateA: self.
	"anAdder = I ifTrue:[^previous].
	^previous - anAdder previous."! !
!II class methodsFor: 'nil' stamp: 'MS 9/25/2023 12:00:47'!
sumateA: aNumber
	^ previous sumateA: aNumber next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 12:01:02' prior: 50688318!
- anAdder
	^anAdder restateA: self.
	"anAdder = I ifTrue:[^previous].
	^previous - anAdder previous."! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 12:01:17'!
restateA: aNumber
	^ previous sumateA: aNumber next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 12:01:17' prior: 50688324!
sumateA: aNumber
	^ previous restateA: aNumber next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 12:01:17' prior: 50688335!
restateA: aNumber
	^ previous restateA: aNumber next.! !

!methodRemoval: II class #sumateA: stamp: 'MS 9/25/2023 12:01:17'!
sumateA: aNumber
	^ previous restateA: aNumber next.!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 12:01:27' prior: 50688345!
restateA: aNumber
	^ previous restateA: aNumber previous.! !
!I class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 12:01:58'!
restateA: aNumber
	^ aNumber previous! !

III - II!

III - III!

III - IIII!

IIIII - IIIII!

IIIII - IIII!
!I class methodsFor: 'nil' stamp: 'MS 9/25/2023 12:07:20'!
* aNumber
	^aNumber! !
!II class methodsFor: 'nil' stamp: 'MS 9/25/2023 12:14:10'!
* aNumber
	^(aNumber previous * self) + self! !

I * III!

II * I!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 12:14:59' prior: 50688368!
* aNumber
	aNumber = I ifTrue: [^self]
	^(aNumber previous * self) + self! !

II * I!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 12:15:09' prior: 50688373!
* aNumber
	aNumber = I ifTrue: [^self].
	^(aNumber previous * self) + self! !

II * I!

II * II!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 12:15:40' prior: 50688379!
* aNumber
	^aNumber multiplicateA: self.
	"
	aNumber = I ifTrue: [^self].
	^(aNumber previous * self) + self"! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 12:17:03'!
multiplicateA: aNumber
	^(self previous * aNumber) + aNumber.! !
!I class methodsFor: 'nil' stamp: 'MS 9/25/2023 12:17:20'!
multiplicateA: aNumber
	^aNumber.! !

I * II!

II * I!

II * II!

II * III!

!classDefinition: #IIIIII category: 'PeanoRepaso' stamp: 'MS 9/25/2023 12:18:01'!
IIIII subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'IIIIII class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 12:18:01'!
IIIIII class
	instanceVariableNames: ''!

III * II!
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 12:18:39'!
next: aNumber
	next := aNumber.! !
!II class methodsFor: 'as yet unclassified' stamp: 'MS 9/25/2023 12:19:23' prior: 50688273!
next
	next ifNil: [self next: (self createChildNamed: (self name, 'I')). next previous: self.].
	^next! !

II * III!

II * IIII!

!classDefinition: #IIIIIII category: 'PeanoRepaso' stamp: 'MS 9/25/2023 12:19:34'!
IIIIII subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'IIIIIII class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 12:19:34'!
IIIIIII class
	instanceVariableNames: ''!

!classDefinition: #IIIIIIII category: 'PeanoRepaso' stamp: 'MS 9/25/2023 12:19:34'!
IIIIIII subclass: #IIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PeanoRepaso'!

!classDefinition: 'IIIIIIII class' category: 'PeanoRepaso' stamp: 'MS 9/25/2023 12:19:34'!
IIIIIIII class
	instanceVariableNames: ''!

III previous!

IIIIII previous!

IIIIII previous!

x := #(1,2,3,4)!

x collect: [:a | a even].!

x collect: [:a | a = 2 or: a = 3].!

x collect: [:a | a = 2 or: a = 3].!

----End fileIn of /home/martin/Desktop/Inge1/linux64/linux64/Packages/TerseGuide.pck.st----!

| x |
x := OrderedCollection new.
x := #(1,2,3,4)
x select: [:a | a = 2] thenCollect: [:a | a + 10].!

x := #(1,2,3,4)
x select: [:a | a = 2] thenCollect: [:a | a + 10].!

x select: [:a | a = 2] thenCollect: [:a | a + 10].!

x sum.!

----STARTUP---- (1 October 2023 15:53:28) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


Array new!

----STARTUP---- (2 October 2023 11:19:21) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Desktop/Inge1/Repo/Inge1_Santesteban_Segre/02-Numeros/Numero-Exercise.st----!

----STARTUP---- (8 October 2023 19:55:01) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


TestCase subclass: #TestXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #TestXX category: 'MarsRover' stamp: 'MS 10/8/2023 19:58:43'!
TestCase subclass: #TestXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRover category: 'Mars Rover' stamp: 'MS 10/8/2023 20:09:32'!
Object subclass: #MarsRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:09:14'!
test01
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	self assert: (marsRover isIn: (5@4) andFacing: #Norte).! !

!testRun: #TestXX #test01 stamp: 'MS 10/8/2023 20:09:38'!
ERROR!
!MarsRover class methodsFor: 'class initialization' stamp: 'MS 10/8/2023 20:09:51'!
in: aRenameMe1 facing: aRenameMe2 
	self shouldBeImplemented.! !
!MarsRover class methodsFor: 'class initialization' stamp: 'MS 10/8/2023 20:13:39' prior: 50691405!
in: initialPosition facing: initialDirection
	^self new in: initialPosition facing: initialDirection ! !

!testRun: #TestXX #test01 stamp: 'MS 10/8/2023 20:13:43'!
ERROR!
!MarsRover methodsFor: 'initialitation' stamp: 'MS 10/8/2023 20:14:01'!
in: initialPosition facing: initialDirection 
	self shouldBeImplemented.! !

!classDefinition: #MarsRover category: 'Mars Rover' stamp: 'MS 10/8/2023 20:14:42'!
Object subclass: #MarsRover
	instanceVariableNames: 'currentPosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!

!classDefinition: #MarsRover category: 'Mars Rover' stamp: 'MS 10/8/2023 20:14:43'!
Object subclass: #MarsRover
	instanceVariableNames: 'currentPosition currentDirection'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!
!MarsRover methodsFor: 'initialitation' stamp: 'MS 10/8/2023 20:14:40' prior: 50691419!
in: initialPosition facing: initialDirection 
	currentPosition := initialPosition.
	currentDirection := initialDirection.! !

!testRun: #TestXX #test01 stamp: 'MS 10/8/2023 20:14:46'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:14:59'!
isIn: aRenameMe1 andFacing: aRenameMe2 
	self shouldBeImplemented.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:17:06' prior: 50691448!
isIn: aPosition andFacing: aDirection
	^true! !

!testRun: #TestXX #test01 stamp: 'MS 10/8/2023 20:17:09'!
PASSED!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:17:33'!
test02
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	self deny: (marsRover isIn: (5@3) andFacing: #Norte).! !

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:17:36'!
FAILURE!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:18:17'!
FAILURE!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:18:40'!
FAILURE!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:18:52'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:19:41' prior: 50691454!
isIn: aPosition andFacing: aDirection
	^(currentPosition = aPosition)! !

!testRun: #TestXX #test01 stamp: 'MS 10/8/2023 20:19:44'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:19:44'!
PASSED!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:19:54'!
test03
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	self deny: (marsRover isIn: (5@3) andFacing: #Sur).! !

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 20:19:58'!
PASSED!

!testRun: #TestXX #test01 stamp: 'MS 10/8/2023 20:19:58'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:19:58'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 20:19:58'!
PASSED!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:20:11' prior: 50691485!
test03
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	self deny: (marsRover isIn: (5@4) andFacing: #Sur).! !

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 20:20:11'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:20:53' prior: 50691476!
isIn: aPosition andFacing: aDirection
	^(currentPosition = aPosition) and: [currentDirection = aDirection]! !

!testRun: #TestXX #test01 stamp: 'MS 10/8/2023 20:20:55'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:20:55'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 20:20:55'!
PASSED!

!methodRemoval: TestXX #test03 stamp: 'MS 10/8/2023 20:22:34'!
test03
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	self deny: (marsRover isIn: (5@4) andFacing: #Sur).!

!methodRemoval: TestXX #test02 stamp: 'MS 10/8/2023 20:22:36'!
test02
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	self deny: (marsRover isIn: (5@3) andFacing: #Norte).!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:22:52' prior: 50691396!
test01
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	self assert: (marsRover isIn: (5@4) andFacing: #Norte).! !
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:24:11'!
test01_MarsRoverIsInDesignatedInitialPositionAndDirection
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	self assert: (marsRover isIn: (5@4) andFacing: #Norte).! !

!methodRemoval: TestXX #test01 stamp: 'MS 10/8/2023 20:24:11'!
test01
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	self assert: (marsRover isIn: (5@4) andFacing: #Norte).!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:25:46'!
test02
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	marsRover process: ''.
	self assert: (marsRover isIn: (5@4) andFacing: #Norte).! !

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:25:48'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:26:07'!
process: aRenameMe1 
	self shouldBeImplemented.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:26:30' prior: 50691566!
process: aStringOfCommands 
	! !

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:26:36'!
PASSED!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 20:26:36'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:26:36'!
PASSED!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:27:14'!
test03
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	marsRover process: 'f'.
	self assert: (marsRover isIn: (5@5) andFacing: #Norte).! !

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 20:27:23'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:29:14' prior: 50691571!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [currentPosition := currentPosition + (0@1).].
	! !

(0@1)!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:29:38' prior: 50691592!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [currentPosition := currentPosition + (0@1).].
	! !

----End fileIn of /home/martin/Desktop/Inge1/linux64/linux64/Packages/TerseGuide.pck.st----!

(0@0) up!

(0@0)!

(0@1)!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 20:32:46'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:32:46'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 20:32:46'!
PASSED!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:33:10'!
test04
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	marsRover process: 'b'.
	self assert: (marsRover isIn: (5@3) andFacing: #Norte).! !

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 20:33:12'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:33:28' prior: 50691599!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [currentPosition := currentPosition + (0@1).].
	(aStringOfCommands = 'b') ifTrue: [currentPosition := currentPosition - (0@1).].	! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 20:33:29'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:33:29'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 20:33:29'!
PASSED!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 20:33:29'!
PASSED!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:33:38'!
test05
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	marsRover process: 'b'.
	self assert: (marsRover isIn: (5@3) andFacing: #Norte).! !
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:34:59' prior: 50694562!
test05
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	marsRover process: 'r'.
	self assert: (marsRover isIn: (5@3) andFacing: #Norte).! !

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 20:35:02'!
FAILURE!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:35:27' prior: 50694570!
test05
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #Norte.
	marsRover process: 'r'.
	self assert: (marsRover isIn: (5@4) andFacing: #Este).! !
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:36:48' prior: 50691542!
test01_MarsRoverIsInDesignatedInitialPositionAndDirection
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #North.
	self assert: (marsRover isIn: (5@4) andFacing: #North).! !
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:36:54' prior: 50691556!
test02
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #North.
	marsRover process: ''.
	self assert: (marsRover isIn: (5@4) andFacing: #North).! !
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:37:01' prior: 50691582!
test03
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #North.
	marsRover process: 'f'.
	self assert: (marsRover isIn: (5@5) andFacing: #North).! !
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:37:08' prior: 50694533!
test04
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #North.
	marsRover process: 'b'.
	self assert: (marsRover isIn: (5@3) andFacing: #North).! !
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:37:17' prior: 50694580!
test05
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #North.
	marsRover process: 'r'.
	self assert: (marsRover isIn: (5@4) andFacing: #East).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:37:50' prior: 50694543!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [currentPosition := currentPosition + (0@1).].
	(aStringOfCommands = 'b') ifTrue: [currentPosition := currentPosition - (0@1).].	
	(aStringOfCommands = 'r') ifTrue: [currentDirection := #East.].	! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 20:37:51'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:37:51'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 20:37:51'!
PASSED!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 20:37:51'!
PASSED!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 20:37:51'!
PASSED!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 20:38:40' prior: 50694621!
test05
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'r'.
	self assert: (marsRover isIn: (5@4) andFacing: #South).! !

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 20:38:41'!
FAILURE!

Object subclass: #ClassXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!

!classDefinition: #ClassXX category: 'Mars Rover' stamp: 'MS 10/8/2023 20:39:10'!
Object subclass: #ClassXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!

ClassXX subclass: #North
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!

!classDefinition: #North category: 'Mars Rover' stamp: 'MS 10/8/2023 20:39:44'!
ClassXX subclass: #North
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!

ClassXX subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!

!classDefinition: #South category: 'Mars Rover' stamp: 'MS 10/8/2023 20:39:49'!
ClassXX subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!

ClassXX subclass: #East
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!

!classDefinition: #East category: 'Mars Rover' stamp: 'MS 10/8/2023 20:39:53'!
ClassXX subclass: #East
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!

ClassXX subclass: #West
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!

!classDefinition: #West category: 'Mars Rover' stamp: 'MS 10/8/2023 20:39:58'!
ClassXX subclass: #West
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!
!ClassXX methodsFor: 'nil' stamp: 'MS 10/8/2023 20:42:23'!
rotateRight! !
!ClassXX methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:42:28'!
rotateLeft! !
!North methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:42:34' overrides: 50694716!
rotateLeft! !
!South methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:42:34' overrides: 50694716!
rotateLeft! !
!East methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:42:34' overrides: 50694716!
rotateLeft! !
!West methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:42:34' overrides: 50694716!
rotateLeft! !
!ClassXX methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:42:34' prior: 50694716!
rotateLeft

	self subclassResponsibility! !
!North methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:42:42' overrides: 50694713!
rotateRight! !
!South methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:42:42' overrides: 50694713!
rotateRight! !
!East methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:42:42' overrides: 50694713!
rotateRight! !
!West methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:42:42' overrides: 50694713!
rotateRight! !
!ClassXX methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:42:42' prior: 50694713!
rotateRight

	self subclassResponsibility! !
!East methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:44:04' prior: 50694728 overrides: 50694736!
rotateLeft
	^North new.! !
!East methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:44:13' prior: 50694749 overrides: 50694757!
rotateRight
	^South new.! !
!North methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:44:21' prior: 50694720 overrides: 50694736!
rotateLeft
	^West new! !
!North methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:44:32' prior: 50694741 overrides: 50694757!
rotateRight
	^East new! !
!South methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:44:48' prior: 50694724 overrides: 50694736!
rotateLeft
	^East new! !
!South methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:45:06' prior: 50694745 overrides: 50694757!
rotateRight
	^West new! !
!West methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:45:28' prior: 50694732 overrides: 50694736!
rotateLeft
	^South new! !
!West methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:45:36' prior: 50694753 overrides: 50694757!
rotateRight
	^North new! !

Object subclass: #CardinalDirections
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!

!classDefinition: #CardinalDirections category: 'Mars Rover' stamp: 'MS 10/8/2023 20:46:39'!
Object subclass: #CardinalDirections
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!

!classRemoval: #CardinalDirections stamp: 'MS 10/8/2023 20:46:56'!
Object subclass: #CardinalDirections
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover'!

!classRenamed: #ClassXX as: #CardinalDirections stamp: 'MS 10/8/2023 20:47:08'!
Smalltalk renameClassNamed: #ClassXX as: #CardinalDirections!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:47:35' prior: 50694629!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [currentPosition := currentPosition + (0@1).].
	(aStringOfCommands = 'b') ifTrue: [currentPosition := currentPosition - (0@1).].	
	(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 20:47:37'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:47:37'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 20:47:37'!
PASSED!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 20:47:37'!
PASSED!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 20:47:37'!
ERROR!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 20:47:37'!
ERROR!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 20:48:02'!
PASSED!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 20:48:07'!
ERROR!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 20:48:07'!
ERROR!
!MarsRover methodsFor: 'initialitation' stamp: 'MS 10/8/2023 20:49:01' prior: 50691439!
in: initialPosition facing: initialDirection 
	currentPosition := initialPosition.
	currentDirection := initialDirection.! !
!MarsRover methodsFor: 'initialitation' stamp: 'MS 10/8/2023 20:49:53' prior: 50694855!
in: initialPosition facing: initialDirection 
	currentPosition := initialPosition.
	currentDirection := CardinalDirections pointing: initialDirection .! !
!CardinalDirections class methodsFor: 'nil' stamp: 'MS 10/8/2023 20:53:20'!
pointing: aDirectionSymbol
	^(self subclasses detect: [ :aCardinalDirection | aCardinalDirection canHandle: aDirectionSymbol.]) new.! !
!CardinalDirections class methodsFor: 'nil' stamp: 'MS 10/8/2023 20:53:53'!
canHandle: aDirectionSymbol! !
!North class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:53:59' overrides: 50694877!
canHandle: aDirectionSymbol! !
!South class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:53:59' overrides: 50694877!
canHandle: aDirectionSymbol! !
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:53:59' overrides: 50694877!
canHandle: aDirectionSymbol! !
!West class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:53:59' overrides: 50694877!
canHandle: aDirectionSymbol! !
!CardinalDirections class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:53:59' prior: 50694877!
canHandle: aDirectionSymbol

	self subclassResponsibility! !
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:54:28' prior: 50694892 overrides: 50694902!
canHandle: aDirectionSymbol
	^aDirectionSymbol = #East! !
!North class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:54:34' prior: 50694882 overrides: 50694902!
canHandle: aDirectionSymbol
	^aDirectionSymbol = #East! !
!North class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:54:40' prior: 50694914 overrides: 50694902!
canHandle: aDirectionSymbol
	^aDirectionSymbol = #North! !
!South class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:54:48' prior: 50694887 overrides: 50694902!
canHandle: aDirectionSymbol
	^aDirectionSymbol = #South! !
!West class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:54:54' prior: 50694897 overrides: 50694902!
canHandle: aDirectionSymbol
	^aDirectionSymbol = #West! !
!CardinalDirections class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:56:50' prior: 50694870!
pointing: aDirectionSymbol
	^(self subclasses detect: [ :aCardinalDirection | aCardinalDirection canHandle: aDirectionSymbol.] ifNone: [self error: self invalidSymbolError]) new.! !
!CardinalDirections class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:57:23'!
invalidSymbolError
	^'This symbol is not a cardinal direction!!'! !

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 20:57:30'!
FAILURE!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 20:57:30'!
FAILURE!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 20:57:37'!
FAILURE!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 20:57:37'!
FAILURE!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 20:57:40'!
FAILURE!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 20:57:40'!
FAILURE!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 20:57:48'!
FAILURE!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 20:57:48'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:58:55' prior: 50691510!
isIn: aPosition andFacing: aDirection
	^(currentPosition = aPosition) and: [currentDirection symbol = aDirection]! !
!CardinalDirections methodsFor: 'nil' stamp: 'MS 10/8/2023 20:59:00'!
symbol! !
!North methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:59:06' overrides: 50694979!
symbol! !
!South methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:59:06' overrides: 50694979!
symbol! !
!East methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:59:06' overrides: 50694979!
symbol! !
!West methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:59:06' overrides: 50694979!
symbol! !
!CardinalDirections methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:59:06' prior: 50694979!
symbol

	self subclassResponsibility! !
!East methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:59:15' prior: 50694991 overrides: 50694999!
symbol
	^#East! !
!North methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:59:22' prior: 50694983 overrides: 50694999!
symbol
	^#North! !
!South methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:59:29' prior: 50694987 overrides: 50694999!
symbol
	^#South! !
!West methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 20:59:36' prior: 50694995 overrides: 50694999!
symbol
	^#West! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 20:59:41'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 20:59:41'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 20:59:41'!
PASSED!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 20:59:41'!
PASSED!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 20:59:41'!
PASSED!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:00:17'!
test06
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'l'.
	self assert: (marsRover isIn: (5@4) andFacing: #South).! !

!testRun: #TestXX #test06 stamp: 'MS 10/8/2023 21:00:20'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:00:41' prior: 50694823!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [currentPosition := currentPosition + (0@1).].
	(aStringOfCommands = 'b') ifTrue: [currentPosition := currentPosition - (0@1).].	
	(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
	(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateLeft.].	! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:00:43'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 21:00:43'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 21:00:43'!
PASSED!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 21:00:43'!
PASSED!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 21:00:43'!
FAILURE!

!testRun: #TestXX #test06 stamp: 'MS 10/8/2023 21:00:43'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:00:49' prior: 50695041!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [currentPosition := currentPosition + (0@1).].
	(aStringOfCommands = 'b') ifTrue: [currentPosition := currentPosition - (0@1).].	
	(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
	(aStringOfCommands = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:00:49'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 21:00:49'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 21:00:49'!
PASSED!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 21:00:49'!
PASSED!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 21:00:49'!
PASSED!

!testRun: #TestXX #test06 stamp: 'MS 10/8/2023 21:00:49'!
FAILURE!

!testRun: #TestXX #test06 stamp: 'MS 10/8/2023 21:00:49'!
FAILURE!

!testRun: #TestXX #test06 stamp: 'MS 10/8/2023 21:00:54'!
FAILURE!

!testRun: #TestXX #test06 stamp: 'MS 10/8/2023 21:00:54'!
FAILURE!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:01:05' prior: 50695031!
test06
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'l'.
	self assert: (marsRover isIn: (5@4) andFacing: #North).! !

!testRun: #TestXX #test06 stamp: 'MS 10/8/2023 21:01:06'!
PASSED!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:01:06'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 21:01:06'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 21:01:06'!
PASSED!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 21:01:06'!
PASSED!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 21:01:06'!
PASSED!

!testRun: #TestXX #test06 stamp: 'MS 10/8/2023 21:01:06'!
PASSED!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:03:56'!
test07
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #North.
	marsRover process: 'rf'.
	self assert: (marsRover isIn: (6@4) andFacing: #East).! !

!testRun: #TestXX #test07 stamp: 'MS 10/8/2023 21:03:57'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:06:40' prior: 50695070!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [currentPosition := currentPosition + (0@1).].
	(aStringOfCommands = 'b') ifTrue: [currentPosition := currentPosition - (0@1).].	
	(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
	(aStringOfCommands = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	! !
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:06:58' prior: 50695129!
test07
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'f'.
	self assert: (marsRover isIn: (6@4) andFacing: #East).! !

!testRun: #TestXX #test07 stamp: 'MS 10/8/2023 21:06:59'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:10:14' prior: 50695139!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [
		(currentDirection symbol = #North) ifTrue: [	currentPosition := currentPosition + (0@1)].
		(currentDirection symbol = #East) ifTrue: [	currentPosition := currentPosition + (1@0)].
		(currentDirection symbol = #West) ifTrue: [	currentPosition := currentPosition - (1@0)].
		(currentDirection symbol = #South) ifTrue: [	currentPosition := currentPosition - (0@1)].
	].
	(aStringOfCommands = 'b') ifTrue: [currentPosition := currentPosition - (0@1).].	
	(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
	(aStringOfCommands = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:10:35'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 21:10:35'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 21:10:35'!
PASSED!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 21:10:35'!
PASSED!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 21:10:35'!
PASSED!

!testRun: #TestXX #test06 stamp: 'MS 10/8/2023 21:10:35'!
PASSED!

!testRun: #TestXX #test07 stamp: 'MS 10/8/2023 21:10:35'!
PASSED!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:11:56' prior: 50695164!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [
		currentPosition := currentPosition + currentDirection moveFoward.
		"(currentDirection symbol = #North) ifTrue: [	currentPosition := currentPosition + (0@1)].
		(currentDirection symbol = #East) ifTrue: [	currentPosition := currentPosition + (1@0)].
		(currentDirection symbol = #West) ifTrue: [	currentPosition := currentPosition - (1@0)].
		(currentDirection symbol = #South) ifTrue: [	currentPosition := currentPosition - (0@1)]."
	].
	(aStringOfCommands = 'b') ifTrue: [currentPosition := currentPosition - (0@1).].	
	(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
	(aStringOfCommands = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	! !
!CardinalDirections methodsFor: 'nil' stamp: 'MS 10/8/2023 21:12:07'!
moveFoward! !
!CardinalDirections methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:12:12'!
moveForward! !

!methodRemoval: CardinalDirections #moveFoward stamp: 'MS 10/8/2023 21:12:16'!
moveFoward!
!North methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:12:21' overrides: 50695236!
moveForward! !
!South methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:12:21' overrides: 50695236!
moveForward! !
!East methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:12:21' overrides: 50695236!
moveForward! !
!West methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:12:21' overrides: 50695236!
moveForward! !
!CardinalDirections methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:12:21' prior: 50695236!
moveForward

	self subclassResponsibility! !
!East methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:12:43' prior: 50695251 overrides: 50695259!
moveForward
	^(1@0)! !
!North methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:12:53' prior: 50695243 overrides: 50695259!
moveForward
	^(0@1)! !
!South methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:13:09' prior: 50695247 overrides: 50695259!
moveForward
	^(0@-1)! !
!West methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:13:19' prior: 50695255 overrides: 50695259!
moveForward
	^(-1@0)! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:13:36'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 21:13:36'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 21:13:36'!
ERROR!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 21:13:36'!
PASSED!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 21:13:36'!
PASSED!

!testRun: #TestXX #test06 stamp: 'MS 10/8/2023 21:13:36'!
PASSED!

!testRun: #TestXX #test07 stamp: 'MS 10/8/2023 21:13:36'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:13:46' prior: 50695205!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [
		currentPosition := currentPosition + currentDirection moveForward.
		"(currentDirection symbol = #North) ifTrue: [	currentPosition := currentPosition + (0@1)].
		(currentDirection symbol = #East) ifTrue: [	currentPosition := currentPosition + (1@0)].
		(currentDirection symbol = #West) ifTrue: [	currentPosition := currentPosition - (1@0)].
		(currentDirection symbol = #South) ifTrue: [	currentPosition := currentPosition - (0@1)]."
	].
	(aStringOfCommands = 'b') ifTrue: [currentPosition := currentPosition - (0@1).].	
	(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
	(aStringOfCommands = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:13:47'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 21:13:47'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 21:13:47'!
PASSED!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 21:13:47'!
PASSED!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 21:13:47'!
PASSED!

!testRun: #TestXX #test06 stamp: 'MS 10/8/2023 21:13:47'!
PASSED!

!testRun: #TestXX #test07 stamp: 'MS 10/8/2023 21:13:47'!
PASSED!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:13:56' prior: 50695299!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [
		currentPosition := currentPosition + currentDirection moveForward.
	].
	(aStringOfCommands = 'b') ifTrue: [currentPosition := currentPosition - (0@1).].	
	(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
	(aStringOfCommands = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	! !
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:15:10'!
test08
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'b'.
	self assert: (marsRover isIn: (4@4) andFacing: #East).! !

!testRun: #TestXX #test08 stamp: 'MS 10/8/2023 21:15:15'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:16:10' prior: 50695343!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [
		currentPosition := currentPosition + currentDirection moveForward.
	].

	(aStringOfCommands = 'b') ifTrue: [
		currentPosition := currentPosition + currentDirection moveBackwards.
	].

	(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
	(aStringOfCommands = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	! !
!CardinalDirections methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:16:19'!
moveBackwards

	self subclassResponsibility! !
!North methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:16:27' overrides: 50695385!
moveBackwards

	self subclassResponsibility! !
!South methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:16:27' overrides: 50695385!
moveBackwards

	self subclassResponsibility! !
!East methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:16:27' overrides: 50695385!
moveBackwards

	self subclassResponsibility! !
!West methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:16:27' overrides: 50695385!
moveBackwards

	self subclassResponsibility! !
!CardinalDirections methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:16:27' prior: 50695385!
moveBackwards

	self subclassResponsibility! !
!East methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:16:51' prior: 50695400 overrides: 50695410!
moveBackwards

	! !
!CardinalDirections methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:17:03'!
moveBackward

	self subclassResponsibility! !
!East methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:17:03' overrides: 50695419!
moveBackward

	! !
!North methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:17:03' overrides: 50695419!
moveBackward

	self subclassResponsibility! !
!South methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:17:03' overrides: 50695419!
moveBackward

	self subclassResponsibility! !
!West methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:17:03' overrides: 50695419!
moveBackward

	self subclassResponsibility! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:17:03' prior: 50695368!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [
		currentPosition := currentPosition + currentDirection moveForward.
	].

	(aStringOfCommands = 'b') ifTrue: [
		currentPosition := currentPosition + currentDirection moveBackward.
	].

	(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
	(aStringOfCommands = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	! !

!methodRemoval: CardinalDirections #moveBackwards stamp: 'MS 10/8/2023 21:17:03'!
moveBackwards

	self subclassResponsibility!

!methodRemoval: East #moveBackwards stamp: 'MS 10/8/2023 21:17:03'!
moveBackwards

	!

!methodRemoval: North #moveBackwards stamp: 'MS 10/8/2023 21:17:03'!
moveBackwards

	self subclassResponsibility!

!methodRemoval: South #moveBackwards stamp: 'MS 10/8/2023 21:17:03'!
moveBackwards

	self subclassResponsibility!

!methodRemoval: West #moveBackwards stamp: 'MS 10/8/2023 21:17:03'!
moveBackwards

	self subclassResponsibility!
!East methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:17:22' prior: 50695424 overrides: 50695419!
moveBackward
	^(-1@0)
	! !
!North methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:17:43' prior: 50695428 overrides: 50695419!
moveBackward

	^(0@-1)! !
!South methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:17:54' prior: 50695433 overrides: 50695419!
moveBackward

	^(0@1)! !
!West methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:18:05' prior: 50695438 overrides: 50695419!
moveBackward

	^(1@0)! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:18:10'!
PASSED!

!testRun: #TestXX #test02 stamp: 'MS 10/8/2023 21:18:10'!
PASSED!

!testRun: #TestXX #test03 stamp: 'MS 10/8/2023 21:18:10'!
PASSED!

!testRun: #TestXX #test04 stamp: 'MS 10/8/2023 21:18:10'!
PASSED!

!testRun: #TestXX #test05 stamp: 'MS 10/8/2023 21:18:10'!
PASSED!

!testRun: #TestXX #test06 stamp: 'MS 10/8/2023 21:18:10'!
PASSED!

!testRun: #TestXX #test07 stamp: 'MS 10/8/2023 21:18:10'!
PASSED!

!testRun: #TestXX #test08 stamp: 'MS 10/8/2023 21:18:10'!
PASSED!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:18:43'!
test04_
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'f'.
	self assert: (marsRover isIn: (6@4) andFacing: #East).! !

!methodRemoval: TestXX #test07 stamp: 'MS 10/8/2023 21:18:43'!
test07
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'f'.
	self assert: (marsRover isIn: (6@4) andFacing: #East).!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:18:51'!
test05_
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'b'.
	self assert: (marsRover isIn: (4@4) andFacing: #East).! !

!methodRemoval: TestXX #test08 stamp: 'MS 10/8/2023 21:18:51'!
test08
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'b'.
	self assert: (marsRover isIn: (4@4) andFacing: #East).!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:19:41'!
test05___
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'r'.
	self assert: (marsRover isIn: (5@4) andFacing: #South).! !

!methodRemoval: TestXX #test05 stamp: 'MS 10/8/2023 21:19:41'!
test05
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'r'.
	self assert: (marsRover isIn: (5@4) andFacing: #South).!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:19:46'!
test05
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'f'.
	self assert: (marsRover isIn: (6@4) andFacing: #East).! !

!methodRemoval: TestXX #test04_ stamp: 'MS 10/8/2023 21:19:46'!
test04_
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'f'.
	self assert: (marsRover isIn: (6@4) andFacing: #East).!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:20:46'!
test02_MarsRoverDoesNothingAfterProcessingEmptyString
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #North.
	marsRover process: ''.
	self assert: (marsRover isIn: (5@4) andFacing: #North).! !

!methodRemoval: TestXX #test02 stamp: 'MS 10/8/2023 21:20:46'!
test02
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #North.
	marsRover process: ''.
	self assert: (marsRover isIn: (5@4) andFacing: #North).!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:21:11'!
test03_MarsRoverMovesFowardsFacingNorth
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #North.
	marsRover process: 'f'.
	self assert: (marsRover isIn: (5@5) andFacing: #North).! !

!methodRemoval: TestXX #test03 stamp: 'MS 10/8/2023 21:21:11'!
test03
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #North.
	marsRover process: 'f'.
	self assert: (marsRover isIn: (5@5) andFacing: #North).!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:21:37'!
test04_MarsRoverMovesFowardFacingEast
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'f'.
	self assert: (marsRover isIn: (6@4) andFacing: #East).! !

!methodRemoval: TestXX #test05 stamp: 'MS 10/8/2023 21:21:37'!
test05
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'f'.
	self assert: (marsRover isIn: (6@4) andFacing: #East).!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:22:03'!
test05_MarsRoverMovesBackwardFacingNorth
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #North.
	marsRover process: 'b'.
	self assert: (marsRover isIn: (5@3) andFacing: #North).! !

!methodRemoval: TestXX #test04 stamp: 'MS 10/8/2023 21:22:03'!
test04
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #North.
	marsRover process: 'b'.
	self assert: (marsRover isIn: (5@3) andFacing: #North).!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:22:21'!
test06_MarsRoverMovesBackwardFacingEast
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'b'.
	self assert: (marsRover isIn: (4@4) andFacing: #East).! !

!methodRemoval: TestXX #test05_ stamp: 'MS 10/8/2023 21:22:21'!
test05_
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'b'.
	self assert: (marsRover isIn: (4@4) andFacing: #East).!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:22:38'!
test07_MarsRoverRotatesToTheRight
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'r'.
	self assert: (marsRover isIn: (5@4) andFacing: #South).! !

!methodRemoval: TestXX #test05___ stamp: 'MS 10/8/2023 21:22:38'!
test05___
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'r'.
	self assert: (marsRover isIn: (5@4) andFacing: #South).!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:22:53'!
test08_MarsRoverRotatesToTheLeft
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'l'.
	self assert: (marsRover isIn: (5@4) andFacing: #North).! !

!methodRemoval: TestXX #test06 stamp: 'MS 10/8/2023 21:22:53'!
test06
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'l'.
	self assert: (marsRover isIn: (5@4) andFacing: #North).!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:30:21' prior: 50695443!
process: aStringOfCommands 
	(aStringOfCommands = 'f') ifTrue: [
		currentPosition := currentPosition + currentDirection moveForward.
	].

	(aStringOfCommands = 'b') ifTrue: [
		currentPosition := currentPosition + currentDirection moveBackward.
	].

	(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
	(aStringOfCommands = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	! !
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:31:10'!
test09_
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'rf'.
	self assert: (marsRover isIn: (5@4) andFacing: #North).! !

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:31:11'!
FAILURE!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:31:22' prior: 50695694!
test09_
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'gf'.
	self assert: (marsRover isIn: (5@4) andFacing: #North).! !
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:31:31' prior: 50695704!
test09_
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #East.
	marsRover process: 'ff'.
	self assert: (marsRover isIn: (5@4) andFacing: #North).! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:31:38'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:31:38'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:31:38'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:31:38'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:31:38'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:31:38'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:31:38'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:31:38'!
PASSED!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:31:38'!
FAILURE!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:31:38'!
FAILURE!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:31:54' prior: 50695712!
test09_
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #North.
	marsRover process: 'ff'.
	self assert: (marsRover isIn: (5@6) andFacing: #North).! !

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:31:55'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:33:21' prior: 50695678!
process: aStringOfCommands 
	|index|
	index := 1.
	[index < aStringOfCommands length] whileTrue: [
		(aStringOfCommands = 'f') ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(aStringOfCommands = 'b') ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
		(aStringOfCommands = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	
	].! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:33:26'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:33:26'!
ERROR!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:33:26'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:33:26'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:33:26'!
ERROR!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:33:26'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:33:26'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:33:26'!
ERROR!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:33:26'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:33:57' prior: 50695761!
process: aStringOfCommands 
	|index|
	index := 1.
	(index < aStringOfCommands length+1) whileTrue: [
		(aStringOfCommands = 'f') ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(aStringOfCommands = 'b') ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
		(aStringOfCommands = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	
	].! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:33:59'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:33:59'!
ERROR!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:33:59'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:33:59'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:33:59'!
ERROR!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:33:59'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:33:59'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:33:59'!
ERROR!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:33:59'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:34:16' prior: 50695808!
process: aStringOfCommands 
	|index|
	index := 1.
	(index < aStringOfCommands length) whileTrue: [
		(aStringOfCommands = 'f') ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(aStringOfCommands = 'b') ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
		(aStringOfCommands = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	
	].! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:34:19'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:34:19'!
ERROR!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:34:19'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:34:19'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:34:19'!
ERROR!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:34:19'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:34:19'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:34:19'!
ERROR!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:34:19'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:34:39' prior: 50695855!
process: aStringOfCommands 
	|index|
	index := 1.
	(index < aStringOfCommands size) whileTrue: [
		(aStringOfCommands = 'f') ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(aStringOfCommands = 'b') ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(aStringOfCommands = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
		(aStringOfCommands = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	
	].! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:34:40'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:34:40'!
ERROR!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:34:40'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:34:40'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:34:40'!
ERROR!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:34:40'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:34:40'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:34:40'!
ERROR!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:34:40'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:36:21' prior: 50695902!
process: aStringOfCommands 
	|index|
	index := 1.
	(index < aStringOfCommands size) whileTrue: [ 
		| currentChar |
		currentChar := aStringOfCommands isAt: index.
		(currentChar = 'f') ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(currentChar = 'b') ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(currentChar = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
		(currentChar = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	
	].! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:36:21'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:36:21'!
ERROR!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:36:21'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:36:21'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:36:21'!
ERROR!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:36:21'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:36:21'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:36:21'!
ERROR!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:36:21'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:36:33' prior: 50695949!
process: aStringOfCommands 
	|index|
	index := 1.
	(index < aStringOfCommands size) whileTrue: [ 
		| currentChar |
		currentChar := aStringOfCommands at: index.
		(currentChar = 'f') ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(currentChar = 'b') ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(currentChar = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
		(currentChar = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	
	].! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:36:34'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:36:34'!
ERROR!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:36:34'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:36:34'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:36:34'!
ERROR!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:36:34'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:36:34'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:36:34'!
ERROR!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:36:34'!
ERROR!

'acacaca' at: 1!

'acacaca' at: 1!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:37:52' prior: 50695997!
process: aStringOfCommands 
	|index currentChar|
	index := 1.
	(index < aStringOfCommands size) whileTrue: [ 
		currentChar := aStringOfCommands at: index.
		(currentChar = 'f') ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(currentChar = 'b') ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(currentChar = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
		(currentChar = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	
	].! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:37:53'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:37:53'!
ERROR!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:37:53'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:37:53'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:37:53'!
ERROR!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:37:53'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:37:53'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:37:53'!
ERROR!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:37:53'!
ERROR!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:38:03'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:38:05'!
ERROR!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:38:05'!
ERROR!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:38:11'!
ERROR!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:38:11'!
ERROR!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:38:16'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:39:37' prior: 50696046!
process: aStringOfCommands 
	|index currentChar|
	index := 1.
	[index < aStringOfCommands size] whileTrue: [ 
		currentChar := aStringOfCommands at: index.
		(currentChar = 'f') ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(currentChar = 'b') ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(currentChar = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
		(currentChar = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	
	].! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:39:38'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:39:38'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:39:38'!
FAILURE!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:39:38'!
FAILURE!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:39:38'!
FAILURE!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:39:38'!
FAILURE!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:39:38'!
FAILURE!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:39:38'!
FAILURE!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:39:49'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:39:49'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:39:49'!
FAILURE!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:39:49'!
FAILURE!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:39:49'!
FAILURE!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:39:49'!
FAILURE!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:39:49'!
FAILURE!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:39:49'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:40:01' prior: 50696115!
process: aStringOfCommands 
	|index currentChar|
	index := 1.
	(index < aStringOfCommands size) whileTrue: [ 
		currentChar := aStringOfCommands at: index.
		(currentChar = 'f') ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(currentChar = 'b') ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(currentChar = 'r') ifTrue: [currentDirection := currentDirection rotateRight.].	
		(currentChar = 'l') ifTrue: [currentDirection := currentDirection rotateLeft.].	
	].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:40:47' prior: 50696187!
process: aStringOfCommands 
	|index currentChar|
	index := 1.
	(index < aStringOfCommands size) whileTrue: [ 
		currentChar := aStringOfCommands at: index.
		(currentChar = $f) ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(currentChar = $b) ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(currentChar = $r) ifTrue: [currentDirection := currentDirection rotateRight.].	
		(currentChar = $l) ifTrue: [currentDirection := currentDirection rotateLeft.].	
	].! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:40:49'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:40:49'!
ERROR!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:40:49'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:40:49'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:40:49'!
ERROR!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:40:49'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:40:49'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:40:49'!
ERROR!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:40:49'!
ERROR!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:40:56'!
ERROR!

'mira' at: 3!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:41:55' prior: 50696207!
process: aStringOfCommands 
	|index currentChar|
	index := 1.
	(index <= aStringOfCommands size) whileTrue: [ 
		currentChar := aStringOfCommands at: index.
		(currentChar = $f) ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(currentChar = $b) ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(currentChar = $r) ifTrue: [currentDirection := currentDirection rotateRight.].	
		(currentChar = $l) ifTrue: [currentDirection := currentDirection rotateLeft.].	
	].! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:41:56'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:41:56'!
ERROR!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:41:56'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:41:56'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:41:56'!
ERROR!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:41:56'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:41:56'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:41:56'!
ERROR!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:41:56'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:45:13' prior: 50696259!
process: aStringOfCommands 
	|index currentChar|
	index := 1.
	[ 
		currentChar := aStringOfCommands at: index.
		(currentChar = $f) ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(currentChar = $b) ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(currentChar = $r) ifTrue: [currentDirection := currentDirection rotateRight.].	
		(currentChar = $l) ifTrue: [currentDirection := currentDirection rotateLeft.].	
	] whileTrue: [index <= aStringOfCommands].! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:45:14'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:45:14'!
ERROR!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:45:14'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:45:14'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:45:14'!
ERROR!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:45:14'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:45:14'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:45:14'!
ERROR!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:45:14'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:47:35' prior: 50696307!
process: aStringOfCommands 
	|currentChar|
	1 to: aStringOfCommands size do: 
	[ : index | 
		currentChar := aStringOfCommands at: index.
		(currentChar = $f) ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(currentChar = $b) ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(currentChar = $r) ifTrue: [currentDirection := currentDirection rotateRight.].	
		(currentChar = $l) ifTrue: [currentDirection := currentDirection rotateLeft.].	
	]! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:47:37'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:47:37'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:47:37'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:47:37'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:47:37'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:47:37'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:47:37'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:47:37'!
PASSED!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:47:37'!
PASSED!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:48:00'!
processBatchOfCommands: aStringOfCommands 
	|currentChar|
	1 to: aStringOfCommands size do: 
	[ : index | 
		currentChar := aStringOfCommands at: index.
		(currentChar = $f) ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(currentChar = $b) ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(currentChar = $r) ifTrue: [currentDirection := currentDirection rotateRight.].	
		(currentChar = $l) ifTrue: [currentDirection := currentDirection rotateLeft.].	
	]! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:49:04'!
processSingleCommand: aStringOfCommands 
	aStringOfCommands do: [ :command | self process: command]! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:50:18' prior: 50696422!
processSingleCommand: aCommand 
	(aCommand = $f) ifTrue: [
		currentPosition := currentPosition + currentDirection moveForward.
	].

	(aCommand = $b) ifTrue: [
		currentPosition := currentPosition + currentDirection moveBackward.
	].

	(aCommand = $r) ifTrue: [currentDirection := currentDirection rotateRight.].	
	(aCommand = $l) ifTrue: [currentDirection := currentDirection rotateLeft.].	! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 21:50:53' prior: 50696355!
process: aStringOfCommands 
	aStringOfCommands do: [: aCommand | self processSingleCommand: aCommand]! !

!methodRemoval: MarsRover #processBatchOfCommands: stamp: 'MS 10/8/2023 21:50:59'!
processBatchOfCommands: aStringOfCommands 
	|currentChar|
	1 to: aStringOfCommands size do: 
	[ : index | 
		currentChar := aStringOfCommands at: index.
		(currentChar = $f) ifTrue: [
			currentPosition := currentPosition + currentDirection moveForward.
		].

		(currentChar = $b) ifTrue: [
			currentPosition := currentPosition + currentDirection moveBackward.
		].

		(currentChar = $r) ifTrue: [currentDirection := currentDirection rotateRight.].	
		(currentChar = $l) ifTrue: [currentDirection := currentDirection rotateLeft.].	
	]!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:51:11'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:51:11'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:51:11'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:51:11'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:51:11'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:51:11'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:51:11'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:51:11'!
PASSED!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:51:11'!
PASSED!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:59:01' prior: 50695750!
test09_
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #North.
	marsRover process: 'ffrfflffrbb'.
	self assert: (marsRover isIn: (0@4) andFacing: #East).! !

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:59:04'!
PASSED!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 21:59:04'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 21:59:04'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 21:59:04'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 21:59:04'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 21:59:04'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 21:59:04'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 21:59:04'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 21:59:04'!
PASSED!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 21:59:04'!
PASSED!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 21:59:48'!
test10_
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #North.
	marsRover process: 'ffrfflffrbb'.
	self assert: (marsRover isIn: (0@4) andFacing: #East).! !
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 22:00:32' prior: 50696535!
test10_
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #North.
	marsRover process: 'ffrff lffrbb'.
	self assert: (marsRover isIn: (2@2) andFacing: #East).! !

!testRun: #TestXX #test10_ stamp: 'MS 10/8/2023 22:00:33'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:03:03' prior: 50696445!
process: aStringOfCommands 
	aStringOfCommands do: [: aCommand | (#($f,$b,$r,$l) includes: aCommand) 
		ifTrue: [self processSingleCommand: aCommand]
		ifFalse: [^self].]! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:03:06'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:03:06'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:03:06'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:03:06'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:03:06'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:03:06'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:03:06'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:03:06'!
PASSED!

!testRun: #TestXX #test09_ stamp: 'MS 10/8/2023 22:03:06'!
PASSED!

!testRun: #TestXX #test10_ stamp: 'MS 10/8/2023 22:03:06'!
PASSED!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 22:03:53'!
test09_MarsRoverCanProcessMultipleCommands
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #North.
	marsRover process: 'ffrfflffrbb'.
	self assert: (marsRover isIn: (0@4) andFacing: #East).! !

!methodRemoval: TestXX #test09_ stamp: 'MS 10/8/2023 22:04:00'!
test09_
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #North.
	marsRover process: 'ffrfflffrbb'.
	self assert: (marsRover isIn: (0@4) andFacing: #East).!
!TestXX methodsFor: 'testing' stamp: 'MS 10/8/2023 22:04:33'!
test10_MarsRoverStopsProcessingAfterInvalidCommand
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #North.
	marsRover process: 'ffrff lffrbb'.
	self assert: (marsRover isIn: (2@2) andFacing: #East).! !

!methodRemoval: TestXX #test10_ stamp: 'MS 10/8/2023 22:04:44'!
test10_
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #North.
	marsRover process: 'ffrff lffrbb'.
	self assert: (marsRover isIn: (2@2) andFacing: #East).!

East class
	instanceVariableNames: 'East'!

!classDefinition: 'East class' category: 'Mars Rover' stamp: 'MS 10/8/2023 22:05:17'!
East class
	instanceVariableNames: 'East'!
!East class methodsFor: 'nil' stamp: 'MS 10/8/2023 22:06:23' overrides: 16904184!
initialize
	East := self basicNew.! !
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:06:40' overrides: 16785646!
new
	^East! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:06:44'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:06:44'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:06:44'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:06:44'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:06:44'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:06:44'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:06:44'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:06:44'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:06:44'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:06:44'!
ERROR!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:07:14'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:07:14'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:07:14'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:07:14'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:07:14'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:07:14'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:07:14'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:07:14'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:07:14'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:07:14'!
ERROR!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:07:47'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:07:47'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:07:47'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:07:47'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:07:47'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:07:47'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:07:47'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:07:47'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:07:47'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:07:47'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:07:49'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:08:02'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:08:02'!
ERROR!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:12:57' prior: 50696635 overrides: 16785646!
new
	East ifNil: [self initialize].
	^East! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:12:59'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:12:59'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:12:59'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:12:59'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:12:59'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:12:59'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:12:59'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:12:59'!
PASSED!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:12:59'!
PASSED!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:12:59'!
PASSED!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:13:19' prior: 50696745 overrides: 16785646!
new
	"East ifNil: [self initialize]."
	^East! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:13:19'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:13:19'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:13:19'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:13:19'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:13:19'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:13:19'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:13:19'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:13:19'!
PASSED!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:13:19'!
PASSED!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:13:19'!
PASSED!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:13:22' prior: 50696783 overrides: 16785646!
new
	"East ifNil: [self initialize]."
	^East! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:13:22'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:13:22'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:13:22'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:13:22'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:13:22'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:13:22'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:13:22'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:13:22'!
PASSED!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:13:22'!
PASSED!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:13:22'!
PASSED!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:13:32'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:13:32'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:13:32'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:13:32'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:13:32'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:13:32'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:13:32'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:13:32'!
PASSED!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:13:32'!
PASSED!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:13:32'!
PASSED!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:13:41' prior: 50696821 overrides: 16785646!
new
	East ifNil: [self initialize].
	^East! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:13:42'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:13:42'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:13:42'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:13:42'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:13:42'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:13:42'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:13:42'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:13:42'!
PASSED!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:13:42'!
PASSED!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:13:42'!
PASSED!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:13:45' prior: 50696891 overrides: 16785646!
new
	^East! !

East class
	instanceVariableNames: 'uniqueInstance'!

!classDefinition: 'East class' category: 'Mars Rover' stamp: 'MS 10/8/2023 22:16:56'!
East class
	instanceVariableNames: 'uniqueInstance'!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:17:05' prior: 50696630 overrides: 16904184!
initialize
	uniqueInstance = self basicNew.! !
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:17:14' prior: 50696929 overrides: 16785646!
new
	^uniqueInstance ! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:17:22'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:17:22'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:17:22'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:17:22'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:17:22'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:17:22'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:17:22'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:17:22'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:17:22'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:17:22'!
ERROR!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:18:06' prior: 50696946 overrides: 16785646!
new
	"uniqueInstance ifNil: [uniqueInstance := self ini]"
	^uniqueInstance ! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:18:08'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:18:08'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:18:08'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:18:08'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:18:08'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:18:08'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:18:08'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:18:08'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:18:08'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:18:08'!
ERROR!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:18:22'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:18:22'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:18:22'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:18:22'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:18:22'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:18:22'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:18:22'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:18:22'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:18:22'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:18:22'!
ERROR!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:18:33' prior: 50696983 overrides: 16785646!
new
	uniqueInstance ifNil: [uniqueInstance := self initialize]
	^uniqueInstance ! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:18:35'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:18:35'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:18:35'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:18:35'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:18:35'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:18:35'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:18:35'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:18:35'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:18:35'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:18:35'!
ERROR!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:18:51' prior: 50697054 overrides: 16785646!
new
	uniqueInstance ifNil: [uniqueInstance := self initialize].
	^uniqueInstance ! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:18:53'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:18:53'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:18:53'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:18:53'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:18:53'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:18:53'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:18:53'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:18:53'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:18:53'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:18:53'!
ERROR!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:19:14' prior: 50697093 overrides: 16785646!
new
	uniqueInstance ifNil: [self initialize].
	^uniqueInstance ! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:19:15'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:19:15'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:19:15'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:19:15'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:19:15'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:19:15'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:19:15'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:19:15'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:19:15'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:19:15'!
ERROR!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:19:25'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:19:25'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:19:25'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:19:25'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:19:25'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:19:25'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:19:25'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:19:25'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:19:25'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:19:25'!
ERROR!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:19:37' prior: 50696940 overrides: 16904184!
initialize
	uniqueInstance := self basicNew.! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:19:38'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:19:38'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:19:38'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:19:38'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:19:38'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:19:38'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:19:38'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:19:38'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:19:38'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:19:38'!
ERROR!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:19:43'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:19:43'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:19:43'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:19:43'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:19:43'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:19:43'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:19:43'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:19:43'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:19:43'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:19:43'!
ERROR!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:19:59' prior: 50697132 overrides: 16785646!
new
	"uniqueInstance ifNil: [self initialize]."
	^uniqueInstance ! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:20:09'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:20:09'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:20:09'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:20:09'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:20:09'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:20:09'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:20:09'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:20:09'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:20:09'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:20:09'!
ERROR!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:20:16' prior: 50697272 overrides: 16785646!
new
	uniqueInstance ifNil: [self initialize].
	^uniqueInstance ! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:20:18'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:20:18'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:20:18'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:20:18'!
ERROR!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:20:18'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:20:18'!
ERROR!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:20:18'!
ERROR!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:20:18'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:20:18'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:20:18'!
ERROR!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:20:37' prior: 50697310 overrides: 16785646!
new
	uniqueInstance := nil.
	uniqueInstance ifNil: [self initialize].
	^uniqueInstance ! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:20:44'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:20:44'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:20:44'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:20:44'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:20:44'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:20:44'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:20:44'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:20:44'!
PASSED!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:20:44'!
PASSED!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:20:44'!
PASSED!
!East class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:20:50' prior: 50697348 overrides: 16785646!
new
	^uniqueInstance ! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:20:51'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:20:51'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:20:51'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:20:51'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:20:51'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:20:51'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:20:51'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:20:51'!
PASSED!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:20:51'!
PASSED!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:20:51'!
PASSED!

North class
	instanceVariableNames: 'uniqueInstance'!

!classDefinition: 'North class' category: 'Mars Rover' stamp: 'MS 10/8/2023 22:22:19'!
North class
	instanceVariableNames: 'uniqueInstance'!
!North class methodsFor: 'nil' stamp: 'MS 10/8/2023 22:22:32' overrides: 16904184!
initialize
	uniqueInstance := self basicNew.! !
!North class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:22:43' overrides: 16785646!
new
	^uniqueInstance ! !

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:22:44'!
ERROR!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:22:44'!
ERROR!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:22:44'!
ERROR!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:22:44'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:22:44'!
ERROR!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:22:44'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:22:44'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:22:44'!
ERROR!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:22:44'!
ERROR!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:22:44'!
ERROR!

North initialize!

North initialize!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:22:58'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:22:58'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:22:58'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:22:58'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:22:58'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:22:58'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:22:58'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:22:58'!
PASSED!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:22:58'!
PASSED!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:22:58'!
PASSED!

!classDefinition: 'South class' category: 'Mars Rover' stamp: 'MS 10/8/2023 22:23:26'!
South class
	instanceVariableNames: 'uniqueInstance'!
!South class methodsFor: 'nil' stamp: 'MS 10/8/2023 22:23:25' overrides: 16904184!
initialize
	uniqueInstance := self basicNew.
	! !
!South class methodsFor: 'nil' stamp: 'MS 10/8/2023 22:23:38' overrides: 16785646!
new
	^uniqueInstance! !

South initialize!

!testRun: #TestXX #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:23:53'!
PASSED!

!testRun: #TestXX #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:23:53'!
PASSED!

!testRun: #TestXX #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:23:53'!
PASSED!

!testRun: #TestXX #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:23:53'!
PASSED!

!testRun: #TestXX #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:23:53'!
PASSED!

!testRun: #TestXX #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:23:53'!
PASSED!

!testRun: #TestXX #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:23:53'!
PASSED!

!testRun: #TestXX #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:23:53'!
PASSED!

!testRun: #TestXX #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:23:53'!
PASSED!

!testRun: #TestXX #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:23:53'!
PASSED!

West class
	instanceVariableNames: 'uniqueInstance'!

!classDefinition: 'West class' category: 'Mars Rover' stamp: 'MS 10/8/2023 22:24:02'!
West class
	instanceVariableNames: 'uniqueInstance'!
!West class methodsFor: 'nil' stamp: 'MS 10/8/2023 22:24:16' overrides: 16904184!
initialize
	uniqueInstance := self basicNew.! !
!West class methodsFor: 'as yet unclassified' stamp: 'MS 10/8/2023 22:24:32' overrides: 16785646!
new
	^uniqueInstance! !

West initialize!

!classRenamed: #TestXX as: #MarsRoverTestSuite stamp: 'MS 10/8/2023 22:25:59'!
Smalltalk renameClassNamed: #TestXX as: #MarsRoverTestSuite!
!MarsRoverTestSuite methodsFor: 'testing' stamp: 'MS 10/8/2023 22:26:20' prior: 50695647!
test07_MarsRoverRotatesToTheRight
	| marsRover |
	marsRover  := MarsRover in: (5@4) facing: #West.
	marsRover process: 'r'.
	self assert: (marsRover isIn: (5@4) andFacing: #North).! !

!testRun: #MarsRoverTestSuite #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:26:21'!
PASSED!

!testRun: #MarsRoverTestSuite #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:26:21'!
PASSED!

!testRun: #MarsRoverTestSuite #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:26:21'!
PASSED!

!testRun: #MarsRoverTestSuite #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:26:21'!
PASSED!

!testRun: #MarsRoverTestSuite #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:26:21'!
PASSED!

!testRun: #MarsRoverTestSuite #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:26:21'!
PASSED!

!testRun: #MarsRoverTestSuite #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:26:21'!
PASSED!

!testRun: #MarsRoverTestSuite #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:26:21'!
PASSED!

!testRun: #MarsRoverTestSuite #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:26:21'!
PASSED!

!testRun: #MarsRoverTestSuite #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:26:21'!
PASSED!

!testRun: #MarsRoverTestSuite #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:26:21'!
PASSED!

Sunday!

Sunday!

Sunday new!

True !

True !

True !

True !

!testRun: #MarsRoverTestSuite #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:30:40'!
PASSED!

!testRun: #MarsRoverTestSuite #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:30:40'!
PASSED!

!testRun: #MarsRoverTestSuite #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:30:40'!
PASSED!

!testRun: #MarsRoverTestSuite #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:30:40'!
PASSED!

!testRun: #MarsRoverTestSuite #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:30:40'!
PASSED!

!testRun: #MarsRoverTestSuite #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:30:40'!
PASSED!

!testRun: #MarsRoverTestSuite #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:30:40'!
PASSED!

!testRun: #MarsRoverTestSuite #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:30:40'!
PASSED!

!testRun: #MarsRoverTestSuite #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:30:40'!
PASSED!

!testRun: #MarsRoverTestSuite #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:30:40'!
PASSED!

!testRun: #MarsRoverTestSuite #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:30:40'!
PASSED!
!Behavior method!
canHandle: aDirectionSymbol
	#_coverageTracker9380100_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380100_
		cover: (31 to: 46)
		declaredAt: (12 to: 27)
		by: aDirectionSymbol.
	#_coverageTracker9380100_
		coverAll:
			{48 to: 48}
		evaluating: [
			receiver1 =
				(#_coverageTracker9380100_
					coverAll:
						{50 to: 55}
					byLiteralOrPseudoVariable: #South) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
new
	#_coverageTracker9380106_ markAsExecuted.
	^ #_coverageTracker9380106_
		cover: (7 to: 20)
		declaredAt: (7 to: 20)
		by: uniqueInstance.! !
!Behavior method!
initialize
	#_coverageTracker9380108_ markAsExecuted.
	#_coverageTracker9380108_
		cover: (13 to: 26)
		declaredAt: (13 to: 26)
		by:
			(uniqueInstance _ [ | receiver1 |
			receiver1 _ #_coverageTracker9380108_
				coverAll:
					{31 to: 34}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker9380108_
				coverAll:
					{36 to: 43}
				evaluating: [ receiver1 basicNew ]
				thatSends: #basicNew
				to: receiver1 ] value).! !
!Behavior method!
rotateRight
	#_coverageTracker9380143_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380143_
		coverAll:
			{15 to: 19}
		by: North.
	#_coverageTracker9380143_
		coverAll:
			{21 to: 23}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
rotateLeft
	#_coverageTracker9380145_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380145_
		coverAll:
			{14 to: 17}
		by: West.
	#_coverageTracker9380145_
		coverAll:
			{19 to: 21}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
initialize
	#_coverageTracker9380147_ markAsExecuted.
	#_coverageTracker9380147_
		cover: (13 to: 26)
		declaredAt: (13 to: 26)
		by:
			(uniqueInstance _ [ | receiver1 |
			receiver1 _ #_coverageTracker9380147_
				coverAll:
					{31 to: 34}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker9380147_
				coverAll:
					{36 to: 43}
				evaluating: [ receiver1 basicNew ]
				thatSends: #basicNew
				to: receiver1 ] value).! !
!Behavior method!
moveBackward
	#_coverageTracker9380149_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380149_
		coverAll:
			{18 to: 18}
		byLiteralOrPseudoVariable: 0.
	#_coverageTracker9380149_
		coverAll:
			{19 to: 19}
		evaluating: [
			receiver1 @
				(#_coverageTracker9380149_
					coverAll:
						{20 to: 20}
					byLiteralOrPseudoVariable: 1) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
moveBackward
	#_coverageTracker9380184_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380184_
		coverAll:
			{18 to: 18}
		byLiteralOrPseudoVariable: 0.
	#_coverageTracker9380184_
		coverAll:
			{19 to: 19}
		evaluating: [
			receiver1 @
				(#_coverageTracker9380184_
					coverAll:
						{20 to: 21}
					byLiteralOrPseudoVariable: -1) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
invalidSymbolError
	#_coverageTracker9380186_ markAsExecuted.
	^ #_coverageTracker9380186_
		coverAll:
			{22 to: 63}
		byLiteralOrPseudoVariable: 'This symbol is not a cardinal direction!!'.! !
!Behavior method!
moveForward
	#_coverageTracker9380186_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380186_
		coverAll:
			{16 to: 16}
		byLiteralOrPseudoVariable: 0.
	#_coverageTracker9380186_
		coverAll:
			{17 to: 17}
		evaluating: [
			receiver1 @
				(#_coverageTracker9380186_
					coverAll:
						{18 to: 18}
					byLiteralOrPseudoVariable: 1) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
processSingleCommand: aCommand
	#_coverageTracker9380190_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker9380190_
		cover: (35 to: 42)
		declaredAt: (23 to: 30)
		by: aCommand.
	#_coverageTracker9380190_
		coverAll:
			{44 to: 44}
		evaluating: [
			receiver1 =
				(#_coverageTracker9380190_
					coverAll:
						{46 to: 47}
					byLiteralOrPseudoVariable: $f) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker9380190_
		coverAll:
			{50 to: 56}
		evaluating: [
			receiver4 ifTrue: [
				#_coverageTracker9380190_
					cover: (81 to: 95)
					declaredAt: (62 to: 76)
					by:
						(currentPosition _ [ | receiver3 |
						receiver3 _ #_coverageTracker9380190_
							cover: (62 to: 76)
							declaredAt: (62 to: 76)
							by: currentPosition.
						#_coverageTracker9380190_
							coverAll:
								{97 to: 97}
							evaluating: [
								receiver3 +
									[ | receiver2 |
									receiver2 _ #_coverageTracker9380190_
										cover: (99 to: 114)
										declaredAt: (99 to: 114)
										by: currentDirection.
									#_coverageTracker9380190_
										coverAll:
											{116 to: 126}
										evaluating: [ receiver2 moveForward ]
										thatSends: #moveForward
										to: receiver2 ] value ]
							thatSends: #+
							to: receiver3 ] value) ]]
		thatSends: #ifTrue:
		to: receiver4 ] value.
	[ | receiver8 |
	receiver8 _ [ | receiver5 |
	receiver5 _ #_coverageTracker9380190_
		cover: (136 to: 143)
		declaredAt: (23 to: 30)
		by: aCommand.
	#_coverageTracker9380190_
		coverAll:
			{145 to: 145}
		evaluating: [
			receiver5 =
				(#_coverageTracker9380190_
					coverAll:
						{147 to: 148}
					byLiteralOrPseudoVariable: $b) ]
		thatSends: #=
		to: receiver5 ] value.
	#_coverageTracker9380190_
		coverAll:
			{151 to: 157}
		evaluating: [
			receiver8 ifTrue: [
				#_coverageTracker9380190_
					cover: (182 to: 196)
					declaredAt: (62 to: 76)
					by:
						(currentPosition _ [ | receiver7 |
						receiver7 _ #_coverageTracker9380190_
							cover: (163 to: 177)
							declaredAt: (62 to: 76)
							by: currentPosition.
						#_coverageTracker9380190_
							coverAll:
								{198 to: 198}
							evaluating: [
								receiver7 +
									[ | receiver6 |
									receiver6 _ #_coverageTracker9380190_
										cover: (200 to: 215)
										declaredAt: (99 to: 114)
										by: currentDirection.
									#_coverageTracker9380190_
										coverAll:
											{217 to: 228}
										evaluating: [ receiver6 moveBackward ]
										thatSends: #moveBackward
										to: receiver6 ] value ]
							thatSends: #+
							to: receiver7 ] value) ]]
		thatSends: #ifTrue:
		to: receiver8 ] value.
	[ | receiver11 |
	receiver11 _ [ | receiver9 |
	receiver9 _ #_coverageTracker9380190_
		cover: (238 to: 245)
		declaredAt: (23 to: 30)
		by: aCommand.
	#_coverageTracker9380190_
		coverAll:
			{247 to: 247}
		evaluating: [
			receiver9 =
				(#_coverageTracker9380190_
					coverAll:
						{249 to: 250}
					byLiteralOrPseudoVariable: $r) ]
		thatSends: #=
		to: receiver9 ] value.
	#_coverageTracker9380190_
		coverAll:
			{253 to: 259}
		evaluating: [
			receiver11 ifTrue: [
				#_coverageTracker9380190_
					cover: (282 to: 297)
					declaredAt: (99 to: 114)
					by:
						(currentDirection _ [ | receiver10 |
						receiver10 _ #_coverageTracker9380190_
							cover: (262 to: 277)
							declaredAt: (99 to: 114)
							by: currentDirection.
						#_coverageTracker9380190_
							coverAll:
								{299 to: 309}
							evaluating: [ receiver10 rotateRight ]
							thatSends: #rotateRight
							to: receiver10 ] value) ]]
		thatSends: #ifTrue:
		to: receiver11 ] value.
	[ | receiver14 |
	receiver14 _ [ | receiver12 |
	receiver12 _ #_coverageTracker9380190_
		cover: (317 to: 324)
		declaredAt: (23 to: 30)
		by: aCommand.
	#_coverageTracker9380190_
		coverAll:
			{326 to: 326}
		evaluating: [
			receiver12 =
				(#_coverageTracker9380190_
					coverAll:
						{328 to: 329}
					byLiteralOrPseudoVariable: $l) ]
		thatSends: #=
		to: receiver12 ] value.
	#_coverageTracker9380190_
		coverAll:
			{332 to: 338}
		evaluating: [
			receiver14 ifTrue: [
				#_coverageTracker9380190_
					cover: (361 to: 376)
					declaredAt: (99 to: 114)
					by:
						(currentDirection _ [ | receiver13 |
						receiver13 _ #_coverageTracker9380190_
							cover: (341 to: 356)
							declaredAt: (99 to: 114)
							by: currentDirection.
						#_coverageTracker9380190_
							coverAll:
								{378 to: 387}
							evaluating: [ receiver13 rotateLeft ]
							thatSends: #rotateLeft
							to: receiver13 ] value) ]]
		thatSends: #ifTrue:
		to: receiver14 ] value.! !
!Behavior method!
canHandle: aDirectionSymbol
	#_coverageTracker9380287_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380287_
		cover: (31 to: 46)
		declaredAt: (12 to: 27)
		by: aDirectionSymbol.
	#_coverageTracker9380287_
		coverAll:
			{48 to: 48}
		evaluating: [
			receiver1 =
				(#_coverageTracker9380287_
					coverAll:
						{50 to: 54}
					byLiteralOrPseudoVariable: #East) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
new
	#_coverageTracker9380289_ markAsExecuted.
	^ #_coverageTracker9380289_
		cover: (7 to: 20)
		declaredAt: (7 to: 20)
		by: uniqueInstance.! !
!Behavior method!
moveForward
	#_coverageTracker9380289_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380289_
		coverAll:
			{16 to: 16}
		byLiteralOrPseudoVariable: 1.
	#_coverageTracker9380289_
		coverAll:
			{17 to: 17}
		evaluating: [
			receiver1 @
				(#_coverageTracker9380289_
					coverAll:
						{18 to: 18}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
new
	#_coverageTracker9380291_ markAsExecuted.
	^ #_coverageTracker9380291_
		cover: (7 to: 20)
		declaredAt: (7 to: 20)
		by: uniqueInstance.! !
!Behavior method!
rotateLeft
	#_coverageTracker9380293_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380293_
		coverAll:
			{14 to: 18}
		by: North.
	#_coverageTracker9380293_
		coverAll:
			{20 to: 22}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
initialize
	#_coverageTracker9380316_ markAsExecuted.
	#_coverageTracker9380316_
		cover: (13 to: 26)
		declaredAt: (13 to: 26)
		by:
			(uniqueInstance _ [ | receiver1 |
			receiver1 _ #_coverageTracker9380316_
				coverAll:
					{31 to: 34}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker9380316_
				coverAll:
					{36 to: 43}
				evaluating: [ receiver1 basicNew ]
				thatSends: #basicNew
				to: receiver1 ] value).! !
!Behavior method!
canHandle: aDirectionSymbol
	#_coverageTracker9380318_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380318_
		cover: (31 to: 46)
		declaredAt: (12 to: 27)
		by: aDirectionSymbol.
	#_coverageTracker9380318_
		coverAll:
			{48 to: 48}
		evaluating: [
			receiver1 =
				(#_coverageTracker9380318_
					coverAll:
						{50 to: 54}
					byLiteralOrPseudoVariable: #West) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
initialize
	#_coverageTracker9380320_ markAsExecuted.
	#_coverageTracker9380320_
		cover: (13 to: 26)
		declaredAt: (13 to: 26)
		by:
			(uniqueInstance _ [ | receiver1 |
			receiver1 _ #_coverageTracker9380320_
				coverAll:
					{31 to: 34}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker9380320_
				coverAll:
					{36 to: 43}
				evaluating: [ receiver1 basicNew ]
				thatSends: #basicNew
				to: receiver1 ] value).! !
!Behavior method!
rotateRight
	#_coverageTracker9380322_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380322_
		coverAll:
			{15 to: 18}
		by: West.
	#_coverageTracker9380322_
		coverAll:
			{20 to: 22}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
in: initialPosition facing: initialDirection
	#_coverageTracker9380324_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker9380324_
		coverAll:
			{48 to: 51}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker9380324_
		coverAll:
			{53 to: 55}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker9380324_
		coverAll:
			{57 to: 59. 77 to: 83}
		evaluating: [
			receiver2
				in:
					(#_coverageTracker9380324_
						cover: (61 to: 75)
						declaredAt: (5 to: 19)
						by: initialPosition)
				facing:
					(#_coverageTracker9380324_
						cover: (85 to: 100)
						declaredAt: (29 to: 44)
						by: initialDirection) ]
		thatSends: #in:facing:
		to: receiver2 ] value.! !
!Behavior method!
symbol
	#_coverageTracker9380367_ markAsExecuted.
	^ #_coverageTracker9380367_
		coverAll:
			{10 to: 15}
		byLiteralOrPseudoVariable: #North.! !
!Behavior method!
isIn: aPosition andFacing: aDirection
	#_coverageTracker9380369_ markAsExecuted.
	^ [ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker9380369_
		cover: (42 to: 56)
		declaredAt: (42 to: 56)
		by: currentPosition.
	#_coverageTracker9380369_
		coverAll:
			{58 to: 58}
		evaluating: [
			receiver1 =
				(#_coverageTracker9380369_
					cover: (60 to: 68)
					declaredAt: (7 to: 15)
					by: aPosition) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker9380369_
		coverAll:
			{71 to: 74}
		evaluating: [
			receiver4 and: [
				[ | receiver3 |
				receiver3 _ [ | receiver2 |
				receiver2 _ #_coverageTracker9380369_
					cover: (77 to: 92)
					declaredAt: (77 to: 92)
					by: currentDirection.
				#_coverageTracker9380369_
					coverAll:
						{94 to: 99}
					evaluating: [ receiver2 symbol ]
					thatSends: #symbol
					to: receiver2 ] value.
				#_coverageTracker9380369_
					coverAll:
						{101 to: 101}
					evaluating: [
						receiver3 =
							(#_coverageTracker9380369_
								cover: (103 to: 112)
								declaredAt: (28 to: 37)
								by: aDirection) ]
					thatSends: #=
					to: receiver3 ] value ]]
		thatSends: #and:
		to: receiver4 ] value.! !
!Behavior method!
in: initialPosition facing: initialDirection
	#_coverageTracker9380400_ markAsExecuted.
	#_coverageTracker9380400_
		cover: (48 to: 62)
		declaredAt: (48 to: 62)
		by:
			(currentPosition _ #_coverageTracker9380400_
				cover: (67 to: 81)
				declaredAt: (5 to: 19)
				by: initialPosition).
	#_coverageTracker9380400_
		cover: (85 to: 100)
		declaredAt: (85 to: 100)
		by:
			(currentDirection _ [ | receiver1 |
			receiver1 _ #_coverageTracker9380400_
				coverAll:
					{105 to: 122}
				by: CardinalDirections.
			#_coverageTracker9380400_
				coverAll:
					{124 to: 132}
				evaluating: [
					receiver1 pointing:
						(#_coverageTracker9380400_
							cover: (134 to: 149)
							declaredAt: (29 to: 44)
							by: initialDirection) ]
				thatSends: #pointing:
				to: receiver1 ] value).! !
!Behavior method!
moveBackward
	#_coverageTracker9380402_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380402_
		coverAll:
			{18 to: 18}
		byLiteralOrPseudoVariable: 1.
	#_coverageTracker9380402_
		coverAll:
			{19 to: 19}
		evaluating: [
			receiver1 @
				(#_coverageTracker9380402_
					coverAll:
						{20 to: 20}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
moveBackward
	#_coverageTracker9380404_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380404_
		coverAll:
			{17 to: 18}
		byLiteralOrPseudoVariable: -1.
	#_coverageTracker9380404_
		coverAll:
			{19 to: 19}
		evaluating: [
			receiver1 @
				(#_coverageTracker9380404_
					coverAll:
						{20 to: 20}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
process: aStringOfCommands
	#_coverageTracker9380406_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ #_coverageTracker9380406_
		cover: (30 to: 46)
		declaredAt: (10 to: 26)
		by: aStringOfCommands.
	#_coverageTracker9380406_
		coverAll:
			{48 to: 50}
		evaluating: [
			receiver4 do: [ :aCommand |
				[ | receiver3 |
				receiver3 _ [ | receiver1 |
				receiver1 _ #_coverageTracker9380406_
					coverAll:
						{67 to: 80}
					byLiteralOrPseudoVariable: #($f #, $b #, $r #, $l ).
				#_coverageTracker9380406_
					coverAll:
						{82 to: 90}
					evaluating: [
						receiver1 includes:
							(#_coverageTracker9380406_
								cover: (92 to: 99)
								declaredAt: (55 to: 62)
								by: aCommand) ]
					thatSends: #includes:
					to: receiver1 ] value.
				#_coverageTracker9380406_
					coverAll:
						{105 to: 111. 153 to: 160}
					evaluating: [
						receiver3
							ifTrue: [
								[ | receiver2 |
								receiver2 _ #_coverageTracker9380406_
									coverAll:
										{114 to: 117}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker9380406_
									coverAll:
										{119 to: 139}
									evaluating: [
										receiver2 processSingleCommand:
											(#_coverageTracker9380406_
												cover: (141 to: 148)
												declaredAt: (55 to: 62)
												by: aCommand) ]
									thatSends: #processSingleCommand:
									to: receiver2 ] value ]
							ifFalse: [ ^ #_coverageTracker9380406_
									coverAll:
										{164 to: 167}
									byLiteralOrPseudoVariable: self ]]
					thatSends: #ifTrue:ifFalse:
					to: receiver3 ] value ]]
		thatSends: #do:
		to: receiver4 ] value.! !
!Behavior method!
symbol
	#_coverageTracker9380435_ markAsExecuted.
	^ #_coverageTracker9380435_
		coverAll:
			{10 to: 15}
		byLiteralOrPseudoVariable: #South.! !
!Behavior method!
rotateRight
	#_coverageTracker9380435_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380435_
		coverAll:
			{15 to: 18}
		by: East.
	#_coverageTracker9380435_
		coverAll:
			{20 to: 22}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
symbol
	#_coverageTracker9380437_ markAsExecuted.
	^ #_coverageTracker9380437_
		coverAll:
			{10 to: 14}
		byLiteralOrPseudoVariable: #West.! !
!Behavior method!
rotateLeft
	#_coverageTracker9380437_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380437_
		coverAll:
			{14 to: 18}
		by: South.
	#_coverageTracker9380437_
		coverAll:
			{20 to: 22}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
moveForward
	#_coverageTracker9380460_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380460_
		coverAll:
			{16 to: 16}
		byLiteralOrPseudoVariable: 0.
	#_coverageTracker9380460_
		coverAll:
			{17 to: 17}
		evaluating: [
			receiver1 @
				(#_coverageTracker9380460_
					coverAll:
						{18 to: 19}
					byLiteralOrPseudoVariable: -1) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
new
	#_coverageTracker9380462_ markAsExecuted.
	^ #_coverageTracker9380462_
		cover: (7 to: 20)
		declaredAt: (7 to: 20)
		by: uniqueInstance.! !
!Behavior method!
canHandle: aDirectionSymbol
	#_coverageTracker9380464_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380464_
		cover: (31 to: 46)
		declaredAt: (12 to: 27)
		by: aDirectionSymbol.
	#_coverageTracker9380464_
		coverAll:
			{48 to: 48}
		evaluating: [
			receiver1 =
				(#_coverageTracker9380464_
					coverAll:
						{50 to: 55}
					byLiteralOrPseudoVariable: #North) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
rotateLeft
	#_coverageTracker9380466_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380466_
		coverAll:
			{14 to: 17}
		by: East.
	#_coverageTracker9380466_
		coverAll:
			{19 to: 21}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
moveForward
	#_coverageTracker9380468_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380468_
		coverAll:
			{16 to: 17}
		byLiteralOrPseudoVariable: -1.
	#_coverageTracker9380468_
		coverAll:
			{18 to: 18}
		evaluating: [
			receiver1 @
				(#_coverageTracker9380468_
					coverAll:
						{19 to: 19}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
rotateRight
	#_coverageTracker9380468_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9380468_
		coverAll:
			{15 to: 19}
		by: South.
	#_coverageTracker9380468_
		coverAll:
			{21 to: 23}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
pointing: aDirectionSymbol
	#_coverageTracker9380492_ markAsExecuted.
	^ [ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ [ | receiver1 |
	receiver1 _ #_coverageTracker9380492_
		coverAll:
			{31 to: 34}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker9380492_
		coverAll:
			{36 to: 45}
		evaluating: [ receiver1 subclasses ]
		thatSends: #subclasses
		to: receiver1 ] value.
	#_coverageTracker9380492_
		coverAll:
			{47 to: 53. 128 to: 134}
		evaluating: [
			receiver5
				detect: [ :aCardinalDirection |
					[ | receiver2 |
					receiver2 _ #_coverageTracker9380492_
						cover: (79 to: 96)
						declaredAt: (58 to: 75)
						by: aCardinalDirection.
					#_coverageTracker9380492_
						coverAll:
							{98 to: 107}
						evaluating: [
							receiver2 canHandle:
								(#_coverageTracker9380492_
									cover: (109 to: 124)
									declaredAt: (11 to: 26)
									by: aDirectionSymbol) ]
						thatSends: #canHandle:
						to: receiver2 ] value ]
				ifNone: [
					[ | receiver4 |
					receiver4 _ #_coverageTracker9380492_
						coverAll:
							{137 to: 140}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker9380492_
						coverAll:
							{142 to: 147}
						evaluating: [
							receiver4 error:
								[ | receiver3 |
								receiver3 _ #_coverageTracker9380492_
									coverAll:
										{149 to: 152}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker9380492_
									coverAll:
										{154 to: 171}
									evaluating: [ receiver3 invalidSymbolError ]
									thatSends: #invalidSymbolError
									to: receiver3 ] value ]
						thatSends: #error:
						to: receiver4 ] value ]]
		thatSends: #detect:ifNone:
		to: receiver5 ] value.
	#_coverageTracker9380492_
		coverAll:
			{175 to: 177}
		evaluating: [ receiver6 new ]
		thatSends: #new
		to: receiver6 ] value.! !
!Behavior method!
symbol
	#_coverageTracker9380501_ markAsExecuted.
	^ #_coverageTracker9380501_
		coverAll:
			{10 to: 14}
		byLiteralOrPseudoVariable: #East.! !

!testRun: #MarsRoverTestSuite #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:31:22'!
PASSED!

!testRun: #MarsRoverTestSuite #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:31:22'!
PASSED!

!testRun: #MarsRoverTestSuite #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:31:22'!
PASSED!

!testRun: #MarsRoverTestSuite #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:31:22'!
PASSED!

!testRun: #MarsRoverTestSuite #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:31:22'!
PASSED!

!testRun: #MarsRoverTestSuite #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:31:22'!
PASSED!

!testRun: #MarsRoverTestSuite #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:31:22'!
PASSED!

!testRun: #MarsRoverTestSuite #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:31:22'!
PASSED!

!testRun: #MarsRoverTestSuite #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:31:22'!
PASSED!

!testRun: #MarsRoverTestSuite #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:31:22'!
PASSED!
!MarsRoverTestSuite methodsFor: 'testing' stamp: 'MS 10/8/2023 22:32:47'!
test11_
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #South.
	marsRover process: 'ffb'.
	self assert: (marsRover isIn: (2@2) andFacing: #East).! !
!MarsRoverTestSuite methodsFor: 'testing' stamp: 'MS 10/8/2023 22:33:55' prior: 50698410!
test11_
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #South.
	marsRover process: 'ffblffblffblffb'.
	self assert: (marsRover isIn: (0@0) andFacing: #East).! !

!testRun: #MarsRoverTestSuite #test11_ stamp: 'MS 10/8/2023 22:33:55'!
FAILURE!

!testRun: #MarsRoverTestSuite #test11_ stamp: 'MS 10/8/2023 22:34:32'!
FAILURE!

!testRun: #MarsRoverTestSuite #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:37:00'!
PASSED!

!testRun: #MarsRoverTestSuite #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:37:00'!
PASSED!

!testRun: #MarsRoverTestSuite #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:37:00'!
PASSED!

!testRun: #MarsRoverTestSuite #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:37:00'!
PASSED!

!testRun: #MarsRoverTestSuite #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:37:00'!
PASSED!

!testRun: #MarsRoverTestSuite #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:37:00'!
PASSED!

!testRun: #MarsRoverTestSuite #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:37:00'!
PASSED!

!testRun: #MarsRoverTestSuite #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:37:00'!
PASSED!

!testRun: #MarsRoverTestSuite #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:37:00'!
PASSED!

!testRun: #MarsRoverTestSuite #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:37:00'!
PASSED!

!testRun: #MarsRoverTestSuite #test11_ stamp: 'MS 10/8/2023 22:37:00'!
FAILURE!

!testRun: #MarsRoverTestSuite #test11_ stamp: 'MS 10/8/2023 22:37:00'!
FAILURE!
!MarsRoverTestSuite methodsFor: 'testing' stamp: 'MS 10/8/2023 22:37:51' prior: 50698418!
test11_
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #South.
	marsRover process: 'ffblffblffblffb'.
	self assert: (marsRover isIn: (0@0) andFacing: #West).! !

!testRun: #MarsRoverTestSuite #test11_ stamp: 'MS 10/8/2023 22:37:55'!
PASSED!

!testRun: #MarsRoverTestSuite #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:37:56'!
PASSED!

!testRun: #MarsRoverTestSuite #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:37:56'!
PASSED!

!testRun: #MarsRoverTestSuite #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:37:56'!
PASSED!

!testRun: #MarsRoverTestSuite #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:37:56'!
PASSED!

!testRun: #MarsRoverTestSuite #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:37:56'!
PASSED!

!testRun: #MarsRoverTestSuite #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:37:56'!
PASSED!

!testRun: #MarsRoverTestSuite #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:37:56'!
PASSED!

!testRun: #MarsRoverTestSuite #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:37:56'!
PASSED!

!testRun: #MarsRoverTestSuite #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:37:56'!
PASSED!

!testRun: #MarsRoverTestSuite #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:37:56'!
PASSED!

!testRun: #MarsRoverTestSuite #test11_ stamp: 'MS 10/8/2023 22:37:56'!
PASSED!
!Behavior method!
canHandle: aDirectionSymbol
	#_coverageTracker9780944_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9780944_
		cover: (31 to: 46)
		declaredAt: (12 to: 27)
		by: aDirectionSymbol.
	#_coverageTracker9780944_
		coverAll:
			{48 to: 48}
		evaluating: [
			receiver1 =
				(#_coverageTracker9780944_
					coverAll:
						{50 to: 55}
					byLiteralOrPseudoVariable: #South) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
new
	#_coverageTracker9780950_ markAsExecuted.
	^ #_coverageTracker9780950_
		cover: (7 to: 20)
		declaredAt: (7 to: 20)
		by: uniqueInstance.! !
!Behavior method!
initialize
	#_coverageTracker9780952_ markAsExecuted.
	#_coverageTracker9780952_
		cover: (13 to: 26)
		declaredAt: (13 to: 26)
		by:
			(uniqueInstance _ [ | receiver1 |
			receiver1 _ #_coverageTracker9780952_
				coverAll:
					{31 to: 34}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker9780952_
				coverAll:
					{36 to: 43}
				evaluating: [ receiver1 basicNew ]
				thatSends: #basicNew
				to: receiver1 ] value).! !
!Behavior method!
rotateRight
	#_coverageTracker9780987_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9780987_
		coverAll:
			{15 to: 19}
		by: North.
	#_coverageTracker9780987_
		coverAll:
			{21 to: 23}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
rotateLeft
	#_coverageTracker9780989_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9780989_
		coverAll:
			{14 to: 17}
		by: West.
	#_coverageTracker9780989_
		coverAll:
			{19 to: 21}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
initialize
	#_coverageTracker9780991_ markAsExecuted.
	#_coverageTracker9780991_
		cover: (13 to: 26)
		declaredAt: (13 to: 26)
		by:
			(uniqueInstance _ [ | receiver1 |
			receiver1 _ #_coverageTracker9780991_
				coverAll:
					{31 to: 34}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker9780991_
				coverAll:
					{36 to: 43}
				evaluating: [ receiver1 basicNew ]
				thatSends: #basicNew
				to: receiver1 ] value).! !
!Behavior method!
moveBackward
	#_coverageTracker9781026_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781026_
		coverAll:
			{18 to: 18}
		byLiteralOrPseudoVariable: 0.
	#_coverageTracker9781026_
		coverAll:
			{19 to: 19}
		evaluating: [
			receiver1 @
				(#_coverageTracker9781026_
					coverAll:
						{20 to: 20}
					byLiteralOrPseudoVariable: 1) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
moveBackward
	#_coverageTracker9781030_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781030_
		coverAll:
			{18 to: 18}
		byLiteralOrPseudoVariable: 0.
	#_coverageTracker9781030_
		coverAll:
			{19 to: 19}
		evaluating: [
			receiver1 @
				(#_coverageTracker9781030_
					coverAll:
						{20 to: 21}
					byLiteralOrPseudoVariable: -1) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
invalidSymbolError
	#_coverageTracker9781032_ markAsExecuted.
	^ #_coverageTracker9781032_
		coverAll:
			{22 to: 63}
		byLiteralOrPseudoVariable: 'This symbol is not a cardinal direction!!'.! !
!Behavior method!
moveForward
	#_coverageTracker9781034_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781034_
		coverAll:
			{16 to: 16}
		byLiteralOrPseudoVariable: 0.
	#_coverageTracker9781034_
		coverAll:
			{17 to: 17}
		evaluating: [
			receiver1 @
				(#_coverageTracker9781034_
					coverAll:
						{18 to: 18}
					byLiteralOrPseudoVariable: 1) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
processSingleCommand: aCommand
	#_coverageTracker9781059_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker9781059_
		cover: (35 to: 42)
		declaredAt: (23 to: 30)
		by: aCommand.
	#_coverageTracker9781059_
		coverAll:
			{44 to: 44}
		evaluating: [
			receiver1 =
				(#_coverageTracker9781059_
					coverAll:
						{46 to: 47}
					byLiteralOrPseudoVariable: $f) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker9781059_
		coverAll:
			{50 to: 56}
		evaluating: [
			receiver4 ifTrue: [
				#_coverageTracker9781059_
					cover: (81 to: 95)
					declaredAt: (62 to: 76)
					by:
						(currentPosition _ [ | receiver3 |
						receiver3 _ #_coverageTracker9781059_
							cover: (62 to: 76)
							declaredAt: (62 to: 76)
							by: currentPosition.
						#_coverageTracker9781059_
							coverAll:
								{97 to: 97}
							evaluating: [
								receiver3 +
									[ | receiver2 |
									receiver2 _ #_coverageTracker9781059_
										cover: (99 to: 114)
										declaredAt: (99 to: 114)
										by: currentDirection.
									#_coverageTracker9781059_
										coverAll:
											{116 to: 126}
										evaluating: [ receiver2 moveForward ]
										thatSends: #moveForward
										to: receiver2 ] value ]
							thatSends: #+
							to: receiver3 ] value) ]]
		thatSends: #ifTrue:
		to: receiver4 ] value.
	[ | receiver8 |
	receiver8 _ [ | receiver5 |
	receiver5 _ #_coverageTracker9781059_
		cover: (136 to: 143)
		declaredAt: (23 to: 30)
		by: aCommand.
	#_coverageTracker9781059_
		coverAll:
			{145 to: 145}
		evaluating: [
			receiver5 =
				(#_coverageTracker9781059_
					coverAll:
						{147 to: 148}
					byLiteralOrPseudoVariable: $b) ]
		thatSends: #=
		to: receiver5 ] value.
	#_coverageTracker9781059_
		coverAll:
			{151 to: 157}
		evaluating: [
			receiver8 ifTrue: [
				#_coverageTracker9781059_
					cover: (182 to: 196)
					declaredAt: (62 to: 76)
					by:
						(currentPosition _ [ | receiver7 |
						receiver7 _ #_coverageTracker9781059_
							cover: (163 to: 177)
							declaredAt: (62 to: 76)
							by: currentPosition.
						#_coverageTracker9781059_
							coverAll:
								{198 to: 198}
							evaluating: [
								receiver7 +
									[ | receiver6 |
									receiver6 _ #_coverageTracker9781059_
										cover: (200 to: 215)
										declaredAt: (99 to: 114)
										by: currentDirection.
									#_coverageTracker9781059_
										coverAll:
											{217 to: 228}
										evaluating: [ receiver6 moveBackward ]
										thatSends: #moveBackward
										to: receiver6 ] value ]
							thatSends: #+
							to: receiver7 ] value) ]]
		thatSends: #ifTrue:
		to: receiver8 ] value.
	[ | receiver11 |
	receiver11 _ [ | receiver9 |
	receiver9 _ #_coverageTracker9781059_
		cover: (238 to: 245)
		declaredAt: (23 to: 30)
		by: aCommand.
	#_coverageTracker9781059_
		coverAll:
			{247 to: 247}
		evaluating: [
			receiver9 =
				(#_coverageTracker9781059_
					coverAll:
						{249 to: 250}
					byLiteralOrPseudoVariable: $r) ]
		thatSends: #=
		to: receiver9 ] value.
	#_coverageTracker9781059_
		coverAll:
			{253 to: 259}
		evaluating: [
			receiver11 ifTrue: [
				#_coverageTracker9781059_
					cover: (282 to: 297)
					declaredAt: (99 to: 114)
					by:
						(currentDirection _ [ | receiver10 |
						receiver10 _ #_coverageTracker9781059_
							cover: (262 to: 277)
							declaredAt: (99 to: 114)
							by: currentDirection.
						#_coverageTracker9781059_
							coverAll:
								{299 to: 309}
							evaluating: [ receiver10 rotateRight ]
							thatSends: #rotateRight
							to: receiver10 ] value) ]]
		thatSends: #ifTrue:
		to: receiver11 ] value.
	[ | receiver14 |
	receiver14 _ [ | receiver12 |
	receiver12 _ #_coverageTracker9781059_
		cover: (317 to: 324)
		declaredAt: (23 to: 30)
		by: aCommand.
	#_coverageTracker9781059_
		coverAll:
			{326 to: 326}
		evaluating: [
			receiver12 =
				(#_coverageTracker9781059_
					coverAll:
						{328 to: 329}
					byLiteralOrPseudoVariable: $l) ]
		thatSends: #=
		to: receiver12 ] value.
	#_coverageTracker9781059_
		coverAll:
			{332 to: 338}
		evaluating: [
			receiver14 ifTrue: [
				#_coverageTracker9781059_
					cover: (361 to: 376)
					declaredAt: (99 to: 114)
					by:
						(currentDirection _ [ | receiver13 |
						receiver13 _ #_coverageTracker9781059_
							cover: (341 to: 356)
							declaredAt: (99 to: 114)
							by: currentDirection.
						#_coverageTracker9781059_
							coverAll:
								{378 to: 387}
							evaluating: [ receiver13 rotateLeft ]
							thatSends: #rotateLeft
							to: receiver13 ] value) ]]
		thatSends: #ifTrue:
		to: receiver14 ] value.! !
!Behavior method!
canHandle: aDirectionSymbol
	#_coverageTracker9781137_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781137_
		cover: (31 to: 46)
		declaredAt: (12 to: 27)
		by: aDirectionSymbol.
	#_coverageTracker9781137_
		coverAll:
			{48 to: 48}
		evaluating: [
			receiver1 =
				(#_coverageTracker9781137_
					coverAll:
						{50 to: 54}
					byLiteralOrPseudoVariable: #East) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
new
	#_coverageTracker9781160_ markAsExecuted.
	^ #_coverageTracker9781160_
		cover: (7 to: 20)
		declaredAt: (7 to: 20)
		by: uniqueInstance.! !
!Behavior method!
moveForward
	#_coverageTracker9781162_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781162_
		coverAll:
			{16 to: 16}
		byLiteralOrPseudoVariable: 1.
	#_coverageTracker9781162_
		coverAll:
			{17 to: 17}
		evaluating: [
			receiver1 @
				(#_coverageTracker9781162_
					coverAll:
						{18 to: 18}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
new
	#_coverageTracker9781164_ markAsExecuted.
	^ #_coverageTracker9781164_
		cover: (7 to: 20)
		declaredAt: (7 to: 20)
		by: uniqueInstance.! !
!Behavior method!
rotateLeft
	#_coverageTracker9781166_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781166_
		coverAll:
			{14 to: 18}
		by: North.
	#_coverageTracker9781166_
		coverAll:
			{20 to: 22}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
initialize
	#_coverageTracker9781191_ markAsExecuted.
	#_coverageTracker9781191_
		cover: (13 to: 26)
		declaredAt: (13 to: 26)
		by:
			(uniqueInstance _ [ | receiver1 |
			receiver1 _ #_coverageTracker9781191_
				coverAll:
					{31 to: 34}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker9781191_
				coverAll:
					{36 to: 43}
				evaluating: [ receiver1 basicNew ]
				thatSends: #basicNew
				to: receiver1 ] value).! !
!Behavior method!
canHandle: aDirectionSymbol
	#_coverageTracker9781211_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781211_
		cover: (31 to: 46)
		declaredAt: (12 to: 27)
		by: aDirectionSymbol.
	#_coverageTracker9781211_
		coverAll:
			{48 to: 48}
		evaluating: [
			receiver1 =
				(#_coverageTracker9781211_
					coverAll:
						{50 to: 54}
					byLiteralOrPseudoVariable: #West) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
initialize
	#_coverageTracker9781215_ markAsExecuted.
	#_coverageTracker9781215_
		cover: (13 to: 26)
		declaredAt: (13 to: 26)
		by:
			(uniqueInstance _ [ | receiver1 |
			receiver1 _ #_coverageTracker9781215_
				coverAll:
					{31 to: 34}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker9781215_
				coverAll:
					{36 to: 43}
				evaluating: [ receiver1 basicNew ]
				thatSends: #basicNew
				to: receiver1 ] value).! !
!Behavior method!
rotateRight
	#_coverageTracker9781244_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781244_
		coverAll:
			{15 to: 18}
		by: West.
	#_coverageTracker9781244_
		coverAll:
			{20 to: 22}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
in: initialPosition facing: initialDirection
	#_coverageTracker9781246_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker9781246_
		coverAll:
			{48 to: 51}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker9781246_
		coverAll:
			{53 to: 55}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker9781246_
		coverAll:
			{57 to: 59. 77 to: 83}
		evaluating: [
			receiver2
				in:
					(#_coverageTracker9781246_
						cover: (61 to: 75)
						declaredAt: (5 to: 19)
						by: initialPosition)
				facing:
					(#_coverageTracker9781246_
						cover: (85 to: 100)
						declaredAt: (29 to: 44)
						by: initialDirection) ]
		thatSends: #in:facing:
		to: receiver2 ] value.! !
!Behavior method!
symbol
	#_coverageTracker9781250_ markAsExecuted.
	^ #_coverageTracker9781250_
		coverAll:
			{10 to: 15}
		byLiteralOrPseudoVariable: #North.! !
!Behavior method!
isIn: aPosition andFacing: aDirection
	#_coverageTracker9781273_ markAsExecuted.
	^ [ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker9781273_
		cover: (42 to: 56)
		declaredAt: (42 to: 56)
		by: currentPosition.
	#_coverageTracker9781273_
		coverAll:
			{58 to: 58}
		evaluating: [
			receiver1 =
				(#_coverageTracker9781273_
					cover: (60 to: 68)
					declaredAt: (7 to: 15)
					by: aPosition) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker9781273_
		coverAll:
			{71 to: 74}
		evaluating: [
			receiver4 and: [
				[ | receiver3 |
				receiver3 _ [ | receiver2 |
				receiver2 _ #_coverageTracker9781273_
					cover: (77 to: 92)
					declaredAt: (77 to: 92)
					by: currentDirection.
				#_coverageTracker9781273_
					coverAll:
						{94 to: 99}
					evaluating: [ receiver2 symbol ]
					thatSends: #symbol
					to: receiver2 ] value.
				#_coverageTracker9781273_
					coverAll:
						{101 to: 101}
					evaluating: [
						receiver3 =
							(#_coverageTracker9781273_
								cover: (103 to: 112)
								declaredAt: (28 to: 37)
								by: aDirection) ]
					thatSends: #=
					to: receiver3 ] value ]]
		thatSends: #and:
		to: receiver4 ] value.! !
!Behavior method!
in: initialPosition facing: initialDirection
	#_coverageTracker9781279_ markAsExecuted.
	#_coverageTracker9781279_
		cover: (48 to: 62)
		declaredAt: (48 to: 62)
		by:
			(currentPosition _ #_coverageTracker9781279_
				cover: (67 to: 81)
				declaredAt: (5 to: 19)
				by: initialPosition).
	#_coverageTracker9781279_
		cover: (85 to: 100)
		declaredAt: (85 to: 100)
		by:
			(currentDirection _ [ | receiver1 |
			receiver1 _ #_coverageTracker9781279_
				coverAll:
					{105 to: 122}
				by: CardinalDirections.
			#_coverageTracker9781279_
				coverAll:
					{124 to: 132}
				evaluating: [
					receiver1 pointing:
						(#_coverageTracker9781279_
							cover: (134 to: 149)
							declaredAt: (29 to: 44)
							by: initialDirection) ]
				thatSends: #pointing:
				to: receiver1 ] value).! !
!Behavior method!
moveBackward
	#_coverageTracker9781306_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781306_
		coverAll:
			{18 to: 18}
		byLiteralOrPseudoVariable: 1.
	#_coverageTracker9781306_
		coverAll:
			{19 to: 19}
		evaluating: [
			receiver1 @
				(#_coverageTracker9781306_
					coverAll:
						{20 to: 20}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
moveBackward
	#_coverageTracker9781308_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781308_
		coverAll:
			{17 to: 18}
		byLiteralOrPseudoVariable: -1.
	#_coverageTracker9781308_
		coverAll:
			{19 to: 19}
		evaluating: [
			receiver1 @
				(#_coverageTracker9781308_
					coverAll:
						{20 to: 20}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
process: aStringOfCommands
	#_coverageTracker9781337_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ #_coverageTracker9781337_
		cover: (30 to: 46)
		declaredAt: (10 to: 26)
		by: aStringOfCommands.
	#_coverageTracker9781337_
		coverAll:
			{48 to: 50}
		evaluating: [
			receiver4 do: [ :aCommand |
				[ | receiver3 |
				receiver3 _ [ | receiver1 |
				receiver1 _ #_coverageTracker9781337_
					coverAll:
						{67 to: 80}
					byLiteralOrPseudoVariable: #($f #, $b #, $r #, $l ).
				#_coverageTracker9781337_
					coverAll:
						{82 to: 90}
					evaluating: [
						receiver1 includes:
							(#_coverageTracker9781337_
								cover: (92 to: 99)
								declaredAt: (55 to: 62)
								by: aCommand) ]
					thatSends: #includes:
					to: receiver1 ] value.
				#_coverageTracker9781337_
					coverAll:
						{105 to: 111. 153 to: 160}
					evaluating: [
						receiver3
							ifTrue: [
								[ | receiver2 |
								receiver2 _ #_coverageTracker9781337_
									coverAll:
										{114 to: 117}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker9781337_
									coverAll:
										{119 to: 139}
									evaluating: [
										receiver2 processSingleCommand:
											(#_coverageTracker9781337_
												cover: (141 to: 148)
												declaredAt: (55 to: 62)
												by: aCommand) ]
									thatSends: #processSingleCommand:
									to: receiver2 ] value ]
							ifFalse: [ ^ #_coverageTracker9781337_
									coverAll:
										{164 to: 167}
									byLiteralOrPseudoVariable: self ]]
					thatSends: #ifTrue:ifFalse:
					to: receiver3 ] value ]]
		thatSends: #do:
		to: receiver4 ] value.! !
!Behavior method!
symbol
	#_coverageTracker9781343_ markAsExecuted.
	^ #_coverageTracker9781343_
		coverAll:
			{10 to: 15}
		byLiteralOrPseudoVariable: #South.! !
!Behavior method!
rotateRight
	#_coverageTracker9781366_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781366_
		coverAll:
			{15 to: 18}
		by: East.
	#_coverageTracker9781366_
		coverAll:
			{20 to: 22}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
symbol
	#_coverageTracker9781370_ markAsExecuted.
	^ #_coverageTracker9781370_
		coverAll:
			{10 to: 14}
		byLiteralOrPseudoVariable: #West.! !
!Behavior method!
rotateLeft
	#_coverageTracker9781372_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781372_
		coverAll:
			{14 to: 18}
		by: South.
	#_coverageTracker9781372_
		coverAll:
			{20 to: 22}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
moveForward
	#_coverageTracker9781374_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781374_
		coverAll:
			{16 to: 16}
		byLiteralOrPseudoVariable: 0.
	#_coverageTracker9781374_
		coverAll:
			{17 to: 17}
		evaluating: [
			receiver1 @
				(#_coverageTracker9781374_
					coverAll:
						{18 to: 19}
					byLiteralOrPseudoVariable: -1) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
new
	#_coverageTracker9781397_ markAsExecuted.
	^ #_coverageTracker9781397_
		cover: (7 to: 20)
		declaredAt: (7 to: 20)
		by: uniqueInstance.! !
!Behavior method!
canHandle: aDirectionSymbol
	#_coverageTracker9781399_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781399_
		cover: (31 to: 46)
		declaredAt: (12 to: 27)
		by: aDirectionSymbol.
	#_coverageTracker9781399_
		coverAll:
			{48 to: 48}
		evaluating: [
			receiver1 =
				(#_coverageTracker9781399_
					coverAll:
						{50 to: 55}
					byLiteralOrPseudoVariable: #North) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
rotateLeft
	#_coverageTracker9781403_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781403_
		coverAll:
			{14 to: 17}
		by: East.
	#_coverageTracker9781403_
		coverAll:
			{19 to: 21}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
moveForward
	#_coverageTracker9781405_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781405_
		coverAll:
			{16 to: 17}
		byLiteralOrPseudoVariable: -1.
	#_coverageTracker9781405_
		coverAll:
			{18 to: 18}
		evaluating: [
			receiver1 @
				(#_coverageTracker9781405_
					coverAll:
						{19 to: 19}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
rotateRight
	#_coverageTracker9781438_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9781438_
		coverAll:
			{15 to: 19}
		by: South.
	#_coverageTracker9781438_
		coverAll:
			{21 to: 23}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
pointing: aDirectionSymbol
	#_coverageTracker9781442_ markAsExecuted.
	^ [ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ [ | receiver1 |
	receiver1 _ #_coverageTracker9781442_
		coverAll:
			{31 to: 34}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker9781442_
		coverAll:
			{36 to: 45}
		evaluating: [ receiver1 subclasses ]
		thatSends: #subclasses
		to: receiver1 ] value.
	#_coverageTracker9781442_
		coverAll:
			{47 to: 53. 128 to: 134}
		evaluating: [
			receiver5
				detect: [ :aCardinalDirection |
					[ | receiver2 |
					receiver2 _ #_coverageTracker9781442_
						cover: (79 to: 96)
						declaredAt: (58 to: 75)
						by: aCardinalDirection.
					#_coverageTracker9781442_
						coverAll:
							{98 to: 107}
						evaluating: [
							receiver2 canHandle:
								(#_coverageTracker9781442_
									cover: (109 to: 124)
									declaredAt: (11 to: 26)
									by: aDirectionSymbol) ]
						thatSends: #canHandle:
						to: receiver2 ] value ]
				ifNone: [
					[ | receiver4 |
					receiver4 _ #_coverageTracker9781442_
						coverAll:
							{137 to: 140}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker9781442_
						coverAll:
							{142 to: 147}
						evaluating: [
							receiver4 error:
								[ | receiver3 |
								receiver3 _ #_coverageTracker9781442_
									coverAll:
										{149 to: 152}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker9781442_
									coverAll:
										{154 to: 171}
									evaluating: [ receiver3 invalidSymbolError ]
									thatSends: #invalidSymbolError
									to: receiver3 ] value ]
						thatSends: #error:
						to: receiver4 ] value ]]
		thatSends: #detect:ifNone:
		to: receiver5 ] value.
	#_coverageTracker9781442_
		coverAll:
			{175 to: 177}
		evaluating: [ receiver6 new ]
		thatSends: #new
		to: receiver6 ] value.! !
!Behavior method!
symbol
	#_coverageTracker9781473_ markAsExecuted.
	^ #_coverageTracker9781473_
		coverAll:
			{10 to: 14}
		byLiteralOrPseudoVariable: #East.! !

!testRun: #MarsRoverTestSuite #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:38:03'!
PASSED!

!testRun: #MarsRoverTestSuite #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:38:03'!
PASSED!

!testRun: #MarsRoverTestSuite #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:38:03'!
PASSED!

!testRun: #MarsRoverTestSuite #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:38:03'!
PASSED!

!testRun: #MarsRoverTestSuite #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:38:03'!
PASSED!

!testRun: #MarsRoverTestSuite #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:38:03'!
PASSED!

!testRun: #MarsRoverTestSuite #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:38:03'!
PASSED!

!testRun: #MarsRoverTestSuite #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:38:03'!
PASSED!

!testRun: #MarsRoverTestSuite #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:38:03'!
PASSED!

!testRun: #MarsRoverTestSuite #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:38:03'!
PASSED!

!testRun: #MarsRoverTestSuite #test11_ stamp: 'MS 10/8/2023 22:38:03'!
PASSED!
!MarsRoverTestSuite methodsFor: 'testing' stamp: 'MS 10/8/2023 22:38:25'!
test12_
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #South.
	marsRover process: 'ffbrffbrffbrffb'.
	self assert: (marsRover isIn: (0@0) andFacing: #East).! !

!testRun: #MarsRoverTestSuite #test12_ stamp: 'MS 10/8/2023 22:38:26'!
PASSED!

!testRun: #MarsRoverTestSuite #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:38:26'!
PASSED!

!testRun: #MarsRoverTestSuite #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:38:26'!
PASSED!

!testRun: #MarsRoverTestSuite #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:38:26'!
PASSED!

!testRun: #MarsRoverTestSuite #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:38:26'!
PASSED!

!testRun: #MarsRoverTestSuite #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:38:26'!
PASSED!

!testRun: #MarsRoverTestSuite #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:38:26'!
PASSED!

!testRun: #MarsRoverTestSuite #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:38:26'!
PASSED!

!testRun: #MarsRoverTestSuite #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:38:26'!
PASSED!

!testRun: #MarsRoverTestSuite #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:38:26'!
PASSED!

!testRun: #MarsRoverTestSuite #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:38:26'!
PASSED!

!testRun: #MarsRoverTestSuite #test11_ stamp: 'MS 10/8/2023 22:38:26'!
PASSED!

!testRun: #MarsRoverTestSuite #test12_ stamp: 'MS 10/8/2023 22:38:26'!
PASSED!
!Behavior method!
canHandle: aDirectionSymbol
	#_coverageTracker9809736_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9809736_
		cover: (31 to: 46)
		declaredAt: (12 to: 27)
		by: aDirectionSymbol.
	#_coverageTracker9809736_
		coverAll:
			{48 to: 48}
		evaluating: [
			receiver1 =
				(#_coverageTracker9809736_
					coverAll:
						{50 to: 55}
					byLiteralOrPseudoVariable: #South) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
new
	#_coverageTracker9809743_ markAsExecuted.
	^ #_coverageTracker9809743_
		cover: (7 to: 20)
		declaredAt: (7 to: 20)
		by: uniqueInstance.! !
!Behavior method!
initialize
	#_coverageTracker9809776_ markAsExecuted.
	#_coverageTracker9809776_
		cover: (13 to: 26)
		declaredAt: (13 to: 26)
		by:
			(uniqueInstance _ [ | receiver1 |
			receiver1 _ #_coverageTracker9809776_
				coverAll:
					{31 to: 34}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker9809776_
				coverAll:
					{36 to: 43}
				evaluating: [ receiver1 basicNew ]
				thatSends: #basicNew
				to: receiver1 ] value).! !
!Behavior method!
rotateRight
	#_coverageTracker9809778_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9809778_
		coverAll:
			{15 to: 19}
		by: North.
	#_coverageTracker9809778_
		coverAll:
			{21 to: 23}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
rotateLeft
	#_coverageTracker9809782_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9809782_
		coverAll:
			{14 to: 17}
		by: West.
	#_coverageTracker9809782_
		coverAll:
			{19 to: 21}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
initialize
	#_coverageTracker9809807_ markAsExecuted.
	#_coverageTracker9809807_
		cover: (13 to: 26)
		declaredAt: (13 to: 26)
		by:
			(uniqueInstance _ [ | receiver1 |
			receiver1 _ #_coverageTracker9809807_
				coverAll:
					{31 to: 34}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker9809807_
				coverAll:
					{36 to: 43}
				evaluating: [ receiver1 basicNew ]
				thatSends: #basicNew
				to: receiver1 ] value).! !
!Behavior method!
moveBackward
	#_coverageTracker9809809_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9809809_
		coverAll:
			{18 to: 18}
		byLiteralOrPseudoVariable: 0.
	#_coverageTracker9809809_
		coverAll:
			{19 to: 19}
		evaluating: [
			receiver1 @
				(#_coverageTracker9809809_
					coverAll:
						{20 to: 20}
					byLiteralOrPseudoVariable: 1) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
moveBackward
	#_coverageTracker9809813_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9809813_
		coverAll:
			{18 to: 18}
		byLiteralOrPseudoVariable: 0.
	#_coverageTracker9809813_
		coverAll:
			{19 to: 19}
		evaluating: [
			receiver1 @
				(#_coverageTracker9809813_
					coverAll:
						{20 to: 21}
					byLiteralOrPseudoVariable: -1) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
invalidSymbolError
	#_coverageTracker9809815_ markAsExecuted.
	^ #_coverageTracker9809815_
		coverAll:
			{22 to: 63}
		byLiteralOrPseudoVariable: 'This symbol is not a cardinal direction!!'.! !
!Behavior method!
moveForward
	#_coverageTracker9809848_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9809848_
		coverAll:
			{16 to: 16}
		byLiteralOrPseudoVariable: 0.
	#_coverageTracker9809848_
		coverAll:
			{17 to: 17}
		evaluating: [
			receiver1 @
				(#_coverageTracker9809848_
					coverAll:
						{18 to: 18}
					byLiteralOrPseudoVariable: 1) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
processSingleCommand: aCommand
	#_coverageTracker9809852_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker9809852_
		cover: (35 to: 42)
		declaredAt: (23 to: 30)
		by: aCommand.
	#_coverageTracker9809852_
		coverAll:
			{44 to: 44}
		evaluating: [
			receiver1 =
				(#_coverageTracker9809852_
					coverAll:
						{46 to: 47}
					byLiteralOrPseudoVariable: $f) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker9809852_
		coverAll:
			{50 to: 56}
		evaluating: [
			receiver4 ifTrue: [
				#_coverageTracker9809852_
					cover: (81 to: 95)
					declaredAt: (62 to: 76)
					by:
						(currentPosition _ [ | receiver3 |
						receiver3 _ #_coverageTracker9809852_
							cover: (62 to: 76)
							declaredAt: (62 to: 76)
							by: currentPosition.
						#_coverageTracker9809852_
							coverAll:
								{97 to: 97}
							evaluating: [
								receiver3 +
									[ | receiver2 |
									receiver2 _ #_coverageTracker9809852_
										cover: (99 to: 114)
										declaredAt: (99 to: 114)
										by: currentDirection.
									#_coverageTracker9809852_
										coverAll:
											{116 to: 126}
										evaluating: [ receiver2 moveForward ]
										thatSends: #moveForward
										to: receiver2 ] value ]
							thatSends: #+
							to: receiver3 ] value) ]]
		thatSends: #ifTrue:
		to: receiver4 ] value.
	[ | receiver8 |
	receiver8 _ [ | receiver5 |
	receiver5 _ #_coverageTracker9809852_
		cover: (136 to: 143)
		declaredAt: (23 to: 30)
		by: aCommand.
	#_coverageTracker9809852_
		coverAll:
			{145 to: 145}
		evaluating: [
			receiver5 =
				(#_coverageTracker9809852_
					coverAll:
						{147 to: 148}
					byLiteralOrPseudoVariable: $b) ]
		thatSends: #=
		to: receiver5 ] value.
	#_coverageTracker9809852_
		coverAll:
			{151 to: 157}
		evaluating: [
			receiver8 ifTrue: [
				#_coverageTracker9809852_
					cover: (182 to: 196)
					declaredAt: (62 to: 76)
					by:
						(currentPosition _ [ | receiver7 |
						receiver7 _ #_coverageTracker9809852_
							cover: (163 to: 177)
							declaredAt: (62 to: 76)
							by: currentPosition.
						#_coverageTracker9809852_
							coverAll:
								{198 to: 198}
							evaluating: [
								receiver7 +
									[ | receiver6 |
									receiver6 _ #_coverageTracker9809852_
										cover: (200 to: 215)
										declaredAt: (99 to: 114)
										by: currentDirection.
									#_coverageTracker9809852_
										coverAll:
											{217 to: 228}
										evaluating: [ receiver6 moveBackward ]
										thatSends: #moveBackward
										to: receiver6 ] value ]
							thatSends: #+
							to: receiver7 ] value) ]]
		thatSends: #ifTrue:
		to: receiver8 ] value.
	[ | receiver11 |
	receiver11 _ [ | receiver9 |
	receiver9 _ #_coverageTracker9809852_
		cover: (238 to: 245)
		declaredAt: (23 to: 30)
		by: aCommand.
	#_coverageTracker9809852_
		coverAll:
			{247 to: 247}
		evaluating: [
			receiver9 =
				(#_coverageTracker9809852_
					coverAll:
						{249 to: 250}
					byLiteralOrPseudoVariable: $r) ]
		thatSends: #=
		to: receiver9 ] value.
	#_coverageTracker9809852_
		coverAll:
			{253 to: 259}
		evaluating: [
			receiver11 ifTrue: [
				#_coverageTracker9809852_
					cover: (282 to: 297)
					declaredAt: (99 to: 114)
					by:
						(currentDirection _ [ | receiver10 |
						receiver10 _ #_coverageTracker9809852_
							cover: (262 to: 277)
							declaredAt: (99 to: 114)
							by: currentDirection.
						#_coverageTracker9809852_
							coverAll:
								{299 to: 309}
							evaluating: [ receiver10 rotateRight ]
							thatSends: #rotateRight
							to: receiver10 ] value) ]]
		thatSends: #ifTrue:
		to: receiver11 ] value.
	[ | receiver14 |
	receiver14 _ [ | receiver12 |
	receiver12 _ #_coverageTracker9809852_
		cover: (317 to: 324)
		declaredAt: (23 to: 30)
		by: aCommand.
	#_coverageTracker9809852_
		coverAll:
			{326 to: 326}
		evaluating: [
			receiver12 =
				(#_coverageTracker9809852_
					coverAll:
						{328 to: 329}
					byLiteralOrPseudoVariable: $l) ]
		thatSends: #=
		to: receiver12 ] value.
	#_coverageTracker9809852_
		coverAll:
			{332 to: 338}
		evaluating: [
			receiver14 ifTrue: [
				#_coverageTracker9809852_
					cover: (361 to: 376)
					declaredAt: (99 to: 114)
					by:
						(currentDirection _ [ | receiver13 |
						receiver13 _ #_coverageTracker9809852_
							cover: (341 to: 356)
							declaredAt: (99 to: 114)
							by: currentDirection.
						#_coverageTracker9809852_
							coverAll:
								{378 to: 387}
							evaluating: [ receiver13 rotateLeft ]
							thatSends: #rotateLeft
							to: receiver13 ] value) ]]
		thatSends: #ifTrue:
		to: receiver14 ] value.! !
!Behavior method!
canHandle: aDirectionSymbol
	#_coverageTracker9809918_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9809918_
		cover: (31 to: 46)
		declaredAt: (12 to: 27)
		by: aDirectionSymbol.
	#_coverageTracker9809918_
		coverAll:
			{48 to: 48}
		evaluating: [
			receiver1 =
				(#_coverageTracker9809918_
					coverAll:
						{50 to: 54}
					byLiteralOrPseudoVariable: #East) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
new
	#_coverageTracker9809943_ markAsExecuted.
	^ #_coverageTracker9809943_
		cover: (7 to: 20)
		declaredAt: (7 to: 20)
		by: uniqueInstance.! !
!Behavior method!
moveForward
	#_coverageTracker9809943_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9809943_
		coverAll:
			{16 to: 16}
		byLiteralOrPseudoVariable: 1.
	#_coverageTracker9809943_
		coverAll:
			{17 to: 17}
		evaluating: [
			receiver1 @
				(#_coverageTracker9809943_
					coverAll:
						{18 to: 18}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
new
	#_coverageTracker9809947_ markAsExecuted.
	^ #_coverageTracker9809947_
		cover: (7 to: 20)
		declaredAt: (7 to: 20)
		by: uniqueInstance.! !
!Behavior method!
rotateLeft
	#_coverageTracker9809947_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9809947_
		coverAll:
			{14 to: 18}
		by: North.
	#_coverageTracker9809947_
		coverAll:
			{20 to: 22}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
initialize
	#_coverageTracker9809972_ markAsExecuted.
	#_coverageTracker9809972_
		cover: (13 to: 26)
		declaredAt: (13 to: 26)
		by:
			(uniqueInstance _ [ | receiver1 |
			receiver1 _ #_coverageTracker9809972_
				coverAll:
					{31 to: 34}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker9809972_
				coverAll:
					{36 to: 43}
				evaluating: [ receiver1 basicNew ]
				thatSends: #basicNew
				to: receiver1 ] value).! !
!Behavior method!
canHandle: aDirectionSymbol
	#_coverageTracker9809992_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9809992_
		cover: (31 to: 46)
		declaredAt: (12 to: 27)
		by: aDirectionSymbol.
	#_coverageTracker9809992_
		coverAll:
			{48 to: 48}
		evaluating: [
			receiver1 =
				(#_coverageTracker9809992_
					coverAll:
						{50 to: 54}
					byLiteralOrPseudoVariable: #West) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
initialize
	#_coverageTracker9809996_ markAsExecuted.
	#_coverageTracker9809996_
		cover: (13 to: 26)
		declaredAt: (13 to: 26)
		by:
			(uniqueInstance _ [ | receiver1 |
			receiver1 _ #_coverageTracker9809996_
				coverAll:
					{31 to: 34}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker9809996_
				coverAll:
					{36 to: 43}
				evaluating: [ receiver1 basicNew ]
				thatSends: #basicNew
				to: receiver1 ] value).! !
!Behavior method!
rotateRight
	#_coverageTracker9810023_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9810023_
		coverAll:
			{15 to: 18}
		by: West.
	#_coverageTracker9810023_
		coverAll:
			{20 to: 22}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
in: initialPosition facing: initialDirection
	#_coverageTracker9810027_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker9810027_
		coverAll:
			{48 to: 51}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker9810027_
		coverAll:
			{53 to: 55}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker9810027_
		coverAll:
			{57 to: 59. 77 to: 83}
		evaluating: [
			receiver2
				in:
					(#_coverageTracker9810027_
						cover: (61 to: 75)
						declaredAt: (5 to: 19)
						by: initialPosition)
				facing:
					(#_coverageTracker9810027_
						cover: (85 to: 100)
						declaredAt: (29 to: 44)
						by: initialDirection) ]
		thatSends: #in:facing:
		to: receiver2 ] value.! !
!Behavior method!
symbol
	#_coverageTracker9810054_ markAsExecuted.
	^ #_coverageTracker9810054_
		coverAll:
			{10 to: 15}
		byLiteralOrPseudoVariable: #North.! !
!Behavior method!
isIn: aPosition andFacing: aDirection
	#_coverageTracker9810056_ markAsExecuted.
	^ [ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker9810056_
		cover: (42 to: 56)
		declaredAt: (42 to: 56)
		by: currentPosition.
	#_coverageTracker9810056_
		coverAll:
			{58 to: 58}
		evaluating: [
			receiver1 =
				(#_coverageTracker9810056_
					cover: (60 to: 68)
					declaredAt: (7 to: 15)
					by: aPosition) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker9810056_
		coverAll:
			{71 to: 74}
		evaluating: [
			receiver4 and: [
				[ | receiver3 |
				receiver3 _ [ | receiver2 |
				receiver2 _ #_coverageTracker9810056_
					cover: (77 to: 92)
					declaredAt: (77 to: 92)
					by: currentDirection.
				#_coverageTracker9810056_
					coverAll:
						{94 to: 99}
					evaluating: [ receiver2 symbol ]
					thatSends: #symbol
					to: receiver2 ] value.
				#_coverageTracker9810056_
					coverAll:
						{101 to: 101}
					evaluating: [
						receiver3 =
							(#_coverageTracker9810056_
								cover: (103 to: 112)
								declaredAt: (28 to: 37)
								by: aDirection) ]
					thatSends: #=
					to: receiver3 ] value ]]
		thatSends: #and:
		to: receiver4 ] value.! !
!Behavior method!
in: initialPosition facing: initialDirection
	#_coverageTracker9810062_ markAsExecuted.
	#_coverageTracker9810062_
		cover: (48 to: 62)
		declaredAt: (48 to: 62)
		by:
			(currentPosition _ #_coverageTracker9810062_
				cover: (67 to: 81)
				declaredAt: (5 to: 19)
				by: initialPosition).
	#_coverageTracker9810062_
		cover: (85 to: 100)
		declaredAt: (85 to: 100)
		by:
			(currentDirection _ [ | receiver1 |
			receiver1 _ #_coverageTracker9810062_
				coverAll:
					{105 to: 122}
				by: CardinalDirections.
			#_coverageTracker9810062_
				coverAll:
					{124 to: 132}
				evaluating: [
					receiver1 pointing:
						(#_coverageTracker9810062_
							cover: (134 to: 149)
							declaredAt: (29 to: 44)
							by: initialDirection) ]
				thatSends: #pointing:
				to: receiver1 ] value).! !
!Behavior method!
moveBackward
	#_coverageTracker9810089_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9810089_
		coverAll:
			{18 to: 18}
		byLiteralOrPseudoVariable: 1.
	#_coverageTracker9810089_
		coverAll:
			{19 to: 19}
		evaluating: [
			receiver1 @
				(#_coverageTracker9810089_
					coverAll:
						{20 to: 20}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
moveBackward
	#_coverageTracker9810116_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9810116_
		coverAll:
			{17 to: 18}
		byLiteralOrPseudoVariable: -1.
	#_coverageTracker9810116_
		coverAll:
			{19 to: 19}
		evaluating: [
			receiver1 @
				(#_coverageTracker9810116_
					coverAll:
						{20 to: 20}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
process: aStringOfCommands
	#_coverageTracker9810118_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ #_coverageTracker9810118_
		cover: (30 to: 46)
		declaredAt: (10 to: 26)
		by: aStringOfCommands.
	#_coverageTracker9810118_
		coverAll:
			{48 to: 50}
		evaluating: [
			receiver4 do: [ :aCommand |
				[ | receiver3 |
				receiver3 _ [ | receiver1 |
				receiver1 _ #_coverageTracker9810118_
					coverAll:
						{67 to: 80}
					byLiteralOrPseudoVariable: #($f #, $b #, $r #, $l ).
				#_coverageTracker9810118_
					coverAll:
						{82 to: 90}
					evaluating: [
						receiver1 includes:
							(#_coverageTracker9810118_
								cover: (92 to: 99)
								declaredAt: (55 to: 62)
								by: aCommand) ]
					thatSends: #includes:
					to: receiver1 ] value.
				#_coverageTracker9810118_
					coverAll:
						{105 to: 111. 153 to: 160}
					evaluating: [
						receiver3
							ifTrue: [
								[ | receiver2 |
								receiver2 _ #_coverageTracker9810118_
									coverAll:
										{114 to: 117}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker9810118_
									coverAll:
										{119 to: 139}
									evaluating: [
										receiver2 processSingleCommand:
											(#_coverageTracker9810118_
												cover: (141 to: 148)
												declaredAt: (55 to: 62)
												by: aCommand) ]
									thatSends: #processSingleCommand:
									to: receiver2 ] value ]
							ifFalse: [ ^ #_coverageTracker9810118_
									coverAll:
										{164 to: 167}
									byLiteralOrPseudoVariable: self ]]
					thatSends: #ifTrue:ifFalse:
					to: receiver3 ] value ]]
		thatSends: #do:
		to: receiver4 ] value.! !
!Behavior method!
symbol
	#_coverageTracker9810149_ markAsExecuted.
	^ #_coverageTracker9810149_
		coverAll:
			{10 to: 15}
		byLiteralOrPseudoVariable: #South.! !
!Behavior method!
rotateRight
	#_coverageTracker9810149_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9810149_
		coverAll:
			{15 to: 18}
		by: East.
	#_coverageTracker9810149_
		coverAll:
			{20 to: 22}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
symbol
	#_coverageTracker9810153_ markAsExecuted.
	^ #_coverageTracker9810153_
		coverAll:
			{10 to: 14}
		byLiteralOrPseudoVariable: #West.! !
!Behavior method!
rotateLeft
	#_coverageTracker9810153_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9810153_
		coverAll:
			{14 to: 18}
		by: South.
	#_coverageTracker9810153_
		coverAll:
			{20 to: 22}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
moveForward
	#_coverageTracker9810178_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9810178_
		coverAll:
			{16 to: 16}
		byLiteralOrPseudoVariable: 0.
	#_coverageTracker9810178_
		coverAll:
			{17 to: 17}
		evaluating: [
			receiver1 @
				(#_coverageTracker9810178_
					coverAll:
						{18 to: 19}
					byLiteralOrPseudoVariable: -1) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
new
	#_coverageTracker9810182_ markAsExecuted.
	^ #_coverageTracker9810182_
		cover: (7 to: 20)
		declaredAt: (7 to: 20)
		by: uniqueInstance.! !
!Behavior method!
canHandle: aDirectionSymbol
	#_coverageTracker9810184_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9810184_
		cover: (31 to: 46)
		declaredAt: (12 to: 27)
		by: aDirectionSymbol.
	#_coverageTracker9810184_
		coverAll:
			{48 to: 48}
		evaluating: [
			receiver1 =
				(#_coverageTracker9810184_
					coverAll:
						{50 to: 55}
					byLiteralOrPseudoVariable: #North) ]
		thatSends: #=
		to: receiver1 ] value.! !
!Behavior method!
rotateLeft
	#_coverageTracker9810186_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9810186_
		coverAll:
			{14 to: 17}
		by: East.
	#_coverageTracker9810186_
		coverAll:
			{19 to: 21}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
moveForward
	#_coverageTracker9810209_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9810209_
		coverAll:
			{16 to: 17}
		byLiteralOrPseudoVariable: -1.
	#_coverageTracker9810209_
		coverAll:
			{18 to: 18}
		evaluating: [
			receiver1 @
				(#_coverageTracker9810209_
					coverAll:
						{19 to: 19}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #@
		to: receiver1 ] value.! !
!Behavior method!
rotateRight
	#_coverageTracker9810211_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker9810211_
		coverAll:
			{15 to: 19}
		by: South.
	#_coverageTracker9810211_
		coverAll:
			{21 to: 23}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.! !
!Behavior method!
pointing: aDirectionSymbol
	#_coverageTracker9810213_ markAsExecuted.
	^ [ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ [ | receiver1 |
	receiver1 _ #_coverageTracker9810213_
		coverAll:
			{31 to: 34}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker9810213_
		coverAll:
			{36 to: 45}
		evaluating: [ receiver1 subclasses ]
		thatSends: #subclasses
		to: receiver1 ] value.
	#_coverageTracker9810213_
		coverAll:
			{47 to: 53. 128 to: 134}
		evaluating: [
			receiver5
				detect: [ :aCardinalDirection |
					[ | receiver2 |
					receiver2 _ #_coverageTracker9810213_
						cover: (79 to: 96)
						declaredAt: (58 to: 75)
						by: aCardinalDirection.
					#_coverageTracker9810213_
						coverAll:
							{98 to: 107}
						evaluating: [
							receiver2 canHandle:
								(#_coverageTracker9810213_
									cover: (109 to: 124)
									declaredAt: (11 to: 26)
									by: aDirectionSymbol) ]
						thatSends: #canHandle:
						to: receiver2 ] value ]
				ifNone: [
					[ | receiver4 |
					receiver4 _ #_coverageTracker9810213_
						coverAll:
							{137 to: 140}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker9810213_
						coverAll:
							{142 to: 147}
						evaluating: [
							receiver4 error:
								[ | receiver3 |
								receiver3 _ #_coverageTracker9810213_
									coverAll:
										{149 to: 152}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker9810213_
									coverAll:
										{154 to: 171}
									evaluating: [ receiver3 invalidSymbolError ]
									thatSends: #invalidSymbolError
									to: receiver3 ] value ]
						thatSends: #error:
						to: receiver4 ] value ]]
		thatSends: #detect:ifNone:
		to: receiver5 ] value.
	#_coverageTracker9810213_
		coverAll:
			{175 to: 177}
		evaluating: [ receiver6 new ]
		thatSends: #new
		to: receiver6 ] value.! !
!Behavior method!
symbol
	#_coverageTracker9810244_ markAsExecuted.
	^ #_coverageTracker9810244_
		coverAll:
			{10 to: 14}
		byLiteralOrPseudoVariable: #East.! !

!testRun: #MarsRoverTestSuite #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:38:31'!
PASSED!

!testRun: #MarsRoverTestSuite #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:38:31'!
PASSED!

!testRun: #MarsRoverTestSuite #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:38:31'!
PASSED!

!testRun: #MarsRoverTestSuite #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:38:31'!
PASSED!

!testRun: #MarsRoverTestSuite #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:38:31'!
PASSED!

!testRun: #MarsRoverTestSuite #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:38:31'!
PASSED!

!testRun: #MarsRoverTestSuite #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:38:31'!
PASSED!

!testRun: #MarsRoverTestSuite #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:38:31'!
PASSED!

!testRun: #MarsRoverTestSuite #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:38:31'!
PASSED!

!testRun: #MarsRoverTestSuite #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:38:31'!
PASSED!

!testRun: #MarsRoverTestSuite #test11_ stamp: 'MS 10/8/2023 22:38:31'!
PASSED!

!testRun: #MarsRoverTestSuite #test12_ stamp: 'MS 10/8/2023 22:38:31'!
PASSED!
!MarsRoverTestSuite methodsFor: 'testing' stamp: 'MS 10/8/2023 22:39:37' prior: 50698473!
test11_
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #South.
	marsRover process: 'ffblffblffblffb$   fr'.
	self assert: (marsRover isIn: (0@0) andFacing: #West).! !

!testRun: #MarsRoverTestSuite #test11_ stamp: 'MS 10/8/2023 22:39:38'!
PASSED!

!testRun: #MarsRoverTestSuite #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:39:38'!
PASSED!

!testRun: #MarsRoverTestSuite #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:39:38'!
PASSED!

!testRun: #MarsRoverTestSuite #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:39:38'!
PASSED!

!testRun: #MarsRoverTestSuite #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:39:38'!
PASSED!

!testRun: #MarsRoverTestSuite #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:39:38'!
PASSED!

!testRun: #MarsRoverTestSuite #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:39:38'!
PASSED!

!testRun: #MarsRoverTestSuite #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:39:38'!
PASSED!

!testRun: #MarsRoverTestSuite #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:39:38'!
PASSED!

!testRun: #MarsRoverTestSuite #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:39:38'!
PASSED!

!testRun: #MarsRoverTestSuite #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:39:38'!
PASSED!

!testRun: #MarsRoverTestSuite #test11_ stamp: 'MS 10/8/2023 22:39:38'!
PASSED!

!testRun: #MarsRoverTestSuite #test12_ stamp: 'MS 10/8/2023 22:39:38'!
PASSED!
!MarsRoverTestSuite methodsFor: 'testing' stamp: 'MS 10/8/2023 22:40:12'!
test11_MarsRoverMovesInASquareToTheLeft
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #South.
	marsRover process: 'ffblffblffblffb$   fr'.
	self assert: (marsRover isIn: (0@0) andFacing: #West).! !

!methodRemoval: MarsRoverTestSuite #test11_ stamp: 'MS 10/8/2023 22:40:16'!
test11_
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #South.
	marsRover process: 'ffblffblffblffb$   fr'.
	self assert: (marsRover isIn: (0@0) andFacing: #West).!
!MarsRoverTestSuite methodsFor: 'testing' stamp: 'MS 10/8/2023 22:40:30'!
test12_MarsRoverMovesInASquareToTheRight
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #South.
	marsRover process: 'ffbrffbrffbrffb'.
	self assert: (marsRover isIn: (0@0) andFacing: #East).! !

!methodRemoval: MarsRoverTestSuite #test12_ stamp: 'MS 10/8/2023 22:40:30'!
test12_
	| marsRover |
	marsRover  := MarsRover in: (0@0) facing: #South.
	marsRover process: 'ffbrffbrffbrffb'.
	self assert: (marsRover isIn: (0@0) andFacing: #East).!

!testRun: #MarsRoverTestSuite #test11_MarsRoverMovesInASquareToTheLeft stamp: 'MS 10/8/2023 22:40:43'!
PASSED!

!testRun: #MarsRoverTestSuite #test01_MarsRoverIsInDesignatedInitialPositionAndDirection stamp: 'MS 10/8/2023 22:40:43'!
PASSED!

!testRun: #MarsRoverTestSuite #test02_MarsRoverDoesNothingAfterProcessingEmptyString stamp: 'MS 10/8/2023 22:40:43'!
PASSED!

!testRun: #MarsRoverTestSuite #test03_MarsRoverMovesFowardsFacingNorth stamp: 'MS 10/8/2023 22:40:43'!
PASSED!

!testRun: #MarsRoverTestSuite #test04_MarsRoverMovesFowardFacingEast stamp: 'MS 10/8/2023 22:40:43'!
PASSED!

!testRun: #MarsRoverTestSuite #test05_MarsRoverMovesBackwardFacingNorth stamp: 'MS 10/8/2023 22:40:43'!
PASSED!

!testRun: #MarsRoverTestSuite #test06_MarsRoverMovesBackwardFacingEast stamp: 'MS 10/8/2023 22:40:43'!
PASSED!

!testRun: #MarsRoverTestSuite #test07_MarsRoverRotatesToTheRight stamp: 'MS 10/8/2023 22:40:43'!
PASSED!

!testRun: #MarsRoverTestSuite #test08_MarsRoverRotatesToTheLeft stamp: 'MS 10/8/2023 22:40:43'!
PASSED!

!testRun: #MarsRoverTestSuite #test09_MarsRoverCanProcessMultipleCommands stamp: 'MS 10/8/2023 22:40:43'!
PASSED!

!testRun: #MarsRoverTestSuite #test10_MarsRoverStopsProcessingAfterInvalidCommand stamp: 'MS 10/8/2023 22:40:43'!
PASSED!

!testRun: #MarsRoverTestSuite #test11_MarsRoverMovesInASquareToTheLeft stamp: 'MS 10/8/2023 22:40:43'!
PASSED!

!testRun: #MarsRoverTestSuite #test12_MarsRoverMovesInASquareToTheRight stamp: 'MS 10/8/2023 22:40:43'!
PASSED!

----SNAPSHOT----(8 October 2023 22:41:26) CuisUniversity-5981.image priorSource: 10199807!

----SNAPSHOT----(8 October 2023 22:41:30) CuisUniversity-5981.image priorSource: 11794068!

----QUIT----(8 October 2023 22:47:15) CuisUniversity-5981.image priorSource: 11794160!

----STARTUP---- (9 October 2023 13:10:15) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


Object subclass: #Obligation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Prueba_MethodObject'!

!classDefinition: #Obligation category: 'Prueba_MethodObject' stamp: 'MS 10/9/2023 13:12:36'!
Object subclass: #Obligation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Prueba_MethodObject'!
!Obligation methodsFor: 'nil' stamp: 'MS 10/9/2023 13:13:09'!
sendTask: aTask job: aJob 
	| notProcessed processed copied executed |
	! !
!Obligation methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 13:14:10' prior: 50700239!
sendTask: aTask job: aJob 
	| notProcessed processed copied executed |
	notProcessed  := 3.
	processed := aTask.
	copied := aJob.
	executed := self.! !
!Obligation methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 13:40:09' prior: 50700245!
sendTask: aTask job: aJob 
	| notProcessed processed copied executed |
	"hacemos cosas compliquetis"
	notProcessed  := 3.
	processed := aTask.
	copied := aJob.
	executed := self.! !
!Obligation methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 13:43:56' prior: 50700253!
sendTask: aTask job: aJob 
	| notProcessed processed copied executed |
	"hacemos cosas compliquetis"
	notProcessed  := 3.
	processed := aTask.
	copied := aJob.
	executed := 4.! !
!Obligation methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 13:44:18' prior: 50700262!
sendTask: aTask job: aJob 
	| notProcessed processed copied executed |
	"hacemos cosas compliquetis"
	notProcessed  := 3.
	processed := aTask.
	copied := aJob.
	executed := 4.
	^ notProcessed  + processed  + copied + executed! !

Obligation new sendTask: 6  job: 7!

!classDefinition: #TaskSender category: 'Prueba_MethodObject' stamp: 'MS 10/9/2023 13:56:36'!
Object subclass: #TaskSender
	instanceVariableNames: 'task job'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Prueba_MethodObject'!
!TaskSender class methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 13:56:36'!
task: anATask job: anAJob
	^self new initializeTask: anATask job: anAJob! !
!TaskSender methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 13:56:36'!
initializeTask: anATask job: anAJob
	task := anATask.
	job := anAJob.! !
!TaskSender methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 13:56:36'!
compute 
	| notProcessed processed copied executed |
	"hacemos cosas compliquetis"
	notProcessed  := 3.
	processed := task.
	copied := job.
	executed := 4.
	^ notProcessed  + processed  + copied + executed! !
!Obligation methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 13:56:36' prior: 50700271!
sendTask: aTask job: aJob
	^(TaskSender task: aTask job: aJob) compute! !
!TaskSender methodsFor: 'evaluating' stamp: 'MS 10/9/2023 14:00:22' prior: 50700300!
compute 
	| notProcessed processed copied executed |
	"hacemos cosas compliquetis"
	notProcessed  := 3.
	processed := task.
	copied := job.
	executed := 4.
	^ notProcessed  + processed  + copied + executed! !
!Obligation methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 14:02:38' prior: 50700310!
sendTask: aTask job: aJob
	! !

!classRemoval: #TaskSender stamp: 'MS 10/9/2023 14:02:48'!
Object subclass: #TaskSender
	instanceVariableNames: 'task job'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Prueba_MethodObject'!
!Obligation methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 13:44:18' prior: 50700325!
sendTask: aTask job: aJob 
	| notProcessed processed copied executed |
	"hacemos cosas compliquetis"
	notProcessed  := 3.
	processed := aTask.
	copied := aJob.
	executed := 4.
	^ notProcessed  + processed  + copied + executed! !
!Obligation methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 14:03:44' prior: 50700336!
sendTask: aTask job: aJob 
	| notProcessed processed copied executed |
	notProcessed  := 3.
	processed := aTask.
	copied := aJob.
	executed := 4.
	^ notProcessed  + processed  + copied + executed! !
!Obligation methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 14:04:18' prior: 50700347!
sendTask: aTask job: aJob 
	| notProcessed processed copied executed |
	notProcessed  := 3.
	processed := 2.
	copied := 1.
	executed := 4.
	^ notProcessed  + processed  + copied + executed! !
!Obligation methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 14:04:42' prior: 50700357!
sendTask: aTask job: aJob 
	| notProcessed processed copied executed |
	notProcessed  := 3.
	processed := aJob.
	copied := aTask.
	executed := 4.
	^ notProcessed  + processed  + copied + executed! !

!classDefinition: #TaskSender category: 'Prueba_MethodObject' stamp: 'MS 10/9/2023 14:06:24'!
Object subclass: #TaskSender
	instanceVariableNames: 'task job'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Prueba_MethodObject'!
!TaskSender class methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 14:06:24'!
task: anATask job: anAJob
	^self new initializeTask: anATask job: anAJob! !
!TaskSender methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 14:06:24'!
initializeTask: anATask job: anAJob
	task := anATask.
	job := anAJob.! !
!TaskSender methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 14:06:24'!
compute 
	| notProcessed processed copied executed |
	notProcessed  := 3.
	processed := job.
	copied := task.
	executed := 4.
	^ notProcessed  + processed  + copied + executed! !
!Obligation methodsFor: 'as yet unclassified' stamp: 'MS 10/9/2023 14:06:24' prior: 50700366!
sendTask: aTask job: aJob
	^(TaskSender task: aTask job: aJob) compute! !

----QUIT----(9 October 2023 15:26:01) CuisUniversity-5981.image priorSource: 11794252!

----STARTUP---- (12 October 2023 15:37:36) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----QUIT----(12 October 2023 15:38:55) CuisUniversity-5981.image priorSource: 11800201!

----STARTUP---- (13 October 2023 18:45:57) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!


----End fileIn of /home/martin/Downloads/Portfolio-Ejercicio.st----!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'MS 10/13/2023 18:46:36'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'MS 10/13/2023 18:46:36'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'MS 10/13/2023 18:46:36'!
FAILURE!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'MS 10/13/2023 18:46:36'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'MS 10/13/2023 18:46:36'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'MS 10/13/2023 18:46:36'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'MS 10/13/2023 18:46:36'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'MS 10/13/2023 18:46:36'!
FAILURE!
!ReceptiveAccount methodsFor: 'balance' stamp: 'MS 10/13/2023 18:49:36' prior: 50700633!
balance

	transactions inject: 0 into:[: aTransaction :partialBalance | aTransaction sumToBalance: partialBalance.].

	
	! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'MS 10/13/2023 18:49:50' prior: 50700676!
balance

	^transactions inject: 0 into:[: aTransaction :partialBalance | aTransaction sumToBalance: partialBalance.].

	
	! !
!AccountTransaction methodsFor: 'nil' stamp: 'MS 10/13/2023 18:50:04'!
addToBalance: aBalance! !
!Deposit methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 18:50:07' overrides: 50700690!
addToBalance: aBalance! !
!Withdraw methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 18:50:07' overrides: 50700690!
addToBalance: aBalance! !
!AccountTransaction methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 18:50:07' prior: 50700690!
addToBalance: aBalance

	self subclassResponsibility! !
!Deposit methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 18:50:22' prior: 50700694 overrides: 50700703!
addToBalance: aBalance
	^aBalance + value ! !
!Withdraw methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 18:50:31' prior: 50700698 overrides: 50700703!
addToBalance: aBalance
	^aBalance - value! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'MS 10/13/2023 18:50:33'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'MS 10/13/2023 18:50:33'!
ERROR!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'MS 10/13/2023 18:50:33'!
ERROR!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'MS 10/13/2023 18:50:33'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'MS 10/13/2023 18:50:33'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'MS 10/13/2023 18:50:33'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'MS 10/13/2023 18:50:33'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'MS 10/13/2023 18:50:38'!
ERROR!
!ReceptiveAccount methodsFor: 'balance' stamp: 'MS 10/13/2023 18:51:23' prior: 50700683!
balance

	^transactions inject: 0 into:[:partialBalance :aTransaction | aTransaction sumToBalance: partialBalance.].

	
	! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'MS 10/13/2023 18:51:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'MS 10/13/2023 18:51:24'!
ERROR!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'MS 10/13/2023 18:51:24'!
ERROR!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'MS 10/13/2023 18:51:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'MS 10/13/2023 18:51:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'MS 10/13/2023 18:51:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'MS 10/13/2023 18:51:24'!
PASSED!
!AccountTransaction methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 18:51:54'!
sumToBalance: aBalance

	self subclassResponsibility! !
!Deposit methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 18:51:54' overrides: 50700783!
sumToBalance: aBalance
	^aBalance + value ! !
!Withdraw methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 18:51:54' overrides: 50700783!
sumToBalance: aBalance
	^aBalance - value! !

!methodRemoval: AccountTransaction #addToBalance: stamp: 'MS 10/13/2023 18:51:54'!
addToBalance: aBalance

	self subclassResponsibility!

!methodRemoval: Deposit #addToBalance: stamp: 'MS 10/13/2023 18:51:54'!
addToBalance: aBalance
	^aBalance + value !

!methodRemoval: Withdraw #addToBalance: stamp: 'MS 10/13/2023 18:51:54'!
addToBalance: aBalance
	^aBalance - value!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'MS 10/13/2023 18:52:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'MS 10/13/2023 18:52:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'MS 10/13/2023 18:52:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'MS 10/13/2023 18:52:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'MS 10/13/2023 18:52:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'MS 10/13/2023 18:52:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'MS 10/13/2023 18:52:03'!
PASSED!

TestCase subclass: #PortfolioTests
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTests category: 'Portfolio-Ejercicio' stamp: 'MS 10/13/2023 18:52:35'!
TestCase subclass: #PortfolioTests
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'MS 10/13/2023 18:54:36'!
Object subclass: #Portfolio
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTests methodsFor: 'no messages' stamp: 'MS 10/13/2023 18:54:27'!
test01
	| aPortfolio |
	aPortfolio := Portfolio new.
	self assert: Portfolio balance equals: 0.! !
!PortfolioTests methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 18:54:48' prior: 50700855!
test01
	| aPortfolio |
	aPortfolio := Portfolio new.
	self assert: aPortfolio balance equals: 0.! !

!testRun: #PortfolioTests #test01 stamp: 'MS 10/13/2023 18:54:50'!
ERROR!
!Portfolio methodsFor: 'accessing' stamp: 'MS 10/13/2023 18:55:06'!
balance
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'accessing' stamp: 'MS 10/13/2023 18:55:15' prior: 50700870!
balance
	^0! !

!classRenamed: #PortfolioTests as: #TestsXX stamp: 'MS 10/13/2023 18:55:27'!
Smalltalk renameClassNamed: #PortfolioTests as: #TestsXX!

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 18:55:31'!
PASSED!

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 18:55:31'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 18:57:36'!
test02
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	self assert: aPortfolio balance equals: 200.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 18:57:44' prior: 50700886!
test02
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	
	Deposit register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	
	self assert: aPortfolio balance equals: 200.! !

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 18:58:04'!
ERROR!

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 18:58:15'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 18:58:24'!
addAccount: anAccount 
	self shouldBeImplemented.! !

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'MS 10/13/2023 19:01:05'!
Object subclass: #Portfolio
	instanceVariableNames: 'xx'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:01:04' prior: 50700910!
addAccount: anAccount 
	xx := anAccount .! !
!Portfolio methodsFor: 'accessing' stamp: 'MS 10/13/2023 19:01:16' prior: 50700874!
balance
	^xx balance! !
!Portfolio methodsFor: 'nil' stamp: 'MS 10/13/2023 19:01:43' overrides: 16920235!
initialize 
	xx := 0.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:01:52' prior: 50700931 overrides: 16920235!
initialize 
	xx := ReceptiveAccount new.! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'MS 10/13/2023 19:02:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'MS 10/13/2023 19:02:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'MS 10/13/2023 19:02:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'MS 10/13/2023 19:02:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'MS 10/13/2023 19:02:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'MS 10/13/2023 19:02:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'MS 10/13/2023 19:02:03'!
PASSED!

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 19:02:06'!
PASSED!

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 19:02:06'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:02:49'!
test03
	| aPortfolio firstAccount secondAccount|
	aPortfolio := Portfolio new.
	
	firstAccount := ReceptiveAccount new.
	Deposit register: 200 on: firstAccount.
	aPortfolio addAccount: firstAccount.
	
	firstAccount := ReceptiveAccount new.
	Deposit register: 200 on: firstAccount.
	aPortfolio addAccount: firstAccount.
	
	self assert: aPortfolio balance equals: 200.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:03:16' prior: 50700971!
test03
	| aPortfolio firstAccount secondAccount|
	aPortfolio := Portfolio new.
	
	firstAccount := ReceptiveAccount new.
	Deposit register: 200 on: firstAccount.
	aPortfolio addAccount: firstAccount.
	
	secondAccount := ReceptiveAccount new.
	Deposit register: 50 on: secondAccount.
	aPortfolio addAccount: secondAccount.
	
	self assert: aPortfolio balance equals: 250.! !

!testRun: #TestsXX #test03 stamp: 'MS 10/13/2023 19:03:17'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:03:37' prior: 50700922!
addAccount: anAccount 
	xx add: anAccount .! !
!Portfolio methodsFor: 'accessing' stamp: 'MS 10/13/2023 19:04:09' prior: 50700927!
balance
	xx sum: [:anAccount | anAccount balance].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:04:16' prior: 50700936 overrides: 16920235!
initialize 
	xx := OrderedCollection new.! !

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 19:04:46'!
ERROR!

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 19:04:46'!
FAILURE!

!testRun: #TestsXX #test03 stamp: 'MS 10/13/2023 19:04:46'!
FAILURE!
!Portfolio methodsFor: 'accessing' stamp: 'MS 10/13/2023 19:05:07' prior: 50701008!
balance
	xx sum: [:anAccount | anAccount balance] ifEmpty: [0].! !

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 19:05:10'!
FAILURE!

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 19:05:10'!
FAILURE!

!testRun: #TestsXX #test03 stamp: 'MS 10/13/2023 19:05:10'!
FAILURE!
!Portfolio methodsFor: 'accessing' stamp: 'MS 10/13/2023 19:05:19' prior: 50701025!
balance
	^xx sum: [:anAccount | anAccount balance] ifEmpty: [0].! !

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 19:05:20'!
PASSED!

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 19:05:20'!
PASSED!

!testRun: #TestsXX #test03 stamp: 'MS 10/13/2023 19:05:20'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:14:06'!
test04
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	
	self
	  should: [aPortfolio addAccount: anAccount. aPortfolio addAccount: anAccount.	]
	  raise: Error
	  description: Portfolio accountAlreadyInPorfolioError.	! !

!testRun: #TestsXX #test04 stamp: 'MS 10/13/2023 19:14:09'!
ERROR!
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:14:21'!
accountAlreadyInPorfolioError
	self shouldBeImplemented.! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:14:46' prior: 50701063!
accountAlreadyInPorfolioError
	'This account has already been added to this porfolio!!'! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:16:59' prior: 50701048!
test04
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	
	self
	  should: [aPortfolio addAccount: anAccount. aPortfolio addAccount: anAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	! !

!testRun: #TestsXX #test04 stamp: 'MS 10/13/2023 19:16:59'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:19:38' prior: 50701003!
addAccount: anAccount 
	(xx includes: anAccount) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	xx add: anAccount .! !

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 19:19:45'!
PASSED!

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 19:19:45'!
PASSED!

!testRun: #TestsXX #test03 stamp: 'MS 10/13/2023 19:19:45'!
PASSED!

!testRun: #TestsXX #test04 stamp: 'MS 10/13/2023 19:19:45'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:24:23'!
test05
	| aPortfolio anPortfolio |
	aPortfolio := Portfolio new.
	
	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:24:55' prior: 50701107!
test05
	| aPortfolio |
	aPortfolio := Portfolio new.
	self assert: aPortfolio balance equals: 0.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:25:33' prior: 50701113!
test05
	| aPortfolio innerPortfolio|
	aPortfolio := Portfolio new.
	self assert: aPortfolio balance equals: 0.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:25:39' prior: 50701119!
test05
	| outerPortfolio innerPortfolio|
	outerPortfolio := Portfolio new.
	self assert: outerPortfolio balance equals: 0.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:27:54' prior: 50701126!
test05
	| outerPortfolio innerPortfolio anAccount|
	outerPortfolio := Portfolio new.
	innerPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	
	innerPortfolio  addAccount: (ReceptiveAccount new)
	self assert: outerPortfolio balance equals: 0.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:29:17' prior: 50701133!
test05
	| outerPortfolio innerPortfolio anAccount|
	outerPortfolio := Portfolio new.
	innerPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	Deposit register: 100 on: anAccount.
	innerPortfolio  addAccount: (ReceptiveAccount new).
	
	outerPortfolio addPortfolio: innerPortfolio.
	self assert: outerPortfolio balance equals: 300.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:29:51' prior: 50701146!
test05
	| outerPortfolio innerPortfolio anAccount|
	outerPortfolio := Portfolio new.
	innerPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	innerPortfolio  addAccount: (ReceptiveAccount new).
	
	outerPortfolio addPortfolio: innerPortfolio.
	self assert: outerPortfolio balance equals: 300.! !

!testRun: #TestsXX #test05 stamp: 'MS 10/13/2023 19:29:52'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:29:59'!
addPortfolio: innerPortfolio 
	self shouldBeImplemented.! !

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'MS 10/13/2023 19:31:59'!
Object subclass: #Portfolio
	instanceVariableNames: 'xx yy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:31:58' prior: 50701177!
addPortfolio: aPortfolio 
	yy add: aPortfolio.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:32:14' prior: 50701014 overrides: 16920235!
initialize 
	xx := OrderedCollection new.
	yy := OrderedCollection new.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:32:44' prior: 50701037!
balance
	^(xx sum: [:anAccount | anAccount balance] ifEmpty: [0]) + (yy sum: [:anAccount | anAccount balance] ifEmpty: [0]).! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:34:20' prior: 50701161!
test05
	| outerPortfolio innerPortfolio anAccount|
	outerPortfolio := Portfolio new.
	innerPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	innerPortfolio  addAccount: (ReceptiveAccount new).
	
	outerPortfolio addPortfolio: innerPortfolio.
	self assert: outerPortfolio balance equals: 200.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:36:15' prior: 50701202!
balance
	^(xx sum: [:anAccount | anAccount balance] ifEmpty: [0]) + (yy sum: [:aPortfolio | aPortfolio balance] ifEmpty: [0]).! !

!testRun: #TestsXX #test05 stamp: 'MS 10/13/2023 19:36:24'!
FAILURE!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:38:58' prior: 50701209!
test05
	| outerPortfolio innerPortfolio anAccount|
	outerPortfolio := Portfolio new.
	innerPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	innerPortfolio  addAccount: anAccount.
	
	outerPortfolio addPortfolio: innerPortfolio.
	self assert: outerPortfolio balance equals: 200.! !

!testRun: #TestsXX #test05 stamp: 'MS 10/13/2023 19:39:03'!
PASSED!

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 19:39:09'!
PASSED!

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 19:39:09'!
PASSED!

!testRun: #TestsXX #test03 stamp: 'MS 10/13/2023 19:39:09'!
PASSED!

!testRun: #TestsXX #test04 stamp: 'MS 10/13/2023 19:39:09'!
PASSED!

!testRun: #TestsXX #test05 stamp: 'MS 10/13/2023 19:39:09'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:45:49'!
test06
	| outerPortfolio innerPortfolio anAccount|
	outerPortfolio := Portfolio new.
	innerPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	innerPortfolio  addAccount: anAccount.
	
	outerPortfolio addPortfolio: innerPortfolio.
	self assert: outerPortfolio balance equals: 200.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 19:59:55' prior: 50701259!
test06
	| fstPortfolio innerPortfolio anAccount|
	fstPortfolio := Portfolio new.
	innerPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	innerPortfolio  addAccount: anAccount.
	
	fstPortfolio addPortfolio: innerPortfolio.
	self assert: fstPortfolio balance equals: 200.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:00:04' prior: 50701273!
test06
	| fstPortfolio sndPortfolio anAccount|
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	sndPortfolio  addAccount: anAccount.
	
	fstPortfolio addPortfolio: sndPortfolio.
	self assert: fstPortfolio balance equals: 200.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:00:21' prior: 50701287!
test06
	| fstPortfolio sndPortfolio trdPortfolio anAccount|
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	sndPortfolio  addAccount: anAccount.
	
	fstPortfolio addPortfolio: sndPortfolio.
	self assert: fstPortfolio balance equals: 200.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:00:29' prior: 50701300!
test06
	| fstPortfolio sndPortfolio trdPortfolio anAccount|
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	trdPortfolio  addAccount: anAccount.
	
	fstPortfolio addPortfolio: sndPortfolio.
	self assert: fstPortfolio balance equals: 200.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:02:47' prior: 50701315!
test06
	| fstPortfolio sndPortfolio trdPortfolio anAccount otherAccount|
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	otherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount.
	Deposit register: 200 on: otherAccount.
	trdPortfolio  addAccount: anAccount.
	sndPortfolio addAccount: otherAccount.
	
	sndPortfolio addPortfolio: trdPortfolio.
	fstPortfolio addPortfolio: sndPortfolio.
	
	self assert: fstPortfolio balance equals: 200.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:02:51' prior: 50701330!
test06
	| fstPortfolio sndPortfolio trdPortfolio anAccount otherAccount|
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	otherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount.
	Deposit register: 200 on: otherAccount.
	trdPortfolio  addAccount: anAccount.
	sndPortfolio addAccount: otherAccount.
	
	sndPortfolio addPortfolio: trdPortfolio.
	fstPortfolio addPortfolio: sndPortfolio.
	
	self assert: fstPortfolio balance equals: 300.! !

!testRun: #TestsXX #test06 stamp: 'MS 10/13/2023 20:02:56'!
PASSED!

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 20:02:56'!
PASSED!

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 20:02:56'!
PASSED!

!testRun: #TestsXX #test03 stamp: 'MS 10/13/2023 20:02:56'!
PASSED!

!testRun: #TestsXX #test04 stamp: 'MS 10/13/2023 20:02:56'!
PASSED!

!testRun: #TestsXX #test05 stamp: 'MS 10/13/2023 20:02:56'!
PASSED!

!testRun: #TestsXX #test06 stamp: 'MS 10/13/2023 20:02:56'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:03:36'!
test07
	| fstPortfolio sndPortfolio trdPortfolio anAccount otherAccount|
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	otherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount.
	Deposit register: 200 on: otherAccount.
	trdPortfolio  addAccount: anAccount.
	sndPortfolio addAccount: otherAccount.
	
	sndPortfolio addPortfolio: trdPortfolio.
	fstPortfolio addPortfolio: sndPortfolio.
	
	self assert: fstPortfolio balance equals: 300.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:03:43' prior: 50701385!
test07
	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:03:58' prior: 50701405!
test07
	| aTransaction anAccount |
	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:04:16' prior: 50701409!
test07
	| aTransaction anAccount aPortfolio |
	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:05:02' prior: 50701414!
test07
	| aTransaction anAccount aPortfolio |
	
	aTransaction := AccountTransaction new.
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:05:41' prior: 50701419!
test07
	| aTransaction anAccount aPortfolio |
	
	aTransaction := AccountTransaction new.
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	
	self assert: (anAccount hasRegister: aTransaction) equals: false.
	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:07:49'!
test08
	| aTransaction anAccount aPortfolio |
	
	aTransaction := AccountTransaction new.
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	
	
	
	self assert: (aPortfolio hasRegister: aTransaction) equals: false.
	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:08:25' prior: 50701437!
test08
	| aTransaction anAccount aPortfolio |
	
	aPortfolio := Portfolio new.
	
	self assert: (aPortfolio hasRegister: 3)equals: false.
	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:08:47'!
test08_
	| aTransaction anAccount aPortfolio |
	
	aTransaction := AccountTransaction new.
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	
	self assert: (anAccount hasRegister: aTransaction) equals: false.
	! !

!methodRemoval: TestsXX #test07 stamp: 'MS 10/13/2023 20:08:47'!
test07
	| aTransaction anAccount aPortfolio |
	
	aTransaction := AccountTransaction new.
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	
	self assert: (anAccount hasRegister: aTransaction) equals: false.
	!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:08:54'!
test07
	| aTransaction anAccount aPortfolio |
	
	aPortfolio := Portfolio new.
	
	self assert: (aPortfolio hasRegister: 3)equals: false.
	! !

!methodRemoval: TestsXX #test08 stamp: 'MS 10/13/2023 20:08:54'!
test08
	| aTransaction anAccount aPortfolio |
	
	aPortfolio := Portfolio new.
	
	self assert: (aPortfolio hasRegister: 3)equals: false.
	!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:08:57'!
test08
	| aTransaction anAccount aPortfolio |
	
	aTransaction := AccountTransaction new.
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	
	self assert: (anAccount hasRegister: aTransaction) equals: false.
	! !

!methodRemoval: TestsXX #test08_ stamp: 'MS 10/13/2023 20:08:57'!
test08_
	| aTransaction anAccount aPortfolio |
	
	aTransaction := AccountTransaction new.
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	
	self assert: (anAccount hasRegister: aTransaction) equals: false.
	!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:09:57' prior: 50701474!
test07
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	
	self assert: (aPortfolio hasRegister: 3)equals: false.
	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:10:10' prior: 50701508!
test07
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	
	self assert: (aPortfolio hasRegister: aTransaction) equals: false.
	! !

!testRun: #TestsXX #test07 stamp: 'MS 10/13/2023 20:10:30'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:10:35'!
hasRegister: aTransaction 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:10:40' prior: 50701532!
hasRegister: aTransaction 
	^false! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:10:55' prior: 50701519!
test07
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	
	self deny: (aPortfolio hasRegister: aTransaction) equals: false.
	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:11:10' prior: 50701542!
test07
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	
	self assert: (aPortfolio hasRegister: aTransaction) equals: false.
	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:11:23' prior: 50701553!
test07
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	
	self deny: (aPortfolio hasRegister: aTransaction).
	! !

!testRun: #TestsXX #test07 stamp: 'MS 10/13/2023 20:11:24'!
PASSED!

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 20:11:24'!
PASSED!

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 20:11:24'!
PASSED!

!testRun: #TestsXX #test03 stamp: 'MS 10/13/2023 20:11:24'!
PASSED!

!testRun: #TestsXX #test04 stamp: 'MS 10/13/2023 20:11:24'!
PASSED!

!testRun: #TestsXX #test05 stamp: 'MS 10/13/2023 20:11:24'!
PASSED!

!testRun: #TestsXX #test06 stamp: 'MS 10/13/2023 20:11:24'!
PASSED!

!testRun: #TestsXX #test07 stamp: 'MS 10/13/2023 20:11:24'!
PASSED!

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:11:24'!
ERROR!

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:11:24'!
ERROR!

!testRun: #TestsXX #test07 stamp: 'MS 10/13/2023 20:11:59'!
PASSED!

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 20:11:59'!
PASSED!

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 20:11:59'!
PASSED!

!testRun: #TestsXX #test03 stamp: 'MS 10/13/2023 20:11:59'!
PASSED!

!testRun: #TestsXX #test04 stamp: 'MS 10/13/2023 20:11:59'!
PASSED!

!testRun: #TestsXX #test05 stamp: 'MS 10/13/2023 20:11:59'!
PASSED!

!testRun: #TestsXX #test06 stamp: 'MS 10/13/2023 20:11:59'!
PASSED!

!testRun: #TestsXX #test07 stamp: 'MS 10/13/2023 20:11:59'!
PASSED!

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:11:59'!
ERROR!

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:11:59'!
ERROR!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:12:16' prior: 50701488!
test08"
	| aTransaction anAccount aPortfolio |
	
	aTransaction := AccountTransaction new.
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	
	self assert: (anAccount hasRegister: aTransaction) equals: false."
	! !

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:12:18'!
PASSED!

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 20:12:18'!
PASSED!

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 20:12:18'!
PASSED!

!testRun: #TestsXX #test03 stamp: 'MS 10/13/2023 20:12:18'!
PASSED!

!testRun: #TestsXX #test04 stamp: 'MS 10/13/2023 20:12:18'!
PASSED!

!testRun: #TestsXX #test05 stamp: 'MS 10/13/2023 20:12:18'!
PASSED!

!testRun: #TestsXX #test06 stamp: 'MS 10/13/2023 20:12:18'!
PASSED!

!testRun: #TestsXX #test07 stamp: 'MS 10/13/2023 20:12:18'!
PASSED!

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:12:18'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:12:34' prior: 50701617!
test08
	| aTransaction anAccount aPortfolio |
	
	aTransaction := AccountTransaction new.
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	
	self assert: (anAccount hasRegister: aTransaction) equals: false.
	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:13:23' prior: 50701647!
test08
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio addAccount: aTransaction.
	
	self assert: (aPortfolio hasRegister: aTransaction).! !

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:13:25'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:26:28' prior: 50701537!
hasRegister: aTransaction 
	^xx anySatisfy: [:anAccount | anAccount transactions includes: aTransaction]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:26:56' prior: 50701672!
hasRegister: aTransaction 
	^xx anySatisfy: [:anAccount | anAccount hasRegistered: aTransaction]! !

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:27:07'!
ERROR!

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:28:28'!
ERROR!

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:28:32'!
ERROR!

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:29:05'!
ERROR!

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:29:09'!
ERROR!

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:29:32'!
ERROR!

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:29:32'!
ERROR!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:30:46' prior: 50701658!
test08
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	
	self assert: (aPortfolio hasRegister: aTransaction).! !

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:30:47'!
PASSED!

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 20:30:47'!
PASSED!

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 20:30:47'!
PASSED!

!testRun: #TestsXX #test03 stamp: 'MS 10/13/2023 20:30:47'!
PASSED!

!testRun: #TestsXX #test04 stamp: 'MS 10/13/2023 20:30:47'!
PASSED!

!testRun: #TestsXX #test05 stamp: 'MS 10/13/2023 20:30:47'!
PASSED!

!testRun: #TestsXX #test06 stamp: 'MS 10/13/2023 20:30:47'!
PASSED!

!testRun: #TestsXX #test07 stamp: 'MS 10/13/2023 20:30:47'!
PASSED!

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:30:47'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:31:13'!
test09
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	
	self assert: (aPortfolio hasRegister: aTransaction).! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:32:31' prior: 50701730!
test09
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio addAccount: anAccount.
	aPortfolio addPortfolio: otherPortfolio.
	self assert: (aPortfolio hasRegister: aTransaction).! !

!testRun: #TestsXX #test09 stamp: 'MS 10/13/2023 20:32:32'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:33:36' prior: 50701679!
hasRegister: aTransaction 
	^(xx anySatisfy: [:anAccount | anAccount hasRegistered: aTransaction]) or: (yy anySatisfy: [:aPortfolio | aPortfolio hasRegister: aTransaction])! !

!testRun: #TestsXX #test09 stamp: 'MS 10/13/2023 20:33:42'!
PASSED!

!testRun: #TestsXX #test01 stamp: 'MS 10/13/2023 20:33:42'!
PASSED!

!testRun: #TestsXX #test02 stamp: 'MS 10/13/2023 20:33:42'!
PASSED!

!testRun: #TestsXX #test03 stamp: 'MS 10/13/2023 20:33:42'!
PASSED!

!testRun: #TestsXX #test04 stamp: 'MS 10/13/2023 20:33:42'!
PASSED!

!testRun: #TestsXX #test05 stamp: 'MS 10/13/2023 20:33:42'!
PASSED!

!testRun: #TestsXX #test06 stamp: 'MS 10/13/2023 20:33:42'!
PASSED!

!testRun: #TestsXX #test07 stamp: 'MS 10/13/2023 20:33:42'!
PASSED!

!testRun: #TestsXX #test08 stamp: 'MS 10/13/2023 20:33:42'!
PASSED!

!testRun: #TestsXX #test09 stamp: 'MS 10/13/2023 20:33:42'!
PASSED!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'MS 10/13/2023 20:35:20'!
Object subclass: #Portfolio
	instanceVariableNames: 'storedAccounts yy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:35:20' prior: 50701196 overrides: 16920235!
initialize 
	storedAccounts := OrderedCollection new.
	yy := OrderedCollection new.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:35:20' prior: 50701223!
balance
	^(storedAccounts sum: [:anAccount | anAccount balance] ifEmpty: [0]) + (yy sum: [:aPortfolio | aPortfolio balance] ifEmpty: [0]).! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:35:20' prior: 50701091!
addAccount: anAccount 
	(storedAccounts includes: anAccount) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedAccounts add: anAccount .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:35:20' prior: 50701759!
hasRegister: aTransaction 
	^(storedAccounts anySatisfy: [:anAccount | anAccount hasRegistered: aTransaction]) or: (yy anySatisfy: [:aPortfolio | aPortfolio hasRegister: aTransaction])! !

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'MS 10/13/2023 20:35:48'!
Object subclass: #Portfolio
	instanceVariableNames: 'storedAccounts storedPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:35:48' prior: 50701798 overrides: 16920235!
initialize 
	storedAccounts := OrderedCollection new.
	storedPortfolios := OrderedCollection new.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:35:48' prior: 50701804!
balance
	^(storedAccounts sum: [:anAccount | anAccount balance] ifEmpty: [0]) + (storedPortfolios sum: [:aPortfolio | aPortfolio balance] ifEmpty: [0]).! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:35:48' prior: 50701190!
addPortfolio: aPortfolio 
	storedPortfolios add: aPortfolio.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:35:48' prior: 50701821!
hasRegister: aTransaction 
	^(storedAccounts anySatisfy: [:anAccount | anAccount hasRegistered: aTransaction]) or: (storedPortfolios anySatisfy: [:aPortfolio | aPortfolio hasRegister: aTransaction])! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:43:33' prior: 50701859!
hasRegister: aTransaction 
	^(storedAccounts anySatisfy: [:anAccount | anAccount hasRegistered: aTransaction]) or:
	   (storedPortfolios anySatisfy: [:aPortfolio | aPortfolio hasRegister: aTransaction])! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:43:41' prior: 50701846!
balance
	^(storedAccounts sum: [:anAccount | anAccount balance] ifEmpty: [0]) +
	   (storedPortfolios sum: [:aPortfolio | aPortfolio balance] ifEmpty: [0]).! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:45:21'!
test10
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio addAccount: anAccount.
	aPortfolio addPortfolio: otherPortfolio.
	self assert: (aPortfolio hasRegister: aTransaction).! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:49:01'!
test01_NewPortfolioHasNoBalance
	| aPortfolio |
	aPortfolio := Portfolio new.
	self assert: aPortfolio balance equals: 0.! !

!methodRemoval: TestsXX #test01 stamp: 'MS 10/13/2023 20:49:01'!
test01
	| aPortfolio |
	aPortfolio := Portfolio new.
	self assert: aPortfolio balance equals: 0.!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:51:46'!
test02_PortfolioWithAccountHasCorrectBalance
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	
	Deposit register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	
	self assert: aPortfolio balance equals: 200.! !

!methodRemoval: TestsXX #test02 stamp: 'MS 10/13/2023 20:51:46'!
test02
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	
	Deposit register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	
	self assert: aPortfolio balance equals: 200.!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:52:20'!
test03_PortfolioWithMultipleAccountsHasCorrectBalance
	| aPortfolio firstAccount secondAccount|
	aPortfolio := Portfolio new.
	
	firstAccount := ReceptiveAccount new.
	Deposit register: 200 on: firstAccount.
	aPortfolio addAccount: firstAccount.
	
	secondAccount := ReceptiveAccount new.
	Deposit register: 50 on: secondAccount.
	aPortfolio addAccount: secondAccount.
	
	self assert: aPortfolio balance equals: 250.! !

!methodRemoval: TestsXX #test03 stamp: 'MS 10/13/2023 20:52:20'!
test03
	| aPortfolio firstAccount secondAccount|
	aPortfolio := Portfolio new.
	
	firstAccount := ReceptiveAccount new.
	Deposit register: 200 on: firstAccount.
	aPortfolio addAccount: firstAccount.
	
	secondAccount := ReceptiveAccount new.
	Deposit register: 50 on: secondAccount.
	aPortfolio addAccount: secondAccount.
	
	self assert: aPortfolio balance equals: 250.!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/13/2023 20:53:03'!
test04_PortfolioWithAccountCannotStoreSameAccount
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	
	self
	  should: [aPortfolio addAccount: anAccount. aPortfolio addAccount: anAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	! !

!methodRemoval: TestsXX #test04 stamp: 'MS 10/13/2023 20:53:03'!
test04
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	
	self
	  should: [aPortfolio addAccount: anAccount. aPortfolio addAccount: anAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	!

----QUIT----(13 October 2023 20:54:30) CuisUniversity-5981.image priorSource: 11800407!

----STARTUP---- (15 October 2023 18:19:18) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!

!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:20:29'!
test05_Portfolio
	| outerPortfolio innerPortfolio anAccount|
	outerPortfolio := Portfolio new.
	innerPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	innerPortfolio  addAccount: anAccount.
	
	outerPortfolio addPortfolio: innerPortfolio.
	self assert: outerPortfolio balance equals: 200.! !

!methodRemoval: TestsXX #test05_Portfolio stamp: 'MS 10/15/2023 18:20:36'!
test05_Portfolio
	| outerPortfolio innerPortfolio anAccount|
	outerPortfolio := Portfolio new.
	innerPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	innerPortfolio  addAccount: anAccount.
	
	outerPortfolio addPortfolio: innerPortfolio.
	self assert: outerPortfolio balance equals: 200.!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:21:03'!
test05_PortfolioWithPortfolioHasCorrectBalance
	| outerPortfolio innerPortfolio anAccount|
	outerPortfolio := Portfolio new.
	innerPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	innerPortfolio  addAccount: anAccount.
	
	outerPortfolio addPortfolio: innerPortfolio.
	self assert: outerPortfolio balance equals: 200.! !

!methodRemoval: TestsXX #test05 stamp: 'MS 10/15/2023 18:21:03'!
test05
	| outerPortfolio innerPortfolio anAccount|
	outerPortfolio := Portfolio new.
	innerPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	innerPortfolio  addAccount: anAccount.
	
	outerPortfolio addPortfolio: innerPortfolio.
	self assert: outerPortfolio balance equals: 200.!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:22:11'!
test06_PortfolioWithNestedPortfoliosHasCorrectBalance
	| fstPortfolio sndPortfolio trdPortfolio anAccount otherAccount|
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	otherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount.
	Deposit register: 200 on: otherAccount.
	trdPortfolio  addAccount: anAccount.
	sndPortfolio addAccount: otherAccount.
	
	sndPortfolio addPortfolio: trdPortfolio.
	fstPortfolio addPortfolio: sndPortfolio.
	
	self assert: fstPortfolio balance equals: 300.! !

!methodRemoval: TestsXX #test06 stamp: 'MS 10/15/2023 18:22:11'!
test06
	| fstPortfolio sndPortfolio trdPortfolio anAccount otherAccount|
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	otherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount.
	Deposit register: 200 on: otherAccount.
	trdPortfolio  addAccount: anAccount.
	sndPortfolio addAccount: otherAccount.
	
	sndPortfolio addPortfolio: trdPortfolio.
	fstPortfolio addPortfolio: sndPortfolio.
	
	self assert: fstPortfolio balance equals: 300.!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:25:10'!
test07_EmptyPortfolioHasNoTransactionsRegistered
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	
	self deny: (aPortfolio hasRegister: aTransaction).
	! !

!methodRemoval: TestsXX #test07 stamp: 'MS 10/15/2023 18:25:10'!
test07
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	
	self deny: (aPortfolio hasRegister: aTransaction).
	!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:26:14'!
test08_PortfolioRegistersTransactionFromAddedAccount
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	
	self assert: (aPortfolio hasRegister: aTransaction).! !

!methodRemoval: TestsXX #test08 stamp: 'MS 10/15/2023 18:26:14'!
test08
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	
	self assert: (aPortfolio hasRegister: aTransaction).!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:27:11'!
test09_PortfolioRegisteresTransactionFromNestedPortfolio
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio addAccount: anAccount.
	aPortfolio addPortfolio: otherPortfolio.
	self assert: (aPortfolio hasRegister: aTransaction).! !

!methodRemoval: TestsXX #test09 stamp: 'MS 10/15/2023 18:27:11'!
test09
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio addAccount: anAccount.
	aPortfolio addPortfolio: otherPortfolio.
	self assert: (aPortfolio hasRegister: aTransaction).!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:27:31'!
test10_xx
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio addAccount: anAccount.
	aPortfolio addPortfolio: otherPortfolio.
	self assert: (aPortfolio hasRegister: aTransaction).! !

!methodRemoval: TestsXX #test10 stamp: 'MS 10/15/2023 18:27:46'!
test10
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio addAccount: anAccount.
	aPortfolio addPortfolio: otherPortfolio.
	self assert: (aPortfolio hasRegister: aTransaction).!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:28:44' prior: 50702164!
test10_xx
	| aPortfolio |
	
	aPortfolio := Portfolio new.	
	self assert: aPortfolio transactions isEmpty.! !

!testRun: #TestsXX #test10_xx stamp: 'MS 10/15/2023 18:28:55'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:29:00'!
transactions
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:29:12' prior: 50702201!
transactions
	^OrderedCollection new.! !

!testRun: #TestsXX #test10_xx stamp: 'MS 10/15/2023 18:29:16'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 18:29:16'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 18:29:16'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 18:29:16'!
PASSED!

!testRun: #TestsXX #test04_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 18:29:16'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 18:29:16'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 18:29:16'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 18:29:16'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 18:29:16'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 18:29:16'!
PASSED!

!testRun: #TestsXX #test10_xx stamp: 'MS 10/15/2023 18:29:16'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:29:32' prior: 50702192!
test10_xx
	| aPortfolio |
	
	aPortfolio := Portfolio new.	
	self assert: aPortfolio transactions isEmpty.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:30:13'!
test10_EmptyPortfolioHasNoTransactions
	| aPortfolio |
	
	aPortfolio := Portfolio new.	
	self assert: aPortfolio transactions isEmpty.! !

!methodRemoval: TestsXX #test10_xx stamp: 'MS 10/15/2023 18:30:13'!
test10_xx
	| aPortfolio |
	
	aPortfolio := Portfolio new.	
	self assert: aPortfolio transactions isEmpty.!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:30:24'!
test11_EmptyPortfolioHasNoTransactions
	| aPortfolio aTransaction|
	
	aPortfolio := Portfolio new.	
	self assert: aPortfolio transactions isEmpty.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:31:55' prior: 50702265!
test11_EmptyPortfolioHasNoTransactions
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	
	self assert: aPortfolio transactions equals: #(aTransaction).! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:32:06'!
test10_EmptyPortfolioHasNoneTransactions
	| aPortfolio |
	
	aPortfolio := Portfolio new.	
	self assert: aPortfolio transactions isEmpty.! !

!methodRemoval: TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 18:32:06'!
test10_EmptyPortfolioHasNoTransactions
	| aPortfolio |
	
	aPortfolio := Portfolio new.	
	self assert: aPortfolio transactions isEmpty.!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:32:18'!
test07_EmptyPortfolioHasNoneTransactionsRegistered
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	
	self deny: (aPortfolio hasRegister: aTransaction).
	! !

!methodRemoval: TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 18:32:18'!
test07_EmptyPortfolioHasNoTransactionsRegistered
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	
	self deny: (aPortfolio hasRegister: aTransaction).
	!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:35:45'!
test10_EmptyPortfolioHasNoTransactions
	| aPortfolio |
	
	aPortfolio := Portfolio new.	
	self assert: aPortfolio transactions isEmpty.! !

!methodRemoval: TestsXX #test10_EmptyPortfolioHasNoneTransactions stamp: 'MS 10/15/2023 18:35:45'!
test10_EmptyPortfolioHasNoneTransactions
	| aPortfolio |
	
	aPortfolio := Portfolio new.	
	self assert: aPortfolio transactions isEmpty.!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:35:57'!
test07_EmptyPortfolioHasNoTransactionsRegistered
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	
	self deny: (aPortfolio hasRegister: aTransaction).
	! !

!methodRemoval: TestsXX #test07_EmptyPortfolioHasNoneTransactionsRegistered stamp: 'MS 10/15/2023 18:35:57'!
test07_EmptyPortfolioHasNoneTransactionsRegistered
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	
	self deny: (aPortfolio hasRegister: aTransaction).
	!

!testRun: #TestsXX #test11_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 18:37:03'!
FAILURE!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:37:30' prior: 50702273!
test11_EmptyPortfolioHasNoTransactions
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	
	self assert: aPortfolio transactions equals: (OrderedCollection with: aTransaction).! !

!testRun: #TestsXX #test11_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 18:37:31'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:40:24' prior: 50702206!
transactions
	! !

#(1 2 3)!

#(1 2 3) , #(4 5 6)!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:42:42' prior: 50702382!
transactions
	^ storedAccounts inject: OrderedCollection new into: [:anAccount :aCollection| aCollection , anAccount transactions.].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:43:20' prior: 50702387!
transactions
	^ storedAccounts inject: OrderedCollection new into: [:aCollection :anAccount| aCollection , anAccount transactions.].! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 18:43:25'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 18:43:25'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 18:43:25'!
PASSED!

!testRun: #TestsXX #test04_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 18:43:25'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 18:43:25'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 18:43:25'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 18:43:25'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 18:43:25'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 18:43:25'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 18:43:25'!
PASSED!

!testRun: #TestsXX #test11_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 18:43:25'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:44:10'!
test11_PortfolioHasTransactionsFromStoredAccount
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	
	self assert: aPortfolio transactions equals: (OrderedCollection with: aTransaction).! !

!methodRemoval: TestsXX #test11_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 18:44:16'!
test11_EmptyPortfolioHasNoTransactions
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	
	self assert: aPortfolio transactions equals: (OrderedCollection with: aTransaction).!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:49:50'!
test12_PortfolioHasTransactionsFromStoredPortfolios
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	
	self assert: aPortfolio transactions equals: (OrderedCollection with: aTransaction).! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:51:09' prior: 50702467!
test12_PortfolioHasTransactionsFromStoredPortfolios
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio addAccount: anAccount.
	aPortfolio addPortfolio: otherPortfolio.
	self assert: aPortfolio transactions equals: (OrderedCollection with: aTransaction) .! !

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 18:51:36'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 18:52:39' prior: 50702395!
transactions
	^ (storedAccounts inject: OrderedCollection new into: [:aCollection :anAccount| aCollection , anAccount transactions.]),
	    (storedPortfolios inject: OrderedCollection new into: [:aCollection :aPortfolio| aCollection , aPortfolio transactions.]).! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 18:52:41'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 18:52:41'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 18:52:41'!
PASSED!

!testRun: #TestsXX #test04_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 18:52:41'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 18:52:41'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 18:52:41'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 18:52:41'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 18:52:41'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 18:52:41'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 18:52:41'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 18:52:41'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 18:52:41'!
PASSED!

Object subclass: #SetOfFinantialEntities
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #SetOfFinantialEntities category: 'Portfolio-Ejercicio' stamp: 'MS 10/15/2023 19:02:50'!
Object subclass: #SetOfFinantialEntities
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

SetOfFinantialEntities subclass: #Portfolio
	instanceVariableNames: 'storedAccounts storedPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'MS 10/15/2023 19:03:04'!
SetOfFinantialEntities subclass: #Portfolio
	instanceVariableNames: 'storedAccounts storedPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

SetOfFinantialEntities subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: 'Portfolio-Ejercicio' stamp: 'MS 10/15/2023 19:03:11'!
SetOfFinantialEntities subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!SetOfFinantialEntities methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:03:31'!
balance

	self subclassResponsibility! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:04:28'!
hasRegistered: aTransaction 
	^(storedAccounts anySatisfy: [:anAccount | anAccount hasRegistered: aTransaction]) or:
	   (storedPortfolios anySatisfy: [:aPortfolio | aPortfolio hasRegister: aTransaction])! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:04:28' prior: 50702112!
test08_PortfolioRegistersTransactionFromAddedAccount
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio addAccount: anAccount.
	
	self assert: (aPortfolio hasRegistered: aTransaction).! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:04:28' prior: 50702135!
test09_PortfolioRegisteresTransactionFromNestedPortfolio
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio addAccount: anAccount.
	aPortfolio addPortfolio: otherPortfolio.
	self assert: (aPortfolio hasRegistered: aTransaction).! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:04:28' prior: 50701869!
hasRegister: aTransaction 
	^(storedAccounts anySatisfy: [:anAccount | anAccount hasRegistered: aTransaction]) or:
	   (storedPortfolios anySatisfy: [:aPortfolio | aPortfolio hasRegistered: aTransaction])! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:04:28' prior: 50702338!
test07_EmptyPortfolioHasNoTransactionsRegistered
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	
	self deny: (aPortfolio hasRegistered: aTransaction).
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:04:28' prior: 50702600!
hasRegistered: aTransaction 
	^(storedAccounts anySatisfy: [:anAccount | anAccount hasRegistered: aTransaction]) or:
	   (storedPortfolios anySatisfy: [:aPortfolio | aPortfolio hasRegistered: aTransaction])! !

!methodRemoval: Portfolio #hasRegister: stamp: 'MS 10/15/2023 19:04:28'!
hasRegister: aTransaction 
	^(storedAccounts anySatisfy: [:anAccount | anAccount hasRegistered: aTransaction]) or:
	   (storedPortfolios anySatisfy: [:aPortfolio | aPortfolio hasRegistered: aTransaction])!
!SetOfFinantialEntities methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:04:41'!
hasRegistered: aTransaction

	self subclassResponsibility! !
!SetOfFinantialEntities methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:04:50'!
transactions

	self subclassResponsibility! !

SetOfFinantialEntities subclass: #Portfolio
	instanceVariableNames: 'storedAccounts storedPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'MS 10/15/2023 19:06:01'!
SetOfFinantialEntities subclass: #Portfolio
	instanceVariableNames: 'storedAccounts storedPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'MS 10/15/2023 19:06:11'!
SetOfFinantialEntities subclass: #Portfolio
	instanceVariableNames: 'storedFinantialEntities storedPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:06:11' prior: 50701812!
addAccount: anAccount 
	(storedFinantialEntities includes: anAccount) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinantialEntities add: anAccount .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:06:11' prior: 50702502 overrides: 50702685!
transactions
	^ (storedFinantialEntities inject: OrderedCollection new into: [:aCollection :anAccount| aCollection , anAccount transactions.]),
	    (storedPortfolios inject: OrderedCollection new into: [:aCollection :aPortfolio| aCollection , aPortfolio transactions.]).! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:06:11' prior: 50701839 overrides: 16920235!
initialize 
	storedFinantialEntities := OrderedCollection new.
	storedPortfolios := OrderedCollection new.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:06:11' prior: 50702661 overrides: 50702680!
hasRegistered: aTransaction 
	^(storedFinantialEntities anySatisfy: [:anAccount | anAccount hasRegistered: aTransaction]) or:
	   (storedPortfolios anySatisfy: [:aPortfolio | aPortfolio hasRegistered: aTransaction])! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:06:11' prior: 50701879 overrides: 50702596!
balance
	^(storedFinantialEntities sum: [:anAccount | anAccount balance] ifEmpty: [0]) +
	   (storedPortfolios sum: [:aPortfolio | aPortfolio balance] ifEmpty: [0]).! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:06:25' prior: 50702754 overrides: 50702596!
balance
	^(storedFinantialEntities sum: [:anAccount | anAccount balance] ifEmpty: [0])! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:06:36' prior: 50702743 overrides: 50702680!
hasRegistered: aTransaction 
	^(storedFinantialEntities anySatisfy: [:anAccount | anAccount hasRegistered: aTransaction]).! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:06:46' prior: 50702723 overrides: 50702685!
transactions
	^ (storedFinantialEntities inject: OrderedCollection new into: [:aCollection :anAccount| aCollection , anAccount transactions.]).! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:06:51' prior: 50702736 overrides: 16920235!
initialize 
	storedFinantialEntities := OrderedCollection new.
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:07:23'!
add: anAccount 
	(storedFinantialEntities includes: anAccount) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinantialEntities add: anAccount .! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:07:23' prior: 50702025!
test05_PortfolioWithPortfolioHasCorrectBalance
	| outerPortfolio innerPortfolio anAccount|
	outerPortfolio := Portfolio new.
	innerPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	innerPortfolio  add: anAccount.
	
	outerPortfolio addPortfolio: innerPortfolio.
	self assert: outerPortfolio balance equals: 200.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:07:23' prior: 50702623!
test09_PortfolioRegisteresTransactionFromNestedPortfolio
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio add: anAccount.
	aPortfolio addPortfolio: otherPortfolio.
	self assert: (aPortfolio hasRegistered: aTransaction).! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:07:23' prior: 50702610!
test08_PortfolioRegistersTransactionFromAddedAccount
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio add: anAccount.
	
	self assert: (aPortfolio hasRegistered: aTransaction).! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:07:23' prior: 50701913!
test02_PortfolioWithAccountHasCorrectBalance
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	
	Deposit register: 200 on: anAccount.
	aPortfolio add: anAccount.
	
	self assert: aPortfolio balance equals: 200.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:07:23' prior: 50701963!
test04_PortfolioWithAccountCannotStoreSameAccount
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	
	self
	  should: [aPortfolio add: anAccount. aPortfolio add: anAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:07:23' prior: 50702052!
test06_PortfolioWithNestedPortfoliosHasCorrectBalance
	| fstPortfolio sndPortfolio trdPortfolio anAccount otherAccount|
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	otherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount.
	Deposit register: 200 on: otherAccount.
	trdPortfolio  add: anAccount.
	sndPortfolio add: otherAccount.
	
	sndPortfolio addPortfolio: trdPortfolio.
	fstPortfolio addPortfolio: sndPortfolio.
	
	self assert: fstPortfolio balance equals: 300.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:07:23' prior: 50701933!
test03_PortfolioWithMultipleAccountsHasCorrectBalance
	| aPortfolio firstAccount secondAccount|
	aPortfolio := Portfolio new.
	
	firstAccount := ReceptiveAccount new.
	Deposit register: 200 on: firstAccount.
	aPortfolio add: firstAccount.
	
	secondAccount := ReceptiveAccount new.
	Deposit register: 50 on: secondAccount.
	aPortfolio add: secondAccount.
	
	self assert: aPortfolio balance equals: 250.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:07:23' prior: 50702440!
test11_PortfolioHasTransactionsFromStoredAccount
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio add: anAccount.
	
	self assert: aPortfolio transactions equals: (OrderedCollection with: aTransaction).! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:07:23' prior: 50702481!
test12_PortfolioHasTransactionsFromStoredPortfolios
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio add: anAccount.
	aPortfolio addPortfolio: otherPortfolio.
	self assert: aPortfolio transactions equals: (OrderedCollection with: aTransaction) .! !

!methodRemoval: Portfolio #addAccount: stamp: 'MS 10/15/2023 19:07:23'!
addAccount: anAccount 
	(storedFinantialEntities includes: anAccount) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinantialEntities add: anAccount .!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:09:34' prior: 50701854!
addPortfolio: aPortfolio 
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:10:03' prior: 50702948!
addPortfolio: anAccount
	(storedFinantialEntities includes: anAccount) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinantialEntities add: anAccount .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:10:54' prior: 50702952!
addPortfolio: anAccount
	! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:11:18'!
addPortfolio: anAccount
	! !

!methodRemoval: Portfolio #addPortfolio: stamp: 'MS 10/15/2023 19:11:18'!
addPortfolio: anAccount
	!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:11:42'!
addPortfolio: anAccount
	! !

!methodRemoval: Portfolio class #addPortfolio: stamp: 'MS 10/15/2023 19:11:42'!
addPortfolio: anAccount
	!

----SNAPSHOT----(15 October 2023 19:11:59) CuisUniversity-5981.image priorSource: 11850914!

!methodRemoval: Portfolio #addPortfolio: stamp: 'MS 10/15/2023 19:15:17'!
addPortfolio: anAccount
	!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:15:49' prior: 50702923!
test12_PortfolioHasTransactionsFromStoredPortfolios
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio add: anAccount.
	aPortfolio add: otherPortfolio.
	self assert: aPortfolio transactions equals: (OrderedCollection with: aTransaction) .! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:15:49' prior: 50702872!
test06_PortfolioWithNestedPortfoliosHasCorrectBalance
	| fstPortfolio sndPortfolio trdPortfolio anAccount otherAccount|
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	otherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount.
	Deposit register: 200 on: otherAccount.
	trdPortfolio  add: anAccount.
	sndPortfolio add: otherAccount.
	
	sndPortfolio add: trdPortfolio.
	fstPortfolio add: sndPortfolio.
	
	self assert: fstPortfolio balance equals: 300.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:15:49' prior: 50702801!
test05_PortfolioWithPortfolioHasCorrectBalance
	| outerPortfolio innerPortfolio anAccount|
	outerPortfolio := Portfolio new.
	innerPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	innerPortfolio  add: anAccount.
	
	outerPortfolio add: innerPortfolio.
	self assert: outerPortfolio balance equals: 200.! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:15:49' prior: 50702816!
test09_PortfolioRegisteresTransactionFromNestedPortfolio
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio add: anAccount.
	aPortfolio add: otherPortfolio.
	self assert: (aPortfolio hasRegistered: aTransaction).! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:16:38' prior: 50702792!
add: aFinantialEntity 
	(storedFinantialEntities includes: aFinantialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinantialEntities add: aFinantialEntity .! !

!classRenamed: #SetOfFinantialEntities as: #SetOfFinancialEntities stamp: 'MS 10/15/2023 19:17:48'!
Smalltalk renameClassNamed: #SetOfFinantialEntities as: #SetOfFinancialEntities!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:18:04' prior: 50703054!
add: aFinancialEntity 
	(storedFinantialEntities includes: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinantialEntities add: aFinancialEntity .! !

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'MS 10/15/2023 19:18:28'!
SetOfFinancialEntities subclass: #Portfolio
	instanceVariableNames: 'storedFinancialEntities storedPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:18:28' prior: 50702778 overrides: 50702685!
transactions
	^ (storedFinancialEntities inject: OrderedCollection new into: [:aCollection :anAccount| aCollection , anAccount transactions.]).! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:18:28' prior: 50702787 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:18:28' prior: 50702770 overrides: 50702680!
hasRegistered: aTransaction 
	^(storedFinancialEntities anySatisfy: [:anAccount | anAccount hasRegistered: aTransaction]).! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:18:28' prior: 50702763 overrides: 50702596!
balance
	^(storedFinancialEntities sum: [:anAccount | anAccount balance] ifEmpty: [0])! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:18:28' prior: 50703069!
add: aFinancialEntity 
	(storedFinancialEntities includes: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !

SetOfFinancialEntities subclass: #Portfolio
	instanceVariableNames: 'storedFinancialEntities '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'MS 10/15/2023 19:18:38'!
SetOfFinancialEntities subclass: #Portfolio
	instanceVariableNames: 'storedFinancialEntities'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 19:19:08'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 19:19:08'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 19:19:08'!
PASSED!

!testRun: #TestsXX #test04_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 19:19:08'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 19:19:08'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 19:19:08'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 19:19:08'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 19:19:08'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 19:19:08'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 19:19:08'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 19:19:08'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 19:19:08'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:24:12' prior: 50703117!
add: aFinancialEntity 
	(storedFinancialEntities includes: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:25:24' prior: 50703182!
add: aFinancialEntity 

	(storedFinancialEntities includes: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:28:20'!
test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio
	| anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	
	otherPortfolio add: anAccount.
	aPortfolio add: otherPortfolio.
	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:28:33'!
test13_PortfolioWithAccountCannotStoreSameAccount
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	
	self
	  should: [aPortfolio add: anAccount. aPortfolio add: anAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	! !

!methodRemoval: TestsXX #test04_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 19:28:33'!
test04_PortfolioWithAccountCannotStoreSameAccount
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	
	self
	  should: [aPortfolio add: anAccount. aPortfolio add: anAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:29:13' prior: 50703201!
test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio
	| anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	
	otherPortfolio add: anAccount.
	aPortfolio add: otherPortfolio.
	
	self
	  should: [aPortfolio add: anAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 19:29:27'!
FAILURE!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:30:09' prior: 50703244!
test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio
	| anAccount aPortfolio nestedPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	nestedPortfolio := Portfolio new.
	
	nestedPortfolio add: anAccount.
	aPortfolio add: nestedPortfolio.
	
	self
	  should: [aPortfolio add: anAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:30:20' prior: 50703266!
test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio
	| nestedAccount aPortfolio nestedPortfolio|
	
	nestedAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	nestedPortfolio := Portfolio new.
	
	nestedPortfolio add: nestedAccount.
	aPortfolio add: nestedPortfolio.
	
	self
	  should: [aPortfolio add: nestedAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:33:42' prior: 50703192!
add: aFinancialEntity 

	(self contains: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:34:34'!
contains: aFinancialEntity! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:37:51' prior: 50703310!
contains: aFinancialEntity
	(aFinancialEntity isKindOf: ReceptiveAccount) and: [storedFinancialEntities noneSatisfy: [:aFE | aFE contains: aFinancialEntity.]].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:41:01' prior: 50703314!
contains: aFinancialEntity
	(aFinancialEntity isKindOf: ReceptiveAccount) and: [storedFinancialEntities noneSatisfy: [:aFE | 
			(aFE isKindOf: ReceptiveAccount) ifTrue: [^aFE = aFinancialEntity].
			(aFE isKindOf: Portfolio) ifTrue: [^aFE contains: aFinancialEntity.].].].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:41:35' prior: 50703323!
contains: aReceptiveAccount
	(aReceptiveAccount isKindOf: ReceptiveAccount) and: [storedFinancialEntities noneSatisfy: [:aFE | 
			(aFE isKindOf: ReceptiveAccount) ifTrue: [^aFE = aReceptiveAccount].
			(aFE isKindOf: Portfolio) ifTrue: [^aFE contains: aReceptiveAccount.].].].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:41:46' prior: 50703335!
contains: aReceptiveAccount
	(aReceptiveAccount isKindOf: ReceptiveAccount) and: [storedFinancialEntities noneSatisfy: [:aFinancialEntity | 
			(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [^aFinancialEntity = aReceptiveAccount].
			(aFinancialEntity isKindOf: Portfolio) ifTrue: [^aFinancialEntity contains: aReceptiveAccount.].].].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:41:54' prior: 50703347!
contains: aReceptiveAccount
	(aReceptiveAccount isKindOf: ReceptiveAccount) and: [storedFinancialEntities noneSatisfy:
		 [:aFinancialEntity | 
			(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [^aFinancialEntity = aReceptiveAccount].
			(aFinancialEntity isKindOf: Portfolio) ifTrue: [^aFinancialEntity contains: aReceptiveAccount.].].].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:42:37'!
containsReceptiveAccount: aReceptiveAccount
	(aReceptiveAccount isKindOf: ReceptiveAccount) and: [storedFinancialEntities noneSatisfy:
		 [:aFinancialEntity | 
			(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [^aFinancialEntity = aReceptiveAccount].
			(aFinancialEntity isKindOf: Portfolio) ifTrue: [^aFinancialEntity contains: aReceptiveAccount.].].].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:42:37' prior: 50703361!
contains: aReceptiveAccount
	(aReceptiveAccount isKindOf: ReceptiveAccount) and: [storedFinancialEntities noneSatisfy:
		 [:aFinancialEntity | 
			(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [^aFinancialEntity = aReceptiveAccount].
			(aFinancialEntity isKindOf: Portfolio) ifTrue: [^aFinancialEntity containsReceptiveAccount: aReceptiveAccount.].].].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:42:37' prior: 50703302!
add: aFinancialEntity 

	(self containsReceptiveAccount: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:42:37' prior: 50703375!
containsReceptiveAccount: aReceptiveAccount
	(aReceptiveAccount isKindOf: ReceptiveAccount) and: [storedFinancialEntities noneSatisfy:
		 [:aFinancialEntity | 
			(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [^aFinancialEntity = aReceptiveAccount].
			(aFinancialEntity isKindOf: Portfolio) ifTrue: [^aFinancialEntity containsReceptiveAccount: aReceptiveAccount.].].].! !

!methodRemoval: Portfolio #contains: stamp: 'MS 10/15/2023 19:42:37'!
contains: aReceptiveAccount
	(aReceptiveAccount isKindOf: ReceptiveAccount) and: [storedFinancialEntities noneSatisfy:
		 [:aFinancialEntity | 
			(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [^aFinancialEntity = aReceptiveAccount].
			(aFinancialEntity isKindOf: Portfolio) ifTrue: [^aFinancialEntity containsReceptiveAccount: aReceptiveAccount.].].].!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 19:43:50'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:44:24' prior: 50703414!
containsReceptiveAccount: aReceptiveAccount
	^(aReceptiveAccount isKindOf: ReceptiveAccount) and: [storedFinancialEntities noneSatisfy:
		 [:aFinancialEntity | 
			(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [^aFinancialEntity = aReceptiveAccount].
			(aFinancialEntity isKindOf: Portfolio) ifTrue: [^aFinancialEntity containsReceptiveAccount: aReceptiveAccount.].].].! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 19:44:26'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 19:44:26'!
ERROR!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 19:44:26'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 19:44:26'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 19:44:26'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 19:44:26'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 19:44:26'!
ERROR!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 19:44:26'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 19:44:26'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 19:44:26'!
ERROR!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 19:44:26'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 19:44:26'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 19:44:26'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 19:44:39'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 19:44:39'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 19:45:23'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 19:45:23'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 19:45:23'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:46:28' prior: 50703447!
containsReceptiveAccount: aReceptiveAccount
	^(aReceptiveAccount isKindOf: ReceptiveAccount) and: [storedFinancialEntities anySatisfy:
		 [:aFinancialEntity | 
			(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [^aFinancialEntity = aReceptiveAccount].
			(aFinancialEntity isKindOf: Portfolio) ifTrue: [^aFinancialEntity containsReceptiveAccount: aReceptiveAccount.].].].! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 19:46:33'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 19:46:33'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 19:46:33'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 19:46:33'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 19:46:33'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 19:46:33'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 19:46:33'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 19:46:33'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 19:46:33'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 19:46:33'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 19:46:33'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 19:46:33'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 19:46:33'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:48:49' prior: 50703524!
containsReceptiveAccount: aReceptiveAccount
	^(aReceptiveAccount isKindOf: ReceptiveAccount) and: [storedFinancialEntities anySatisfy:
		 [:aFinancialEntity | aFinancialEntity containsReceptiveAccount: aReceptiveAccount .].].
			"(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [^aFinancialEntity = aReceptiveAccount].
			(aFinancialEntity isKindOf: Portfolio) ifTrue: [^aFinancialEntity containsReceptiveAccount: aReceptiveAccount.].].]."! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:49:09'!
containsReceptiveAccount: aReceptiveAccount

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:49:58' overrides: 50703602!
containsReceptiveAccount: aReceptiveAccount

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:49:58' prior: 50703602!
containsReceptiveAccount: aReceptiveAccount

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:50:10' prior: 50703608 overrides: 50703614!
containsReceptiveAccount: aReceptiveAccount

	^aReceptiveAccount  = self! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:50:13' prior: 50703621 overrides: 50703614!
containsReceptiveAccount: aReceptiveAccount

	^(aReceptiveAccount  = self)! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:50:44' prior: 50703628 overrides: 50703614!
containsReceptiveAccount: aReceptiveAccount

	^(self = aReceptiveAccount )! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:50:45' prior: 50703635 overrides: 50703614!
containsReceptiveAccount: aReceptiveAccount

	^(self = aReceptiveAccount)! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 19:50:50'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 19:50:50'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 19:50:50'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 19:50:50'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 19:50:50'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 19:50:50'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 19:50:50'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 19:50:50'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 19:50:50'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 19:50:50'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 19:50:50'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 19:50:50'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 19:50:50'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:51:05' prior: 50703585 overrides: 50703614!
containsReceptiveAccount: aReceptiveAccount
	^(aReceptiveAccount isKindOf: ReceptiveAccount) and: [storedFinancialEntities anySatisfy:
		 [:aFinancialEntity | aFinancialEntity containsReceptiveAccount: aReceptiveAccount .].].
			! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 19:51:10'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 19:51:10'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 19:51:10'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 19:51:10'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 19:51:10'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 19:51:10'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 19:51:10'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 19:51:10'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 19:51:10'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 19:51:10'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 19:51:10'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 19:51:10'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 19:51:10'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:55:44'!
test15_
	| nestedAccount aPortfolio nestedPortfolio|
	
	nestedAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	nestedPortfolio := Portfolio new.
	
	nestedPortfolio add: nestedAccount.
	aPortfolio add: nestedPortfolio.
	
	self
	  should: [aPortfolio add: nestedAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:55:59' prior: 50703749!
test15_
	| anAccount aPortfolio nestedPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	nestedPortfolio := Portfolio new.
	
	nestedPortfolio add: anAccount.
	aPortfolio add: nestedPortfolio.
	
	self
	  should: [aPortfolio add: anAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:56:43' prior: 50703766!
test15_
	| anAccount aPortfolio nestedPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aPortfolio add: anAccount.
	
	nestedPortfolio := Portfolio new.
	nestedPortfolio add: anAccount.
	
	self
	  should: [aPortfolio add: nestedPortfolio.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:57:33' prior: 50703782!
test15_
	| anAccount aPortfolio nestedPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aPortfolio add: anAccount.
	
	nestedPortfolio := Portfolio new.
	nestedPortfolio add: anAccount.
	
	self
	  should: [aPortfolio add: nestedPortfolio.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:58:03' prior: 50703798!
test15_
	| anAccount aPortfolio aPortfolioWithTheSameAccount|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aPortfolio add: anAccount.
	
	aPortfolioWithTheSameAccount := Portfolio new.
	aPortfolioWithTheSameAccount add: anAccount.
	
	self
	  should: [aPortfolio add: aPortfolioWithTheSameAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test15_ stamp: 'MS 10/15/2023 19:58:10'!
FAILURE!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:58:59'!
test15_PortfolioCantStorePortfolioWithCommonAccount
	| anAccount aPortfolio aPortfolioWithTheSameAccount|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aPortfolio add: anAccount.
	
	aPortfolioWithTheSameAccount := Portfolio new.
	aPortfolioWithTheSameAccount add: anAccount.
	
	self
	  should: [aPortfolio add: aPortfolioWithTheSameAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !

!methodRemoval: TestsXX #test15_ stamp: 'MS 10/15/2023 19:58:59'!
test15_
	| anAccount aPortfolio aPortfolioWithTheSameAccount|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aPortfolio add: anAccount.
	
	aPortfolioWithTheSameAccount := Portfolio new.
	aPortfolioWithTheSameAccount add: anAccount.
	
	self
	  should: [aPortfolio add: aPortfolioWithTheSameAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:59:27' prior: 50703833!
test15_PortfolioCantStorePortfolioWithCommonAccount
	| sharedAccount aPortfolio aPortfolioWithTheSameAccount|
	
	sharedAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aPortfolio add: sharedAccount.
	
	aPortfolioWithTheSameAccount := Portfolio new.
	aPortfolioWithTheSameAccount add: sharedAccount.
	
	self
	  should: [aPortfolio add: aPortfolioWithTheSameAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 19:59:38'!
test15_PortfolioCantStorePortfolioWithSharedAccount
	| sharedAccount aPortfolio aPortfolioWithTheSameAccount|
	
	sharedAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aPortfolio add: sharedAccount.
	
	aPortfolioWithTheSameAccount := Portfolio new.
	aPortfolioWithTheSameAccount add: sharedAccount.
	
	self
	  should: [aPortfolio add: aPortfolioWithTheSameAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !

!methodRemoval: TestsXX #test15_PortfolioCantStorePortfolioWithCommonAccount stamp: 'MS 10/15/2023 19:59:38'!
test15_PortfolioCantStorePortfolioWithCommonAccount
	| sharedAccount aPortfolio aPortfolioWithTheSameAccount|
	
	sharedAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aPortfolio add: sharedAccount.
	
	aPortfolioWithTheSameAccount := Portfolio new.
	aPortfolioWithTheSameAccount add: sharedAccount.
	
	self
	  should: [aPortfolio add: aPortfolioWithTheSameAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:00:10' prior: 50703887!
test15_PortfolioCantStorePortfolioWithSharedAccount
	| sharedAccount aPortfolio otherAccount|
	
	sharedAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aPortfolio add: sharedAccount.
	
	otherAccount := Portfolio new.
	otherAccount add: sharedAccount.
	
	self
	  should: [aPortfolio add: otherAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:01:14' prior: 50703926!
test15_PortfolioCantStorePortfolioWithSharedAccount
	| sharedAccount aPortfolio otherPortfolio|
	
	sharedAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aPortfolio add: sharedAccount.
	
	otherPortfolio := Portfolio new.
	otherPortfolio add: sharedAccount.
	
	self
	  should: [aPortfolio add: otherPortfolio.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:01:19'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:03:01' prior: 50703694 overrides: 50703614!
containsReceptiveAccount: aReceptiveAccount
	(aReceptiveAccount isKindOf: ReceptiveAccount) ifTrue: [storedFinancialEntities anySatisfy:
		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: aReceptiveAccount .].]

			! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:03:11' prior: 50703966 overrides: 50703614!
containsReceptiveAccount: aReceptiveAccount
	(aReceptiveAccount isKindOf: ReceptiveAccount) ifTrue: 
		[storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: aReceptiveAccount .].]

			! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:03:20' prior: 50703977 overrides: 50703614!
containsReceptiveAccount: aReceptiveAccount
	(aReceptiveAccount isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: aReceptiveAccount .].]

			! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:06:32' prior: 50703988 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].]
			! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:08:57' prior: 50703999 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [xxx containsReceptiveAccount: aFinancialEntity .].
				(aFinancialEntity isKindOf: Portfolio) ifTrue: [aFinancialEntity containsReceptiveAccount: xxx .].]			.]! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:09:38'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:09:38'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:09:38'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:09:38'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:09:38'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:09:38'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:09:38'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:09:38'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:09:38'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:09:38'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:09:38'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:09:38'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:09:38'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:09:38'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:09:51' prior: 50704014 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [xxx containsReceptiveAccount: aFinancialEntity .].
				(aFinancialEntity isKindOf: Portfolio) ifTrue: [aFinancialEntity containsReceptiveAccount: xxx .].]			.]
	^false! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:09:57'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:09:57'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:09:57'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:09:57'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:09:57'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:09:57'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:09:57'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:09:57'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:09:57'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:09:57'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:09:57'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:09:57'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:09:57'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:09:57'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:10:09' prior: 50704083 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [xxx containsReceptiveAccount: aFinancialEntity .].
				(aFinancialEntity isKindOf: Portfolio) ifTrue: [aFinancialEntity containsReceptiveAccount: xxx .].]			.].
	^false! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:10:10'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:10:10'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:10:10'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:10:10'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:10:10'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:10:10'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:10:10'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:10:10'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:10:10'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:10:10'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:10:10'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:10:10'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:10:10'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:10:10'!
FAILURE!

(ReceptiveAccount new) = (ReceptiveAccount new)!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:12:03'!
ERROR!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:13:00' prior: 50703002!
test06_PortfolioWithNestedPortfoliosHasCorrectBalance
	| fstPortfolio sndPortfolio trdPortfolio anAccount otherAccount|
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	otherAccount := ReceptiveAccount new.
	
	Deposit register: 100 on: anAccount.
	Deposit register: 200 on: otherAccount.
	
	trdPortfolio  add: anAccount.
	sndPortfolio add: otherAccount.
	
	sndPortfolio add: trdPortfolio.
	fstPortfolio add: sndPortfolio.
	
	self assert: fstPortfolio balance equals: 300.! !

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:13:10'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:14:57' prior: 50704152 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [xxx containsReceptiveAccount: aFinancialEntity .].
				(aFinancialEntity isKindOf: Portfolio) ifTrue: [aFinancialEntity containsReceptiveAccount: xxx .].]			.].
	^false! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:16:18' prior: 50704251 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [^xxx containsReceptiveAccount: aFinancialEntity.].
				(aFinancialEntity isKindOf: Portfolio) ifTrue: [aFinancialEntity containsReceptiveAccount: xxx .].]			.].
	^false! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:16:23' prior: 50704271 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [^xxx containsReceptiveAccount: aFinancialEntity.].
				(aFinancialEntity isKindOf: Portfolio) ifTrue: [^aFinancialEntity containsReceptiveAccount: xxx .].]			.].
	^false! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:16:25'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:16:25'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:16:25'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:16:25'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:16:25'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:16:25'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:16:25'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:16:25'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:16:25'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:16:25'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:16:25'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:16:25'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:16:25'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:16:25'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:18:54' prior: 50704291 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [^xxx containsReceptiveAccount: aFinancialEntity.].
				(aFinancialEntity isKindOf: Portfolio) ifTrue: [^aFinancialEntity containsReceptiveAccount: xxx .].]			.].
	^false! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:18:56'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:18:56'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:18:56'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:18:56'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:18:56'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:18:56'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:18:56'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:18:56'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:18:56'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:18:56'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:18:56'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:18:56'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:18:56'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:18:56'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:19:46' prior: 50704360 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [xxx containsReceptiveAccount: aFinancialEntity.].
				(aFinancialEntity isKindOf: Portfolio) ifTrue: [aFinancialEntity containsReceptiveAccount: xxx .].]			.].
	^false! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:20:55' prior: 50704429 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				((aFinancialEntity isKindOf: ReceptiveAccount) and: [xxx containsReceptiveAccount: aFinancialEntity.])
				or:
				[((aFinancialEntity isKindOf: Portfolio) ifTrue: [aFinancialEntity containsReceptiveAccount: xxx .]).]			.].].
	^false! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:21:41' prior: 50704449 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				((aFinancialEntity isKindOf: ReceptiveAccount) and: [xxx containsReceptiveAccount: aFinancialEntity.])
				or:
				[(aFinancialEntity isKindOf: Portfolio) ifTrue: [aFinancialEntity containsReceptiveAccount: xxx .].]			.].].
	^false! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:21:47'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:21:47'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:21:47'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:21:47'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:21:47'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:21:47'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:21:47'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:21:47'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:21:47'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:21:47'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:21:47'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:21:47'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:21:47'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:21:47'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:21:47'!
ERROR!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:24:32'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:24:32'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:24:32'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:24:32'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:24:32'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:24:32'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:24:32'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:24:32'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:24:32'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:24:32'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:24:32'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:24:32'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:24:32'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:24:32'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:24:32'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:25:15'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:25:44'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:31:01' prior: 50704470 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				((aFinancialEntity isKindOf: ReceptiveAccount) and: [xxx containsReceptiveAccount: aFinancialEntity.])
				or:
				[(aFinancialEntity isKindOf: Portfolio) and: [aFinancialEntity containsReceptiveAccount: xxx .].]			.].].
	^false! !

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:31:05'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:31:09'!
PASSED!

true and: true!

true and: true!

true ifTrue: true!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:36:20' prior: 50704603 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				(aFinancialEntity isKindOf: ReceptiveAccount) ifTrue: [xxx containsReceptiveAccount: aFinancialEntity.].

				(aFinancialEntity isKindOf: Portfolio) ifTrue: [aFinancialEntity containsReceptiveAccount: xxx .].]			.].
	^false! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:36:24'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:36:24'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:36:24'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:36:24'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:36:24'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:36:24'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:36:24'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:36:24'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:36:24'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:36:24'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:36:24'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:36:24'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:36:24'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:36:24'!
FAILURE!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:37:10'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:37:10'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:37:10'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:37:10'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:37:10'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:37:10'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:37:10'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:37:10'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:37:10'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:37:10'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:37:10'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:37:10'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:37:10'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:37:10'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:31:01' prior: 50704681 overrides: 50703614!
containsReceptiveAccount: xxx
	(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				((aFinancialEntity isKindOf: ReceptiveAccount) and: [xxx containsReceptiveAccount: aFinancialEntity.])
				or:
				[(aFinancialEntity isKindOf: Portfolio) and: [aFinancialEntity containsReceptiveAccount: xxx .].]			.].].
	^false! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:37:43'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:37:43'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:37:43'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:37:43'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:37:43'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:37:43'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:37:43'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:37:43'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:37:43'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:37:43'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:37:43'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:37:43'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:37:43'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:37:43'!
PASSED!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:41:56' prior: 50703642 overrides: 50703614!
containsReceptiveAccount: aReceptiveAccount
	(aReceptiveAccount isKindOf: Portfolio) ifTrue: [^aReceptiveAccount containsReceptiveAccount: self].
	^(self = aReceptiveAccount)! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:42:52' prior: 50704799 overrides: 50703614!
containsReceptiveAccount: xxx
	^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .]
	
	"(xxx isKindOf: ReceptiveAccount) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .].].
	(xxx isKindOf: Portfolio) ifTrue: 
		[^storedFinancialEntities anySatisfy: 		[:aFinancialEntity |
				((aFinancialEntity isKindOf: ReceptiveAccount) and: [xxx containsReceptiveAccount: aFinancialEntity.])
				or:
				[(aFinancialEntity isKindOf: Portfolio) and: [aFinancialEntity containsReceptiveAccount: xxx .].]			.].].
	^false"! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:42:54'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:42:54'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:42:54'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:42:54'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:42:54'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:42:54'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:42:54'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:42:54'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:42:54'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:42:54'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:42:54'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:42:54'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:42:54'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:42:54'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:43:19' prior: 50704878 overrides: 50703614!
containsReceptiveAccount: xxx

	^storedFinancialEntities anySatisfy: 		[:aFinancialEntity | aFinancialEntity containsReceptiveAccount: xxx .]
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:44:24' prior: 50704951 overrides: 50703614!
containsReceptiveAccount: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity containsReceptiveAccount: aFinancialEntity .]
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:44:43'!
containsSharedReceptiveAccount: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity containsReceptiveAccount: aFinancialEntity .]
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:44:44' prior: 50703405!
add: aFinancialEntity 

	(self containsSharedReceptiveAccount: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:44:44' prior: 50704960 overrides: 50703614!
containsReceptiveAccount: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity containsSharedReceptiveAccount: aFinancialEntity .]
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:44:44' prior: 50704969!
containsSharedReceptiveAccount: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity containsSharedReceptiveAccount: aFinancialEntity .]
	
	! !

!methodRemoval: Portfolio #containsReceptiveAccount: stamp: 'MS 10/15/2023 20:44:44'!
containsReceptiveAccount: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity containsSharedReceptiveAccount: aFinancialEntity .]
	
	!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:45:41' overrides: 50703614!
containsReceptiveAccount: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity containsSharedReceptiveAccount: aFinancialEntity .]
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:45:41' prior: 50704978!
add: aFinancialEntity 

	(self containsReceptiveAccount: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:45:41' prior: 50704997!
containsSharedReceptiveAccount: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity containsReceptiveAccount: aFinancialEntity .]
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:45:41' prior: 50705015 overrides: 50703614!
containsReceptiveAccount: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity containsReceptiveAccount: aFinancialEntity .]
	
	! !

!methodRemoval: Portfolio #containsSharedReceptiveAccount: stamp: 'MS 10/15/2023 20:45:41'!
containsSharedReceptiveAccount: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity containsReceptiveAccount: aFinancialEntity .]
	
	!
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:51:22'!
hasReceptiveAccountInCommon: aReceptiveAccount

	self subclassResponsibility! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:51:22' overrides: 50705061!
hasReceptiveAccountInCommon: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity containsReceptiveAccount: aFinancialEntity .]
	
	! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:51:22' overrides: 50705061!
hasReceptiveAccountInCommon: aReceptiveAccount
	(aReceptiveAccount isKindOf: Portfolio) ifTrue: [^aReceptiveAccount containsReceptiveAccount: self].
	^(self = aReceptiveAccount)! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:51:22' prior: 50705024!
add: aFinancialEntity 

	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:51:22' prior: 50705043 overrides: 50703614!
containsReceptiveAccount: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity hasReceptiveAccountInCommon: aFinancialEntity .]
	
	! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:51:22' prior: 50704868 overrides: 50703614!
containsReceptiveAccount: aReceptiveAccount
	(aReceptiveAccount isKindOf: Portfolio) ifTrue: [^aReceptiveAccount hasReceptiveAccountInCommon: self].
	^(self = aReceptiveAccount)! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:51:22' prior: 50705067 overrides: 50705061!
hasReceptiveAccountInCommon: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity hasReceptiveAccountInCommon: aFinancialEntity .]
	
	! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:51:22' prior: 50705077 overrides: 50705061!
hasReceptiveAccountInCommon: aReceptiveAccount
	(aReceptiveAccount isKindOf: Portfolio) ifTrue: [^aReceptiveAccount hasReceptiveAccountInCommon: self].
	^(self = aReceptiveAccount)! !

!methodRemoval: SetOfFinancialEntities #containsReceptiveAccount: stamp: 'MS 10/15/2023 20:51:22'!
containsReceptiveAccount: aReceptiveAccount

	self subclassResponsibility!

!methodRemoval: Portfolio #containsReceptiveAccount: stamp: 'MS 10/15/2023 20:51:22'!
containsReceptiveAccount: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity hasReceptiveAccountInCommon: aFinancialEntity .]
	
	!

!methodRemoval: ReceptiveAccount #containsReceptiveAccount: stamp: 'MS 10/15/2023 20:51:22'!
containsReceptiveAccount: aReceptiveAccount
	(aReceptiveAccount isKindOf: Portfolio) ifTrue: [^aReceptiveAccount hasReceptiveAccountInCommon: self].
	^(self = aReceptiveAccount)!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:51:29'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:51:29'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:51:29'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:51:29'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:51:29'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:51:29'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:51:29'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:51:29'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:51:29'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:51:29'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:51:29'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:51:29'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:51:29'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:51:29'!
PASSED!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:54:18' prior: 50705126 overrides: 50705061!
hasReceptiveAccountInCommon: xxx
	"(aReceptiveAccount isKindOf: Portfolio) ifTrue: [^aReceptiveAccount hasReceptiveAccountInCommon: self].
	^(self = aReceptiveAccount)"
	^xxx includesReceptiveAccount: self! !
!SetOfFinancialEntities methodsFor: 'nil' stamp: 'MS 10/15/2023 20:54:54'!
includesReceptiveAccount: aReceptiveAccount! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:55:00' overrides: 50705216!
includesReceptiveAccount: aReceptiveAccount! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:55:00' overrides: 50705216!
includesReceptiveAccount: aReceptiveAccount! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:55:00' prior: 50705216!
includesReceptiveAccount: aReceptiveAccount

	self subclassResponsibility! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:55:32' prior: 50705226 overrides: 50705231!
includesReceptiveAccount: aReceptiveAccount
	^ self hasReceptiveAccountInCommon: aReceptiveAccount ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:56:29' prior: 50705221 overrides: 50705231!
includesReceptiveAccount: aReceptiveAccount
	^ self = aReceptiveAccount ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:56:49' prior: 50705207 overrides: 50705061!
hasReceptiveAccountInCommon: aFinancialEntity
	"(aReceptiveAccount isKindOf: Portfolio) ifTrue: [^aReceptiveAccount hasReceptiveAccountInCommon: self].
	^(self = aReceptiveAccount)"
	^aFinancialEntity includesReceptiveAccount: self! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 20:57:00' prior: 50705251 overrides: 50705061!
hasReceptiveAccountInCommon: aFinancialEntity
	
	^aFinancialEntity includesReceptiveAccount: self! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 20:57:09'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 20:57:09'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 20:57:09'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 20:57:09'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 20:57:09'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 20:57:09'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 20:57:09'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 20:57:09'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 20:57:09'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 20:57:09'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 20:57:09'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 20:57:09'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 20:57:09'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 20:57:09'!
PASSED!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:00:22' prior: 50705244 overrides: 50705231!
includesReceptiveAccount: aReceptiveAccount

	^ self = aReceptiveAccount ! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:03:24'!
test16_PortfolioCantStoreHimself
	|aPortfolio|
	
	
	aPortfolio := Portfolio new.
	self
	  should: [aPortfolio add: aPortfolio .	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:03:27' prior: 50705324!
test16_PortfolioCantStoreHimself
	|aPortfolio|
	
	aPortfolio := Portfolio new.
	self
	  should: [aPortfolio add: aPortfolio .	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:03:29' prior: 50705336!
test16_PortfolioCantStoreHimself
	|aPortfolio|
	
	aPortfolio := Portfolio new.
	
	self
	  should: [aPortfolio add: aPortfolio .	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:03:36'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:04:32' prior: 50705086!
add: aFinancialEntity 
	"(self = aFinancialEntity ) ifTrue: "
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 21:04:32'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:04:32'!
FAILURE!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:04:32'!
FAILURE!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:05:15' prior: 50705348!
test16_PortfolioCantStoreHimself
	|aPortfolio|
	
	aPortfolio := Portfolio new.
	
	self
	  should: [aPortfolio add: aPortfolio .	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:05:21'!
FAILURE!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:05:21'!
FAILURE!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:06:34' prior: 50705429!
test16_PortfolioCantStoreHimself
	|aPortfolio|
	
	aPortfolio := Portfolio new.
	
	self
	  should: [aPortfolio add: aPortfolio.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:06:54'!
portfolioAlreadyInPorfolioError
	'This portfolio has already been added to this porfolio!!'! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:08:40' prior: 50705363!
add: aFinancialEntity 
	(self = aFinancialEntity ) ifTrue: [^self error: self class portfolioAlreadyInPorfolioError .].
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:08:41' prior: 50705464!
add: aFinancialEntity 
	(self = aFinancialEntity ) ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.].
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 21:08:43'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:08:43'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:29:28'!
test17_PortfolioCantStoreTheSamePortfolioTwice
	|aPortfolio|
	
	aPortfolio := Portfolio new.
	
	self
	  should: [aPortfolio add: aPortfolio.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:30:17' prior: 50705541!
test17_PortfolioCantStoreTheSamePortfolioTwice
	|aPortfolio otherPortfolio|
	
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.	
	
	self
	  should: [aPortfolio add: otherPortfolio ; add: otherPortfolio.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:30:25'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:38:29' prior: 50705477!
add: aFinancialEntity 
	
	(self hasPortfolioAlreadyStored: aFinancialEntity ) ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.].
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:38:57'!
hasPortfolioAlreadyStored: aFinancialEntity

	^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity hasReceptiveAccountInCommon: aFinancialEntity .]
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:39:31' prior: 50705584!
hasPortfolioAlreadyStored: aFinancialEntity
	^(self = aFinancialEntity )
	"^storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity hasReceptiveAccountInCommon: aFinancialEntity .]"
	
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:39:34'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:39:34'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:39:34'!
FAILURE!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:39:41'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:39:41'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:39:41'!
FAILURE!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:39:55'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:41:18' prior: 50705593!
hasPortfolioAlreadyStored: aFinancialEntity
	^(self = aFinancialEntity ) or: [storedFinancialEntities includes: aFinancialEntity]
	
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:41:30' prior: 50705724!
hasPortfolioAlreadyStored: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities includes: aPortfolio]
	
	
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:42:03'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:42:03'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:42:33'!
test18_PortfolioCantStoreTheSamePortfolioTwice
	|aPortfolio otherPortfolio nestedPortfolio|
	
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.	
	
	self
	  should: [aPortfolio add: otherPortfolio ; add: otherPortfolio.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:43:29' prior: 50705794!
test18_PortfolioCantStoreTheSamePortfolioTwice
	|aPortfolio otherPortfolio nestedPortfolio|
	
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.	
	nestedPortfolio := Portfolio new.		
	
	aPortfolio add: otherPortfolio.
	nestedPortfolio add: otherPortfolio.
	aPortfolio add: nestedPortfolio. 
	
	self
	  should: [aPortfolio add: otherPortfolio ; add: otherPortfolio.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:44:17' prior: 50705809!
test18_PortfolioCantStoreTheSamePortfolioTwice
	|aPortfolio otherPortfolio nestedPortfolio|
	
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.	
	nestedPortfolio := Portfolio new.		
	
	aPortfolio add: otherPortfolio.
	nestedPortfolio add: otherPortfolio.
	 
	
	self
	  should: [aPortfolio add: nestedPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:44:24' prior: 50705829!
test18_PortfolioCantStoreTheSamePortfolioTwice
	|aPortfolio otherPortfolio nestedPortfolio|
	
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.	
	nestedPortfolio := Portfolio new.		
	
	aPortfolio add: otherPortfolio.
	nestedPortfolio add: otherPortfolio.
	 
	self
	  should: [aPortfolio add: nestedPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:44:40' prior: 50705847!
test18_PortfolioCantStoreTheSamePortfolioTwice
	|fstPortfolio otherPortfolio nestedPortfolio|
	
	fstPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.	
	nestedPortfolio := Portfolio new.		
	
	fstPortfolio add: otherPortfolio.
	nestedPortfolio add: otherPortfolio.
	 
	self
	  should: [fstPortfolio add: nestedPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:44:50' prior: 50705865!
test18_PortfolioCantStoreTheSamePortfolioTwice
	|fstPortfolio sndPortfolio nestedPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	nestedPortfolio := Portfolio new.		
	
	fstPortfolio add: sndPortfolio.
	nestedPortfolio add: sndPortfolio.
	 
	self
	  should: [fstPortfolio add: nestedPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:45:03' prior: 50705883!
test18_PortfolioCantStoreTheSamePortfolioTwice
	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	fstPortfolio add: sndPortfolio.
	trdPortfolio add: sndPortfolio.
	 
	self
	  should: [fstPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test18_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:45:18'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:47:59' prior: 50705732!
hasPortfolioAlreadyStored: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: [:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) ifTrue: [aFinancialEntity hasPortfolioAlreadyStored: aPortfolio].].].
	
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:48:12' prior: 50705922!
hasPortfolioAlreadyStored: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) ifTrue: [aFinancialEntity hasPortfolioAlreadyStored: aPortfolio].].].
	
	
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 21:48:14'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 21:48:14'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 21:48:14'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 21:48:14'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 21:48:14'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 21:48:14'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 21:48:14'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 21:48:14'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 21:48:14'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 21:48:14'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 21:48:14'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 21:48:14'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 21:48:14'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 21:48:14'!
FAILURE!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:48:14'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:48:14'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:48:14'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:48:44' prior: 50705933!
hasPortfolioAlreadyStored: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) and: [aFinancialEntity hasPortfolioAlreadyStored: aPortfolio].].].
	
	
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:48:45'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:48:45'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:48:45'!
FAILURE!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:50:07'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:50:07'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:50:07'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:51:10'!
FAILURE!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:57:00' prior: 50705901!
test18_PortfolioCantStoreTheSamePortfolioTwice
	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	sndPortfolio add: trdPortfolio.
	fstPortfolio add: sndPortfolio.
	 
	self
	  should: [fstPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test18_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:57:04'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/15/2023 21:57:05'!
PASSED!

----SNAPSHOT----(15 October 2023 21:57:48) CuisUniversity-5981.image priorSource: 11882504!

----SNAPSHOT----(15 October 2023 21:57:52) CuisUniversity-5981.image priorSource: 11986242!

----QUIT----(15 October 2023 21:57:55) CuisUniversity-5981.image priorSource: 11986335!

----STARTUP---- (17 October 2023 12:29:39) as /home/martin/Desktop/Inge1/linux64/linux64/CuisUniversity-5981.image!

!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 12:33:29'!
test18_PortfolioCantStoreANestedPortoflio
	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	sndPortfolio add: trdPortfolio.
	fstPortfolio add: sndPortfolio.
	 
	self
	  should: [fstPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !

!methodRemoval: TestsXX #test18_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 12:33:45'!
test18_PortfolioCantStoreTheSamePortfolioTwice
	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	sndPortfolio add: trdPortfolio.
	fstPortfolio add: sndPortfolio.
	 
	self
	  should: [fstPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 12:35:37'!
test19_
	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	sndPortfolio add: trdPortfolio.
	fstPortfolio add: trdPortfolio.
	 
	self
	  should: [fstPortfolio add: sndPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 12:35:45' prior: 50706267!
test19_
	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: trdPortfolio.
	 
	self
	  should: [fstPortfolio add: sndPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test19_ stamp: 'MS 10/17/2023 12:35:46'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 12:37:41' prior: 50706003!
hasPortfolioAlreadyStored: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) and: [aPortfolio hasPortfolioAlreadyStored: aFinancialEntity ].].].
	
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 12:40:29' prior: 50705571!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[(self hasPortfolioAlreadyStored: aFinancialEntity ) ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.].].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 12:40:39' prior: 50706312!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[(self hasPortfolioAlreadyStored: aFinancialEntity ) ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.].].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	
	storedFinancialEntities add: aFinancialEntity .! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 12:40:41'!
FAILURE!

!testRun: #TestsXX #test19_ stamp: 'MS 10/17/2023 12:40:41'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 12:40:41'!
FAILURE!

Portfolio!

!testRun: #TestsXX #test19_ stamp: 'MS 10/17/2023 12:46:56'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:48:12' prior: 50706301!
hasPortfolioAlreadyStored: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) ifTrue: [aFinancialEntity hasPortfolioAlreadyStored: aPortfolio].].].
	
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 12:49:32' prior: 50706409!
hasPortfolioAlreadyStored: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) and: [aFinancialEntity hasPortfolioAlreadyStored: aPortfolio] 
			and: [aPortfolio hasPortfolioAlreadyStored: aFinancialEntity.].].].
	
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 12:50:57' prior: 50706420!
hasPortfolioAlreadyStored: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) 
			and: [aFinancialEntity hasPortfolioAlreadyStored: aPortfolio] 
			and: [aPortfolio hasPortfolioAlreadyStored: aFinancialEntity.].].].
	
	
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 12:51:05'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 12:51:05'!
FAILURE!

!testRun: #TestsXX #test19_ stamp: 'MS 10/17/2023 12:51:05'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 12:52:05' prior: 50706433!
hasPortfolioAlreadyStored: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) 
			and: [(aFinancialEntity hasPortfolioAlreadyStored: aPortfolio) 
			        or: [aPortfolio hasPortfolioAlreadyStored: aFinancialEntity.].].].].
	
	
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 12:52:07'!
PASSED!

!testRun: #TestsXX #test19_ stamp: 'MS 10/17/2023 12:52:07'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 12:52:17' prior: 50706507!
hasPortfolioAlreadyStored: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) 
			and: [(aFinancialEntity hasPortfolioAlreadyStored: aPortfolio) 
			        or: [aPortfolio hasPortfolioAlreadyStored: aFinancialEntity]]]]
	
	
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 12:52:18'!
PASSED!

!testRun: #TestsXX #test19_ stamp: 'MS 10/17/2023 12:52:18'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 12:52:23' prior: 50706581!
hasPortfolioAlreadyStored: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) 
			and: [(aFinancialEntity hasPortfolioAlreadyStored: aPortfolio) 
			        or: [aPortfolio hasPortfolioAlreadyStored: aFinancialEntity.].].].].
	
	
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 12:52:28'!
PASSED!

!testRun: #TestsXX #test19_ stamp: 'MS 10/17/2023 12:52:28'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 12:54:56'!
test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio
	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: trdPortfolio.
	 
	self
	  should: [fstPortfolio add: sndPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !

!methodRemoval: TestsXX #test19_ stamp: 'MS 10/17/2023 12:55:01'!
test19_
	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: trdPortfolio.
	 
	self
	  should: [fstPortfolio add: sndPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 12:56:45'!
test20_
	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: trdPortfolio.
	 
	self
	  should: [fstPortfolio add: sndPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:00:47' prior: 50706761!
test20_
	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	 
	self
	  should: [sndPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test20_ stamp: 'MS 10/17/2023 13:00:56'!
FAILURE!

SetOfFinancialEntities subclass: #Portfolio
	instanceVariableNames: 'storedFinancialEntities upperPortfolio'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'MS 10/17/2023 13:02:26'!
SetOfFinancialEntities subclass: #Portfolio
	instanceVariableNames: 'storedFinancialEntities upperPortfolio'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

SetOfFinancialEntities subclass: #Portfolio
	instanceVariableNames: 'storedFinancialEntities fatherPortfolio'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'MS 10/17/2023 13:03:56'!
SetOfFinancialEntities subclass: #Portfolio
	instanceVariableNames: 'storedFinancialEntities fatherPortfolio'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:04:07' prior: 50706327!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[(self hasPortfolioAlreadyStored: aFinancialEntity ) ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.].].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	
	
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:06:23' prior: 50706825!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[(self hasPortfolioAlreadyStored: aFinancialEntity ) ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
												ifFalse: [aFinancialEntity newfatherPorfolio: self]	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:06:32' prior: 50706840!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[(self hasPortfolioAlreadyStored: aFinancialEntity ) ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
												ifFalse: [aFinancialEntity newFatherPorfolio: self]	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:06:52'!
newFatherPortfolio: aPortfolio
	fatherPortfolio := aPortfolio.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:08:57' prior: 50706857!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[(self hasPortfolioAlreadyStored: aFinancialEntity ) ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
												ifFalse: [aFinancialEntity newFatherPorfolio: self.].	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:13:56' prior: 50706879!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[(self hasPortfolioAlreadyStored: aFinancialEntity ) ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
												ifFalse: [aFinancialEntity newFatherPorfolio: self.].	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'nil' stamp: 'MS 10/17/2023 13:14:13'!
root! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:14:14' prior: 50706912!
root
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:14:21'!
rootPortfolio
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:14:47' prior: 50706919!
rootPortfolio
	fatherPortfolio isNil ifTrue: [^self].
	^fatherPortfolio rootPortfolio. 
	! !

!methodRemoval: Portfolio #root stamp: 'MS 10/17/2023 13:15:07'!
root
	!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:15:25' prior: 50706896!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[((self rootPortfolio) hasPortfolioAlreadyStored: aFinancialEntity ) ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
												ifFalse: [aFinancialEntity newFatherPorfolio: self.].	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 13:17:38'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 13:17:38'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 13:17:38'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 13:17:38'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 13:17:38'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 13:17:38'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 13:17:38'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 13:17:38'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 13:17:38'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 13:17:38'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 13:17:38'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 13:17:38'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 13:17:38'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 13:17:38'!
FAILURE!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 13:17:38'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 13:17:38'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 13:17:38'!
ERROR!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 13:17:38'!
ERROR!

!testRun: #TestsXX #test20_ stamp: 'MS 10/17/2023 13:17:38'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:17:58' prior: 50703097 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
	fatherPortfolio := nil.
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:18:32' prior: 50706932!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[((self rootPortfolio) hasPortfolioAlreadyStored: aFinancialEntity ) ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
												ifFalse: [aFinancialEntity newFatherPorfolio: self.].	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:18:35' prior: 50707021!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[((self rootPortfolio) hasPortfolioAlreadyStored: aFinancialEntity ) ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
												ifFalse: [aFinancialEntity newFatherPorfolio: self.].	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:18:50' prior: 50707039!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[((self rootPortfolio) hasPortfolioAlreadyStored: aFinancialEntity )
			 ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
			 ifFalse: [aFinancialEntity newFatherPorfolio: self.].	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:19:14' prior: 50707057!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[((self rootPortfolio) hasPortfolioAlreadyStored: aFinancialEntity )
			 ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
			 ifFalse: [aFinancialEntity newFatherPortfolio: self.].	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 13:19:15'!
PASSED!

!testRun: #TestsXX #test20_ stamp: 'MS 10/17/2023 13:19:15'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:23:05'!
test20_PortfolioCantStorePortfolioStoredInFather
	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	 
	self
	  should: [sndPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 13:23:12'!
test21_PortfolioCantStorePortfolioStoredInFathers
	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	 
	self
	  should: [sndPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !

!methodRemoval: TestsXX #test20_ stamp: 'MS 10/17/2023 13:23:16'!
test20_
	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	 
	self
	  should: [sndPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
!

----SNAPSHOT----(17 October 2023 13:27:26) CuisUniversity-5981.image priorSource: 11986428!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 15:39:23' prior: 50707174!
test21_PortfolioCantStorePortfolioStoredInFathers
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	frthPortfolio := Portfolio new.
	
	fstPortfolio add: trdPortfolio.
	fstPortfolio add: frthPortfolio.
	sndPortfolio add: trdPortfolio.
	 
	self
	  should: [trdPortfolio add: frthPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 15:39:24'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 15:39:55' prior: 50707015 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 15:40:09' prior: 50706874!
newFatherPortfolio: aPortfolio
	fatherPortfolio add: aPortfolio.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 15:42:51' prior: 50706923!
rootPortfolio
	fatherPortfolio isEmpty ifTrue: [^self].
	^fatherPortfolio inject: OrderedCollection new into: [:aCollection :aFather | aCollection , aFather rootPortfolio]. 
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 15:42:57'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 15:42:57'!
FAILURE!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 15:42:57'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 15:44:13' prior: 50707075!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[(self rootPortfolio anySatisfy: [:aRootPortfolio| aRootPortfolio hasPortfolioAlreadyStored: aFinancialEntity])
			 ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
			 ifFalse: [aFinancialEntity newFatherPortfolio: self.].	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 15:44:25'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 15:44:25'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 15:44:25'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 15:44:25'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 15:44:25'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 15:44:25'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 15:44:25'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 15:44:25'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 15:44:25'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 15:44:25'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 15:44:25'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 15:44:25'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 15:44:25'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 15:44:25'!
FAILURE!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 15:44:25'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 15:44:25'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 15:44:25'!
ERROR!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 15:44:25'!
ERROR!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 15:44:25'!
ERROR!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 15:44:25'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 15:45:57' prior: 50707246!
rootPortfolio
	fatherPortfolio isEmpty ifTrue: [^OrderedCollection with: self].
	^fatherPortfolio inject: OrderedCollection new into: [:aCollection :aFather | aCollection , aFather rootPortfolio]. 
	! !

| a b c |
a := Portfolio new.
b := Portfolio new.
c := Portfolio new.
a add: b.
c add: b.
b rootPortfolio.!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 15:46:13'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 16:04:21'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 16:04:21'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:06:30'!
test22_
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	frthPortfolio := Portfolio new.
	
	fstPortfolio add: trdPortfolio.
	fstPortfolio add: frthPortfolio.
	sndPortfolio add: trdPortfolio.
	 
	self
	  should: [trdPortfolio add: frthPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:18:32'!
test22_PruebaDeFuego
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio fthPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	frthPortfolio := Portfolio new.
	fthPortfolio := Portfolio new.
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	
	fthPortfolio add: sndPortfolio.
	 
	self
	  should: [fthPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:19:23' prior: 50707585!
test22_PruebaDeFuego
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio |
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	frthPortfolio := Portfolio new.
	frthPortfolio := Portfolio new.
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	
	frthPortfolio add: sndPortfolio.
	 
	self
	  should: [frthPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 16:19:31'!
FAILURE!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:19:54' prior: 50707606!
test22_PruebaDeFuego
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	frthPortfolio := Portfolio new.
	frthPortfolio := Portfolio new.
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	
	frthPortfolio add: sndPortfolio.
	 
	self
	  should: [frthPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:20:09' prior: 50707629!
test22_PruebaDeFuego
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	frthPortfolio := Portfolio new.
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	
	frthPortfolio add: sndPortfolio.
	 
	self
	  should: [frthPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:25:32' prior: 50707324!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[(self rootPortfolio anySatisfy: [:aRootPortfolio| aRootPortfolio hasPortfolioAlreadyStored: aFinancialEntity])
			 ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
			 ifFalse: [
				(aFinancialEntity rootPortfolio anySatisfy: [:aRootPortfolio| aRootPortfolio hasPortfolioAlreadyStored: self])
					 ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.].
				aFinancialEntity newFatherPortfolio: self.].	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test22_ stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 16:25:34'!
PASSED!

!methodRemoval: TestsXX #test22_ stamp: 'MS 10/17/2023 16:26:18'!
test22_
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	frthPortfolio := Portfolio new.
	
	fstPortfolio add: trdPortfolio.
	fstPortfolio add: frthPortfolio.
	sndPortfolio add: trdPortfolio.
	 
	self
	  should: [trdPortfolio add: frthPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:26:28'!
test23_PruebaDeMuchoFuego
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	frthPortfolio := Portfolio new.
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	
	frthPortfolio add: sndPortfolio.
	 
	self
	  should: [frthPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:27:43' prior: 50707784!
test23_PruebaDeMuchoFuego
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio fthPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	frthPortfolio := Portfolio new.
	fthPortfolio := Portfolio new.
		
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	
	frthPortfolio add: sndPortfolio.
	frthPortfolio add: fthPortfolio.
	
	self
	  should: [trdPortfolio add: fthPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 16:27:45'!
FAILURE!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 16:29:45'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:38:20' prior: 50707668!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[(self rootPortfolio anySatisfy: [:aRootPortfolio|
				 aFinancialEntity rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasPortfolioAlreadyStored: rootFE]])				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		       ifFalse: [	aFinancialEntity newFatherPortfolio: self.].	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:40:24'!
hasPortfolioInCommon: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) 
			and: [(aFinancialEntity hasPortfolioAlreadyStored: aPortfolio) 
			        or: [aPortfolio hasPortfolioAlreadyStored: aFinancialEntity.].].].].
	
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:40:24' prior: 50707830!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[(self rootPortfolio anySatisfy: [:aRootPortfolio|
				 aFinancialEntity rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasPortfolioInCommon: rootFE]])				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		       ifFalse: [	aFinancialEntity newFatherPortfolio: self.].	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:40:24' prior: 50706655!
hasPortfolioAlreadyStored: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) 
			and: [(aFinancialEntity hasPortfolioInCommon: aPortfolio) 
			        or: [aPortfolio hasPortfolioInCommon: aFinancialEntity.].].].].
	
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:40:24' prior: 50707851!
hasPortfolioInCommon: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) 
			and: [(aFinancialEntity hasPortfolioInCommon: aPortfolio) 
			        or: [aPortfolio hasPortfolioInCommon: aFinancialEntity.].].].].
	
	
	! !

!methodRemoval: Portfolio #hasPortfolioAlreadyStored: stamp: 'MS 10/17/2023 16:40:24'!
hasPortfolioAlreadyStored: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) 
			and: [(aFinancialEntity hasPortfolioInCommon: aPortfolio) 
			        or: [aPortfolio hasPortfolioInCommon: aFinancialEntity.].].].].
	
	
	!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 16:40:33'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 16:40:33'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:42:04' prior: 50707864!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aFinancialEntity rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasPortfolioInCommon: rootFE]])				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		       ifFalse: [	aFinancialEntity newFatherPortfolio: self.].	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:44:14'!
rootPortfoliosHavePortfolioInCommon: aPortfolio
	^(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aPortfolio rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasPortfolioInCommon: rootFE]])				
		
		
		
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 16:45:19' prior: 50707998!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHavePortfolioInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		       ifFalse: [	aFinancialEntity newFatherPortfolio: self.].	].
		
	(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	storedFinancialEntities add: aFinancialEntity .! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:01:28'!
test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree

	|fstPortfolio sndPortfolio trdPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	 
	self
	  should: [sndPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:01:39' prior: 50708045!
test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree

	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	 
	self
	  should: [sndPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:02:12' prior: 50708063!
test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree

	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.
	
	sndPortfolio add: anAccount.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	 
	self
	  should: [sndPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:02:27' prior: 50708081!
test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree

	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: anAccount.
	 
	self
	  should: [sndPortfolio add: anAccount.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:02:35'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 17:03:02'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:03:02'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:04:13' prior: 50708101!
test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree

	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: anAccount.
	 
	self
	  should: [sndPortfolio add: anAccount.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError ].	
! !

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 17:04:14'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:04:14'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:04:38' prior: 50708286!
test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree

	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: anAccount.
	 
	self
	  should: [sndPortfolio add: anAccount.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError ].	
! !

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 17:04:39'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:04:39'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:05:21' prior: 50708389!
test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree

	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: anAccount.
	 
	self
	  should: [trdPortfolio add: anAccount.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError ].	
! !

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:05:22'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:06:25' prior: 50708028!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHavePortfolioInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		       ifFalse: [	aFinancialEntity newFatherPortfolio: self.].	].
	(aFinancialEntity isKindOf: ReceptiveAccount ) ifTrue: 	
		[(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:06:27' prior: 50708516!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHavePortfolioInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		       ifFalse: [	aFinancialEntity newFatherPortfolio: self.].	].
	
	(aFinancialEntity isKindOf: ReceptiveAccount ) ifTrue: 	
		[(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].].
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:06:28' prior: 50708536!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHavePortfolioInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		       ifFalse: [	aFinancialEntity newFatherPortfolio: self.].	].
	
	(aFinancialEntity isKindOf: ReceptiveAccount ) ifTrue: 	
		[(self hasReceptiveAccountInCommon: aFinancialEntity) ifTrue: [^self error: self class accountAlreadyInPorfolioError.].].
		
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:07:10' prior: 50708556!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHavePortfolioInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		       ifFalse: [	aFinancialEntity newFatherPortfolio: self.].	].
	
	(aFinancialEntity isKindOf: ReceptiveAccount ) ifTrue: 	
		[(self hasReceptiveAccountInCommon: aFinancialEntity) 
			ifTrue: [^self error: self class accountAlreadyInPorfolioError.].].
		
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:08:35' prior: 50708576!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHavePortfolioInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		].
	
	(aFinancialEntity isKindOf: ReceptiveAccount ) ifTrue: 	
		[(self hasReceptiveAccountInCommon: aFinancialEntity) 
			ifTrue: [^self error: self class accountAlreadyInPorfolioError.].].
	
	aFinancialEntity newFatherPortfolio: self.	
	storedFinancialEntities add: aFinancialEntity .! !

SetOfFinancialEntities subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions fatherPortfolio'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: 'Portfolio-Ejercicio' stamp: 'MS 10/17/2023 17:08:49'!
SetOfFinancialEntities subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions fatherPortfolio'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccount methodsFor: 'initialization' stamp: 'MS 10/17/2023 17:09:15' prior: 50700619 overrides: 16920235!
initialize

	transactions := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.! !
!ReceptiveAccount methodsFor: 'nil' stamp: 'MS 10/17/2023 17:09:35'!
newFatherPortfolio: aPortfolio! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:09:42' prior: 50708637!
newFatherPortfolio: aPortfolio
	fatherPortfolio add: aPortfolio.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:13:58' prior: 50708596!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHavePortfolioInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		].
	
	(aFinancialEntity isKindOf: ReceptiveAccount ) ifTrue: 	
		[(self rootPortfolio anySatisfy: [:aRootPortfolio | aRootPortfolio 			hasReceptiveAccountInCommon: aFinancialEntity]) 
			ifTrue: [^self error: self class accountAlreadyInPorfolioError.].].
	
	aFinancialEntity newFatherPortfolio: self.	
	storedFinancialEntities add: aFinancialEntity .! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:14:28'!
FAILURE!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:14:28'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:14:28'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:15:05' prior: 50708648!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHavePortfolioInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		].
	
	(aFinancialEntity isKindOf: ReceptiveAccount ) ifTrue: 	
		[(self rootPortfolio anySatisfy: [:aRootPortfolio | aRootPortfolio 			hasReceptiveAccountInCommon: aFinancialEntity]) 
			ifTrue: [^self error: self class accountAlreadyInPorfolioError.]
	.].
	
	aFinancialEntity newFatherPortfolio: self.	
	storedFinancialEntities add: aFinancialEntity .! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:15:27'!
FAILURE!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:15:27'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:15:27'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:17:37' prior: 50708752!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHavePortfolioInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		].
	 	
	(self rootPortfolio anySatisfy: [:aRootPortfolio | aRootPortfolio 			hasReceptiveAccountInCommon: aFinancialEntity]) 
			ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	
	aFinancialEntity newFatherPortfolio: self.	
	storedFinancialEntities add: aFinancialEntity .! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 17:18:25'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:18:25'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:19:48'!
test25_PruebaDeFuego_ReceptiveAccount
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	frthPortfolio := Portfolio new.
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	
	frthPortfolio add: sndPortfolio.
	 
	self
	  should: [frthPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:19:51' prior: 50708953!
test25_PruebaDeFuego_ReceptiveAccount
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	frthPortfolio := Portfolio new.
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	
	frthPortfolio add: sndPortfolio.
	 
	self
	  should: [frthPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:21:45' prior: 50708973!
test25_PruebaDeFuego_ReceptiveAccount
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: trdPortfolio.
	
	fstPortfolio add: anAccount.
	 
	self
	  should: [sndPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:21:59' prior: 50708993!
test25_PruebaDeFuego_ReceptiveAccount
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	anAccount := ReceptiveAccount new.
	
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: trdPortfolio.
	
	fstPortfolio add: anAccount.
	 
	self
	  should: [sndPortfolio add: trdPortfolio.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:22:58' prior: 50709012!
test25_PruebaDeFuego_ReceptiveAccount
	|fstPortfolio sndPortfolio trdPortfolio frthPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	anAccount := ReceptiveAccount new.
	
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: trdPortfolio.
	
	fstPortfolio add: anAccount.
	 
	self
	  should: [sndPortfolio add: anAccount .]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError ].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:23:14' prior: 50709032!
test25_PruebaDeFuego_ReceptiveAccount
	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	anAccount := ReceptiveAccount new.
	
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: trdPortfolio.
	
	fstPortfolio add: anAccount.
	 
	self
	  should: [sndPortfolio add: anAccount .]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError ].	
! !

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'MS 10/17/2023 17:23:15'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:27:23' prior: 50708856!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHavePortfolioInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		].
	 	
	(self rootPortfolioHaveReceptiveAccountInCommon: aFinancialEntity)
			ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	
	aFinancialEntity newFatherPortfolio: self.	
	storedFinancialEntities add: aFinancialEntity .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:27:44'!
rootPortfolioHaveReceptiveAccountInCommon: aFinancialEntity! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:27:47' prior: 50709092!
rootPortfolioHaveReceptiveAccountInCommon: aFinancialEntity
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:27:57' prior: 50709097!
rootPortfolioHaveReceptiveAccountInCommon: aFinancialEntity
	! !

!methodRemoval: Portfolio #rootPortfolioHaveReceptiveAccountInCommon: stamp: 'MS 10/17/2023 17:28:28'!
rootPortfolioHaveReceptiveAccountInCommon: aFinancialEntity
	!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:30:18'!
rootPortfolioHaveReceptiveAccountInCommon: aReceptiveAccount
	^(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aReceptiveAccount rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasReceptiveAccountInCommon: rootFE]])				
		
		
		
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 17:30:31'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 17:30:31'!
ERROR!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 17:30:31'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 17:30:31'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 17:30:31'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 17:30:31'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 17:30:31'!
ERROR!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 17:30:31'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 17:30:31'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 17:30:31'!
ERROR!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 17:30:31'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 17:30:31'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 17:30:31'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:30:31'!
ERROR!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 17:30:31'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 17:30:31'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 17:30:31'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 17:30:31'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 17:30:31'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 17:30:31'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 17:30:31'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 17:30:31'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:30:31'!
ERROR!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'MS 10/17/2023 17:30:31'!
ERROR!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'MS 10/17/2023 17:32:30'!
SetOfFinancialEntities subclass: #Portfolio
	instanceVariableNames: 'storedFinancialEntities'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: 'Portfolio-Ejercicio' stamp: 'MS 10/17/2023 17:32:31'!
SetOfFinancialEntities subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #SetOfFinancialEntities category: 'Portfolio-Ejercicio' stamp: 'MS 10/17/2023 17:32:31'!
Object subclass: #SetOfFinancialEntities
	instanceVariableNames: 'fatherPortfolio'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:32:31'!
rootPortfolio
	fatherPortfolio isEmpty ifTrue: [^OrderedCollection with: self].
	^fatherPortfolio inject: OrderedCollection new into: [:aCollection :aFather | aCollection , aFather rootPortfolio]. 
	! !

!methodRemoval: Portfolio #rootPortfolio stamp: 'MS 10/17/2023 17:32:31'!
rootPortfolio
	fatherPortfolio isEmpty ifTrue: [^OrderedCollection with: self].
	^fatherPortfolio inject: OrderedCollection new into: [:aCollection :aFather | aCollection , aFather rootPortfolio]. 
	!
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:32:44'!
newFatherPortfolio: aPortfolio
	fatherPortfolio add: aPortfolio.! !

!methodRemoval: Portfolio #newFatherPortfolio: stamp: 'MS 10/17/2023 17:32:44'!
newFatherPortfolio: aPortfolio
	fatherPortfolio add: aPortfolio.!

!methodRemoval: ReceptiveAccount #newFatherPortfolio: stamp: 'MS 10/17/2023 17:32:44'!
newFatherPortfolio: aPortfolio
	fatherPortfolio add: aPortfolio.!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 17:33:59'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 17:34:00'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 17:34:00'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 17:34:00'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 17:34:00'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 17:34:00'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 17:34:00'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:34:00'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'MS 10/17/2023 17:34:00'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'MS 10/17/2023 17:34:00'!
FAILURE!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:34:59'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'MS 10/17/2023 17:34:59'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'MS 10/17/2023 17:34:59'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:38:44' prior: 50705116 overrides: 50705061!
hasReceptiveAccountInCommon: aFinancialEntity

	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | aStoredFinancialEntity hasReceptiveAccountInCommon: aFinancialEntity .].].
	
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:38:54'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'MS 10/17/2023 17:38:54'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'MS 10/17/2023 17:38:54'!
FAILURE!

(self rootPortfolio first) = self!

self rootPortfolio !

self rootPortfolio !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:47:35' prior: 50709433 overrides: 50705061!
hasReceptiveAccountInCommon: aFinancialEntity

	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | 
			aStoredFinancialEntity hasReceptiveAccountInCommon: aFinancialEntity .].].
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:50:20' prior: 50709531 overrides: 50705061!
hasReceptiveAccountInCommon: aFinancialEntity

	"^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 		[:aStoredFinancialEntity | 
			aStoredFinancialEntity hasReceptiveAccountInCommon: aFinancialEntity .].]."
	
	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasReceptiveAccountInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasReceptiveAccountInCommon: aFinancialEntity.].].].
	
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'MS 10/17/2023 17:50:26'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'MS 10/17/2023 17:50:26'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'MS 10/17/2023 17:50:51' prior: 50709542 overrides: 50705061!
hasReceptiveAccountInCommon: aFinancialEntity
	
	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasReceptiveAccountInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasReceptiveAccountInCommon: aFinancialEntity.].].].
	
	! !

----SNAPSHOT----(17 October 2023 17:51:43) CuisUniversity-5981.image priorSource: 12017760!

----SNAPSHOT----(17 October 2023 17:52:58) CuisUniversity-5981.image priorSource: 12096153!

----STARTUP---- (17 October 2023 17:59:00) as /home/pablosm/cuisUniversity/CuisUniversity-5981.image!

!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:00:57'!
hasFinancialEntityAccountInCommon: aReceptiveAccount

	self subclassResponsibility! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:00:57' overrides: 50709665!
hasFinancialEntityAccountInCommon: aFinancialEntity
	
	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasReceptiveAccountInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasReceptiveAccountInCommon: aFinancialEntity.].].].
	
	! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:00:57' overrides: 50709665!
hasFinancialEntityAccountInCommon: aFinancialEntity
	
	^aFinancialEntity includesReceptiveAccount: self! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:00:57' prior: 50709643 overrides: 50705061!
hasReceptiveAccountInCommon: aFinancialEntity
	
	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasFinancialEntityAccountInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasFinancialEntityAccountInCommon: aFinancialEntity.].].].
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:00:57' prior: 50709112!
rootPortfolioHaveReceptiveAccountInCommon: aReceptiveAccount
	^(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aReceptiveAccount rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasFinancialEntityAccountInCommon: rootFE]])				
		
		
		
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:00:57' prior: 50705237 overrides: 50705231!
includesReceptiveAccount: aReceptiveAccount
	^ self hasFinancialEntityAccountInCommon: aReceptiveAccount ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:00:57' prior: 50709671 overrides: 50709665!
hasFinancialEntityAccountInCommon: aFinancialEntity
	
	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasFinancialEntityAccountInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasFinancialEntityAccountInCommon: aFinancialEntity.].].].
	
	! !

!methodRemoval: SetOfFinancialEntities #hasReceptiveAccountInCommon: stamp: 'psm 10/17/2023 18:00:57'!
hasReceptiveAccountInCommon: aReceptiveAccount

	self subclassResponsibility!

!methodRemoval: Portfolio #hasReceptiveAccountInCommon: stamp: 'psm 10/17/2023 18:00:57'!
hasReceptiveAccountInCommon: aFinancialEntity
	
	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasFinancialEntityAccountInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasFinancialEntityAccountInCommon: aFinancialEntity.].].].
	
	!

!methodRemoval: ReceptiveAccount #hasReceptiveAccountInCommon: stamp: 'psm 10/17/2023 18:00:57'!
hasReceptiveAccountInCommon: aFinancialEntity
	
	^aFinancialEntity includesReceptiveAccount: self!

!methodRemoval: Portfolio #hasPortfolioInCommon: stamp: 'psm 10/17/2023 18:01:14'!
hasPortfolioInCommon: aPortfolio
	^(self = aPortfolio ) or: [storedFinancialEntities anySatisfy: 
		[:aFinancialEntity | (aFinancialEntity isKindOf: Portfolio) 
			and: [(aFinancialEntity hasPortfolioInCommon: aPortfolio) 
			        or: [aPortfolio hasPortfolioInCommon: aFinancialEntity.].].].].
	
	
	!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:01:57' prior: 50708018!
rootPortfoliosHavePortfolioInCommon: aPortfolio
	^(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aPortfolio rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasFinacialEntityInCommon: rootFE]])				
		
		
		
	! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:02:23'!
hasFinancialEntityInCommon: aReceptiveAccount

	self subclassResponsibility! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:02:23' overrides: 50709786!
hasFinancialEntityInCommon: aFinancialEntity
	
	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasFinancialEntityAccountInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasFinancialEntityAccountInCommon: aFinancialEntity.].].].
	
	! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:02:23' overrides: 50709786!
hasFinancialEntityInCommon: aFinancialEntity
	
	^aFinancialEntity includesReceptiveAccount: self! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:02:23' prior: 50709725 overrides: 50709665!
hasFinancialEntityAccountInCommon: aFinancialEntity
	
	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasFinancialEntityInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasFinancialEntityInCommon: aFinancialEntity.].].].
	
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:02:23' prior: 50709706!
rootPortfolioHaveReceptiveAccountInCommon: aReceptiveAccount
	^(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aReceptiveAccount rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasFinancialEntityInCommon: rootFE]])				
		
		
		
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:02:23' prior: 50709718 overrides: 50705231!
includesReceptiveAccount: aReceptiveAccount
	^ self hasFinancialEntityInCommon: aReceptiveAccount ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:02:23' prior: 50709792 overrides: 50709786!
hasFinancialEntityInCommon: aFinancialEntity
	
	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasFinancialEntityInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasFinancialEntityInCommon: aFinancialEntity.].].].
	
	! !

!methodRemoval: SetOfFinancialEntities #hasFinancialEntityAccountInCommon: stamp: 'psm 10/17/2023 18:02:23'!
hasFinancialEntityAccountInCommon: aReceptiveAccount

	self subclassResponsibility!

!methodRemoval: Portfolio #hasFinancialEntityAccountInCommon: stamp: 'psm 10/17/2023 18:02:23'!
hasFinancialEntityAccountInCommon: aFinancialEntity
	
	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasFinancialEntityInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasFinancialEntityInCommon: aFinancialEntity.].].].
	
	!

!methodRemoval: ReceptiveAccount #hasFinancialEntityAccountInCommon: stamp: 'psm 10/17/2023 18:02:23'!
hasFinancialEntityAccountInCommon: aFinancialEntity
	
	^aFinancialEntity includesReceptiveAccount: self!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:02:58' prior: 50709776!
rootPortfoliosHavePortfolioInCommon: aPortfolio
	^(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aPortfolio rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasFinancialEntityInCommon: rootFE]])				
		
		
		
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:03:55'!
rootPortfolioHaveFinancialEntityInCommon: aReceptiveAccount
	^(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aReceptiveAccount rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasFinancialEntityInCommon: rootFE]])				
		
		
		
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:03:55' prior: 50709075!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHavePortfolioInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		].
	 	
	(self rootPortfolioHaveFinancialEntityInCommon: aFinancialEntity)
			ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	
	aFinancialEntity newFatherPortfolio: self.	
	storedFinancialEntities add: aFinancialEntity .! !

!methodRemoval: Portfolio #rootPortfolioHaveReceptiveAccountInCommon: stamp: 'psm 10/17/2023 18:03:55'!
rootPortfolioHaveReceptiveAccountInCommon: aReceptiveAccount
	^(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aReceptiveAccount rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasFinancialEntityInCommon: rootFE]])				
		
		
		
	!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:04:12'!
rootPortfoliosHaveFinancialEntityInCommon: aReceptiveAccount
	^(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aReceptiveAccount rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasFinancialEntityInCommon: rootFE]])				
		
		
		
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:04:12' prior: 50709905!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHavePortfolioInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		].
	 	
	(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity)
			ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	
	aFinancialEntity newFatherPortfolio: self.	
	storedFinancialEntities add: aFinancialEntity .! !

!methodRemoval: Portfolio #rootPortfolioHaveFinancialEntityInCommon: stamp: 'psm 10/17/2023 18:04:12'!
rootPortfolioHaveFinancialEntityInCommon: aReceptiveAccount
	^(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aReceptiveAccount rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasFinancialEntityInCommon: rootFE]])				
		
		
		
	!

!methodRemoval: Portfolio #rootPortfoliosHavePortfolioInCommon: stamp: 'psm 10/17/2023 18:04:22'!
rootPortfoliosHavePortfolioInCommon: aPortfolio
	^(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aPortfolio rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasFinancialEntityInCommon: rootFE]])				
		
		
		
	!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:04:40' prior: 50709944!
add: aFinancialEntity 
	
	(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		].
	 	
	(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity)
			ifTrue: [^self error: self class accountAlreadyInPorfolioError.].
	
	aFinancialEntity newFatherPortfolio: self.	
	storedFinancialEntities add: aFinancialEntity .! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:04:50'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:04:50'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:08:05'!
avoidPortfoliosInANestedConectionFromHavingTheSameEntity: aFinancialEntity 
	
	 (self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]! !

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:08:14'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:08:14'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:09:11'!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	
	 (self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]! !

!methodRemoval: Portfolio #avoidPortfoliosInANestedConectionFromHavingTheSameEntity: stamp: 'psm 10/17/2023 18:09:11'!
avoidPortfoliosInANestedConectionFromHavingTheSameEntity: aFinancialEntity 
	
	 (self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:10:37' prior: 50710166!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	
	 (self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:11:12'!
collisionErrorMessage

	^self class portfolioAlreadyInPorfolioError ! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:11:18'!
collisionErrorMessage

	self subclassResponsibility! !
!SetOfFinancialEntities class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:11:30'!
accountAlreadyInPorfolioError
	'This account has already been added to this porfolio!!'! !

!methodRemoval: Portfolio class #accountAlreadyInPorfolioError stamp: 'psm 10/17/2023 18:11:30'!
accountAlreadyInPorfolioError
	'This account has already been added to this porfolio!!'!
!SetOfFinancialEntities class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:11:47'!
portfolioAlreadyInPorfolioError

	self subclassResponsibility! !
!SetOfFinancialEntities class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:11:52' prior: 50710220!
portfolioAlreadyInPorfolioError
	'This portfolio has already been added to this porfolio!!'! !

!methodRemoval: Portfolio class #portfolioAlreadyInPorfolioError stamp: 'psm 10/17/2023 18:11:52'!
portfolioAlreadyInPorfolioError
	'This portfolio has already been added to this porfolio!!'!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:12:41' overrides: 50710203!
collisionErrorMessage

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:12:41' prior: 50710203!
collisionErrorMessage

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:13:04' prior: 50710239 overrides: 50710245!
collisionErrorMessage

	^self class accountAlreadyInPorfolioError ! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:14:17'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:14:17'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:14:28' prior: 50709983!
add: aFinancialEntity 
	
	"(aFinancialEntity isKindOf: Portfolio) ifTrue: 
		[ (self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: self class portfolioAlreadyInPorfolioError.]
		].
	 	
	(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity)
			ifTrue: [^self error: self class accountAlreadyInPorfolioError.]."
	
	self avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity .
	
	aFinancialEntity newFatherPortfolio: self.	
	storedFinancialEntities add: aFinancialEntity .! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:14:30'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:14:30'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:14:30'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:14:30'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:14:30'!
FAILURE!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:14:42'!
FAILURE!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:17:12'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:17:12'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:17:12'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:17:12'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:17:12'!
FAILURE!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:17:15'!
FAILURE!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:17:44'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:17:44'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:17:44'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:17:44'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:17:44'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:17:49'!
FAILURE!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:24:18' prior: 50705319 overrides: 50705231!
includesReceptiveAccount: aReceptiveAccount

	"^ self = aReceptiveAccount"
	(self = aReceptiveAccount) ifTrue: [self error: self collisionErrorMessage]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:26:06' prior: 50709845 overrides: 50709786!
hasFinancialEntityInCommon: aFinancialEntity
	
	"^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasFinancialEntityInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasFinancialEntityInCommon: aFinancialEntity.].].]."
	
	((self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasFinancialEntityInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasFinancialEntityInCommon: aFinancialEntity.].].]) ifTrue:[self error: self collisionErrorMessage ]! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:26:10'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:26:10'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:26:10'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:26:10'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:26:10'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:26:10'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:26:10'!
ERROR!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:26:10'!
ERROR!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'MS 10/15/2023 21:00:22' prior: 50710618 overrides: 50705231!
includesReceptiveAccount: aReceptiveAccount

	^ self = aReceptiveAccount ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:27:04' prior: 50710627 overrides: 50709786!
hasFinancialEntityInCommon: aFinancialEntity
	
	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasFinancialEntityInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasFinancialEntityInCommon: aFinancialEntity.].].].! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:27:06'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:27:06'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:27:06'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:27:06'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:27:06'!
FAILURE!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:31:15'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:31:15'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:31:15'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:31:15'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:31:15'!
FAILURE!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:32:40' prior: 50710732 overrides: 50705231!
includesReceptiveAccount: aReceptiveAccount

	(self = aReceptiveAccount )ifTrue:[self error: self collisionErrorMessage]! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'psm 10/17/2023 18:32:41'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 18:32:41'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 18:32:41'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'psm 10/17/2023 18:32:41'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'psm 10/17/2023 18:32:41'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'psm 10/17/2023 18:32:41'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'psm 10/17/2023 18:32:41'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:32:45'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:32:45'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:32:45'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:32:45'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:32:45'!
FAILURE!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:32:45'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:32:45'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:32:45'!
FAILURE!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:34:01' prior: 50710917 overrides: 50705231!
includesReceptiveAccount: aReceptiveAccount

	(self = aReceptiveAccount )
		ifTrue:[self error: self collisionErrorMessage]
		ifFalse: [^false]! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'psm 10/17/2023 18:34:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 18:34:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 18:34:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'psm 10/17/2023 18:34:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'psm 10/17/2023 18:34:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'psm 10/17/2023 18:34:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'psm 10/17/2023 18:34:04'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:34:08'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:34:08'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:34:08'!
FAILURE!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:34:08'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:34:08'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:34:08'!
FAILURE!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:34:17'!
FAILURE!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:34:58' prior: 50711034 overrides: 50705231!
includesReceptiveAccount: aReceptiveAccount

	^self = aReceptiveAccount ! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'psm 10/17/2023 18:34:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 18:34:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 18:34:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'psm 10/17/2023 18:34:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'psm 10/17/2023 18:34:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'psm 10/17/2023 18:34:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'psm 10/17/2023 18:34:59'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:35:03'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:35:03'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:35:03'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:35:03'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:35:03'!
FAILURE!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:35:27' prior: 50703213!
test13_PortfolioWithAccountCannotStoreSameAccount
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	
	self
	  should: [aPortfolio add: anAccount. aPortfolio add: anAccount.	]
	  raise: Error
		  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError ].	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:35:37' prior: 50703284!
test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio
	| nestedAccount aPortfolio nestedPortfolio|
	
	nestedAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	nestedPortfolio := Portfolio new.
	
	nestedPortfolio add: nestedAccount.
	aPortfolio add: nestedPortfolio.
	
	self
	  should: [aPortfolio add: nestedAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio portfolioAlreadyInPorfolioError ].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:35:46' prior: 50708492!
test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree

	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: anAccount.
	 
	self
	  should: [trdPortfolio add: anAccount.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio  portfolioAlreadyInPorfolioError].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:35:59' prior: 50709052!
test25_PruebaDeFuego_ReceptiveAccount
	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	anAccount := ReceptiveAccount new.
	
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: trdPortfolio.
	
	fstPortfolio add: anAccount.
	 
	self
	  should: [sndPortfolio add: anAccount .]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio  portfolioAlreadyInPorfolioError].	
! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:36:00'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:36:01'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:36:01'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:36:01'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:36:01'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:36:01'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:36:01'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:36:01'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:36:01'!
FAILURE!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:36:01'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:36:01'!
FAILURE!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:36:05'!
FAILURE!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:37:18'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:37:18'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:37:18'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:37:18'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:37:18'!
FAILURE!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:37:31' prior: 50711271!
test13_PortfolioWithAccountCannotStoreSameAccount
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	
	self
	  should: [aPortfolio add: anAccount. aPortfolio add: anAccount.	]
	  raise: Error
		  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError ].	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:37:42' prior: 50711287!
test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio
	| nestedAccount aPortfolio nestedPortfolio|
	
	nestedAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	nestedPortfolio := Portfolio new.
	
	nestedPortfolio add: nestedAccount.
	aPortfolio add: nestedPortfolio.
	
	self
	  should: [aPortfolio add: nestedAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError ].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:37:52' prior: 50711305!
test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree

	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: anAccount.
	 
	self
	  should: [trdPortfolio add: anAccount.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError ].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:38:00' prior: 50711325!
test25_PruebaDeFuego_ReceptiveAccount
	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	anAccount := ReceptiveAccount new.
	
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: trdPortfolio.
	
	fstPortfolio add: anAccount.
	 
	self
	  should: [sndPortfolio add: anAccount .]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError ].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:38:14' prior: 50711567!
test25_PruebaDeFuego_ReceptiveAccount
	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	anAccount := ReceptiveAccount new.
	
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: trdPortfolio.
	
	fstPortfolio add: anAccount.
	 
	self
	  should: [sndPortfolio add: anAccount .]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: ReceptiveAccount accountAlreadyInPorfolioError ].	
! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:38:15'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:38:15'!
FAILURE!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:38:15'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:38:15'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:38:25'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:38:25'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:38:25'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:38:25'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:38:25'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:38:57' prior: 50711513!
test13_PortfolioWithAccountCannotStoreSameAccount
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	
	self
	  should: [aPortfolio add: anAccount. aPortfolio add: anAccount.	]
	  raise: Error
		  withExceptionDo: [:anError | self assert: anError messageText equals: ReceptiveAccount accountAlreadyInPorfolioError ].	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:39:07' prior: 50711529!
test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio
	| nestedAccount aPortfolio nestedPortfolio|
	
	nestedAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	nestedPortfolio := Portfolio new.
	
	nestedPortfolio add: nestedAccount.
	aPortfolio add: nestedPortfolio.
	
	self
	  should: [aPortfolio add: nestedAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: ReceptiveAccount accountAlreadyInPorfolioError ].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:39:14' prior: 50711547!
test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree

	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: anAccount.
	 
	self
	  should: [trdPortfolio add: anAccount.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: ReceptiveAccount accountAlreadyInPorfolioError ].	
! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:39:15'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:39:15'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:39:59' prior: 50711587!
test25_PruebaDeFuego_ReceptiveAccount
	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.		
	anAccount := ReceptiveAccount new.
	
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: trdPortfolio.
	
	fstPortfolio add: anAccount.
	 
	self
	  should: [sndPortfolio add: anAccount .]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError ].	
! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:40:16' prior: 50710251 overrides: 50710245!
collisionErrorMessage

	^Portfolio accountAlreadyInPorfolioError ! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'psm 10/17/2023 18:40:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 18:40:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 18:40:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'psm 10/17/2023 18:40:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'psm 10/17/2023 18:40:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'psm 10/17/2023 18:40:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'psm 10/17/2023 18:40:18'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:40:21'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:40:21'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:40:21'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:40:21'!
FAILURE!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:40:21'!
PASSED!
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:40:31' prior: 50711772!
test13_PortfolioWithAccountCannotStoreSameAccount
	| aPortfolio anAccount |
	aPortfolio := Portfolio new.
	
	anAccount := ReceptiveAccount new.
	Deposit register: 200 on: anAccount.
	
	self
	  should: [aPortfolio add: anAccount. aPortfolio add: anAccount.	]
	  raise: Error
		  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError ].	! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:40:41' prior: 50711788!
test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio
	| nestedAccount aPortfolio nestedPortfolio|
	
	nestedAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	nestedPortfolio := Portfolio new.
	
	nestedPortfolio add: nestedAccount.
	aPortfolio add: nestedPortfolio.
	
	self
	  should: [aPortfolio add: nestedAccount.	]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError ].	
! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:40:48' prior: 50711807!
test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree

	|fstPortfolio sndPortfolio trdPortfolio anAccount|
	
	fstPortfolio := Portfolio new.
	sndPortfolio := Portfolio new.	
	trdPortfolio := Portfolio new.
	anAccount := ReceptiveAccount new.		
	
	fstPortfolio add: sndPortfolio.
	fstPortfolio add: trdPortfolio.
	sndPortfolio add: anAccount.
	 
	self
	  should: [trdPortfolio add: anAccount.]
	  raise: Error
	  withExceptionDo: [:anError | self assert: anError messageText equals: Portfolio accountAlreadyInPorfolioError ].	
! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 18:40:50'!
PASSED!

----QUIT----(17 October 2023 18:41:02) CuisUniversity-5981.image priorSource: 12096246!

----STARTUP---- (17 October 2023 18:43:12) as /home/pablosm/cuisUniversity/CuisUniversity-5981.image!


Object subclass: #SetOfFinancialEntities
	instanceVariableNames: 'fatherPortfolio colored'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #SetOfFinancialEntities category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 18:44:00'!
Object subclass: #SetOfFinancialEntities
	instanceVariableNames: 'fatherPortfolio colored'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:45:53' prior: 50710187!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity coloredAsReceiver]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:50:36'!
coloredAsReceiver

	(colored = #receiver) ifFalse: [ 
			colored := #receiver.
			storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsReceiver]]! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:50:59'!
coloredAsReceiver

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:51:26' overrides: 50712224!
coloredAsReceiver

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:51:26' prior: 50712224!
coloredAsReceiver

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:51:53' prior: 50712229 overrides: 50712234!
coloredAsReceiver

	colored := #receiver! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:52:49'!
coloredAsTheAdder

	self subclassResponsibility! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:52:49' overrides: 50712245!
coloredAsTheAdder

	(colored = #receiver) ifFalse: [ 
			colored := #receiver.
			storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsReceiver]]! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:52:49' overrides: 50712245!
coloredAsTheAdder

	colored := #receiver! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:52:49' prior: 50712202!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity coloredAsTheAdder]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:52:49' prior: 50712215 overrides: 50712234!
coloredAsReceiver

	(colored = #receiver) ifFalse: [ 
			colored := #receiver.
			storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:52:49' prior: 50712250 overrides: 50712245!
coloredAsTheAdder

	(colored = #receiver) ifFalse: [ 
			colored := #receiver.
			storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]]! !

!methodRemoval: SetOfFinancialEntities #coloredAsReceiver stamp: 'psm 10/17/2023 18:52:49'!
coloredAsReceiver

	self subclassResponsibility!

!methodRemoval: Portfolio #coloredAsReceiver stamp: 'psm 10/17/2023 18:52:49'!
coloredAsReceiver

	(colored = #receiver) ifFalse: [ 
			colored := #receiver.
			storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]]!

!methodRemoval: ReceptiveAccount #coloredAsReceiver stamp: 'psm 10/17/2023 18:52:49'!
coloredAsReceiver

	colored := #receiver!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:53:03' prior: 50712288 overrides: 50712245!
coloredAsTheAdder

	(colored = #adder) ifFalse: [ 
			colored := #adder.
			storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]]! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:53:10' prior: 50712259 overrides: 50712245!
coloredAsTheAdder

	colored := #adder! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:55:32'!
coloredAsTheAdded

	(colored = #adder) ifTrue: [^true].
	colored := #added. ^false! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:55:43'!
coloredAsTheAdded

	self subclassResponsibility! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:56:02' overrides: 50712334!
coloredAsTheAdded

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:56:02' prior: 50712334!
coloredAsTheAdded

	self subclassResponsibility! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 18:58:12' prior: 50712339 overrides: 50712344!
coloredAsTheAdded

	(colored = #adder) ifTrue: [^true].
	colored := #added.
	^storedFinancialEntities anySatisfy: [:storedFinacialEntity | storedFinacialEntity coloredAsTheAdded]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:01:19' prior: 50712264!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity coloredAsTheAdded].
	
	self rootPortfolio uncolorIt.
	aFinancialEntity rootPortfolio uncolorIt.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:02:10' prior: 50712359!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity coloredAsTheAdded].
	
	self rootPortfolio uncolorIt.
	aFinancialEntity rootPortfolio uncolorIt.
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:04:43'!
uncolorIt

	colored isNil ifFalse: [
		colored := nil.
		storedFinancialEntities do:[:storedEntity | storedEntity uncolorIt]]! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:05:36'!
uncolorIt

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:05:43' overrides: 50712408!
uncolorIt

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:05:43' prior: 50712408!
uncolorIt

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:05:53' prior: 50712413 overrides: 50712418!
uncolorIt

	colored := nil.! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'psm 10/17/2023 19:05:55'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 19:05:55'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 19:05:55'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'psm 10/17/2023 19:05:55'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'psm 10/17/2023 19:05:55'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'psm 10/17/2023 19:05:55'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'psm 10/17/2023 19:05:55'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 19:05:57'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 19:05:57'!
ERROR!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 19:05:57'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 19:05:57'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 19:05:57'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 19:05:57'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 19:05:57'!
ERROR!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 19:05:57'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 19:05:57'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 19:05:57'!
ERROR!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 19:05:57'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 19:05:57'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 19:05:57'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 19:05:57'!
ERROR!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 19:05:58'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 19:05:58'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 19:05:58'!
ERROR!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 19:05:58'!
ERROR!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 19:05:58'!
ERROR!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 19:05:58'!
ERROR!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 19:05:58'!
ERROR!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 19:05:58'!
ERROR!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 19:05:58'!
ERROR!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 19:05:58'!
ERROR!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 19:06:19'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 19:06:19'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 19:06:19'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 19:06:19'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 19:06:19'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 19:06:19'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 19:06:19'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 19:06:21'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:07:20' prior: 50712379!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity coloredAsTheAdded].
	
	self rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity uncolorIt].
	aFinancialEntity rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 19:07:23'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 19:07:23'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 19:07:23'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 19:07:23'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 19:07:23'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 19:07:23'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 19:07:23'!
ERROR!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 19:07:23'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:07:58' prior: 50712622!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity coloredAsTheAdded].
	
	self rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity uncolorIt].
	aFinancialEntity rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:08:07' prior: 50712730!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity uncolorIt].
	aFinancialEntity rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:08:15' prior: 50712755!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:storedFinancialEntity | storedFinancialEntity uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:08:22' prior: 50712780!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 19:08:30'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 19:08:30'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 19:08:30'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 19:08:30'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 19:08:30'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 19:08:30'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 19:08:30'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 19:08:32'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:09:20' prior: 50712804!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:09:43' prior: 50712913!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 19:09:43'!
PASSED!

Object subclass: #ColoredState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ColoredState category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 19:11:22'!
Object subclass: #ColoredState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

ColoredState subclass: #asAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

ColoredState subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 19:12:34'!
ColoredState subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRenamed: #ColoredState as: #ColoredStateForFinancialEntityStruct stamp: 'psm 10/17/2023 19:13:11'!
Smalltalk renameClassNamed: #ColoredState as: #ColoredStateForFinancialEntityStruct!

ColoredStateForFinancialEntityStruct subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 19:14:01'!
ColoredStateForFinancialEntityStruct subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

ColoredStateForFinancialEntityStruct subclass: #AsBlank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsBlank category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 19:14:10'!
ColoredStateForFinancialEntityStruct subclass: #AsBlank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 19:28:11'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 19:28:11'!
PASSED!
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 19:28:43' prior: 50712937!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 (self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]"! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 19:28:45'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 19:28:52'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 19:28:52'!
PASSED!
!ColoredStateForFinancialEntityStruct methodsFor: 'no messages' stamp: 'psm 10/17/2023 19:30:29'!
coloredAsTheAdded: aFinancialEntity

	^self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:31:22'!
coloredAsTheAdder: aFinatialEntity

	^self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:32:32'!
uncolorIt: aFinatialEntity

	^self subclassResponsibility ! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:32:43' overrides: 50713387!
uncolorIt: aFinatialEntity

	^self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:32:43' overrides: 50713387!
uncolorIt: aFinatialEntity

	^self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:32:43' overrides: 50713387!
uncolorIt: aFinatialEntity

	^self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:32:43' prior: 50713387!
uncolorIt: aFinatialEntity

	self subclassResponsibility! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:32:48' overrides: 50713381!
coloredAsTheAdder: aFinatialEntity

	^self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:32:48' overrides: 50713381!
coloredAsTheAdder: aFinatialEntity

	^self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:32:48' overrides: 50713381!
coloredAsTheAdder: aFinatialEntity

	^self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:32:48' prior: 50713381!
coloredAsTheAdder: aFinatialEntity

	self subclassResponsibility! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:32:53' overrides: 50713375!
coloredAsTheAdded: aFinancialEntity

	^self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:32:53' overrides: 50713375!
coloredAsTheAdded: aFinancialEntity

	^self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:32:53' overrides: 50713375!
coloredAsTheAdded: aFinancialEntity

	^self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:32:53' prior: 50713375!
coloredAsTheAdded: aFinancialEntity

	self subclassResponsibility! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:33:59' prior: 50713437 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	aFinancialEntity recursivecoloredAsTheAdded
	^self  ! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:35:48' prior: 50713462 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	^self  ! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:36:37' prior: 50713413 overrides: 50713431!
coloredAsTheAdder: aFinatialEntity

	self error: 'hay que blanquear antes del coloreo'! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:39:11' prior: 50713392 overrides: 50713408!
uncolorIt: aFinatialEntity

	^AsBlank new! !

ColoredStateForFinancialEntityStruct class
	instanceVariableNames: 'uniqueInstance'!

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 19:39:27'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: 'uniqueInstance'!
!ColoredStateForFinancialEntityStruct class methodsFor: 'no messages' stamp: 'psm 10/17/2023 19:40:04' overrides: 16904184!
initialize
	
	uniqueInstance := self basicNew ! !
!ColoredStateForFinancialEntityStruct class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:40:06' prior: 50713497 overrides: 16904184!
initialize
	
	uniqueInstance := self basicNew.! !
!ColoredStateForFinancialEntityStruct class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:40:24' overrides: 16785646!
new
	
	^uniqueInstance.! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:41:13' prior: 50713443 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	^self! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:41:30' prior: 50713419 overrides: 50713431!
coloredAsTheAdder: aFinantialEntity

	^self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:41:39' prior: 50713397 overrides: 50713408!
uncolorIt: aFinancialEntity

	^self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:41:45' prior: 50713520 overrides: 50713431!
coloredAsTheAdder: aFinancialEntity

	^self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:42:08' prior: 50713431!
coloredAsTheAdder: aFinancialEntity

	self subclassResponsibility! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:42:12' prior: 50713408!
uncolorIt: aFinancialEntity

	self subclassResponsibility! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:42:18' prior: 50713482 overrides: 50713545!
uncolorIt: aFinancialEntity

	^AsBlank new! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:42:24' prior: 50713475 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	self error: 'hay que blanquear antes del coloreo'! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:42:48' prior: 50713425 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	^self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:42:53' prior: 50713402 overrides: 50713545!
uncolorIt: aFinancialEntity

	^self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:43:10' prior: 50713526 overrides: 50713545!
uncolorIt: aFinancialEntity

	^AsBlank new! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:43:22' prior: 50713532 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	^self! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:44:35' prior: 50713575 overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity uncolorItRecursively.
	^AsBlank new! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:44:47' prior: 50713551 overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity uncolorItRecursively.
	^AsBlank new! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:45:44'!
uncolorItRecursively

	storedFinancialEntities do:[:storedEntity | storedEntity uncolorIt]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:46:06'!
unColorItRecursively

	storedFinancialEntities do:[:storedEntity | storedEntity uncolorIt]! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:46:06' prior: 50713592 overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:46:06' prior: 50713585 overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new! !

!methodRemoval: Portfolio #uncolorItRecursively stamp: 'psm 10/17/2023 19:46:06'!
uncolorItRecursively

	storedFinancialEntities do:[:storedEntity | storedEntity uncolorIt]!
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:46:25'!
unColorItRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:46:39' overrides: 50713630!
unColorItRecursively

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:46:39' prior: 50713630!
unColorItRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:46:52' prior: 50713636 overrides: 50713642!
unColorItRecursively

	^self! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:31' prior: 50712424 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:50' prior: 50712401 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:04:43' prior: 50713660 overrides: 50712418!
uncolorIt

	colored isNil ifFalse: [
		colored := nil.
		storedFinancialEntities do:[:storedEntity | storedEntity uncolorIt]]! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:05:53' prior: 50713654 overrides: 50712418!
uncolorIt

	colored := nil.! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 19:48:38'!
PASSED!

----SNAPSHOT----(17 October 2023 19:48:43) CuisUniversity-5981.image priorSource: 12176965!
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:31' prior: 50713675 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:50' prior: 50713666 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self! !
!Portfolio methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:53:55' prior: 50707233 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.
! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:54:00' prior: 50708631 overrides: 16920235!
initialize

	transactions := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:55:34' prior: 50713569 overrides: 50713545!
uncolorIt: aFinancialEntity

	^self! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:56:23' prior: 50713563 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	aFinancialEntity coloredAsTheAdderRecursively.
	^AsAdder new.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:56:48'!
coloredAsTheAdderRecursively

	storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:48'!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' overrides: 50713813!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50713813!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:22' prior: 50713819 overrides: 50713825!
coloredAsTheAdderRecursively

	^self! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:42' prior: 50712324 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:59:39' prior: 50712314 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:01:06' prior: 50713449 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	^AsAdded new.! !

ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 20:02:05'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 20:02:13'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 20:02:21'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:02:37' overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new! !

!methodRemoval: AsAdded #uncolorIt: stamp: 'psm 10/17/2023 20:02:37'!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new!

!methodRemoval: AsAdder #uncolorIt: stamp: 'psm 10/17/2023 20:02:37'!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:14:18' prior: 50712350 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoredAsTheAddedRecursively.! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:14:41'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50713925!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50713925!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' prior: 50713925!
tryColoredAsTheAddedRecursively

	self subclassResponsibility! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50713950!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50713950!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' prior: 50713918 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 20:15:34'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 20:15:34'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 20:15:34'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:15:59' prior: 50712328 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:00' prior: 50713956 overrides: 50713950!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:01' prior: 50714001 overrides: 50713950!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50713963!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50713963!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' prior: 50713963 overrides: 50713950!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 20:17:14'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50714039!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50714039!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50714039!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50713994 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50713969 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:18:36' prior: 50714058 overrides: 50714039!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06' overrides: 50714108!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50714108!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50714108!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50714065 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50714073 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 20:19:07'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 20:19:07'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 20:19:07'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 20:19:07'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:20:53' prior: 50713186!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:21:35' prior: 50714171!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:00' prior: 50714121 overrides: 50714108!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^aFinacialEntity coloredAsTheAddedRecursively.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:40' prior: 50714219 overrides: 50714108!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:25:58' prior: 50714195!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:27' prior: 50714141 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.
	"coloredAsTheAddedRecursively"! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39'!
canIColoreAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' overrides: 50714264!
canIColoreAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' overrides: 50714264!
canIColoreAsTheAddedRecursively

	^true.! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' overrides: 50714264!
canIColoreAsTheAddedRecursively

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50714133 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50714256 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.
	"coloredAsTheAddedRecursively"! !

!methodRemoval: ColoredStateForFinancialEntityStruct #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 20:26:39'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 20:26:39'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 20:26:39'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.!

!methodRemoval: AsAdder #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 20:26:39'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:57' prior: 50714295 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: self coloredAsTheAddedRecursively.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:28:55'!
coloredAsTheAddedRecursively.

	storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 20:29:24'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 20:29:24'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 20:29:24'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 20:29:24'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 20:29:24'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 20:29:24'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 20:29:24'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:29:28'!
ERROR!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 20:32:16'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 20:32:16'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 20:32:16'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 20:32:16'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 20:32:16'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 20:32:16'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 20:32:16'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:32:20'!
ERROR!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 20:33:08'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 20:33:08'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 20:33:08'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 20:33:08'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 20:33:08'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 20:33:08'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 20:33:08'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:33:11'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:33:18'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:33:23'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:34:01'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:34:13'!
ERROR!

!methodRemoval: ColoredStateForFinancialEntityStruct class #new stamp: 'psm 10/17/2023 20:36:18'!
new
	
	^uniqueInstance.!

!methodRemoval: ColoredStateForFinancialEntityStruct class #initialize stamp: 'psm 10/17/2023 20:36:25'!
initialize
	
	uniqueInstance := self basicNew.!

ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 20:36:32'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 20:36:35'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:36:35'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 20:36:35'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 20:36:35'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 20:36:35'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 20:36:35'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 20:36:35'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 20:36:35'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 20:36:35'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 20:36:35'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 20:36:36'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 20:36:36'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 20:36:36'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 20:36:36'!
ERROR!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 20:36:36'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 20:36:36'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 20:36:36'!
ERROR!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 20:36:36'!
ERROR!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 20:36:36'!
ERROR!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 20:36:36'!
ERROR!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 20:36:36'!
ERROR!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 20:36:36'!
ERROR!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 20:36:36'!
ERROR!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 20:36:36'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 20:36:42'!
ERROR!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:33' prior: 50714326 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: [self coloredAsTheAddedRecursively].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:50' prior: 50714334!
coloredAsTheAddedRecursively.

	^storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 20:38:00'!
PASSED!

!methodRemoval: Portfolio #rootPortfoliosHaveFinancialEntityInCommon: stamp: 'psm 10/17/2023 20:38:53'!
rootPortfoliosHaveFinancialEntityInCommon: aReceptiveAccount
	^(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aReceptiveAccount rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasFinancialEntityInCommon: rootFE]])				
		
		
		
	!

!methodRemoval: Portfolio #hasFinancialEntityInCommon: stamp: 'psm 10/17/2023 20:39:04'!
hasFinancialEntityInCommon: aFinancialEntity
	
	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasFinancialEntityInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasFinancialEntityInCommon: aFinancialEntity.].].].!

!methodRemoval: Portfolio #includesReceptiveAccount: stamp: 'psm 10/17/2023 20:39:19'!
includesReceptiveAccount: aReceptiveAccount
	^ self hasFinancialEntityInCommon: aReceptiveAccount !

!methodRemoval: SetOfFinancialEntities #hasFinancialEntityInCommon: stamp: 'psm 10/17/2023 20:39:37'!
hasFinancialEntityInCommon: aReceptiveAccount

	self subclassResponsibility!

!methodRemoval: SetOfFinancialEntities #includesReceptiveAccount: stamp: 'psm 10/17/2023 20:39:37'!
includesReceptiveAccount: aReceptiveAccount

	self subclassResponsibility!

!methodRemoval: ReceptiveAccount #hasFinancialEntityInCommon: stamp: 'psm 10/17/2023 20:39:45'!
hasFinancialEntityInCommon: aFinancialEntity
	
	^aFinancialEntity includesReceptiveAccount: self!

!methodRemoval: ReceptiveAccount #includesReceptiveAccount: stamp: 'psm 10/17/2023 20:39:45'!
includesReceptiveAccount: aReceptiveAccount

	^self = aReceptiveAccount !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'psm 10/17/2023 20:39:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 20:39:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 20:39:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'psm 10/17/2023 20:39:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'psm 10/17/2023 20:39:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'psm 10/17/2023 20:39:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'psm 10/17/2023 20:39:47'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 20:39:49'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 20:39:50'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 20:39:50'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 20:39:50'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 20:39:50'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 20:39:50'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 20:39:50'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 20:39:50'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 20:39:50'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 20:39:50'!
PASSED!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:40:47'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:12' prior: 50714231!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdder. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:21'!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:41:21' prior: 50714981!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #coloredRootsAsAdder stamp: 'psm 10/17/2023 20:41:21'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:28' prior: 50715010!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:44:37'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:03' prior: 50715039!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity .
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:08' prior: 50715067!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:26'!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:45:26' prior: 50715083!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #uncolorAllEntitysInvolved: stamp: 'psm 10/17/2023 20:45:26'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:46:56'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:04'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' overrides: 50715140!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' prior: 50715140!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:29' prior: 50715147 overrides: 50715154!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'psm 10/17/2023 20:47:35'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 20:47:35'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 20:47:35'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'psm 10/17/2023 20:47:35'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'psm 10/17/2023 20:47:35'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'psm 10/17/2023 20:47:35'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'psm 10/17/2023 20:47:35'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 20:47:39'!
PASSED!

!methodRemoval: ReceptiveAccount #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 20:48:39'!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .!

!methodRemoval: SetOfFinancialEntities #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 20:48:44'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:15' prior: 50715108!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAdded: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:36'!
tryToColorRootsAsAddedIn: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:49:36' prior: 50715287!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAddedIn: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 20:49:36'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].!
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:52:31'!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio sendTo: aMessage ]. 
	! !

#(0) sentTo: #first!

#(0) executeMethod: #first!

#(0) messageText !

#(0) method !

#(0) first!

#(0) perform: #first!
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:58:11' prior: 50715329!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio perform: aMessage ]. 
	! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50715003!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 21:00:38'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 21:00:38'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 21:00:38'!
FAILURE!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 21:00:38'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 21:00:38'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 21:00:38'!
FAILURE!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 21:00:38'!
FAILURE!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 21:00:38'!
FAILURE!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 21:00:38'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 21:00:38'!
FAILURE!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 21:00:44'!
FAILURE!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:01:12' prior: 50715347!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	
	"self rootPortfolioDo: #coloredAsTheAdder."! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 21:01:14'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 21:01:14'!
PASSED!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50715442!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 21:01:49'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 21:01:49'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 21:01:49'!
FAILURE!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 21:01:49'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 21:01:49'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 21:01:49'!
FAILURE!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 21:01:49'!
FAILURE!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 21:01:49'!
FAILURE!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 21:01:49'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 21:01:49'!
FAILURE!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 21:01:53'!
FAILURE!

Portfolio new coloredRootsAsAdders !

Portfolio coloredAsTheAdder !

Portfolio new coloredAsTheAdder !

Portfolio new perform: #coloredAsTheAdder !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:05:49' prior: 50715533!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 21:05:51'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 21:05:51'!
FAILURE!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 21:05:51'!
FAILURE!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 21:05:51'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 21:05:51'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 21:05:51'!
FAILURE!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 21:05:51'!
FAILURE!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 21:05:51'!
FAILURE!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 21:05:51'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 21:05:51'!
FAILURE!
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 21:06:14' prior: 50715340!
rootPortfolioDo: aMessage
	self rootPortfolio do:[:rootPortfolio | rootPortfolio perform: aMessage ]. 
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 21:06:21'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 21:06:21'!
PASSED!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:25:29' prior: 50715098!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolioDo: #uncolorIt.
	aFinancialEntity rootPortfolioDo: #uncolorIt.! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 21:25:32'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 21:25:32'!
PASSED!
!Portfolio methodsFor: 'transactions' stamp: 'psm 10/17/2023 21:26:05' prior: 50710339!
add: aFinancialEntity 
	
	self avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity .
	
	aFinancialEntity newFatherPortfolio: self.	
	storedFinancialEntities add: aFinancialEntity .! !
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 21:28:51'!
rootPortfoliosSend: aMessage
	self rootPortfolio do:[:rootPortfolio | rootPortfolio perform: aMessage ]. 
	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:28:51' prior: 50715813!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfoliosSend: #uncolorIt.
	aFinancialEntity rootPortfoliosSend: #uncolorIt.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:28:51' prior: 50715632!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfoliosSend: #coloredAsTheAdder.! !

!methodRemoval: SetOfFinancialEntities #rootPortfolioDo: stamp: 'psm 10/17/2023 21:28:51'!
rootPortfolioDo: aMessage
	self rootPortfolio do:[:rootPortfolio | rootPortfolio perform: aMessage ]. 
	!

OrderedCollection subclass: #OrderedCollectionEnumeratingWithSenders
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #OrderedCollectionEnumeratingWithSenders category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:30:24'!
OrderedCollection subclass: #OrderedCollectionEnumeratingWithSenders
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'initialization' stamp: 'psm 10/17/2023 21:30:50' prior: 50713777 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollectionEnumeratingWithSenders new.
	fatherPortfolio := OrderedCollectionEnumeratingWithSenders new.
	colored := AsBlank new.
! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'psm 10/17/2023 21:31:13' prior: 50713785 overrides: 16920235!
initialize

	transactions := OrderedCollectionEnumeratingWithSenders new.
	fatherPortfolio := OrderedCollectionEnumeratingWithSenders new.
	colored := AsBlank new.! !
!OrderedCollectionEnumeratingWithSenders methodsFor: 'no messages' stamp: 'psm 10/17/2023 21:32:50'!
doSend: aMessage

	self do:[:anElement | anElement perform: aMessage]! !
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 21:33:30' prior: 50715913!
rootPortfoliosSend: aMessage
	self rootPortfolio doSend: aMessage . 
	! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 21:33:37'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 21:33:37'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 21:33:37'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 21:33:37'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 21:33:37'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 21:33:37'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 21:33:37'!
ERROR!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 21:33:37'!
ERROR!
!OrderedCollectionEnumeratingWithSenders methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:34:18' prior: 50715977!
doSend: aMessage

	^self do:[:anElement | anElement perform: aMessage].! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'psm 10/17/2023 21:34:30'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 21:34:30'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'psm 10/17/2023 21:34:30'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'psm 10/17/2023 21:34:30'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'psm 10/17/2023 21:34:30'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'psm 10/17/2023 21:34:30'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'psm 10/17/2023 21:34:30'!
PASSED!

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 21:34:30'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 21:34:30'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 21:34:30'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 21:34:30'!
FAILURE!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 21:34:30'!
FAILURE!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 21:34:30'!
FAILURE!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 21:34:30'!
ERROR!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 21:34:33'!
ERROR!

!classRenamed: #OrderedCollection as: #OrderedCollectionEnu stamp: 'psm 10/17/2023 21:35:21'!
Smalltalk renameClassNamed: #OrderedCollection as: #OrderedCollectionEnu!
!ClosureScanner methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16817097!
newScanQueueSegment
	"Segment the scan queue, otherwise the GC will be forced to scan the whole
	queue every time (obviously, the scan queue will be in the remember table)"

	| newScanQueue |
	newScanQueue _ OrderedCollectionEnu new: self scanQueueSegmentTargetSize.
	newScanQueue resetTo: 1.
	^newScanQueue! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50363456!
privateReadSelector
	| args selector |
	doitFlag := false.

	hereType == #word ifTrue: [
		^ here asSymbol ].

	self transformVerticalBarAndUpArrowIntoABinarySelector.

	hereType == #binary ifTrue: [
		^ here asSymbol ].

	hereType == #keyword ifTrue: [
		selector := source collectionSpecies writeStream.
		args := OrderedCollectionEnu new.
		[hereType == #keyword] whileTrue: [
			selector nextPutAll: self advance.
			args addLast: (encoder bindArg: self argumentName).
		].
		^ selector contents asSymbol ].

	^self expected: 'Message pattern'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16821591!
unusedMethods
	| classes unsent messageList cls |

	(cls _ self selectedClass) ifNil: [^ nil].
	classes _ Array with: cls with: cls class.
	unsent _ Set new.
	classes do: [:c | unsent addAll: c selectors].
	unsent _ Smalltalk allUnSentMessagesIn: unsent.
	messageList _ OrderedCollectionEnu new.
	classes do: [:c | (c selectors select: [:s | unsent includes: s]) asArray sort
					do: [:sel | messageList add: 
						(MethodReference class: c selector: sel) ]].
	^messageList! !
!TestRunner methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16962468!
selectedTests
	| retval |
	retval _ OrderedCollectionEnu new.
	tests with: selectedSuites do: [ :str :sel | sel ifTrue: [ retval add: str ]].
	^retval
! !
!RemoveInstanceVariable class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16926243!
assert: aVaraible isNotReferencedInHierarchyOf: aClassToRefactor

	| references |
	
	references := OrderedCollectionEnu new.
	aClassToRefactor withAllSubclassesDo: [ :aClass | 
		(aClass whichSelectorsAccess: aVaraible) do: [ :aSelector | references add: (MethodReference class: aClass selector: aSelector) ]].
	
	references notEmpty ifTrue: [ self signalInstanceVariable: aVaraible isReferencedInAll: references ]! !
!MethodTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50626719!
errorsAsMethodReferencesPrefixing: aPrefix

	^self addMethodReferencesOf: errors prefixing: aPrefix to: OrderedCollectionEnu new! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50515237!
testCreationWithMeasures

	| measures measureBag |

	measures := OrderedCollectionEnu with: self tenPesos with: self twentyDollars with: self tenEuros.	
	measureBag := CompoundMeasure measures: measures.
	
	self assert: measureBag numberOfMeasures = 3.
	self assert: (measureBag atSameBaseUnitAs: self peso) = self tenPesos.
	self assert: (measureBag atSameBaseUnitAs: self dollar) = self twentyDollars.
	self assert: (measureBag atSameBaseUnitAs: self euro) = self tenEuros! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50577784!
testInlineBlockCollectionSD1
	| a1 b1 a2 b2 |
	b1 := OrderedCollectionEnu new.
	1 to: 3 do:
		[:i |
		a1 := i.
		b1 add: [a1]].
	b1 := b1 asArray collect: [:b | b value].
	b2 := OrderedCollectionEnu new.
	1 to: 3 do:
		[:i |
		a2 := i.
		b2 add: [a2]] yourself. "defeat optimization"
	b2 := b2 asArray collect: [:b | b value].
	self assert: b1 = b2! !
!FileList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16855112!
itemsForNoFile

	| services |
	services := OrderedCollectionEnu new: 6.
	services add: self serviceSortByName.
	services add: self serviceSortBySize.
	services add: (self serviceSortByDate useLineAfter: true).
	services add: self serviceAddNewFile.
	services add: self serviceAddNewDirectory.
	^ services

		! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16805311!
changedMessageList
	"Used by a message set browser to access the list view information."

	| messageList |
	messageList _ OrderedCollectionEnu new.
	changeRecords associationsDo: [ :clAssoc | | classNameInFull classNameInParts |
		classNameInFull _ clAssoc key asString.
		classNameInParts _ classNameInFull findTokens: ' '.

		(clAssoc value allChangeTypes includes: #comment) ifTrue: [
			messageList add:
				(MethodReference new
					setClassSymbol: classNameInParts first asSymbol
					classIsMeta: false 
					methodSymbol: #Comment 
					stringVersion: classNameInFull, ' Comment')].

		clAssoc value methodChangeTypes associationsDo: [ :mAssoc |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse: [
				messageList add:
					(MethodReference new
						setClassSymbol: classNameInParts first asSymbol
						classIsMeta: classNameInParts size > 1 
						methodSymbol: mAssoc key 
						stringVersion: classNameInFull, ' ' , mAssoc key)]]].
	^ messageList sorted! !
!UndeclaredVariable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16975506 overrides: 16899936!
defaultAction
	
	| labels actions lines caption choice icons |
	
	labels _ OrderedCollectionEnu new.
	actions _ OrderedCollectionEnu new.
	lines _ OrderedCollectionEnu new.
	icons _ OrderedCollectionEnu new.
	
	self createMenuOptionsAddingTo: labels actions: actions icons: icons lines: lines.
	caption _ 'Unknown variable: ' , name , ' please correct, or cancel:'.
	choice _ (PopUpMenu labelArray: labels lines: lines icons: icons) startUpWithCaption: caption.
	
	self resume: (actions at: choice ifAbsent:[ nil ]).! !
!TestCaseTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50584921!
testAssertChangesPassesWhenConditionIsAlteredByAction

	|aCollection|

	aCollection := OrderedCollectionEnu new.
	
	self assert: [ aCollection add: 1 ] changes: [ aCollection size ]! !
!Morph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16891897!
ownerChain
	"Answer a list of objects representing the receiver and all of its owners.   The first element is the receiver, and the last one is typically the world in which the receiver resides"

	| c next |
	c := OrderedCollectionEnu with: self.
	next := self.
	[(next := next owner) notNil] whileTrue: [c add: next].
	^c asArray! !
!PreDebugWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16914961!
buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollectionEnu new.
	triads _ OrderedCollectionEnu withAll: self preDebugButtonSpec.
	aDebugger shouldBeAbleToCreateMethod ifTrue: [ triads add: { 'Create'. #createMethod. 'create the missing method' }].
	
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: `Color transparent`.
	row separation: 1.
	row addMorphs: buttons.
	^row! !
!FileListWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16856079!
updateButtonRow: row
	"Dynamically update the contents of the button row, if any."

	| buttons |
	row removeAllMorphs.
	buttons _ OrderedCollectionEnu new.
	model universalButtonServices do: [ :service |
		buttons add: (self buttonToTriggerIn: model for: service) ].
	model dynamicButtonServices do: [ :service | 
		buttons add: (self buttonToTriggerIn: model for: service).
		service when: #fileListChanged send: #updateFileList to: model ].
	row addMorphs: buttons! !
!ContentPack class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16831752!
resetImporter

	count _ 1.
	payload _ OrderedCollectionEnu new! !
!SystemOrganizer methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50418200!
withSubCategoriesOf: aRootCategoryName

	"Returns the root category and subcategories if they exist
	The order is important because it is assumed like that in some senders
	If aRootCategoryName does not exist as category, it will return it anyway - Hernan"
	^(OrderedCollectionEnu with: aRootCategoryName) 
		addAll: (self subCategoriesOf: aRootCategoryName);
		yourself.
	
	! !
!TrieTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50579972!
assert: subject prefixSelection: aString isEquivalentToSet: controlGroup
	| selection1 selection2 |
	selection1 _ OrderedCollectionEnu new.
	subject forPrefix: aString keysAndValuesDo: [ :k :v |
		selection1 add: k ].
	selection2 _ (controlGroup select: [ :each |
		aString isEmpty or: [
			each asLowercase asUnaccented beginsWith: aString asLowercase asUnaccented]]) asOrderedCollection 
				sort: [ :a :b | a asLowercase asUnaccented < b asLowercase asUnaccented ].
	self assert: selection1 = selection2.! !
!ActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50614243!
initializeIn: toAnalizeCompiledMethod of: aSentCompiledMethod 

	toAnalize := toAnalizeCompiledMethod.
	toAnalizeMethodClass := toAnalizeCompiledMethod methodClass.
	sent := aSentCompiledMethod.
	sentSelector := sent selector.
	sentMethodClass := sent methodClass.
	isToAnalizeInSuperclass := sentMethodClass includesBehavior: toAnalizeMethodClass.
	
	sureMessageSends := OrderedCollectionEnu new.
	possibleMessageSends := OrderedCollectionEnu new.! !
!ArgumentsAndReturnsFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50609934 overrides: 16902254!
value

	| paramsAndReturnsFinder |
	
	ranges := OrderedCollectionEnu new.
	
	paramsAndReturnsFinder := ParseNodeEnumerator ofBlock: [ :node | 	
		(self isReturnIvar: node) ifTrue: [self addReturnRangesFrom: node].
		(self isMessageWithIvarAsArg: node) ifTrue: [ self addParametersRangesFrom: node]].

	methodNode accept: paramsAndReturnsFinder.
! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50598141!
simpleIsNestedTestResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		add: self doSomethingElseString;
		yourself! !
!UnicodeString methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50454961!
basicCanonicallyOrdered
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	(UnicodeString fromCodePoints: #(16r61  16r0300 16r0315 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0300 16r031B 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r031B 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r0300 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0300 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0315 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	"
	| byteIndex stopByteIndex n combining cls element |
	byteIndex _ 1.
	stopByteIndex _ bytes size.
	combining _ OrderedCollectionEnu new.
	^UnicodeString streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			n _ Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				cls _ UnicodeCodePoint combiningClass: codePoint.
				cls = 0
					ifTrue: [
						combining notEmpty ifTrue: [
							combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
							combining do: [ :e | strm nextPutCodePoint: e third ]].
						strm nextPutCodePoint: codePoint.
						combining _ OrderedCollectionEnu new ]
					ifFalse: [
						element _ { cls. combining size+1. codePoint }.
						combining add: element ]].
			byteIndex _ byteIndex + n ].
		combining notEmpty ifTrue: [
			combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
			combining do: [ :e | strm nextPutCodePoint: e third ] ]].! !
!TestSuite methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16963230!
tests
	tests ifNil: [tests := OrderedCollectionEnu new].
	^tests
			! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50549536!
messageSendWithMessageSendReceiver

	(OrderedCollectionEnu new)
		value! !
!ImmutableTextModelMorph class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50600705!
minimumHeightToDisplay: aString on: aWidth

	| aComposer composition lines aText disregardHeight |

	aComposer := TextComposer new.
	aText := Text fromString: aString.
	disregardHeight := 999999.
	composition := aComposer composeLinesFrom: 1 to: aText size delta: 0 into: OrderedCollectionEnu new priorLines: Array new atY: 0 text: aText extentForComposing: aWidth @ disregardHeight.
	lines := composition first asArray size.

	^lines * self textHeight! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16847499!
temps: tempVars literals: lits class: cl 
	"Decompile."

	supered := false.
	class := cl.
	nTemps := tempVars size.
	tempVars do: [:node | scopeTable at: node name put: node].
	literalStream := ReadStream on: lits.
	literalStream position: lits size.
	sourceRanges := Dictionary new: 32.
	globalSourceRanges := OrderedCollectionEnu new: 32.
! !
!TopologicalSort methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50526838 overrides: 16902254!
value

	| tempGraph result |

	tempGraph := graph copy.
	result := OrderedCollectionEnu new.

	[tempGraph notEmpty] whileTrue: [| startingNodes |
		startingNodes := tempGraph nodesWithoutConvergingEdges.
		result addAll: startingNodes.
		tempGraph := tempGraph removeNodes: startingNodes].

	^result! !
!AllActualLocalImplementors methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50622428 overrides: 50622393!
value
	
	notImplemented := OrderedCollectionEnu new.
	implementors := types 
		inject: IdentitySet new
		into: [ :methods :aClass | 
			(aClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | methods add: method ].
			methods ].

	implementors := implementors collect: [ :method | method asMethodReference ].
	
	^self 
! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50346507!
writeConversionMethodIn: newClass fromInstVars: oldList to: newList renamedFrom: oldName
	"The method convertToCurrentVersion:refStream: was not found in newClass.  Write a default conversion method for the author to modify.  If method exists, append new info into the end."

	| code newOthers oldOthers copied newCode |

	newOthers _ newList asOrderedCollection "copy".
	oldOthers _ oldList asOrderedCollection "copy".
	copied _ OrderedCollectionEnu new.
	newList do: [:instVar |
		(oldList includes: instVar) ifTrue: [
			instVar isInteger ifFalse: [copied add: instVar].
			newOthers remove: instVar.
			oldOthers remove: instVar]].
	code _ WriteStream on: (String new: 500).
	code newLine; newLine; tab; nextPutAll: '"From ', SystemVersion current version, ' [', Smalltalk lastUpdateString;
			nextPutAll: '] on ', Date today printString, '"'; newLine.
	code tab; nextPutAll: '"These variables are automatically stored into the new instance: '.
	code nextPutAll: copied asArray printString; nextPut: $.; newLine.
	code tab; nextPutAll: 'Test for this particular conversion.'; 
		nextPutAll: '  Get values using expressions like (varDict at: ''foo'')."'; newLine; newLine.
	newOthers isEmpty & oldOthers isEmpty & oldName isNil ifTrue: [^ self].
		"Instance variables are the same.  Only the order changed.  No conversion needed."
	newOthers notEmpty ifTrue: [
		code tab; nextPutAll: '"New variables: ', newOthers asArray printString, 
			'.  If a non-nil value is needed, please assign it."'; newLine].
	oldOthers notEmpty ifTrue: [
		code tab; nextPutAll: '"These are going away ', oldOthers asArray printString, 
			'.  Possibly store their info in some other variable?"'; newLine].
	oldName ifNotNil: [
		code tab; nextPutAll: '"Test for instances of class ', oldName, '.'; newLine.
		code tab; nextPutAll: 'Instance vars with the same name have been moved here."'; newLine.
		].
	code tab; nextPutAll: '"Move your code above the ^ super...  Delete extra comments."'; newLine. 

	(newClass includesSelector: #convertToCurrentVersion:refStream:) 
		ifTrue: ["append to old methods"
			newCode _ (newClass sourceCodeAt: #convertToCurrentVersion:refStream:),
				code contents]
		ifFalse: ["new method"
			newCode _ 'convertToCurrentVersion: varDict refStream: smartRefStrm',
				code contents, 
				'	^ super convertToCurrentVersion: varDict refStream: smartRefStrm'].
	newClass compile: newCode classified: 'object fileIn'.


	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)
	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe."! !
!TimeUnits class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50540928!
allUnits
	
	^OrderedCollectionEnu new
		add: day;
		add: hour;
		add: minute;
		add: second;
		add: millisecond;
		add: week;
		add: month;
		add: year;
		yourself.! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16954086!
allReferencesToLiteral: aLiteral
	| coll |
	coll := OrderedCollectionEnu new.
	Smalltalk allBehaviorsDo: [ :eaClass |
		eaClass
			addMethodsTo: coll
			thatReferenceTo: aLiteral
			special: false
			byte: nil ].
	^ coll.! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50597928!
log

	log == nil
		ifTrue: [log := OrderedCollectionEnu new].
	^log! !
!CodeFileBrowserWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50494435 overrides: 50474094!
messageListMenu
	| aMenu itemColl |
	self flag: #assumesKeyboardShortcuts.
	aMenu := MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Message List'.
	itemColl := OrderedCollectionEnu new.
	self model baseCodeSource isLiveSmalltalkImage ifTrue: [
		itemColl add:
			{#label -> 'fileIn'. #object -> #model. #selector -> #fileInMessage. #icon -> #updateIcon} asDictionary ].
	itemColl addAll:
		{
			{#label -> 'fileOut'. #object -> #model. #selector -> #fileOutMessage. #icon -> #fileOutIcon} asDictionary. 
			nil
		}.
	self model baseCodeSource isLiveSmalltalkImage ifTrue: [
		itemColl addAll:
			{
				{#label -> 'senders (n)'. #selector -> #browseSenders. #icon -> #mailForwardIcon} asDictionary. 
				{#label -> 'implementors (m)'. #selector -> #browseImplementors. #icon -> #developmentIcon} asDictionary. 
				{#label -> 'method inheritance (h)'. #selector -> #methodInheritance. #icon -> #goDownIcon} asDictionary. 
				{#label -> 'versions (v)'. #selector -> #browseVersions. #icon -> #clockIcon} asDictionary
			} ].
	itemColl addAll:
		{
			nil. 
			{#label -> 'remove method (x)'. #object -> #model. #selector -> #removeMessage. #icon -> #deleteIcon} asDictionary
		}.
	aMenu addItemsFromDictionaries: itemColl.
	^ aMenu.! !
!OrderedCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50574988!
testWriteStreamOnOrderedCollectionGrowsAsExpected

	| contents |
	
	contents := OrderedCollectionEnu streamContents: [ :stream | 
		1 to: 101 do: [ :aNumber | stream nextPut: aNumber ]].
	
	1 to: 101 do: [ :aNumber | self assert: (contents at: aNumber) equals: aNumber ].! !
!SequenceableCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50575196!
testWithIndexDoSeparatedByDoesNotValueSeparatedBlockForCollectionsOfOneElement

	| collectionToTraverse traversedElements |

	collectionToTraverse := OrderedCollectionEnu with: $a.
	traversedElements := OrderedCollectionEnu new.

	self shouldntFail: [ collectionToTraverse withIndexDo: [ :anElement :index | traversedElements add: anElement  -> index ] separatedBy: [ self fail ] ].

	self assert: traversedElements size equals: 1.
	self assert: traversedElements first equals: $a->1.! !
!HierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16867486!
list: aCollection

	| wereExpanded morphList |
	wereExpanded _ self currentlyExpanded.
	scroller removeAllMorphs.
	(aCollection isNil or: [aCollection isEmpty]) ifTrue: [^ self selectedMorph: nil].
	morphList _ OrderedCollectionEnu new.
	self 
		addMorphsTo: morphList
		from: aCollection 
		allowSorting: false
		withExpandedItems: wereExpanded
		atLevel: 0.
	self insertNewMorphs: morphList.! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16786320!
allSubInstances 
	"Answer a list of all current instances of the receiver and all of its subclasses."
	| aCollection |
	aCollection _ OrderedCollectionEnu new.
	self allSubInstancesDo:
		[:x | x == aCollection ifFalse: [aCollection add: x]].
	^ aCollection! !
!MoveInstanceVariableRefactoring methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50543214!
accessInSourceClass
	| accessMethods |
	accessMethods := OrderedCollectionEnu new.
	sourceClass withAllSubclassesDo: [ :aSubClass | | selectorsAccessingIV | 
		selectorsAccessingIV := (aSubClass whichSelectorsAccess: instVarNameSourceClass) asOrderedCollection .
		accessMethods addAll: ( selectorsAccessingIV collect: [ :aSelector | aSubClass methodDict at: aSelector ])
		].
	^ accessMethods! !
!PathArcCommand methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50431947 overrides: 50431909!
buildFrom: commandChar stream: aStream

	| rx ry xAxisRotation doLargerArc useIncreasingAngle x y |
	super buildFrom: commandChar stream: aStream.
	rs _ OrderedCollectionEnu new.
	xAxisRotations _ OrderedCollectionEnu new.
	toPoints _ OrderedCollectionEnu new.
	doLargerArcs _ OrderedCollectionEnu new.
	useIncreasingAngles _ OrderedCollectionEnu new.
	[
		rx _ aStream nextNumber.
		ry _ aStream nextNumber.
		xAxisRotation _ aStream nextNumber.
		doLargerArc _ (aStream nextNumber = 0) not.
		useIncreasingAngle _ (aStream nextNumber = 0) not.
		x _ aStream nextNumber.
		y _ aStream nextNumber.
		y notNil ] whileTrue: [
			rs add: rx@ry.
			xAxisRotations add: xAxisRotation degreesToRadians.
			doLargerArcs add: doLargerArc.
			useIncreasingAngles add: useIncreasingAngle.
			toPoints add: x@y ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16795551!
hierarchicalClassList

	"classNames are an arbitrary collection of classNames of the system.
	Reorder those class names so that they are sorted and indended by inheritance"

	| classes |

	"Creating the hierarchy is *really slow* for the full class list. Skip it for now."
	selectedSystemCategory = SystemOrganizer allCategory ifTrue: [^ self defaultClassList].		
	classes := self defaultClassList collect: [:sym | Smalltalk classNamed: sym].
	
	^ self
		flattenHierarchyTree: (self createHierarchyTreeOf: classes)
		on: OrderedCollectionEnu new
		indent: ''.! !
!Browser class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16796871!
recentClasses
	RecentClasses ifNil: [
		RecentClasses := OrderedCollectionEnu new ].
	^RecentClasses! !
!SpaceTally methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16943810!
printSpaceAnalysis: threshold on: aStream
	"
	SpaceTally new printSpaceAnalysis: 1 on:(FileStream forceNewFileNamed: 'STspace.text')
	"
	"sd-This method should be rewrote to be more coherent within the rest of the class 
	ie using preAllocate and spaceForInstanceOf:"

	"If threshold > 0, then only those classes with more than that number
	of instances will be shown, and they will be sorted by total instance space.
	If threshold = 0, then all classes will appear, sorted by name."

	| codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n totalPercent percent |
	Smalltalk garbageCollect.
	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.
	results _ OrderedCollectionEnu new: Smalltalk classNames size.
	'Taking statistics...'
		displayProgressAt: Sensor mousePoint
		from: 0 to: Smalltalk classNames size
		during: [ :barBlock |
			Smalltalk allClassesDo: [ :cl |
				codeSpace _ cl spaceUsed.
				barBlock value: (n _ n+1).
				Smalltalk garbageCollectMost.
				instCount _ cl instanceCount.
				instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8]) * instCount. "Object headers""Warning: The 3rd header word for big objects is not considered!!"
				cl isVariable
					ifTrue: [
						eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].
						cl allInstancesDo: [ :x |
							instSpace _ instSpace + (x basicSize * eltSize)]]
					ifFalse: [instSpace _ instSpace + (cl instSize * instCount * 4)].
				results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).
				totalCodeSpace _ totalCodeSpace + codeSpace.
				totalInstCount _ totalInstCount + instCount.
				totalInstSpace _ totalInstSpace + instSpace]].
	totalPercent _ 0.0.

	aStream timeStamp.
	aStream
		nextPutAll: ('Class' padded: #right to: 30 with: $ );
		nextPutAll: ('code space' padded: #left to: 12 with: $ );
		nextPutAll: ('# instances' padded: #left to: 12 with: $ );
		nextPutAll: ('inst space' padded: #left to: 12 with: $ );
		nextPutAll: ('percent' padded: #left to: 8 with: $ ); newLine.

	threshold > 0 ifTrue: [
		"If inst count threshold > 0, then sort by space"
		results _ (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])
			asArray sort: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].

	results do: [:s |
		aStream
			nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );
			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );
			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );
			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).
		percent _ s spaceForInstances*100.0/totalInstSpace.
		totalPercent _ totalPercent + percent.
		percent >= 0.1 ifTrue: [
			percent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil ].
		aStream newLine].

	aStream
		newLine; nextPutAll: ('Total' padded: #right to: 30 with: $ );
		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ ).
	totalPercent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50383660!
findBetweenSubStrs: delimiters
	"Answer the collection of String tokens that result from parsing self.  Tokens are separated by 'delimiters', which can be a collection of Strings, or a collection of Characters.  Several delimiters in a row are considered as just one separation."

	| tokens keyStart keyStop |
	tokens _ OrderedCollectionEnu new.
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipAnySubStr: delimiters startingAt: keyStop.
		keyStop _ self findAnySubStr: delimiters startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens! !
!SequenceableCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50575114!
testDoSeparatedByDoesNotValueSeparatedBlockForCollectionsOfOneElement

	| collectionToTraverse traversedElements |

	collectionToTraverse := OrderedCollectionEnu with: 1.
	traversedElements := OrderedCollectionEnu new.
	self shouldntFail: [ collectionToTraverse do: [ :anElement | traversedElements add: anElement ] separatedBy: [ self fail ] ].

	self assert: traversedElements equals: collectionToTraverse.! !
!VariableTypeInfoTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50619570!
test28CommonSelectorsPreviousToIfInvalidSupertypeWithManyTypesEvaluatesInvalidBlock

	| variableTypeInfo |

	variableTypeInfo := VariableTypeInfo new initializeRawTypes: (Array new: 3).

	variableTypeInfo addType: Array.
	variableTypeInfo addType: Magnitude.
	variableTypeInfo addType: OrderedCollectionEnu.

	self assert: Magnitude equals: (variableTypeInfo commonSelectorsPreviousTo: Collection ifInvalidSupertype: [ :aStartingClass | aStartingClass ])
		! !
!FileList class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16855938!
itemsForFileEntry: aFileEntry
	"Answer a list of services appropriate for a file of the given name"
	| services suffix classList |
	"
	suffix _ (FileIOAccessor default extensionFor: filename) asLowercase.
	"
	suffix := aFileEntry extension asLowercase.
	"Build the list dynamically for all implementers of the appropriate class method... registration no longer required"
	classList _ (Smalltalk allClassesImplementing: #fileReaderServicesForFileEntry:suffix:)
		collect: [ :item |
			item class == Metaclass ifTrue: [ item soleInstance ]]
		thenSelect: [ :item |
			item notNil ].
	services _ OrderedCollectionEnu new.
	classList do: [ :reader |
		services addAll:
			(reader
				fileReaderServicesForFileEntry: aFileEntry 
				suffix: suffix) ].
	services sort: [ :a :b | a sortOrder < b sortOrder ].
	^ services.! !
!ExtractToMethodObjectForm methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50601073!
buildPreview

	| keywordParamStrings previewContent |

	keywordParamStrings := OrderedCollectionEnu new.
	inputTable keywordsAndParametersDo: [:keyword :parameterName |
		(keyword isEmpty or: [parameterName isEmpty]) ifTrue: [
			preview model actualContents: self previewUnavailableMessage.
			^self].

		keywordParamStrings addFirst: '', keyword, ': ', parameterName].

	previewContent := ' ' join: keywordParamStrings.

	preview model actualContents: previewContent.! !
!PathQuadraticCurveToCommand methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50432156 overrides: 50431909!
buildFrom: commandChar stream: aStream

	| x1 y1 x y |
	super buildFrom: commandChar stream: aStream.
	toPoints _ OrderedCollectionEnu new.
	controlPoints _ OrderedCollectionEnu new.
	[
		x1 _ aStream nextNumber.
		y1 _ aStream nextNumber.
		x _ aStream nextNumber.
		y _ aStream nextNumber.
		y notNil ] whileTrue: [
			toPoints add: x@y.
			controlPoints add: x1@y1 ]! !
!CompiledMethodInspector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16830562 overrides: 16871803!
fieldList

	| keys |
	keys _ OrderedCollectionEnu new.
	keys add: 'self'.
	keys add: 'all bytecodes'.
	keys add: 'header'.
	1 to: object numLiterals do: [ :i |
		keys add: 'literal', i printString ].
	object initialPC to: object size do: [ :i |
		keys add: i printString ].
	^ keys asArray
	! !
!DefinedByRules methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50532319!
initializeFor: aUniverse
	
	rules := OrderedCollectionEnu new.
	universe := aUniverse! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16867954!
initHierarchyForClass: aClassOrMetaClass
	| tab stab index nonMetaClass |
	centralClass _ aClassOrMetaClass.
	nonMetaClass _ aClassOrMetaClass theNonMetaClass.
	self systemOrganizer: SystemOrganization.
	metaClassIndicated _ aClassOrMetaClass isMeta.
	classList _ OrderedCollectionEnu new.
	tab _ ''.
	nonMetaClass allSuperclasses reverseDo: 
		[:aClass | 
		classList add: tab , aClass name.
		tab _ tab , '  '].
	index _ classList size + 1.
	nonMetaClass allSubclassesWithLevelDo:
		[:aClass :level |
		stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].
		classList add: tab , stab , aClass name]
	 	startingLevel: 0.
	self classListIndex: index! !
!SerializableBlockClosure methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 16935346!
onBlockClosure: aBlockClosure

	| both blockNode methodNode indirectTempNames sortedOuterTemps ownNames usedOuterNames sortedUsedOuterNames |
	aBlockClosure hasNonLocalReturn ifTrue: [
		self error: 'Can not serialize closures with non-local returns.' ].
	aBlockClosure sendsToSuper ifTrue: [
		self error: 'Can not currently serialize closures with super sends.' ].
	both _ SerializableClosureDecompiler new  decompileBlockAndMethod: aBlockClosure.
	blockNode _ both first.
	methodNode _ both second.

	indirectTempNames _ methodNode temporaries
		detect: [ :node | node isIndirectTempVector ]
		ifFound: [ :node | node remoteTemps collect: [ :n | n name ]]
		ifNone: [#()].
	sortedOuterTemps _ OrderedCollectionEnu new.
	aBlockClosure outerContextsDo: [ :c | c closure ifNotNil: [ :cc |
		| ccn |
		ccn _ cc decompile.
		sortedOuterTemps addAll: ccn arguments; addAll: ccn temporaries ]].
	sortedOuterTemps addAll: methodNode temporaries; addAll: methodNode arguments.

	ownNames _ ((blockNode arguments, blockNode temporaries)
		collect: [ :node | node name ]) asSet.
	usedOuterNames _ Set new.
	blockNode nodesDo: [ :node | node isTemp ifTrue: [
		(ownNames includes: node name) | (indirectTempNames includes: node name) ifFalse: [
			usedOuterNames add: node name]]].

	sortedUsedOuterNames _ sortedOuterTemps select: [ :node |
		usedOuterNames includes: node name ]. "sort them"
	sortedUsedOuterNames _ sortedUsedOuterNames collect: [ :node | node name ].

	blockNode nodesDo: [ :node | node isTemp ifTrue: [ 
		node isRemote
			ifTrue: [node capturedIndex: (indirectTempNames indexOf: node name) ]
			ifFalse: [
				(sortedUsedOuterNames includes: node name)
					ifTrue: [node capturedIndex: (sortedUsedOuterNames indexOf: node name)]]]].

	theSelf _ aBlockClosure receiver.
	capturedValues _ aBlockClosure capturedValues.
	sourceCode _ blockNode decompileString.! !
!CodeForNodeOnMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:22' prior: 50541851!
initializeFor: aNode replace: instVarNameToReplace onMethod: aCompiledMethod accessingThrough: instVarNameToUseAsReceiver rejectingIntervals: intervals
	node := aNode.
	instanceVariableName := instVarNameToReplace.
	compiledMethod := aCompiledMethod.
	instVarNameTargetClass := instVarNameToUseAsReceiver.
	methodNode := compiledMethod notOptimizedMethodNode.
	intervalsToModify := OrderedCollectionEnu new.
	intervalsToReject := intervals.
	modifiedReads := 0.
	modifiedWrites := 0! !
!Rectangle methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16923089!
areasOutside: aRectangle
	"Answer an Array of Rectangles comprising the parts of the receiver not 
	intersecting aRectangle."

	| areas |
	"Make sure the intersection is non-empty"
     (self intersects: aRectangle)
		ifFalse: [^Array with: self].
	areas := OrderedCollectionEnu new.
	self areasOutside: aRectangle do: [ :r |  areas add: r ].
	^areas! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16842360!
keysAndValuesRemove: keyValueBlock
	"Removes all entries for which keyValueBlock returns true."
	"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method."

	| removals |
	removals _ OrderedCollectionEnu new.
	self associationsDo:
		[:assoc | (keyValueBlock value: assoc key value: assoc value)
			ifTrue: [removals add: assoc key]].
 	removals do:
		[:aKey | self removeKey: aKey]! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50399699 overrides: 16920235!
initialize
	"Initialize a blank ChangeList.  Set the contentsSymbol to reflect whether diffs will initally be shown or not"

	contentsSymbol _ (Preferences at: #diffsInChangeList)
		ifTrue:
			[self defaultDiffsSymbol]
		ifFalse:
			[#source].
	changeList _ OrderedCollectionEnu new.
	list _ OrderedCollectionEnu new.
	listIndex _ 0.
	super initialize! !
!EqualsTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50626153 overrides: 50625983!
buildCastApplierBefore: aPreviousCastingApplier 
	
	 ^EffectiveTypeCastApplier 
		casts: (OrderedCollectionEnu with: self buildTypeCast)
		rejections: OrderedCollectionEnu new
		previous: aPreviousCastingApplier! !
!TestSuite class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50335918!
forClasses: classes named: aName

	| testMethods suite classTests tests testPrintString |
	
	"I don't want repeated tests. TestCase does not redefine #= so instead of redefining it and use a Set
	I decided to keep the related tests methods in a different set and decide to add it or note base on that
	- Hernan"
	
	testMethods := Set new.
	tests := OrderedCollectionEnu new.
	
	classes do: [ :aClass |
		classTests := (self forClass: aClass) tests.
		classTests do: [ :aTest | 
				testPrintString := aTest printString.
				(testMethods includes: testPrintString) ifFalse: [ 
					testMethods add: testPrintString.
					tests add: aTest ]]].
		
	suite := self named: aName.
	suite addTests: tests.
	
	^suite
		
! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50513728!
testNodesAdjacentTo

	| graph adjacentNodes |

	graph :=
		Graph edges: (
			OrderedCollectionEnu new
				add: (Edge from: 1 to: 2);
				add: (Edge from: 2 to: 3);
				add: (Edge from: 4 to: 5);
				add: (Edge from: 1 to: 6);
				add: (Edge from: 1 to: 7);
				yourself).

	adjacentNodes := #(2 6 7).

	self assert: (graph nodesAdjacentTo: 1) asOrderedCollection = adjacentNodes asOrderedCollection! !
!StringTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50568389!
testLineSeparators
	"
	Test that #newLineCharacter is considered a line separator and not a line terminator.
	This means that the last line never ends with a #newLineCharacter (although it might be empty!!)
	StringTest new testLineSeparators
	"
	| justAnLf linesBounds |
	linesBounds _ OrderedCollectionEnu new.
	justAnLf _ '
'.
	justAnLf lineIndicesDo: [ :start :endWithoutDelimiters :end |
		linesBounds add: { start . endWithoutDelimiters. end }.
		].

	self assert: linesBounds size = 2 description: 'There should be two lines.'.

	self assert: linesBounds first first = 1 description: 'First line starts at position 1'.
	self assert: linesBounds first second = (linesBounds first first-1) description: 'First line is empty'.
	self assert: linesBounds first third = (linesBounds first second+1) description: 'First line is terminated by ab Lf'.

	self assert: linesBounds second first = ( linesBounds first third+1) description: 'Second line starts after end of first line'.
	self assert: linesBounds second second = (linesBounds second first-1) description: 'Second line is empty'.
	self assert: linesBounds second third = (linesBounds second second+0) description: 'Second line is not terminated by ab Lf'.! !
!ChangeLog methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50646736 overrides: 16920235!
initialize
	changeDetectors := OrderedCollectionEnu new.
	
	changeDetectors add: self testRenamedDetector.
	changeDetectors add: self testClassRemovedDetector.
	changeDetectors add: self classRemovedDetector.
	changeDetectors add: self classRenamedDetector.
	changeDetectors add: self testRemovedDetector.
	changeDetectors add: self modelMethodRemovedDetector.
	changeDetectors add: self newProductionClassDetector.
	changeDetectors add: self newProductionMethodDetector.
	changeDetectors add: self newTestDetector.
	changeDetectors add: self newTestClassDetector.
	changeDetectors add: self productionMethodChangedDetector.
	changeDetectors add: self testChangedDetector.
	changeDetectors add: self testFailedDetector.
	changeDetectors add: self testPassedDetector.
	changeDetectors add: self testUtilityChangeDetector.
	changeDetectors add: self unknownChangeDetector.	! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16955164!
send: startUpOrShutDown toClassesNamedIn: startUpOrShutDownList with: argument
	"Send the message #startUp: or #shutDown: to each class named in the list.
	The argument indicates if the system is about to quit (for #shutDown:) or if
	the image is ia real startup (or just continue after image save) (for #startUp:).
	If any name cannot be found, then remove it from the list."

	| removals class |
	removals _ OrderedCollectionEnu new.
	startUpOrShutDownList do:
		[:name |
		class _ self at: name ifAbsent: nil.
		class
			ifNil: [removals add: name]
			ifNotNil: [
				class isInMemory ifTrue: [
					class perform: startUpOrShutDown with: argument]]].

	"Remove any obsolete entries, but after the iteration"
	"Well, not. Better just ignore them. Maybe it is stuff, like SoundPlayer, that was moved to optional packages, and can be loaded again anytime."
	"startUpOrShutDownList removeAll: removals"! !
!CollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50574526!
testGroupByReturnsADictionaryThatGroupsACollectionByThePluggableKey

	| collectionToGroupBy groupedByEven |
	
	collectionToGroupBy := OrderedCollectionEnu with: 1 with: 2 with: 3 with: 4 with: 5.
	groupedByEven := collectionToGroupBy groupBy: [ :anInteger | anInteger even ].
	
	self assert: groupedByEven size equals: 2.
	self assert: (collectionToGroupBy select: [ :anInteger | anInteger even ]) equals: (groupedByEven at: true).
	self assert:(collectionToGroupBy select: [ :anInteger | anInteger odd ]) equals: (groupedByEven at: false).! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16952835!
contributionsOf: aString
	"
	Smalltalk contributionsOf: 'JMV'
	"
	| author answer |
	answer _ OrderedCollectionEnu new.
	Smalltalk allBehaviorsDo: [ :behavior |
		behavior methodsDo: [ :compiledMethod |
			author _ compiledMethod author.
			aString = author ifTrue: [
				answer add: {compiledMethod methodClass. compiledMethod selector}]]].
	^answer! !
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16972377!
divideRectVertically: aRectangle by: aNumber

	| h y rects |
	
	y _ aRectangle origin y.
	h _ aRectangle height // aNumber.
	rects _ OrderedCollectionEnu new.
	
	aNumber timesRepeat: [ |rect|
		rect _ Rectangle origin: aRectangle origin x@y extent: aRectangle width@h.
		y _ y + h.
		rects add: rect].
	
	 ^ rects
	
	! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50598336!
simpleEnsureTestResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		add: self doSomethingElseString;
		add: self doYetAnotherThingString;
		yourself! !
!PackageInstaller methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50331990!
updatePackageList
	
	(PopUpMenu confirm: 'I need to scan for packages. This takes some time. Continue?')
		ifFalse: [^ OrderedCollectionEnu new].
	packageList _ OrderedCollectionEnu new.
	self collectPackagesFromDisk.
	packageList sort: [:p1 :p2 | p1 packageName < p2 packageName].
	PackageList _ packageList.
	self changed: #packageList.
	^ packageList! !
!InlineMethodApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50372426!
createMessageSends

	^OrderedCollectionEnu new.
! !
!TDDGuru methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50647015!
initializeChangeLog
	| fileStream changeList file changes |
	
	changeLog := OrderedCollectionEnu new.
	file := changesFile asFileEntry.
	
	file exists ifTrue: [
		fileStream := file readStream.
		changeList := (ChangeList new scanFile: fileStream from: changesFileStartPosition to: fileStream size) changeList.
		changes := changeList copyFrom: startingPoint to: changeList size.
		changeLog := ChangeLog from: changes using: inventory.
	]
	
	
	! !
!DefinedByRules methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50532340 overrides: 16823689!
species

	^OrderedCollectionEnu! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50366205!
chooseInstVarThenDo: aBlock
	"Put up a menu of all the instance variables in the receiver, and when
the user chooses one, evaluate aBlock with the chosen variable as its
parameter.  If the list is 6 or larger, then offer an alphabetical
formulation as an alternative. triggered by a 'show alphabetically' item
at the top of the list."

	| lines labelStream allVars index count offerAlpha |
	(count _ self allInstVarNames size) = 0 ifTrue: 
		[ ^ self inform: 'There are no\instance variables.' withNewLines ].

	allVars _ OrderedCollectionEnu new.
	lines _ OrderedCollectionEnu new.
	labelStream _ String writeStream.

	(offerAlpha _ count > 5)
		ifTrue: [
			lines add: 1.
			allVars add: 'show alphabetically'.
			labelStream nextPutAll: allVars first].
	self withAllSuperclasses reverseDo: [ :class | | vars |
		vars _ class instVarNames.
		vars do: [ :var |
			labelStream position = 0 ifFalse: [labelStream newLine].
			labelStream nextPutAll: var.
			allVars add: var].
		vars isEmpty ifFalse: [lines add: allVars size]].
	(lines notEmpty and: [ lines last = allVars size ]) ifTrue: [
		lines removeLast ].  "dispense with inelegant line beneath last item"
	index _ (PopUpMenu labels: labelStream contents lines: lines)
startUpWithCaption: 'Instance variables in
', self name.
	index = 0 ifTrue: [^ self].
	(index = 1 and: [offerAlpha]) ifTrue: [
		^ self chooseInstVarAlphabeticallyThenDo: aBlock].
	aBlock value: (allVars at: index)! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50366456!
case: dist
	"statements = keyStmts #CascadeFlag keyValueBlock ... keyStmts"

	| nextCase thenJump stmtStream elements b node cases otherBlock myExits |
	nextCase := pc + dist.

	"Now add #CascadeFlag & keyValueBlock to statements"
	statements addLast: stack removeLast.
	stack addLast: #CaseFlag. "set for next pop"
	statements addLast: (self blockForCaseTo: nextCase).

	stack last == #CaseFlag
		ifTrue: "Last case"
			["ensure jump is within block (in case thenExpr returns weirdly I guess)"
			stack removeLast. "get rid of #CaseFlag"
			stmtStream := (self popTo: stack removeLast) readStream.
			
			elements := OrderedCollectionEnu new.
			b := OrderedCollectionEnu new.
			[stmtStream atEnd] whileFalse:
				[(node := stmtStream next) == #CascadeFlag
					ifTrue:
						[elements addLast: (constructor
							codeMessage: (constructor codeBlock: b returns: false)
							selector: (constructor codeSelector: #-> code: #macro)
							arguments: (Array with: stmtStream next)).
						 b := OrderedCollectionEnu new]
					ifFalse: [b addLast: node]].
			b size > 0 ifTrue: [self error: 'Bad cases'].
			cases := constructor codeBrace: elements.
			
			"try find the end of the case"
			myExits := caseExits removeLast: elements size.
			myExits := myExits reject: [ :e | e isNil or: [ e < 0 or: [ e > method endPC ] ] ].
			thenJump := myExits isEmpty
							ifTrue: [ nextCase ]
							ifFalse: [ myExits max ].
			
			otherBlock := self blockTo: thenJump.
			stack addLast:
				(constructor
					codeMessage: stack removeLast
					selector: (constructor codeSelector: #caseOf:otherwise: code: #macro)
					arguments: (Array with: cases with: otherBlock))].! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50578440 overrides: 16961394!
setUp
	super setUp.
	collection := OrderedCollectionEnu new! !
!PathCurveToCommand methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50432004 overrides: 50431909!
buildFrom: commandChar stream: aStream

	| x1 y1 x2 y2 x y |
	super buildFrom: commandChar stream: aStream.
	toPoints _ OrderedCollectionEnu new.
	control1Points _ OrderedCollectionEnu new.
	control2Points _ OrderedCollectionEnu new.
	[
		x1 _ aStream nextNumber.
		y1 _ aStream nextNumber.
		x2 _ aStream nextNumber.
		y2 _ aStream nextNumber.
		x _ aStream nextNumber.
		y _ aStream nextNumber.
		y notNil ] whileTrue: [
			toPoints add: x@y.
			control1Points add: x1@y1.
			control2Points add: x2@y2 ]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16792482!
analyseArguments: methodArguments temporaries: methodTemporaries rootNode: rootNode "<MethodNode>" "^<Sequence of: <TempVarNade>>"
	"Top level entry-point for analysing temps within the hierarchy of blocks in the receiver's method.
	 Answer the (possibly modified) sequence of temp vars.
	 Need to hoist temps out of macro-optimized blocks into their actual blocks.
	 Need to note reads and writes to temps from blocks other than their actual blocks to determine
	 whether blocks can be local (simple slots within a block/method context) or remote (slots in
	 indirection vectors that are shared between contexts by sharing indirection vectors).

	 The algorithm is based on numbering temporary reads and writes and block extents.
	 The index used for numbering starts at zero and is incremented on every block entry
	 and block exit.  So the following
		| a b blk r1 r2 t |
		a := 1. b := 2. t := 0.
		blk := [ | s | s := a + b. t := t + s].
		r1 := blk value.
		b := -100.
		r2 := blk value.
		r1 -> r2 -> t
	is numbered as
		method block 0 to: 6:
		| a b blk r1 r2 t |
		a w@1 := 1. b w@1 := 2. t w@1 := 0.
		blk w@5 := [entry@2 | s |
					 t  w@3 := t r@3 + a r@3 + b r@3
					] exit@4.
		r1 w@5 := blk r@5 value.
		b w@5 := nil.
		r2 w@5 := blk r@5 value.
		r1 r@5 -> r2 r@5 -> t r@5
	So:
		b and blk cannot be copied because for both there exists a write @5 that follows a
			read @4 within block 2 through 4
		t must be remote because there exists a write @3 within block (2 to: 4)
	Complications are introduced by optimized blocks.  In the following temp is written to
	after it is closed over by [ temp ] since the inlined block is executed more than once.
		| temp coll |
		coll := OrderedCollection new.
		1 to: 5 do: [ :index | 
			temp := index. 
			coll add: [ temp ] ].
		self assert: (coll collect: [:ea| ea value]) asArray = #(5 5 5 5 5)
	In the following i is local to the block and must be initialized each time around the loop
	but if the block is inlined it must be declared at method level.
		| col |
		col := OrderedCollection new.
		1 to: 3 do: [ :each | | i | i := each. col add: [ i ]. i := i + 1 ].
		self assert: (col collect: [ :each | each value ]) asArray = #(2 3 4)"
	self assert: (arguments isEmpty or: [arguments hasEqualElements: methodArguments]).
	arguments := methodArguments asArray. "won't change"
	self assert: (temporaries isNil or: [temporaries isEmpty or: [temporaries hasEqualElements: methodTemporaries]]).
	temporaries := OrderedCollectionEnu withAll: methodTemporaries.

	self assert: optimized not. "the top-level block should not be optimized."
	self analyseTempsWithin: self rootNode: rootNode assignmentPools: Dictionary new.

	"The top-level block needs to reindex temporaries since analysis may have rearranged them.
	 This happens when temps are made remote and/or a remote node is added."
	temporaries withIndexDo:
		[:temp :offsetPlusOne| temp index: arguments size + offsetPlusOne - 1].

	"Answer the (possibly modified) sequence of temps."
	^temporaries asArray! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50626366!
errorsAndWarningsAsMethodReferencesWithProblems: showProblems
	
	| list |
	
	list := OrderedCollectionEnu new.
	self sortedTypeCheckers do: [ :aTypeChecker | 
		(aTypeChecker hasErrorsOrWarnings or: [ showProblems and: [ aTypeChecker hasProblems ]])
			ifTrue: [
				list add: aTypeChecker method.
				list addAll: (aTypeChecker errorsAndWarningsAsMethodReferencesWithProblems: showProblems prefixing: '  ') ]].
				
	^list! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16952205!
testDecompiler
	"
	Smalltalk testDecompiler
	"
	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."
	| methodNode oldMethod newMethod badOnes oldCodeString n |
	badOnes _ OrderedCollectionEnu new.
	'Decompiling all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldMethod _ cls compiledMethodAt: selector.
					oldCodeString _ (cls decompilerClass new
						decompile: selector
						in: cls
						method: oldMethod) decompileString.
					methodNode _ cls compilerClass new
						compile: oldCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod _ methodNode generate: #(0 0 0 0 ).
					oldCodeString =
						(cls decompilerClass new
							decompile: selector
							in: cls
							method: newMethod) decompileString ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: (MethodReference class: cls selector: selector) ]]]].
	Smalltalk
		browseMessageList: badOnes
		name: 'Decompiler Discrepancies'.! !
!WorldMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16982924!
deleteAllHalos
	| c |
	c _ OrderedCollectionEnu new.
	self haloMorphsDo: [ :halo | c add: halo ].
	self removeAllMorphsIn: c! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50637582!
definitionOf: aMetaclass

	^ String streamContents: [ :stream | | selector collaborators |
		stream
			nextPutAll: aMetaclass soleInstance name.
	
		"Done this way to support rename of #create:collarobatorNames:in: - Hernan"
		collaborators := OrderedCollectionEnu new.
		(aMetaclass soleInstance superclass is: #DenotativeObject) 
			ifTrue: [ 
				selector := #asChildOf:collaboratorNames:in:.
				collaborators add: aMetaclass soleInstance superclass name ]
			ifFalse: [ selector := #collaboratorNames:in: ].
			
		collaborators 
			add: '''', aMetaclass instanceVariablesString, '''';
			add: '''', aMetaclass category, ''''. 
									
		selector keywords withIndexDo: [ :keyword :index |
			stream
				newLine;
				tab;
				nextPutAll: keyword;
				space;
				nextPutAll: (collaborators at: index) ]]! !
!Form methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16861164!
asColorFormOfDepth: destDepth
	"
	Answer a ColorForm with a custom optimized palette of up to 256, 16 or 4 entries.
	self runningWorld backgroundImage asColorFormOfDepth: 8 :: display
	self runningWorld backgroundImage orderedDither32To16 asColorFormOfDepth: 8 :: display
	self runningWorld backgroundImage orderedDither32To16 asColorFormOfDepth: 4 :: display
	"
	| answer bitsPerColor clusterIndexToSplit clusterToSplit clusters colors desiredNumberOfClusters errors firstCluster map metricToSplitOn tally valueToSplitOn box hueWeightFactor brightnessWeightFactor saturationWeightFactor |
	self depth > 8 ifFalse: [
		^self error: 'Only for 16 bit and 32 bit Forms' ].
	desiredNumberOfClusters _ 1 bitShift: destDepth.

	"Wheights to balance error on each color metric"
	hueWeightFactor _ 8.0 / 360.0.
	saturationWeightFactor _ 1.0.
	brightnessWeightFactor _ 3.0.
	destDepth < 8 ifTrue: [
		brightnessWeightFactor _ 13.0.
		destDepth < 4 ifTrue: [
			hueWeightFactor _ 0.0.
			saturationWeightFactor _ 0.0. ]].
	"Assign all pixels to a single cluster"
	tally _ self tallyPixelValues.
	firstCluster _ OrderedCollectionEnu new.
	tally withIndexDo: [ :pixelCount :pixelValuePlusOne |
		pixelCount = 0 ifFalse: [ |c|
			c _ Color colorFromPixelValue: pixelValuePlusOne -1 depth: 16.
			firstCluster add: {c hue. c saturation. c brightness. pixelCount. pixelValuePlusOne } ]].
	clusters _ OrderedCollectionEnu with: firstCluster.

	"Pick the existing cluster with the largest error, and split it."
	[clusters size < desiredNumberOfClusters and: [ clusters anySatisfy: [:eachCluster | eachCluster size > 1]]] whileTrue: [ | cluster1 cluster2 |
		"Detect cluster with largest error, and split it"
		errors _ clusters collect: [ :eachCluster | | sum average error |
			sum _ (eachCluster sum: [ :e | {e first * e fourth. e second * e fourth. e third * e fourth. e fourth }]).
			average _ {sum first. sum second. sum third} / sum fourth.
			error _ eachCluster sum: [ :e | | hueError |
				hueError _ (e first - average first) abs. hueError > (360/2) ifTrue: [hueError _ 360 - hueError].
				{hueError * hueWeightFactor. (e second-average second) abs * saturationWeightFactor. (e third-average third) abs * brightnessWeightFactor} * e fourth ].
			{error max. error indexOfMax. average at: error indexOfMax} ].
		clusterIndexToSplit _ (errors collect: [ :e | e first]) indexOfMax.
		metricToSplitOn _ (errors at: clusterIndexToSplit) second.
		valueToSplitOn _ (errors at: clusterIndexToSplit) third.
		clusterToSplit _ clusters at: clusterIndexToSplit.
		cluster1 _ OrderedCollectionEnu new.
		cluster2 _ OrderedCollectionEnu new.
		clusterToSplit do: [ :pixelMetricsAndCount |
			(pixelMetricsAndCount at: metricToSplitOn) < valueToSplitOn
				ifTrue: [cluster1 add: pixelMetricsAndCount]
				ifFalse: [cluster2 add: pixelMetricsAndCount]].
		clusters at: clusterIndexToSplit put: cluster1.
		clusters add: cluster2.
	].

	colors _ clusters collect: [ :eachCluster | | sum average |
		average _ eachCluster average.
			sum _ (eachCluster sum: [ :a | {a first * a fourth. a second * a fourth. a third * a fourth. a fourth }]).
			average _ {sum first. sum second. sum third} / sum fourth.
		Color hue: average first saturation: average second brightness: average third ].
	answer _ ColorForm extent: self extent depth: destDepth.
	answer colors: colors.

	"Build colormap for displaying self on answer"
	bitsPerColor _ 5.				"To read 16bpp source"
	map _ Bitmap new: (1 bitShift: 3*bitsPerColor).
	clusters withIndexDo: [ :eachCluster :clusterIndex |
		eachCluster do: [ :pixMetrixsAndCount |
			map at: pixMetrixsAndCount fifth put: clusterIndex-1 ]].

	box _ self boundingBox.
	answer copyBits: box from: self at: 0@0 clippingBox: box rule: Form over map: map.
	^answer
! !
!Collection methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16823397!
groupBy: keyBlock 

	^ self 
		inject: Dictionary new
		into: [ :groupedCollection :elementToGroup | | group |
			group := groupedCollection at: (keyBlock value: elementToGroup) ifAbsentPut: [ OrderedCollectionEnu new ].
			group add: elementToGroup.
			groupedCollection ]
		! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16842234!
keysSortedSafely
	"Answer a sorted Collection containing the receiver's keys."
	| sortedKeys |
	sortedKeys _ OrderedCollectionEnu new: self size.
	self keysDo: [:each | sortedKeys addLast: each].
	sortedKeys sort:
		[ :x :y |  "Should really be use <obj, string, num> compareSafely..."
		((x isString and: [y isString])
			or: [x isNumber and: [y isNumber]])
			ifTrue: [x < y]
			ifFalse: [x class == y class
				ifTrue: [x printString < y printString]
				ifFalse: [x class name < y class name]]].
	^ sortedKeys! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50577753!
testInlineBlockCollectionLR1
	"Test case from Lukas Renggli"
	| col |
	col := OrderedCollectionEnu new.
	1 to: 11 do: [ :each | col add: [ each ] ].
	self assert: (col collect: [ :each | each value ]) asArray = (1 to: 11) asArray! !
!MinusInfinity methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50525823 overrides: 50524008!
composeWithSimpleMeasure: aMeasure

	^CompoundMeasure measures: (OrderedCollectionEnu with: self with: aMeasure)! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50626382!
errorsAsMethodReferences
	
	| list |
	
	list := OrderedCollectionEnu new.
	self sortedTypeCheckers do: [ :aTypeChecker | 
		aTypeChecker hasErrors ifTrue: [
			list add: aTypeChecker method.
			list addAll: (aTypeChecker errorsAsMethodReferencesPrefixing: '  ')
			"list addAll: aTypeChecker errorsAsMethodReferences"]].
			
	^list! !
!MirrorPrimitiveTests methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50579082!
testMirrorPerform
	| stackpBefore stackpAfter anInterval |

	Smalltalk isRunningCog ifFalse: [
		^self assert: false description: 'Needs Cog' ].

	stackpBefore := thisContext stackPtr.
	anInterval := 1 to: 2.
	self assert: (thisContext object: anInterval perform:# species withArguments: #() inClass: Interval) == Array.
	self assert: (thisContext object: anInterval perform:# species withArguments: #() inClass: Interval superclass) == Interval.
	self should: [thisContext object: anInterval perform:# species withArguments: #() inClass: Point]
		raise: Error.
	self should: [thisContext object: anInterval perform:# species withArguments: OrderedCollectionEnu new inClass: Interval]
		raise: Error.
	stackpAfter := thisContext stackPtr.
	self assert: stackpBefore = stackpAfter "Make sure primitives pop all their arguments"! !
!UnicodeString methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50454899!
basicCanonicalComposition
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	See examples at #canonicalComposition.
	(UnicodeString fromCodePoints: #(119128 119141)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119135 119151)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119128 119141 119151)) basicCanonicalComposition asCodePoints
	"
	| byteIndex stopByteIndex n combining cls |
	byteIndex _ 1.
	stopByteIndex _ bytes size.
	combining _ OrderedCollectionEnu new.
	^UnicodeString streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			n _ Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				cls _ UnicodeCodePoint combiningClass: codePoint.
				cls = 0 ifTrue: [
					self basicCompose: combining on: strm.
					combining _ OrderedCollectionEnu new ].
				combining add: codePoint ].
			byteIndex _ byteIndex + n ].
		self basicCompose: combining on: strm ].! !
!CodePackageListWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16820320!
addRequirement
	"Ask user for a FeatureRequirement based on loaded packages"
	
	| current currentName packageNames reqiredNames selectionNames choices selection cuisBaseName req selectedName |
	current _ model selection.
	current ifNil: [ ^self ].

	packageNames := model packages collect: [ :pak | pak packageName ].
	currentName := current packageName.
	reqiredNames := current requires collect: [ :r | r name ].
	selectionNames := packageNames select: [ :name |
		((name = currentName) or: [reqiredNames includes: name]) not ].
	cuisBaseName := Feature baseSystemFeature name.
	choices := OrderedCollectionEnu with: #CANCEL.
	(reqiredNames includes: cuisBaseName)
		ifFalse: [ choices add: cuisBaseName ].		
	choices addAll: selectionNames.
	choices size = 1 ifTrue: [
		^ PopUpMenu inform: 'All loaded packages are already required, as is Cuis base system' ].
	selection := PopUpMenu
		withCaption: 'Choose package to require' 
		chooseFrom: choices.
	selection <= 1
		ifTrue: [ ^ self ]  "1 -> Cance, 0 -> Clicked outside the menu"
		ifFalse: [
			selectedName := choices at: selection.
			req := (selectedName = cuisBaseName)
				ifTrue: [ Feature baseSystemFeature requirementOfMe ]
				ifFalse: [ (CodePackage installedPackages at: selectedName) requirementOfMe].
			current featureSpec requires: req.
			current hasUnsavedChanges: true.
			self changed: #requirement ]! !
!ExtractMethodReplacementsFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16852177 overrides: 16902254!
value

	sourceCodeToExtract := sourceMethod sourceCode copyFrom: intervalToExtract first to: intervalToExtract last.
	sizeToExtract := intervalToExtract size - 1.
	replacements := OrderedCollectionEnu new.
	
	sourceMethod methodClass withAllSubclassesDo: [ :aClass | self findReplacementsAt: aClass]
	 ! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50598328!
signalFromHandlerActionTestResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		add: 'Unhandled Exception';
		yourself! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50605355!
test43ReplacesMultipleAssignmentsInMultipleMethodsWithNullObject

	| definitions sourceWithAssignment refactoredMethod expectedSource nextLine firstRightSide secondRightSide aClassToRefactor refactoring replacementParameters |

	nextLine := String newLineString, String tab.
	aClassToRefactor := self defaultClassToRefactor.
	replacementParameters := OrderedCollectionEnu new.
	(1 to: 2) do: [:i | | ifMessageNode methodNode selector |
		selector := (self methodToRefactorSelector asString, i asString) asSymbol.
		sourceWithAssignment := selector asString, nextLine, self defaultInstVarName, ' ifNil: [1+1. 2+2].'.
		firstRightSide := 'self doSomething'.
		sourceWithAssignment := sourceWithAssignment, nextLine, self defaultInstVarName, ' := ', firstRightSide,'.'.
		secondRightSide := 'self doSomething +  ivar different'.
		sourceWithAssignment := sourceWithAssignment, nextLine, self defaultInstVarName, ' := ', secondRightSide, '.'.
		definitions := VariablesToParametrizeKeywordsDefinitions withSelector: #unaryPolymorphicSelector.
		aClassToRefactor compile: sourceWithAssignment.
		methodNode := (aClassToRefactor compiledMethodAt: selector) methodNode.
		ifMessageNode :=  methodNode block statements first.

		replacementParameters add: (
			ReplaceIfNilWithPolymorphismParameters
				forIfNilMessageSending: ifMessageNode
				onMethod: methodNode
				useKeywordsDefinitions: definitions)].

	refactoring := IntroduceNullObject
		on: self defaultInstVarName
		of: aClassToRefactor
		usingAsConcreteClass: self concreteClass
		usingAsNullClass: self nullClass
		for: replacementParameters.

	refactoring apply.

	(1 to: 2) do: [:i | | selector |	
		selector := (self methodToRefactorSelector asString, i asString) asSymbol.
		refactoredMethod := self defaultClassToRefactor compiledMethodAt: selector.
		expectedSource := selector asString, nextLine, self defaultInstVarName, ' unaryPolymorphicSelector.'.
		expectedSource := expectedSource, nextLine, 'self assignNullObjectIfNil: (', firstRightSide, ').'.
		expectedSource := expectedSource, nextLine, 'self assignNullObjectIfNil: (', secondRightSide withBlanksCondensed , ').'.
		self assert: expectedSource equals: refactoredMethod sourceCode].! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16801765!
currentVersionsOfSelections
	"Opens a message-list browser on the current in-memory versions of all methods that are currently seleted"
	| aList |

	aList _ OrderedCollectionEnu new.
	1 to: changeList size do: [ :i |
		(listSelections at: i) ifTrue: [
			| aClass aChange |
			aChange _ changeList at: i.
			(aChange changeType == #method
				and: [(aClass _ aChange changeClass) notNil
				and: [aClass includesSelector: aChange methodSelector]])
					ifTrue: [
						aList add: (MethodReference
							class: aClass
							selector: aChange methodSelector)]]].
	^ aList! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16942056!
conversionMethodsFor: classList
	| oldStruct newStruct list |
	"Each of these needs a conversion method.  Hard part is the comment in it.  Return a MessageSet."

	list _ OrderedCollectionEnu new.
	classList do: [:cls |
		oldStruct _ structures at: cls name ifAbsent: [#()].
		newStruct _ (Array with: cls classVersion), (cls allInstVarNames).
		self writeConversionMethodIn: cls fromInstVars: oldStruct to: newStruct 
				renamedFrom: nil.
		list add: cls name, ' convertToCurrentVersion:refStream:'.
		].

	^ MessageSet new initializeMessageList: list.! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16891090!
defaultQueue
	defaultQueue ifNil: [defaultQueue _ OrderedCollectionEnu new].
	^ defaultQueue! !
!SystemDictionary class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16958615 overrides: 16904184!
initialize
	"
	SystemDictionary initialize
	"
	
	"Hacer esto bien explicito al menos para las clases en la imagen base?
	Quisiera un mecanismo que sea igual de bueno para clases base que para clases en paquetes.
	Excepto para MUY pocas cosas quizas, como la 1ra parte de StartUpList... El resto deberia usar el mismo esquema
	este en la imagen base o en paquetes. Y seria quizas onda initialize.
	O sea, quizas al cargar un paquete deberia llamarse initialize y startup, no se.
	Como que initialize es cuando se crea la clase (o en cualquier momento que quieras reinicializar)
	y startUp se ejecuta TAMBIEN cuando levanta la imagen.
	Como initialize clashea con las instancias, quizas uniformar todo en startUp: y shutDown: / startUp y shutDown .... 
	
	Cargar todos los paquetes. estudiar implementors y senders de startUp: y shutDown: / startUp y shutDown
	ver senders de addToStartUpList: y addToShutDownList:"

	StartUpList _ OrderedCollectionEnu new.
	"These get processed from the top down..."
	#(
		#Delay
		#DisplayScreen
		#Cursor
		#InputSensor
		#ProcessorScheduler 	"Starts low space watcher and bkground."
		#WeakArray)
			do: [ :clsName | 	
				Smalltalk at: clsName ifPresent: [:cls | Smalltalk addToStartUpList: cls]].
			
	ShutDownList _ OrderedCollectionEnu new.
	"These get processed from the bottom up..."
	#(
		#Delay
		#DisplayScreen
		#InputSensor
		#Symbol
		#ProcessBrowser
		#CPUWatcher)
			do: [ :clsName | 
				Smalltalk at: clsName ifPresent: [:cls | Smalltalk addToShutDownList: cls]]! !
!IsKindOfManyTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50626031 overrides: 50625983!
buildCastApplierBefore: aPreviousCastingApplier 

	^EffectiveTypeCastApplier 
		casts: (OrderedCollectionEnu with: self buildTypeCast)
		rejections: OrderedCollectionEnu new
		previous: aPreviousCastingApplier! !
!InlineMethodApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50372764 overrides: 16923927!
value

	requestExitBlock := [ ^self ].

	self requestRefactoringParametersHandlingRefactoringExceptions.

	self
		ifHasNoUsagesAndOneImplementor: [ :anImplementor |
			shouldRemoveImplementor ifFalse: [self askIfImplementorShouldBeRemovedWhenNoSenders ]. "Give the user another chance to delete the message"
			shouldRemoveImplementor ifFalse: [^self].
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor
		]
		ifNot: [
			self askScope.
			shouldInlineTriggeringMessageSendOnly ifTrue: [
				messageSends := OrderedCollectionEnu new.
				messageSends add: triggeringMessageSend.
				^self askForImplementorsOnly
			].
			self shouldAskForImplementors ifFalse: [implementors := IdentitySet with: (selectedClass >> selectorToInline). ^self askForMessagesToInlineOnly].
			self askForImplementorsAndMessageSends.
	]! !
!ChangeSelectorKeepingParameters class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16804394!
from: anOldSelector to: aNewSelector inSystem: aSystem

	| implementors senders |

	implementors := OrderedCollectionEnu new.
	senders := OrderedCollectionEnu new.

	self 
		addImplementorsOf: anOldSelector 
		to: implementors 
		andSendersTo: senders 
		inSystem: aSystem.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: (self collectCompiledMethodsOf: senders)
	! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16805718!
askRemovedInstVars: classList
	| pairList pairClasses index pls |
	"Ask the author whether these newly removed inst vars need to have their info saved"

	pairList _ OrderedCollectionEnu new.
	pairClasses _ OrderedCollectionEnu new.
	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."
	classList do: [ :cls |
		| newStruct oldStruct |
		newStruct _ (cls allInstVarNames).
		oldStruct _ (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.
		oldStruct do: [:instVarName |
			(newStruct includes: instVarName) ifFalse: [
				pairList add: cls name, ' ', instVarName.
				pairClasses add: cls]]].

	pairList isEmpty ifTrue: [^ #()].
	[
		index _ PopUpMenu withCaption: 'These instance variables were removed.
When an old project comes in, instance variables 
that have been removed will lose their contents.
Click on items to remove them from the list.
Click on any whose value is unimportant and need not be saved.'
			chooseFrom: pairList, #('all of these need a conversion method'
						'all of these have old values that can be erased').
		(index <= (pls _ pairList size)) & (index > 0) ifTrue: [
			pairList removeAt: index.
			pairClasses removeAt: index].
		index = (pls + 2) ifTrue: ["all are OK" ^ #()].
		pairList isEmpty | (index = (pls + 1))  "all need conversion, exit"] whileFalse.

	^ pairClasses asSet asArray	"non redundant"! !
!CollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50574509!
testGroupByHavingSelectsTheResultOfGroupBy

	| collectionToGroupBy groupedByEven |
	
	collectionToGroupBy := OrderedCollectionEnu with: 1 with: 2 with: 3 with: 4 with: 5.
	groupedByEven := collectionToGroupBy groupBy: [ :anInteger | anInteger even ] having: [ :group | group size > 2 ].
	
	self assert: (groupedByEven size) equals: 1.	
	self assert: (collectionToGroupBy select: [ :anInteger | anInteger odd ]) equals: (groupedByEven at: false).! !
!OrderedDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16905765 overrides: 16935795!
init: n

	super init: n.
	orderedKeys _ OrderedCollectionEnu new: n! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 50342299!
obsoleteClasses   "Smalltalk obsoleteClasses inspect"
	"NOTE:  Also try inspecting comments below"
	| obs c |
	obs _ OrderedCollectionEnu new.  Smalltalk garbageCollect.
	Metaclass allInstancesDo:
		[:m | c _ m soleInstance.
		(c notNil and: ['AnOb*' match: c name asPlainString])
			ifTrue: [obs add: c]].
	^ obs asArray

"Likely in a ClassDict or Pool...
(Association allInstances select: [:a | (a value isKindOf: Class) and: ['AnOb*' match: a value name]]) asArray
"
"Obsolete class refs or super pointer in last lit of a method...
| n l found |
Smalltalk browseAllSelect:
	[:m | found _ false.
	1 to: m numLiterals do:
		[:i | (((l _ m literalAt: i) isMemberOf: Association)
				and: [(l value isKindOf: Behavior)
				and: ['AnOb*' match: l value name]])
			ifTrue: [found _ true]].
	found]
"! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:23' prior: 16785749!
allSuperclassesUpTo: aSuperclass
	
	| superclasses |
	
	^ superclass = aSuperclass
		ifTrue: [ OrderedCollectionEnu with: aSuperclass]
		ifFalse: [superclasses _ superclass allSuperclassesUpTo: aSuperclass.
			superclasses addFirst: superclass.
			superclasses]! !
!DecompilerConstructor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16841306!
codeMethod: selector block: block tempVars: vars primitive: primitive class: class

	| blockNode selectorNode visibleTemps invisibleTemps arguments temporaries properties |
	selectorNode := self codeSelector: selector code: nil.
	tempVars := vars.
	visibleTemps := OrderedCollectionEnu new.
	invisibleTemps := OrderedCollectionEnu new.
	tempVars do: [:t|
				   ((t isIndirectTempVector or: [t scope >= 0])
						ifTrue: [visibleTemps]
						ifFalse: [invisibleTemps]) addLast: t].
	arguments := visibleTemps copyFrom: 1 to: nArgs.
	temporaries := visibleTemps copyFrom: nArgs + 1 to: visibleTemps size.
	block
		arguments: arguments;
		temporaries: temporaries.
	properties := method properties copy.
	(properties at: #onceCache ifAbsent: []) ifNotNil:
		[:onceCache|
		 properties := properties copyWithout: (Association
													key: #onceCache
													value: onceCache)].
	blockNode := MethodNode new
		selector: selectorNode
		arguments: arguments
		precedence: selector precedence
		temporaries: temporaries
		block: block
		encoder: (method encoderClass new initScopeAndLiteralTables
					temps: visibleTemps, invisibleTemps
					literals: literalValues
					class: class)
		primitive: primitive
		properties: properties.
	blockNode properties method: blockNode.
	^blockNode! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16813962!
methodCategories

	| categories |
	
	categories := OrderedCollectionEnu withAll: self organization categories.
	categories remove: ClassOrganizer nullCategory asSymbol ifAbsent: nil.
	
	^categories ! !
!Symbol class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50378964!
selectorsContaining: aString
	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."

	| size selectorList ascii |

	selectorList _ OrderedCollectionEnu new.
	(size _ aString size) = 0 ifTrue: [^selectorList].

	aString size = 1 ifTrue: [
		ascii _ aString first numericValue.
		ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]].

	aString first isValidInIdentifiers ifFalse: [
		aString size = 2 ifTrue: [
			Symbol hasInterned: aString ifTrue: [ :s | selectorList add: s]].
		^selectorList ].

	selectorList _ selectorList copyFrom: 2 to: selectorList size.

	self allSymbolTablesDo: [ :each |
		each size >= size ifTrue: [
			(each findString: aString startingAt: 1 caseSensitive: false) > 0
				ifTrue: [selectorList add: each]]].

	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"
		each numArgs < 0 and: [each asPlainString uncapitalized numArgs < 0]].

"Symbol selectorsContaining: 'scon'"! !
!CodeCoverageTextStyler methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50552864!
consolidate: sourceRanges using: sourceCode

	"Try to close the gaps between source ranges in sourceRanges to highlight source code without
	interruptions as much as possible.
	
	TODO(NPM): this is a hack, and it is done here to make highlighted code look better. It can probably be
	solved better when compiled methods are traced."

	^ (sourceRanges asSortedCollection: [ :sourceRange :otherSourceRange |  sourceRange first < otherSourceRange first ])
		inject: OrderedCollectionEnu new
		into: [ :consolidatedSourceRanges :sourceRage |
			self consolidate: sourceRage in: consolidatedSourceRanges using: sourceCode.
			consolidatedSourceRanges ]! !
!Graph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50526688!
initializeEdges: aCollectionOfEdges nodes: aCollectionOfNodes

	edges := OrderedCollectionEnu withAll: aCollectionOfEdges.
	nodes := aCollectionOfNodes asSet
	
! !
!Class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50475857!
declareSharedPools: sharedPoolNames
	"Set up sharedPools. Answer whether recompilation is advisable."
	| oldPools |
	oldPools := self sharedPools.
	sharedPools := OrderedCollectionEnu new.
	sharedPoolNames do: [ :poolName | 
		sharedPools add: (Smalltalk at: poolName asSymbol ifAbsent: [
			(PoolDefinitionNotification signalNamed: poolName)
				ifTrue: [ Smalltalk at: poolName asSymbol put: Dictionary new ]
				ifFalse: [^self error: poolName,' does not exist']])].
	sharedPools isEmpty ifTrue: [ sharedPools := nil ].
	^oldPools anySatisfy: [ :pool |
		self sharedPools noneSatisfy: [ :p | p == pool ]].! !
!GraphPathFinderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50513391!
testPathToFarAwayPlaces

	| path |

	path := finder pathFrom: 1 to: 3.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 2 to: 3))).

	path := finder pathFrom: 1 to: 4.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 2 to: 3)
		with: (Edge from: 3 to: 4))).
	
	path := finder pathFrom: 2 to: 4.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 2 to: 3)
		with: (Edge from: 3 to: 4)))! !
!PlusInfinity methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50526198 overrides: 50524003!
composeWithNumber: aNumber

	^CompoundMeasure measures: (OrderedCollectionEnu with: self with: aNumber)! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16920521!
hierarchyForClass: aClass
	"Set the class hierarchy for the list pane"
	| tab |

	selectiveClassList _ OrderedCollectionEnu new.
	tab _ ''.
	aClass withAllSuperclasses reverse do: [:ea | 
		selectiveClassList add: tab , ea name.
		tab _ tab , '  '].
	self classListIndex: 0! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16847301!
positionsOfLiteralArraysContaining: aSymbol

	| positions |

	positions := OrderedCollectionEnu new.
	litSet keysAndValuesDo: [ :aLiteral :aLiteralNode |
		(aLiteral isArray and: [ aLiteral hasLiteral: aSymbol ]) ifTrue: [ positions addAll: (sourceRanges at: aLiteralNode) ]].

	^positions ! !
!CodeFileBrowserWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50494406!
codeFileListMenu
	| aMenu itemColl |
	self flag: #assumesKeyboardShortcuts.
	aMenu := MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Code File'.
	itemColl := OrderedCollectionEnu new.
	itemColl addAll:
		{
			{#label -> 'find class... (f)'. #selector -> #findClass} asDictionary. 
			nil
		}.
	self model baseCodeSource isLiveSmalltalkImage ifTrue: [
		itemColl add:
			{#label -> 'fileIn'. #object -> #model. #selector -> #fileIn} asDictionary ].
	itemColl add:
		{#label -> 'fileOut'. #object -> #model. #selector -> #fileOut} asDictionary.
	self model caseCodeSource isLiveSmalltalkImage ifFalse: [
		itemColl add:
			{#label -> 'remove existing'. #object -> #model. #selector -> #removeUnmodifiedClasses} asDictionary ].
	aMenu addItemsFromDictionaries: itemColl.
	^ aMenu.! !
!Collection methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16823015!
asOrderedCollection
	"Answer an OrderedCollection whose elements are the elements of the
	receiver. The order in which elements are added depends on the order
	in which the receiver enumerates its elements. In the case of unordered
	collections, the ordering is not necessarily the same for multiple 
	requests for the conversion."

	^ self as: OrderedCollectionEnu! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16785864!
allSelectors
	"Answer all selectors understood by instances of the receiver"

	| coll |
	coll _ OrderedCollectionEnu new.
	self withAllSuperclasses do:
		[:aClass | coll addAll: aClass selectors].
	^ coll asIdentitySet! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16891146!
queueFor: aSymbol
	aSymbol ifNil: [^ self defaultQueue].
	^ self queueDict 
		at: aSymbol 
		ifAbsent: [self queueDict at: aSymbol put: OrderedCollectionEnu new].! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16805279!
methodsWithoutClassifications
	"Return a collection representing methods in the receiver which have not been categorized"

	| slips notClassified |

	notClassified _ {'as yet unclassified' asSymbol. #all}.
	slips _ OrderedCollectionEnu new.
	self changedClasses do: [ :aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | aSelector |
			(aClass selectors includes:  (aSelector _ mAssoc key)) ifTrue: [
				(notClassified includes: (aClass organization categoryOfElement: aSelector))
					ifTrue: [slips add: aClass name , ' ' , aSelector]]]].
	^ slips

	"
	Smalltalk browseMessageList: (ChangeSet changeSetForBaseSystem methodsWithoutClassifications) name: 'unclassified methods'
	"! !
!ChangeSelectorKeepingParameters class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16804378!
from: anOldSelector to: aNewSelector inHierarchyOf: aClass

	| implementors senders |

	implementors := OrderedCollectionEnu new.
	senders := OrderedCollectionEnu new.
	
	self 
		addImplementorsOf: anOldSelector 
		to: implementors 
		andSendersTo: senders 
		inHierarchyOf: aClass.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: (self collectCompiledMethodsOf: senders)

	! !
!SHParserST80 methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16929151!
pushTemporary: aString 
	(temporaries at: blockDepth ifAbsentPut: [OrderedCollectionEnu new: 10]) 
		add: aString! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16815130!
allInstVarNamesEverywhere
	"Answer the set of inst var names used by the receiver, all superclasses, and all subclasses"

	| aList |
	aList _ OrderedCollectionEnu new.
	(self allSuperclasses , self withAllSubclasses asOrderedCollection) do:
		[:cls | aList addAll: cls instVarNames].
	^ aList asSet

	"BoxedMorph allInstVarNamesEverywhere"! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16785723!
allSuperclasses
	"Answer an OrderedCollection of the receiver's and the receiver's  
	ancestor's superclasses. The first element is the receiver's immediate  
	superclass, followed by its superclass and subsequent superclasses,
	and proceeding as long as there is a non-nil superclass."

	| answer pivot |
	answer := OrderedCollectionEnu new.
	pivot := superclass.
	[pivot == nil] whileFalse:
		[
			answer add: pivot.
			pivot := pivot superclass
		].
	^answer! !
!TTFontDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50498702!
glyphsByUtf8Bytes: glyphsByUTF8 unknownGlyph: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs

	| mGlyph |
	
	mGlyph := glyphsByUTF8 at: $M asciiValue + 1.
	letterMTopSideBearing := (mGlyph ifNil: [theUnknownGlyph]) topSideBearing.

	contourDataIndexesByUtf8 := (IntegerArray new: 256) as: OrderedCollectionEnu.
	contourDataForUtf8 := Float32Array streamContents: [ :stream |
		theUnknownGlyph addGlyphDataTo: stream tx: nil.		"First data is for unknownGlyph"	
		self fullName, ' - Processing glyph data' 
			displayProgressAt: 100@100
			from: 1 
			to: glyphsByUTF8 size 
			during: [ :bar |
				self appendGlyphDataTo: stream glyphsArray: glyphsByUTF8 indexes: contourDataIndexesByUtf8
					base: 0 bar: bar unknown: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs ]].
	contourDataIndexesByUtf8 := contourDataIndexesByUtf8 as: IntegerArray.! !
!FileList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16855869!
updateFileList
	"Update my files list with file names in the current directory  
	that match the pattern.
	The pattern string may have embedded newlines or semicolons; these separate different patterns."
	| patterns patternsThatReject patternsThatSelect |
	patterns _ OrderedCollectionEnu new.
	(pattern findTokens: (String with: Character cr with: Character lf with: $;))
		do: [ :each |
			(each includes: $*) | (each includes: $?)
				ifTrue: [ patterns add: (each copyReplaceAll: '?' with: '#')]
				ifFalse: [
					each isEmpty
						ifTrue: [ patterns add: '*']
						ifFalse: [ patterns add: '*' , each , '*']]].
	"A pattern that starts with $/ is used to reject entries
	Rejecting patterns are applied after selecting patterns."
	patternsThatSelect _ patterns reject: [ :any | any first = $/ ].
	patternsThatSelect isEmpty ifTrue: [ patternsThatSelect add: '*' ]. 
	patternsThatReject _ patterns select: [ :any | any first = $/ ] thenCollect: [ :each | each copyFrom: 2 to: each size ].
	list _ self listForSelectingPatterns: patternsThatSelect rejectingPatterns: patternsThatReject.
	listIndex _ 0.
	fileName _ nil.
	acceptedContentsCache _ ''.
	self changed: #fileList.
	self triggerEvent: #updateButtonRow! !
!DynamicMenuBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50408923!
collectMenuOptions

	itemsDefinition := OrderedCollectionEnu new.
	self classesProvidingMenuOptions do: [ :aClass | itemsDefinition addAll: (aClass soleInstance perform: menuDefinitionSelector) ].
	! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50598184!
simpleRetryTestResults

	^OrderedCollectionEnu new
			add: self doSomethingString;
			add: self doYetAnotherThingString;
			add: self doSomethingString;
			add: self doSomethingElseString;
			yourself! !
!MonitorTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50570661!
testExample2
	"Here is a second version that does not use a semaphore to inform the 
	forking process about termination of both forked processes"

	| producer1 producer2  monitor goal work counter goalReached activeProducers|
	goal := (1 to: 1000) asOrderedCollection.
	work := OrderedCollectionEnu new.
	counter := 0.
	goalReached := false.
	activeProducers := 0.
	monitor := Monitor new.

  producer1 :=
      [ monitor critical: [activeProducers := activeProducers + 1].
  [monitor critical:
            [monitor waitUntil: [counter \\5 = 0].
      goalReached or: [work add: (counter := counter + 1)].
     " Transcript show: 'P1  '; show: counter printString; show: '  ';
       show: activeProducers printString; cr."
      goalReached := counter >= goal size.
      monitor signal
            ].
           goalReached
          ]
             whileFalse.
         monitor critical: [activeProducers := activeProducers - 1.
        monitor signal: #finish].
 ] .

 producer2 :=
    [monitor critical: [activeProducers := activeProducers + 1].

  [monitor critical:
          [monitor waitWhile: [counter \\5 = 0].
    goalReached or: [work add: (counter := counter + 1)].
    goalReached := counter >= goal size.
    monitor signal].
         goalReached ] whileFalse.
     monitor critical: [
		activeProducers := activeProducers - 1. 
		monitor signal: #finish].
	].

	producer1 forkAt: Processor userBackgroundPriority.
	producer2  forkAt: Processor userBackgroundPriority.


	monitor critical: [
		monitor waitUntil: [activeProducers = 0 & (goalReached)]
				for: #finish.
  	].

	self assert: goal = work
! !
!ExtractMethodParametersDetector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50502494 overrides: 16902254!
value

	| parseNodesFound |
	
	parseNodesFound := OrderedCollectionEnu new.
	methodNodeToRefactor completeSourceRangesDo: [ :parseNode :sourceRanges |
		(self shouldBeParameterized: parseNode appearingIn: sourceRanges)
			ifTrue: [ parseNodesFound add: parseNode ]].
		
	^ parseNodesFound! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50598202!
simpleReturnTestResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		yourself! !
!Finder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50545055!
initializeResults
	
	currentQuery := ''.
	results := OrderedCollectionEnu new.
	selectedResultIndex := 0.! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50472168!
browseAllStoresInto: instVarName from: aClass
	"Create and schedule a Message Set browser for all the receiver's methods
	or any methods of a subclass/superclass that refer to the instance variable name."

	"self new browseAllStoresInto: 'contents' from: Collection."

	| coll |
	coll := OrderedCollectionEnu new.
	aClass withAllSubAndSuperclassesDo: [:class |
		(class whichSelectorsStoreInto: instVarName) do: [:sel |
			coll add: (MethodReference class: class selector: sel)]].
	^ self
		browseMessageList: coll
		name: 'Stores into ' , instVarName
		autoHighlight: instVarName
		allOccurrences: true! !
!Finder class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50545129!
availableCatalogs

	^ OrderedCollectionEnu new
		add: Catalog classNames;
		add: Catalog implementors;
		add: Catalog implementedSelectors;
		add: Catalog senders;
		add: Catalog systemCategories;
		add: Catalog tools;
		yourself! !
!ChangeSelectorKeepingParameters class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16804360!
from: anOldSelector to: aNewSelector inCategoryOf: aClass organizedBy: anOrganization

	| implementors senders |

	implementors := OrderedCollectionEnu new.
	senders := OrderedCollectionEnu new.

	self 
		addImplementorsOf: anOldSelector 
		to: implementors 
		andSendersTo: senders
		inCategory: aClass category 
		organizedBy: anOrganization.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: (self collectCompiledMethodsOf: senders)
! !
!RenameSelectorWithActualScopeApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50622027 overrides: 16803828!
createSenders

	^OrderedCollectionEnu new.
! !
!ChangeListWithFileInErrors methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16803128!
removeSucessfullyFiledInChanges

	| newChangeList newList |

	newChangeList := OrderedCollectionEnu new.
	newList := OrderedCollectionEnu new.

	changeList withIndexDo: [ :aChange :anIndex | self ifFiledInWithErrorAdd: aChange at: anIndex to: newChangeList and: newList ].
			
	changeList _ newChangeList.
	list _ newList.
	listIndex _ 0.
	self clearSelections.
	self changed: #list.! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50598311!
nonResumableFallOffTheEndHandlerResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		add: self doSomethingExceptionalString;
		add: self doYetAnotherThingString;
		yourself! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50534913!
testRulesThatIncludeADate

	| timeLineFilter rule1 rule2 rule3 september14Of2005 september15Of2005 september16Of2005 |

	september14Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 14.
	september15Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 15.
	september16Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 16.
	timeLineFilter := TimeLineFilter new.
	rule1 := timeLineFilter dateRule: september14Of2005.
	rule2 := timeLineFilter dateRule: september15Of2005.
	rule3 := timeLineFilter dateRule: september16Of2005.

	timeLineFilter addRules: (OrderedCollectionEnu with: rule1 with: rule2 with: rule3).

	self assert: (timeLineFilter rulesThatInclude: september14Of2005) = (OrderedCollectionEnu with: rule1).
	self deny: (timeLineFilter rulesThatInclude: september15Of2005) = (OrderedCollectionEnu with: rule1).
	self deny: (timeLineFilter rulesThatInclude: september16Of2005) = (OrderedCollectionEnu with: rule1).
	
	self deny: (timeLineFilter rulesThatInclude: september14Of2005) = (OrderedCollectionEnu with: rule2).
	self assert: (timeLineFilter rulesThatInclude: september15Of2005) = (OrderedCollectionEnu with: rule2).
	self deny: (timeLineFilter rulesThatInclude: september16Of2005) = (OrderedCollectionEnu with: rule2).
	
	self deny: (timeLineFilter rulesThatInclude: september14Of2005) = (OrderedCollectionEnu with: rule3).
	self deny: (timeLineFilter rulesThatInclude: september15Of2005) = (OrderedCollectionEnu with: rule3).
	self assert: (timeLineFilter rulesThatInclude: september16Of2005) = (OrderedCollectionEnu with: rule3)! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16954184!
allUnimplementedCalls
	"Answer an Array of each message that is sent by an expression in a 
	method but is not implemented by any object in the system."

	| aStream all  selectors |
	all _ self allImplementedMessages.
	aStream _ WriteStream on: (Array new: 50).
	self allBehaviorsDo: [ :cl |
		 cl selectorsDo: [ :sel |
			selectors _ OrderedCollectionEnu new.
			(cl compiledMethodAt: sel) messages do: [ :m |
				(all includes: m) ifFalse: [selectors add: m ]].
			selectors notEmpty ifTrue: [
				aStream nextPut: (MethodReference class: cl selector: sel).
				(cl name , '>>#' , sel , (String new: (70-sel size * 15//10 max: 0) withAll: $ ), ' calls:          ', selectors asArray printString) print.
				"aStream nextPut: cl name , ' ' , sel , ' calls: ', secondStream contents" ]]].
	^aStream contents! !
!TestCaseTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50584929!
testAssertDoeNotChangePassesWhenConditionIsNotAlteredByAction

	|aCollection|

	aCollection := OrderedCollectionEnu with: 1.
	
	self assert: [ aCollection sum ] doesNotChange: [ aCollection size ]! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50598320!
resumableFallOffTheEndHandlerResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		add: self doSomethingExceptionalString;
		add: self doYetAnotherThingString;
		yourself! !
!ChangeKeywordsSelectorOrderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50588047!
test07ChangesKeywordsAndParametersOrderForMoreThanTwoKeywords

	| classToRefactor refactoring renamedMethod oldSelector newSelector selectorAndParameters parameters |

	oldSelector := #m1:m2:m3:.
	newSelector := #m2:m3:m1:.
	classToRefactor := self createClassNamed: #ClassToChangeSelectorOrder.
	selectorAndParameters := self selectorAndParametersFor: oldSelector.
	classToRefactor compile: selectorAndParameters.

	refactoring := ChangeKeywordsSelectorOrder from: oldSelector to: newSelector implementors: { classToRefactor >> oldSelector } senders: #().
	refactoring apply.

	renamedMethod := classToRefactor >> newSelector.
	parameters := selectorAndParameters substrings reject: [ :aKeywordOrParameter | oldSelector keywords includes: aKeywordOrParameter  ].
	self
		assert: (OrderedCollectionEnu with: parameters second with: parameters third with: parameters first)
		equals: renamedMethod methodNode argumentNames ! !
!Clipboard methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16816497 overrides: 16920235!
initialize
	contents _ nil.
	contentsOriginalObjectWeakly _ WeakArray new: 1.
	recent _ OrderedCollectionEnu new.! !
!HierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16867820!
addSubmorphsAfter: parentMorph fromCollection: aCollection allowSorting: sortBoolean

	| priorMorph morphList newCollection |
	priorMorph _ nil.
	newCollection _ (sortBoolean and: [sortingSelector notNil]) ifTrue: [
		aCollection asOrderedCollection sort: [ :a :b | 
			(a perform: sortingSelector) <= (b perform: sortingSelector)]
	] ifFalse: [
		aCollection
	].
	morphList _ OrderedCollectionEnu new.
	newCollection do: [:item | 
		priorMorph _ self indentingItemClass basicNew 
			initWithContents: item 
			prior: priorMorph 
			forList: self
			indentLevel: parentMorph indentLevel + 1.
		morphList add: priorMorph.
	].
	scroller addAllMorphs: morphList after: parentMorph.
	^morphList
	
! !
!PackageSnapshot methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50546217!
setupClassesToTakeSnapshots

	classesToTakeSnapshots _ OrderedCollectionEnu new.

	sourcePackage classesInSafeOrderDo: [ :class |
		class sharedPoolsString
			ifEmpty: [
				classesToTakeSnapshots add: class ]
			ifNotEmpty: [
				self error: self takingSnapshotOfClassesWithSharedPoolsIsNotSupportedYetErrorMessage  ] ]! !
!FileSystemEntry methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16856674!
parents
	| ord par |
	par := self parent.
	ord := OrderedCollectionEnu with: par.
	[par isRoot] whileFalse: [
		par := par parent.
		ord add: par.
	].
	^ord! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50598360!
simpleEnsureTestWithUparrowResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
"		add: self doSomethingElseString;"
		add: self doYetAnotherThingString;
		yourself! !
!SmartRefStream class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16942639!
subObjects: anObject ofClass: aClass
	"Return a collection of all instances of aClass that would be written out with anObject.  Does not actually write on the disk.  Inspect the result and ask for 'references to this object'."

	| dummy coll |
	dummy _ ReferenceStream on: (DummyStream on: nil).
		"Write to a fake Stream, not a file"
	"Collect all objects"
	dummy rootObject: anObject.	"inform him about the root"
	dummy nextPut: anObject.
	coll _ OrderedCollectionEnu new.
	dummy references keysDo: [:each |
		each class == aClass ifTrue: [coll add: each]].
	^ coll! !
!VariableTypeInfoTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50619760!
test40TypesDoEvaluatesBlockOnEachType

	| variableTypeInfo types |

	variableTypeInfo := VariableTypeInfo new initializeRawTypes: (Array new: 3).
	types := OrderedCollectionEnu new.
	
	variableTypeInfo addType: 1 class.
	variableTypeInfo addType: 1.0 class.
	
	variableTypeInfo typesDo: [ :aType | types add: aType ].
	
	self assert: types size equals: 2.
	self assert: (types includes: 1 class).
	self assert: (types includes: 1.0 class)! !
!IntroduceNullObjectForm methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50601718!
initializeWithModel: aModel

	super model: aModel.

	self setLabel: 'Introduce Null Object'.

	discardEdits := false.

	ifNilChecks := model ifNilChecks.
	introduceNullObjectRequest := IntroduceNullObjectRequest for: ifNilChecks.
	messageListModel := IfNilMessageListModel with: ifNilChecks withForm: self.
	focusMorphs := OrderedCollectionEnu new.

! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50598194!
simpleRetryUsingTestResults

	^OrderedCollectionEnu new
			add: self doSomethingString;
			add: self doYetAnotherThingString;
			yourself! !
!GraphPathFinderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50513427!
testSamePlace

	| path |

	path := finder pathFrom: 1 to: 1.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 1 to: 1)))! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16783418!
entriesToShow
	
	self hasCollectedOnlyOneSelector
		ifTrue: [ entriesToShow := categoriesWithSelectors anyOne ]
		ifFalse: [ 
			entriesToShow := OrderedCollectionEnu new.
			self 
				addPrioritizedCategories;
				addLeftCategories ].
						  			
	^entriesToShow 
	
	   ! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50702986!
test12_PortfolioHasTransactionsFromStoredPortfolios
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio add: anAccount.
	aPortfolio add: otherPortfolio.
	self assert: aPortfolio transactions equals: (OrderedCollectionEnu with: aTransaction) .! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50598384!
simpleTimeoutWithZeroDurationTestResults

	^OrderedCollectionEnu new
		add: self doSomethingElseString;
		yourself! !
!ClassCommentVersionsBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50365742!
scanVersionsOf: class
	"Scan for all past versions of the class comment of the given class"

	| oldCommentRemoteStr sourceFilesCopy position prevPos stamp preamble tokens prevFileIndex |

	classOfMethod _ class.
	oldCommentRemoteStr _ class  organization commentRemoteStr.
	currentCompiledMethod _ oldCommentRemoteStr.
	selectorOfMethod _ #Comment.
	changeList _ OrderedCollectionEnu new.
	list _ OrderedCollectionEnu new.
	listIndex _ 0.
	oldCommentRemoteStr ifNil:[^ nil] ifNotNil: [oldCommentRemoteStr sourcePointer].

	sourceFilesCopy _ SourceFiles collect: [ :x | x ifNotNil: [x name asFileEntry readStream]].
	position _ oldCommentRemoteStr position.
	file _ sourceFilesCopy at: oldCommentRemoteStr sourceFileNumber.
	[ position notNil & file notNil]  whileTrue: [
		"Skip back filler"
		file position: position.
		file backChunk.
		"Get preamble"
		preamble _ file backChunk.
		prevPos _ nil.
		stamp _ ''.
		(preamble includesSubString: 'commentStamp:')
			ifTrue: [
				tokens _ Scanner new scanTokens: preamble.
				stamp _ CompiledMethod field: #commentStamp: from: tokens ifAbsentOrNil: [ '' ].
				(CompiledMethod priorReferenceFrom: tokens) ifNotNil: [ :priorRef |
					prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: priorRef.
					prevPos _ sourceFilesCopy filePositionFromSourcePointer: priorRef ]]
			ifFalse: [
				"The stamp get lost, maybe after a condenseChanges"
				stamp _ '<historical>'].
 		self addItem:
				(ChangeRecord new file: file position: position type: #classComment
						class: class name category: nil meta: class isMeta stamp: stamp)
			text: stamp , ' ' , class name , ' class comment'. 
		prevPos = 0 ifTrue: [ prevPos _ nil ].
		position _ prevPos.
		prevPos notNil ifTrue: [ file _ sourceFilesCopy at: prevFileIndex ]].
	sourceFilesCopy do: [ :x | x notNil ifTrue: [ x close ]].
	self clearSelections! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50628784!
variablesNames

	| names |
	
	names := OrderedCollectionEnu new.
	self variablesNamesDo: [ :aVarName | names add: aVarName ].
	
	^names! !
!DifferenceFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16842908!
maxLengthPoints
	| max points |
	max := self maxLength.
	max = 0 ifTrue: [^Array with: `0 @ 0`].
	points := OrderedCollectionEnu new.
	tally withIndexesDo: [:i :j :t | t = max ifTrue: [points add: i @ j]].
	^ points! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50629248!
actualImplementorsOf: aSelector in: aClass 
	
	| highestImplementorClass implementors |
	
	implementors := OrderedCollectionEnu new.
	highestImplementorClass := aClass 
		highestClassImplementing: aSelector 
		ifNone: [ 
			implementors add: (NotImplementedMethod class: aClass selector: aSelector).
			aClass ].
	
	^ highestImplementorClass withAllSubclassesImplementing: aSelector addTo: implementors.
	! !
!TestCaseTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50584911!
testAssertChangesFromToPassesWhenActionChangesConditionFromAndToTheSpecifiedValues

	|aCollection|

	aCollection := OrderedCollectionEnu with: 1.
	
	self assert: [ aCollection add: 2 ] changes: [ aCollection size ] from: 1 to: 2! !
!Compiler class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16831063!
notSameMethodsAfterCompilingAll

	"
	self notSameMethodsAfterCompilingAll
	"
	
	| notEqual |
	
	notEqual := OrderedCollectionEnu new.

	ProtoObject withAllSubclassesDo: [ :class | 
		class selectorsDo: [ :selector | | currentCompiledMethod newCompiledMethod |
			currentCompiledMethod := class >> selector.
			newCompiledMethod := class
				basicCompile: currentCompiledMethod sourceCode
				notifying: nil
				trailer: class defaultMethodTrailer
				ifFail: [^self error: 'error compiling'].
			currentCompiledMethod = newCompiledMethod method ifFalse: [ notEqual add: currentCompiledMethod ]].	
		].

	^notEqual.! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50598374!
simpleTimeoutTestResults

	| things |
	things := OrderedCollectionEnu new: self iterationsBeforeTimeout.

	self iterationsBeforeTimeout timesRepeat: [ things add: self  doSomethingString ].
	things add: self doSomethingElseString.

	^ things! !
!DenotativeObjectBrowser class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50634657 overrides: 50716970!
recentClasses

	RecentDenotativeObjects ifNil: [ RecentDenotativeObjects := OrderedCollectionEnu new ].
	
	^RecentDenotativeObjects ! !
!ExtractToMethodObjectForm methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50601165!
initializeWithModel: aModel

	super model: aModel.

	self setLabel: 'Extract Method to Method Object'.

	discardEdits := false.
	variablesToParametrize := model variablesToParametrize.
	extractToMethodObjectRequest := ExtractToMethodObjectRequest for: aModel methodToExtract.
	focusMorphs := OrderedCollectionEnu new.! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50625065!
allWithNoCommonSupertype

	"
	InstanceVariablesTypes allWithNoCommonSupertype
	MethodVariablesTypes allWithNoCommonSupertype
	"
	
	| allWithNoCommonSupertype |
	
	allWithNoCommonSupertype := OrderedCollectionEnu new.
	ProtoObject withAllSubclassesDo: [ :aClass | self of: aClass do: [ :aVariablesTypes | aVariablesTypes addWithNoCommonSupertypeTo: allWithNoCommonSupertype ]].
			
	^allWithNoCommonSupertype 
	
! !
!PathQuadraticCurveToSmoothCommand methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50432199 overrides: 50431909!
buildFrom: commandChar stream: aStream

	| x y |
	super buildFrom: commandChar stream: aStream.
	toPoints _ OrderedCollectionEnu new.
	[
		x _ aStream nextNumber.
		y _ aStream nextNumber.
		y notNil ] whileTrue: [
			toPoints add: x@y]! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16840973!
decompile: aSelector in: aClass method: aMethod using: aConstructor

	| block node |
	constructor := aConstructor.
	method := aMethod.
	self initSymbols: aClass.  "create symbol tables"
	method isQuick
		ifTrue: [block := self quickMethod]
		ifFalse: 
			[stack := OrderedCollectionEnu new: method frameSize.
			lastJumpIfPcStack := OrderedCollectionEnu new.
			caseExits := OrderedCollectionEnu new.
			statements := OrderedCollectionEnu new: 20.
			numLocalTemps := 0.
			super method: method pc: method initialPC.
			"skip primitive error code store if necessary"
			(method primitive ~= 0 and: [self skipCallPrimitive; willStore]) ifTrue:
				[pc := pc + (method encoderClass bytecodeSize: self firstByte).
				 tempVars := tempVars asOrderedCollection].
			block := self blockTo: method endPC + 1.
			stack isEmpty ifFalse: [self error: 'stack not empty']].
	node := constructor
				codeMethod: aSelector
				block: block
				tempVars: tempVars
				primitive: method primitive
				class: aClass.
	method primitive > 0 ifTrue:
		[node removeAndRenameLastTempIfErrorCode].
	^node preen! !
!TestResult methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 16962135!
defects
	^OrderedCollectionEnu new
		addAll: self errors;
		addAll: self failures; yourself
			! !
!IfNilChecksFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:24' prior: 50610081 overrides: 16902254!
value

	| selectors |

	selectors := contextClass whichSelectorsAccess: instanceVariable.

	^selectors inject: OrderedCollectionEnu new into: [:ifNilChecks :selector |
		ifNilChecks addAll: (self ifNilChecksIn: selector). ifNilChecks.].! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16801947!
removeOlderMethodVersions
	"Remove older versions of entries from the receiver."

	| newChangeList newList found |
	newChangeList _ OrderedCollectionEnu new.
	newList _ OrderedCollectionEnu new.
	found _ OrderedCollectionEnu new.
	changeList reverseWith: list do: [ :chRec :strNstamp | | str |
		str _ strNstamp copyUpTo: $;.
		(found includes: str) ifFalse: [
			found add: str.
			newChangeList add: chRec.
			newList add: strNstamp]].
	newChangeList size < changeList size ifTrue: [
		changeList _ newChangeList reversed.
		list _ newList reversed.
		listIndex _ 0.
		self clearSelections ].
	self changed: #list! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16952113!
obsoleteBehaviors
	"
	Smalltalk obsoleteBehaviors inspect
	Find all obsolete behaviors including meta classes
	"
	| obs |
	obs _ OrderedCollectionEnu new.
	Smalltalk garbageCollect.
	self allObjectsDo: [ :cl |
		(cl isBehavior and: [cl isObsolete]) ifTrue: [obs add: cl]].
	^ obs asArray! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50626325 overrides: 50626282!
errors
	
	^typeCheckers 
		inject: OrderedCollectionEnu new
		into: [ :errors :typeChecker |
			errors addAll: typeChecker errors.
			errors ]! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16829745!
embeddedBlockClosures
	"
	(CompiledMethod >> #embeddedBlockClosures)embeddedBlockClosures
	"
	| bms extractor scanner |
	bms := OrderedCollectionEnu new.
	scanner := self scanner.
	extractor := ClosureExtractor withAction: [ :c | bms add: c ] andScanner: scanner.
	[ scanner pc <= self endPC ] whileTrue: [ scanner interpretNextInstructionFor: extractor ].
	^ bms! !
!TestResult methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16962144!
errors

	errors
		ifNil: [errors := OrderedCollectionEnu new].
	^errors
			! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50534349!
testAddRules

	| timeLineFilter rule1 rule2 rule3 september14Of2005 september15Of2005 september16Of2005 |
	
	september14Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 14.
	september15Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 15.
	september16Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 16.

	timeLineFilter := TimeLineFilter new.
	rule1 := timeLineFilter dateRule: september14Of2005.
	rule2 := timeLineFilter dateRule: september15Of2005.
	rule3 := timeLineFilter dateRule: september16Of2005.

	timeLineFilter addRules: (OrderedCollectionEnu with: rule1 with: rule2 with: rule3).
	self assert: (timeLineFilter includes: september14Of2005).
	self assert: (timeLineFilter includes: september15Of2005).
	self assert: (timeLineFilter includes: september16Of2005)! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50375792!
findTokens: delimiters
	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."

	| tokens keyStart keyStop separators |

	tokens _ OrderedCollectionEnu new.
	separators _ delimiters isCharacter
		ifTrue: [Array with: delimiters]
		ifFalse: [delimiters].
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipDelimiters: separators startingAt: keyStop.
		keyStop _ self findDelimiters: separators startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens! !
!TestRunner methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16962796 overrides: 16920235!
initialize

	result := TestResult new.
	passFail := ''.
	details := ''.
	failures := OrderedCollectionEnu new.
	errors := OrderedCollectionEnu new.
	tests := self gatherTestNames.
	selectedSuite := 0.
	selectedFailureTest := 0.
	selectedErrorTest := 0.
	selectedSuites := tests collect: [:ea | true].
	running := nil.
	runSemaphore := Semaphore new! !
!SequenceableCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50575099!
testCombinationsAtATimeDoWorksAsExpected
	
	| combinations |
	 
	combinations := OrderedCollectionEnu new.
	'abc' combinations: 2 atATimeDo: [ :combination | combinations add: combination copy].
	
	self assert: combinations size equals: 3.
	self assert: (combinations includes: #($a $b)).
	self assert: (combinations includes: #($a $c)).
	self assert: (combinations includes: #($b $c)).! !
!SpaceTally methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16943916!
printSpaceDifferenceFrom: fileName1 to: fileName2
	"For differential results, run printSpaceAnalysis twice with different fileNames,
	then run this method...
		'STspace.text1' asFileEntry writeStreamDo: [ :stream | SpaceTally new printSpaceAnalysis: 0 on: stream ].
			--- do something that uses space here ---
		'STspace.text2' asFileEntry writeStreamDo: [ :stream | SpaceTally new printSpaceAnalysis: 0 on: stream ].
		SpaceTally new printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'
"
	| coll1 coll2 item |
	coll1 _ OrderedCollectionEnu new.
	DirectoryEntry smalltalkImageDirectory // fileName1 readStreamDo: [ :stream |
		[stream atEnd] whileFalse: [coll1 add: stream crLfNextLine]].
	
	coll2 _ OrderedCollectionEnu new.
	DirectoryEntry smalltalkImageDirectory // fileName2 readStreamDo: [ :stream |
		[stream atEnd] whileFalse: [
			item _ stream crLfNextLine.
			((coll1 includes: item) and: [(item endsWith: 'percent') not])
				ifTrue: [coll1 remove: item]
				ifFalse: [coll2 add: item]]].

	(TextModel new contents: (String streamContents: 
			[ :s | 
			s nextPutAll: fileName1; newLine.
			coll1 do: [:x | s nextPutAll: x; newLine].
			s newLine; newLine.
			s nextPutAll: fileName2; newLine.
			coll2 do: [:x | s nextPutAll: x; newLine]]))
		openLabel: 'Differential Space Analysis'.
! !
!CodeFile methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16817577 overrides: 16920235!
initialize
	classes _ Dictionary new.
	classOrder _ OrderedCollectionEnu new.
	sourceSystem _ ''.
	doIts _ OrderedCollectionEnu new! !
!SequenceableCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50575214!
testWithIndexDoSeparatedByDoesNotValueSeparatedBlockOnLastElement

	| collectionToTraverse traversedElements |

	collectionToTraverse := OrderedCollectionEnu with: $a with: $b.
	traversedElements := OrderedCollectionEnu new.

	collectionToTraverse
		withIndexDo: [ :anElement :index | traversedElements add: anElement  -> index ]
		separatedBy: [ traversedElements add: $-].

	self assert: traversedElements size equals: 3.
	self assert: traversedElements first equals: $a->1.
	self assert: traversedElements second equals: $-.
	self assert: traversedElements third equals: $b->2.! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16907739!
blockExpression
	"[ ({:var} |) (| {temps} |) (statements) ] => BlockNode."

	| blockNode tempsDeclarationNode variableNodes temporaryBlockVariables start |

	self advance.
	
	blockNode := BlockNode new.
	variableNodes := OrderedCollectionEnu new.
	start := prevMark + requestorOffset.
	"Gather parameters."
	[self match: #colon] whileTrue:
		[self argumentNameWithRangeDo: [ :argumentName :range |
			variableNodes addLast: (encoder bindBlockArg: argumentName within: blockNode range: range)]].
	(variableNodes size > 0 & (hereType ~~ #rightBracket) and: [(self match: #verticalBar) not]) ifTrue:
		[^self expected: 'Vertical bar'].

	tempsDeclarationNode := self temporaryBlockVariablesFor: blockNode.
	temporaryBlockVariables := tempsDeclarationNode allDeclaredVariableNodes.
	self statements: variableNodes innerBlock: true blockNode: blockNode.
	blockNode temporariesDeclaration: tempsDeclarationNode.

	(self match: #rightBracket) ifFalse: [^self expected: 'Period or right bracket'].

	blockNode noteSourceRangeStart: start end: self endOfLastToken encoder: encoder.

	"The scope of the parameters and temporary block variables is no longer active."
	temporaryBlockVariables do: [:variable | variable scope: -1].
	variableNodes do: [:variable | variable scope: -1].

	^true! !
!CodeWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50419172!
methodInheritance
	"Create and schedule a method browser on the inheritance of implementors."

	| list aClassNonMeta isMeta theClassOrMeta aClass sel |
	aClass _ model selectedClassOrMetaClass.
	sel _ model selectedMessageName.
	aClass ifNil: [ ^ self ].
	sel ifNil: [ ^ self ].
	aClassNonMeta _ aClass theNonMetaClass.
	isMeta _ aClassNonMeta ~~ aClass.
	list _ OrderedCollectionEnu new.
	aClass allSuperclasses reverseDo: [ :cl |
		(cl includesSelector: sel) ifTrue: [
			list addLast: (MethodReference class: cl selector: sel) ]].
	aClassNonMeta
		allSubclassesWithLevelDo: [ :cl :level |
			theClassOrMeta _ isMeta
				ifTrue: [ cl class ]
				ifFalse: [ cl ].
			(theClassOrMeta includesSelector: sel) ifTrue: [
				list addLast: (MethodReference class: theClassOrMeta selector: sel) ]]
		startingLevel: 0.
	^ Smalltalk
		browseMessageList: list
		name: 'Inheritance of ' , sel.! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50631521!
buildPrimaryPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollectionEnu with: (Color fromHexString: '#DA627D') with: 'Sunset'.
	ocean := OrderedCollectionEnu with: (Color fromHexString: '#598392') with: 'Ocean'.
	forest := OrderedCollectionEnu with: (Color fromHexString: '#5E5D5C') with: 'Forest'.
	ash := OrderedCollectionEnu with: (Color fromHexString: '#696773') with: 'Ash'.
	light := OrderedCollectionEnu with: (Color fromHexString: '#CEB5A7') with: 'Light'.
	
	primaryPalette := OrderedCollectionEnu with: sunset with: ocean with: forest with: ash with: light.! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16815409!
allMethodsInCategory: aSymbol
	"Answer a list of all the method categories of the receiver and all its superclasses"

	| aColl |
	aColl _ OrderedCollectionEnu new.
	self withAllSuperclasses do:
		[:aClass | aColl addAll:
			(aSymbol == ClassOrganizer allCategory
				ifTrue:
					[aClass organization allMethodSelectors]
				ifFalse:
					[aClass organization listAtCategoryNamed: aSymbol])].
	^ aColl asSet sorted

"TileMorph allMethodsInCategory: #initialization"! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50534892!
testRules

	| timeLineFilter rule1 rule2 rule3 rulesCollection |

	timeLineFilter := TimeLineFilter new.
	rule1 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 14).
	rule2 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 15).
	rule3 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 16).

	rulesCollection := OrderedCollectionEnu with: rule1 with: rule2 with: rule3.
	timeLineFilter addRules: rulesCollection.

	self assert: timeLineFilter rules = rulesCollection! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50597933!
suiteLog

	suiteLog == nil
		ifTrue: [suiteLog := OrderedCollectionEnu new].
	^suiteLog! !
!DenotativeObjectTheme methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50636578 overrides: 16971312!
pseudoVariables

	^ (OrderedCollectionEnu withAll: super pseudoVariables) 
		add: #parent;
		asArray! !
!TypeCheckerTestMethods methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50627505!
typeCheckMessageWithReturnOnIfFalse

	| temp1  |
	
	temp1 := OrderedCollectionEnu new.
	temp1 := 1.
	
	temp1 isNumber ifFalse: [ ^self ].
	temp1 odd! !
!IsKindOfManyTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50626042 overrides: 50625989!
buildRejectApplierBefore: aPreviousCastingApplier

	^EffectiveTypeCastApplier 
		casts: OrderedCollectionEnu new
		rejections: (OrderedCollectionEnu with: self buildTypeReject)
		previous: aPreviousCastingApplier! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16805765!
askRenames: renamed addTo: msgSet using: smart
	| list |
	"Go through the renamed classes.  Ask the user if it could be in a project.  Add a method in SmartRefStream, and a conversion method in the new class."

	list _ OrderedCollectionEnu new.
	renamed do: [ :cls | | rec |
		rec _ changeRecords at: cls name.
		rec priorName ifNotNil: [
			| ans |
			ans _ PopUpMenu withCaption: 'You renamed class ', rec priorName, 
				' to be ', rec thisName,
				'.\Could an instance of ', rec priorName, 
				' be in a project on someone''s disk?'
			chooseFrom: #('Yes, write code to convert those instances'
				'No, no instances are in projects').
			ans = 1 ifTrue: [
				| oldStruct newStruct  |
				oldStruct _ structures at: rec priorName ifAbsent: nil.
				newStruct _ (Array with: cls classVersion), (cls allInstVarNames).
				oldStruct ifNotNil: [
					smart writeConversionMethodIn: cls fromInstVars: oldStruct 
							to: newStruct renamedFrom: rec priorName.
					smart writeClassRename: cls name was: rec priorName.
					list add: cls name, ' convertToCurrentVersion:refStream:']]
			ifFalse: [structures removeKey: rec priorName ifAbsent: nil]]].
	list isEmpty ifTrue: [^ msgSet].
	msgSet messageList ifNil: [msgSet initializeMessageList: list]
		ifNotNil: [list do: [:item | msgSet addMethodReference: item]].
	^ msgSet! !
!EqualsTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50626164 overrides: 50625989!
buildRejectApplierBefore: aPreviousCastingApplier
	
	 ^EffectiveTypeCastApplier 
		casts: OrderedCollectionEnu new
		rejections: (OrderedCollectionEnu with: self buildTypeReject)
		previous: aPreviousCastingApplier! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50383708!
findTokens: delimiters keep: keepers
	"Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)"

	| tokens keyStart keyStop |
	tokens _ OrderedCollectionEnu new.
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipDelimiters: delimiters startingAt: keyStop.
		keyStop to: keyStart-1 do: [:ii | 
			(keepers includes: (self at: ii)) ifTrue: [
				tokens add: (self copyFrom: ii to: ii)]].	"Make this keeper be a token"
		keyStop _ self findDelimiters: delimiters startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens! !
!ConversionTable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50522197 overrides: 16920235!
initialize

	unitConversionRules := OrderedCollectionEnu new.
	self invalidateGraph! !
!IsKindOfTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50626198 overrides: 50625989!
buildRejectApplierBefore: aPreviousCastingApplier

	^EffectiveTypeCastApplier 
		casts: OrderedCollectionEnu new
		rejections: (OrderedCollectionEnu with: self buildTypeReject)
		previous: aPreviousCastingApplier
	! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50626435 overrides: 50626252!
problems

	^typeCheckers 
		inject: OrderedCollectionEnu new
		into: [ :problems :typeChecker |
			problems addAll: typeChecker problems.
			problems ]! !
!CodeFile methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16817395!
removeDoIts
	doIts := OrderedCollectionEnu new.! !
!CollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50574628!
testItMaintainsTheSameCollectionSpecies

	self assert: (OrderedCollectionEnu with: 1 with: #(2)) flatten equals: (OrderedCollectionEnu with: 1 with: 2).! !
!CodeFileBrowserWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50494358 overrides: 16797244!
classListMenu

	| aMenu itemColl |
	self flag: #assumesKeyboardShortcuts.
	aMenu := MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Class List'.
	itemColl := OrderedCollectionEnu new.
	itemColl addAll:
		{
			{#label -> 'definition'. #object -> #model. #selector -> #editClass. #icon -> #editFindReplaceIcon} asDictionary. 
			{#label -> 'comment'. #object -> #model. #selector -> #editComment. #icon -> #editFindReplaceIcon} asDictionary. 
			nil
		}.
	self model baseCodeSource isLiveSmalltalkImage ifTrue: [
		itemColl addAll:
			{
				{#label -> 'browse full (b)'. #selector -> #browseMethodFull. #icon -> #editFindReplaceIcon} asDictionary. 
				{#label -> 'class refs (N)'. #selector -> #browseClassRefs. #icon -> #classIcon} asDictionary. 
				nil. 
				{#label -> 'fileIn'. #object -> #model. #selector -> #fileInClass. #icon -> #updateIcon} asDictionary
			} ].
	itemColl addAll:
		{
			{#label -> 'fileOut'. #object -> #model. #selector -> #fileOutClass. #icon -> #fileOutIcon} asDictionary. 
			nil. 
			{#label -> 'rename...'. #object -> #model. #selector -> #renameClass. #icon -> #saveAsIcon} asDictionary. 
			{#label -> 'remove'. #object -> #model. #selector -> #removeClass. #icon -> #listRemoveIcon} asDictionary. 
			nil. 
			{#label -> 'remove existing'. #object -> #model. #selector -> #removeUnmodifiedCategories. #icon -> #deleteIcon} asDictionary
		}.
	aMenu addItemsFromDictionaries: itemColl.
	^ aMenu.! !
!PackageSnapshot methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50546178!
initializeToTakeOf: aCodePackage

	sourcePackage _ aCodePackage.
	id _ Time millisecondClockValue.
	systemOrganizer _ SystemOrganization.
	snapshotOfClassesByOriginalClassName _ OrderedDictionary new.
	snapshotsOfExtensionMethods _ OrderedCollectionEnu new.! !
!ExtractAsParameter class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16850921!
intervalsForEquivalentNodesTo: node in: methodNode

	| completeSourceRanges intervalsForEquivalentNodes | 
	
	intervalsForEquivalentNodes := OrderedCollectionEnu new.
	completeSourceRanges := methodNode completeSourceRanges.
	
	methodNode nodesDo: [ :aNode | 
		(aNode equivalentTo: node) ifTrue: [ 
			"There can not be more than one range because of the is not a multi range node. See senders - Hernan"
			intervalsForEquivalentNodes add: (completeSourceRanges at: aNode) first ]].
	
	^intervalsForEquivalentNodes! !
!IfNilChecksFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50610021!
ifNilChecksIn: aSelector

	| methodNode ifNilChecks |

	"It is using methodNode and not notOptimizedMethodNode becuase isIfNilCheckNode:
	was developed before notOptimizedMethodNode and assumes optimizations.
	Run test04ResultIncludesIfNotNilMessageSending to see the problem - Hernan"
	methodNode := (contextClass compiledMethodAt: aSelector) methodNode.

	ifNilChecks := OrderedCollectionEnu new.
	methodNode accept: (ParseNodeEnumerator ofBlock: [:node |
		(self isIfNilCheckNode: node) ifTrue:[ | nodeIndex |
			nodeIndex := (methodNode encoder rangeForNode: node ifAbsent: [ self shouldNotHappen ]) first.
			ifNilChecks add: (IfNilCheck in: methodNode representedBy: node atIndex: nodeIndex)]]).

	^ifNilChecks reverse! !
!SystemWindow class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16960115!
windowsIn: aWorld satisfying: windowBlock
	| windows |
	windows _ OrderedCollectionEnu new.
	aWorld submorphs do: [ :m |
		((m is: #SystemWindow) and: [ windowBlock value: m ]) ifTrue: [ windows addLast: m ]].
	^ windows! !
!DenotativeObjectLightTheme methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50636558 overrides: 16971312!
pseudoVariables

	^ (OrderedCollectionEnu withAll: super pseudoVariables) 
		add: #parent;
		asArray! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16805839!
checkForSlips
	"Return a collection of method refs with possible debugging code in them."
	| slips |
	slips _ OrderedCollectionEnu new.
	self changedClasses do: [ :aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc |  | method |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse: [
				method _ aClass compiledMethodAt: mAssoc key ifAbsent: nil.
				method ifNotNil: [
					method hasReportableSlip
						ifTrue: [slips add: (MethodReference method: method)]]]]].
	^ slips! !
!FileIOAccessor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50362403!
entriesIn: parentEntryOrNil
	"
	Warning: Private. Only to be called from within FileMan.
	Accepts nil as argument, but behavior depends on platform.

Windows (nil means root)
FileIOAccessor default entriesIn: nil #(C:\ D:\)
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(\$Recycle.Bin \Config.Msi \Documents and Settings \gratMusic \hiberfil.sys \Intel \pagefile.sys \PerfLogs \Program Files \Program Files (x86) \ProgramData \Python27 \Recovery \SimuloHoy \System Volume Information \totalcmd \Users \Windows)

Linux  (nil means current dir, like '' and '.')
FileIOAccessor default entriesIn: nil #(Lots of stuff in current directory)
(FileIOAccessor default entriesIn: nil) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(/vmlinuz /boot /sbin /srv /lib /lib32 /tmp /sys /home /etc /initrd.img /bin /dev /opt /proc /lost+found /var /root /lib64 /mnt /usr /run /media)

MacOsX (nil means current dir, like '' and '.')
FileIOAccessor default entriesIn: nil #(/Volumes/SanDisk32-NTFS/CuisTest/2554-REVISAR-JuanVuletich-2015Oct21-16h40m-jmv.1.cs.st /Volumes/SanDisk32-NTFS/CuisTest/Cog.app /Volumes/SanDisk32-NTFS/CuisTest/Cog.app.tgz /Volumes/SanDisk32-NTFS/CuisTest/Cuis4.2-2553.changes /Volumes/SanDisk32-NTFS/CuisTest/Cuis4.2-2553.image /Volumes/SanDisk32-NTFS/CuisTest/CuisV4.sources)
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(/.dbfseventsd /.DocumentRevisions-V100 /.DS_Store /.file /.fseventsd /.hotfiles.btree /.Spotlight-V100 /.Trashes /.vol /Applications /bin /cores /dev /etc /home /installer.failurerequests /Library /net /Network /opt /private /sbin /System /tmp /Users /usr /var /Volumes)

	"
	| entries index done entryArray entry isDirectory lookIn |
	entries _ OrderedCollectionEnu new: 200.
	index _ 1.
	done _ false.
	lookIn _ parentEntryOrNil ifNil: [''] ifNotNil: [parentEntryOrNil pathName].
	[done] whileFalse: [
		entryArray _ self primFixedNameLookupEntryIn: lookIn asUtf8Bytes index: index.
		#badDirectoryPath == entryArray ifTrue: [
			^#()].
		entryArray == nil
			ifTrue: [done _ true]
			ifFalse: [
				isDirectory _ entryArray at: 4.
				entry _ isDirectory ifTrue: [DirectoryEntry new] ifFalse: [FileEntry new].
				entry name: (entryArray at: 1) parent: parentEntryOrNil.
				entry updateFrom: entryArray entryInParent: index.
				entries addLast: entry ].
		index _ index + 1].

	^entries asArray! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16805673!
askAddedInstVars: classList
	| pairList pairClasses index pls |
	"Ask the author whether these newly added inst vars need to be non-nil"

	pairList _ OrderedCollectionEnu new.
	pairClasses _ OrderedCollectionEnu new.
	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."
	classList do: [ :cls |
		| newStruct oldStruct |
		newStruct _ (cls allInstVarNames).
		oldStruct _ (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.
		newStruct do: [ :instVarName |
			(oldStruct includes: instVarName) ifFalse: [
				pairList add: cls name, ' ', instVarName.
				pairClasses add: cls]]].

	pairList isEmpty ifTrue: [^ #()].
	[
		index _ PopUpMenu withCaption: 'These instance variables were added.
When an old project comes in, newly added 
instance variables will have the value nil.
Click on items to remove them from the list.
Click on any for which nil is an OK value.'
			chooseFrom: pairList, #('all of these need a non-nil value'
						'all of these are OK with a nil value').
		(index <= (pls _ pairList size)) & (index > 0) ifTrue: [
			pairList removeAt: index.
			pairClasses removeAt: index].
		index = (pls + 2) ifTrue: ["all are OK" ^ #()].
		pairList isEmpty | (index = (pls + 1)) "all need conversion, exit"] whileFalse.

	^ pairClasses asSet asArray	"non redundant"! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50598368!
simpleNoTimeoutTestResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		yourself! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16783330!
addCategory: aCategory of: classOrganization

	| categorySelectors selectedSelectors |

	selectedSelectors := self prefixedSelectorsOf: aCategory in: classOrganization.
	selectedSelectors isEmpty ifFalse: [ 
		categorySelectors := categoriesWithSelectors at: aCategory ifAbsentPut: [ OrderedCollectionEnu new ].
		categorySelectors addAll: selectedSelectors.
		self addedSelectors: selectedSelectors.
		self addToPossibleInvalidIfCorrespond: selectedSelectors ]! !
!ChangeDetector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50646703!
lookaheadRecordsFrom: aChangeList
	| lookaheads |
	
	lookaheads := OrderedCollectionEnu new.
	
	1 to: lookahead do: [ :index | lookaheads add: (aChangeList at: index ifAbsent: [ nil ]) ].
	
	^ lookaheads 
! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16906501!
consolidateAsCollection: sourceRanges

	^ sourceRanges isInterval
		ifTrue: [ OrderedCollectionEnu with: sourceRanges ]
		ifFalse: [ sourceRanges ]! !
!BlockNodeParentsFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16793420!
initializeFor: aSelectedBlockNode

	selectedBlockNode := aSelectedBlockNode.
	parents := OrderedCollectionEnu new.
	found := false.! !
!WeakRegistry methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16980190!
finalizeValues
	"Some of our elements may have gone away. Look for those and activate the associated executors."
	| finiObjects |
	finiObjects _ nil.
	"First collect the objects."
	self protected:[
		valueDictionary associationsDo:[:assoc|
			assoc key ifNil: [
				finiObjects 
					ifNil: [ finiObjects := OrderedCollectionEnu with: assoc value]
					ifNotNil: [ finiObjects add: assoc value]]
		].
		finiObjects ifNotNil: [ valueDictionary finalizeValues: finiObjects asArray].
	].
	"Then do the finalization"
	finiObjects ifNotNil: [
		finiObjects do:[:each| each finalize]]! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50626333 overrides: 50626286!
errorsAndWarnings
	
	| list |
	
	list := self sortedTypeCheckers
		inject: OrderedCollectionEnu new 
		into: [ :aList :aTypeChecker | 
			aList add: aTypeChecker methodReference.
			aList addAll: aTypeChecker errorsAndWarnings.
			aList ].
			
	^list! !
!ToolsCatalog methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50544926!
menuItemsForOpenGroup

	| openMenuOptions worldMenuOptions |
	
	worldMenuOptions := (ImplementorsCatalog new search: #worldMenuOptions)
		collect: [ :implementor |
				implementor compiledMethod
					valueWithReceiver: implementor
					methodClass arguments: {} ].
	openMenuOptions := worldMenuOptions 
		inject: OrderedCollectionEnu new
		into: [ :result :options | 
			result addAll: (options select: [ :option | (option at: #submenuOf ifAbsent: [ '' ]) = TheWorldMenu openLabel ]).
			result ].
		
	^openMenuOptions ! !
!RenameInstanceVariable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16927459!
renameReferencesToOldVariable
	
	renamedReferences := OrderedCollectionEnu new.
	methodsAndRangesToChange do: [ :aMethodAndRangesToChange | self renameReferencesToOldVariableInMethod: aMethodAndRangesToChange ].
	! !
!GraphPathFinderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50513353!
initializeGraph

	| edges |
	
	edges := OrderedCollectionEnu new
		add: (Edge from: 1 to: 1);
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		add: (Edge from: 3 to: 4);
		add: (Edge from: 1 to: 5);
		yourself.
		
	graph := Graph edges: edges
! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16920579!
protocolFor: anIndex
	"Change the listed protocol"

	exclude _ OrderedCollectionEnu new.
	anIndex > 0
		ifTrue: [
			selectedName _ (selectiveClassList at: anIndex) withBlanksTrimmed.
			(1 to: anIndex - 1) do: [:ix |
				exclude addLast: (selectiveClassList at: ix) withBlanksTrimmed]]
		ifFalse: [
			selectedName _ nil.
			].
	self on: baseClass.
	self changed: #relabel! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50515434!
testEqual

	self assert: (CompoundMeasure with: self tenPesos with: self twentyDollars) = (CompoundMeasure with: self tenPesos with: self twentyDollars).
	self assert: (CompoundMeasure with: self tenPesos with: self twentyDollars) = (CompoundMeasure with: self twentyDollars with: self tenPesos ).
	self assert: (CompoundMeasure measures: (OrderedCollectionEnu with: self tenPesos with: self twentyDollars with: self tenEuros)) =
		(CompoundMeasure measures: (OrderedCollectionEnu with: self tenEuros with: self twentyDollars with: self tenPesos)).
	
	self deny: (CompoundMeasure with: self tenPesos with: self twentyDollars) = (CompoundMeasure with: (self tenPesos+self onePeso) with: self twentyDollars)
	! !
!Theme methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50421016!
generateShoutConfig

	| styles colors |
	styles := OrderedCollectionEnu new.
	colors := self shout as: Dictionary.

	{
		{self undefined. colors at: #undefined}.
		{self defaults . colors at: #defaults}.
		{self pseudoVariables . colors at: #pseudoVariables}.
		{self literals . colors at: #literals}.
		{self instVar . colors at: #instVar}.
		{self messages . colors at: #messages}.
		{self blockLevelZero . colors at: #blockLevelZero}.
		{self blockLevelOne . colors at: #blockLevelOne}.
		{self blockLevelTwo . colors at: #blockLevelTwo}.
		{self blockLevelThree . colors at: #blockLevelThree}.
		{self blockLevelFour . colors at: #blockLevelFour}.
		{self blockLevelFive . colors at: #blockLevelFive}.
		{self blockLevelSix . colors at: #blockLevelSix}.
		{self blockLevelSeven . colors at: #blockLevelSeven}.
		{self tempBar . colors at: #tempBar}.
		{self methodTags . colors at: #methodTags . #bold}.
		{self globals . colors at: #defaults . #bold}.
		{self incompleteMessages . colors at: #incompleteMessages . #underlined}.
		{self argumentTypes . colors at: #arguments . self italic}.
		{self symbols . colors at: #messages . #bold}.
		{self pattern . colors at: #selector . #bold}.
		{self ansiAssignment . nil . #bold}.
		{self assignment . nil . #bold}.
		{self return . nil . #bold}.
		{self tempVars . colors at: #tempVars . self italic}.
		{self blockTemps . colors at: #tempBar . self italic}
	} do: [ :style |
		styles addAll:
			(style first
				collect: [ :category | | elements |
					elements _ style asOrderedCollection.
					elements at: 1 put: category.
					Array withAll: elements ])].

	"Miscellaneous remainder after factoring out commonality:"
	styles addAll: {
		{#unfinishedString . colors at: #undefined . #normal}.
		{#undefinedIdentifier . colors at: #undefined .#bold}.
		{#unfinishedComment . colors at: #pseudoVariables . self italic}.
		{#comment . colors at: #comment . self italic}.
		{#string . colors at: #instVar . #normal}.
		{#literal . nil . self italic}.
		{#incompleteIdentifier . colors at: #tempVars . {#italic. #underlined}}.
		{#classVar . colors at: #tempVars . #bold}.
	}.

	^ styles! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16890399!
isMultipleRanges: aRangeOrRanges

	^aRangeOrRanges isKindOf: OrderedCollectionEnu ! !
!Exception methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16849997 overrides: 16920235!
initialize

	self handlerContexts: OrderedCollectionEnu new! !
!Scanner methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50363403!
xDoubleQuote
    "Collect a comment."
    "wod 1/10/98: Allow 'empty' comments by testing the first character
for $"" rather than blindly adding it to the comment being collected."
    | aStream stopChar |
    stopChar := DoItCharacter.
    aStream := source collectionSpecies writeStream.
    self step.
    [hereChar = $"]
        whileFalse:
            [(hereChar = stopChar and: [source atEnd])
                ifTrue: [^self offEnd: self class unmatechedCommentQuoteErrorDescription].
            aStream nextPut: self step.].
    self step.
    currentComment == nil
        ifTrue: [currentComment := OrderedCollectionEnu with: aStream contents]
        ifFalse: [currentComment add: aStream contents].
    self scanToken! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50629277!
allActualSendersOn: aSentCompiledMethod 
	
	| allSenders sureSenders possibleSenders actualMessageSendersCollector |
	
	allSenders := self allCallsOn: aSentCompiledMethod selector.
	
	sureSenders := OrderedCollectionEnu new.
	possibleSenders := OrderedCollectionEnu new.
	
	allSenders do: [ :aSender | 
		actualMessageSendersCollector := aSender actualSendersOf: aSentCompiledMethod.
		actualMessageSendersCollector hasSureMessageSends ifTrue: [ sureSenders add: aSender ].
		actualMessageSendersCollector hasPossibleMessageSends ifTrue: [ 
			possibleSenders add: (PossibleSender in: aSender withPossibleMessageSends: actualMessageSendersCollector possibleMessageSends) ]].
		
	^Array with: sureSenders with: possibleSenders ! !
!GraphPathFinderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50513434!
testWithLoops

	| path newGraph newFinder edges |

	"Add a cycle from 2 to 2"
	edges := graph edges.
	edges add: (Edge from: 2 to: 2).
	newGraph := Graph edges: edges.
	newFinder := GraphPathFinder on: newGraph.
	
	path := newFinder pathFrom: 1 to: 2.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 1 to: 2))).

	path := newFinder pathFrom: 1 to: 3.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 2 to: 3))).
		
	path := newFinder pathFrom: 2 to: 2.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 2 to: 2))).

	"To the new graph, add a cycle from 3 to 3"	
	edges := graph edges.
	edges add: (Edge from: 3 to: 3).
	newGraph := Graph edges: edges.
	newFinder := GraphPathFinder on: newGraph.

	path := newFinder pathFrom: 1 to: 3.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 2 to: 3))).
		
	path := newFinder pathFrom: 1 to: 4.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 2 to: 3)
		with: (Edge from: 3 to: 4))).
		
	path := newFinder pathFrom: 3 to: 3.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 3 to: 3))).
		
	path := newFinder pathFrom: 2 to: 4.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 2 to: 3)
		with: (Edge from: 3 to: 4))).
		
	path := newFinder pathFrom: 3 to: 4.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 3 to: 4)))! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 16920532!
initListFrom: selectorCollection highlighting: aClass 
	"Make up the messageList with items from aClass in boldface."
	| defClass item |

	messageList _ OrderedCollectionEnu new.
	selectorCollection do: [ :selector |  
		defClass _ aClass whichClassIncludesSelector: selector.
		item _ selector, '     (' , defClass name , ')'.
		defClass == aClass ifTrue: [item _ item asText allBold].
		messageList add: (
			MethodReference new
				setClass: defClass 
				methodSymbol: selector 
				stringVersion: item)].
	self hierarchyForClass: (baseClass _ aClass)! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:25' prior: 50497117!
pragmaStatement
	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."
	
	| selector arguments words index keyword |
	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])
		ifFalse: [  ^ self expected: 'pragma declaration' ].

	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "
	(here = #apicall: or: [ here = #cdecl: ])
		ifTrue: [ ^ self externalFunctionDeclaration ].

	selector := String new.
	arguments := OrderedCollectionEnu new.
	words := OrderedCollectionEnu new.
	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [
		index := self startOfNextToken + requestorOffset.
		selector := selector , self advance.
		selector := encoder asciiStringLiteral: selector.
		words add: (index to: self endOfLastToken + requestorOffset).
		(selector last = $: or: [ selector first isLetter not ]) ifTrue: [
			arguments add: (encoder asciiStringLiteral: (self pragmaLiteral: selector)) ] ].
	selector numArgs ~= arguments size
		ifTrue: [ ^ self expected: 'pragma argument' ].
	(Symbol hasInterned: selector 
		ifTrue: [ :value | keyword := value]) 
		ifFalse: [ 
			keyword := self 
				correctSelector: selector wordIntervals: words
				exprInterval: (words first first to: words last last)
				ifAbort: [ ^ self fail ] ].
	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).
	^ true! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50534802!
testNumberOfDatesBetweenTwoDates

	| timeLineFilter rule1 rule2 rule3 |

	timeLineFilter := TimeLineFilter new.
	rule1 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 14).
	rule2 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 15).
	rule3 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 16).

	timeLineFilter addRules: (OrderedCollectionEnu with: rule1 with: rule2 with: rule3).

	self assert: (timeLineFilter negated numberOfDatesBetween: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 01)
		and: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 20)) = (TimeUnits day with: 17)! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50615107!
withReceiverTypesOf: aMessageNode do: aTypesBlock

	| incompleteTypeInfoReasons receiverTypes |
	
	incompleteTypeInfoReasons := OrderedCollectionEnu new.
	receiverTypes := blockCastingApplier receiverTypesFor: aMessageNode in: actualMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons do: [ :anIncompleteTypeInfoReason | anIncompleteTypeInfoReason addTo: self node: aMessageNode ].
	
	(receiverTypes isEmpty and: [ incompleteTypeInfoReasons isEmpty ])
		ifTrue: [ problems add: (TypeCheckingProblem forReceiverWithNoTypesOn: methodReference node: aMessageNode of: methodNode)]
		ifFalse: [ aTypesBlock value: receiverTypes ]
		! !
!Scanner methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50363310!
scanMessageParts: sourceString
	"Return an array of the form (comment keyword comment arg comment keyword comment arg comment) for the message pattern of this method.  Courtesy of Ted Kaehler, June 1999"

	| coll nonKeywords |
	coll := OrderedCollectionEnu new.
	self scan: sourceString asPlainString readStream.
	nonKeywords := 0.
	[tokenType == #doIt] whileFalse:
		[(currentComment == nil or: [currentComment isEmpty])
			ifTrue: [coll addLast: nil]
			ifFalse: [coll addLast: currentComment removeFirst.
				[currentComment isEmpty] whileFalse:
					[coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].
		(token numArgs < 1 or: [token = #| and: [ coll size > 1 ] ])
			ifTrue: [(nonKeywords := nonKeywords + 1) > 1 ifTrue: [^ coll]]
						"done with header"
			ifFalse: [nonKeywords := 0].
		coll addLast: token.
		self scanToken].
	(currentComment == nil or: [currentComment isEmpty])
		ifTrue: [coll addLast: nil]
		ifFalse: [coll addLast: currentComment removeFirst.
			[currentComment isEmpty] whileFalse: [
				coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].
	^ coll! !
!ReferenceStream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16924666!
nextPutWeak: anObject
    "Write a weak reference to anObject to the receiver stream. Answer anObject.
     If anObject is not a reference type of object, then just put it normally.
     A 'weak' reference means: If anObject gets written this stream via nextPut:,
     then its weak references will become normal references. Otherwise they'll
     read back as nil. -- "
    | typeID referencePosn |

    "Is it a reference type of object? If not, just write it normally."
    typeID _ self typeIDFor: anObject.
    (self isAReferenceType: typeID) ifFalse: [^ self nextPut: anObject].

    "Have we heard of and maybe even written anObject before?"
    referencePosn _ references at: anObject ifAbsent: [
			references at: anObject put: OrderedCollectionEnu new].

    "If referencePosn is an Integer, it's the stream position of anObject.
     Else it's a collection of hopeful weak-references to anObject."
    referencePosn isInteger ifFalse:
        [referencePosn add: byteStream position - basePos.		"relative"
        referencePosn _ self vacantRef].
    self outputReference: referencePosn.		"relative"

    ^ anObject! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50513614!
testCreationImmutability

	| graph edges |

	edges := OrderedCollectionEnu new
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		add: (Edge from: 3 to: 4);
		add: (Edge from: 1 to: 4);
		add: (Edge from: 4 to: 4);
		yourself.
	
	graph := Graph edges: edges.		

	"Verify if modifying the entrance collection the graph follows immutable"
	edges add: (Edge from: 4 to: 5).
	self assert: 5 equals: graph edges size.
	self deny: (graph edges includes: (Edge from: 4 to: 5))! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16907782!
braceExpression
	" { elements } => BraceNode."

	| elements locations loc more sourceRangeStart sourceRangeEnd |

	sourceRangeStart _ hereMark.
	elements := OrderedCollectionEnu new.
	locations := OrderedCollectionEnu new.
	self advance.
	more := hereType ~~ #rightBrace.
	[more]
		whileTrue: 
			[loc := hereMark + requestorOffset.
			self expression
				ifTrue: 
					[elements addLast: parseNode.
					locations addLast: loc]
				ifFalse:
					[^self expected: 'Variable or expression or right brace'].
			(self match: #period)
				ifTrue: [more := hereType ~~ #rightBrace]
				ifFalse: [more := false]].
	parseNode := BraceNode new elements: elements sourceLocations: locations.
	sourceRangeEnd _ hereEnd.

	(self match: #rightBrace) ifFalse: [^self expected: 'Period or right brace'].
	encoder noteSourceRange: (sourceRangeStart to: sourceRangeEnd) forNode: parseNode.

	^true! !
!GraphPathFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50526781!
findEdgesFrom: source to: target

	| convergingEdges matchingEdge |

	convergingEdges := graph edgesConvergingTo: target.
	matchingEdge := convergingEdges detect: [ :anEdge | anEdge goesFrom: source to: target ] ifNone: [ nil ].
		
	^matchingEdge isNil 
		ifTrue: [ self findEdgesFrom: source toAnyEdgeOf: convergingEdges ]
		ifFalse: [ OrderedCollectionEnu with: matchingEdge ].
				

! !
!TopologicalSortTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50513901!
testValue

	"Example from http://en.wikipedia.org/wiki/Topological_sorting"

	| graph result |

	graph :=
		Graph edges: (
			OrderedCollectionEnu new
				add: (Edge from: 7 to: 11);
				add: (Edge from: 7 to: 8);
				add: (Edge from: 11 to: 2);
				add: (Edge from: 11 to: 9);
				add: (Edge from: 11 to: 10);
				add: (Edge from: 5 to: 11);
				add: (Edge from: 3 to: 8);
				add: (Edge from: 3 to: 10);
				add: (Edge from: 8 to: 9);
				yourself).

	result := (TopologicalSort for: graph) value asOrderedCollection.

	self assert: 8 equals: result size.
	self assert: (result includesAllOf: #(3 5 7 11 8 2 9 10))! !
!Catalog methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50544664!
processEmptySearchQuery
	
	^ OrderedCollectionEnu new! !
!ChangeSet class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16806401 overrides: 16904184!
initialize
	"
	ChangeSet initialize
	"
	AllChangeSets _ OrderedCollectionEnu new.
	
	self initializeNotificationActions! !
!TemporaryToInstanceVariable class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16961104!
assertNoOtherMethodIn: aClass orSubclassesDefinesTemporaryNamed: aTemporaryVariableName

 	| methodsDefiningTemporaryInHierarchy |

	methodsDefiningTemporaryInHierarchy := OrderedCollectionEnu new.
	aClass withAllSubclassesDo: [ :subclass | 
		methodsDefiningTemporaryInHierarchy addAll: (subclass methodsWithArgumentOrTemporaryNamed: aTemporaryVariableName) ].

	methodsDefiningTemporaryInHierarchy size > 1 ifTrue: [
		self 
			canNotRefactorDueToReferencesError: self temporaryExistsInOtherMethodsErrorDescription
			references: (methodsDefiningTemporaryInHierarchy collect: [ :implementor | MethodReference method: implementor ])
			to: aTemporaryVariableName. ].! !
!TextComposition methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16965574!
recomposeFrom: startArg to: stopArg delta: delta
	"Recompose this text.  The altered portion is between start and stop.
	Recomposition may continue to the end of the text, due to a ripple effect.
	Delta is the amount by which the current text is longer than it was
	when its current lines were composed.
	Expand the requested interval to include whole paragraphs because there could be paragraph attributes."
	| intervalToFix start stop startLine newLines partialMaxRightX |
	"Have to recompose line above in case a word-break was affected."
	intervalToFix _ model actualContents encompassParagraph: (startArg to: stopArg).
	start _ intervalToFix first.
	stop _ intervalToFix last.
	startLine _ (self lineIndexFor: start) - 1 max: 1.
	[startLine > 1 and: [(lines at: startLine-1) top = (lines at: startLine) top]]
		whileTrue: [startLine _ startLine - 1].  "Find leftmost of line pieces"
	newLines _ OrderedCollectionEnu new: lines size + 1.
	1 to: startLine-1 do: [:i | newLines addLast: (lines at: i)].
	partialMaxRightX _ self composeLinesFrom: (lines at: startLine) first to: stop delta: delta
			into: newLines priorLines: lines
			atY: (lines at: startLine) top.
	"Partial recomposition computes actual right border only of recompsed text,
	so, it could make maxRightX larger but not smaller.
	This means that if the longest line gets shortened, we won't know, and maxRightX will be erroneously large"
	maxRightX _ maxRightX max: partialMaxRightX! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16801969!
removeSelections
	"Remove the selected items from the receiver.  9/18/96 sw"

	| newChangeList newList |

	newChangeList _ OrderedCollectionEnu new.
	newList _ OrderedCollectionEnu new.

	1 to: changeList size do: [ :i |
		(listSelections at: i) ifFalse: [
			newChangeList add: (changeList at: i).
			newList add: (list at: i)]].
	newChangeList size < changeList size
		ifTrue: [
			changeList _ newChangeList.
			list _ newList.
			listIndex _ 0.
			self clearSelections ].
	self changed: #list

	! !
!CompiledMethodCoverageNotifier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50553948 overrides: 16920235!
initialize
	
	coverageTrackers := OrderedCollectionEnu new.! !
!TypeCheckerTestMethods methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50627513!
typeCheckMessageWithReturnOnIfTrue

	| temp1  |
	
	temp1 := OrderedCollectionEnu new.
	temp1 := Color new.
	
	temp1 isCollection ifTrue: [ ^self ].
	temp1 alpha! !
!DefinedByRulesTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50533074!
testIncludedFromTo

	| set |
	
	set := DefinedByRules for: NaturalNumbersTestUniverse new.
	set 
		addRule: (SpecificObjectInclusionRule for: 1);
		addRule: (SpecificObjectInclusionRule for: 2).
		
	self assert: (set includedFrom: 0 to: 10) size = 2.
	self assert: ((set includedFrom: 0 to: 10) asOrderedCollection includesAllOf: (OrderedCollectionEnu with: 1 with: 2)).
	self assert: (set includedFrom: 1 to: 2) size = 2.
	self assert: ((set includedFrom: 1 to: 2) asOrderedCollection includesAllOf: (OrderedCollectionEnu with: 1 with: 2)).
	self assert: (set includedFrom: 2 to: 3) size = 1.
	self assert: ((set includedFrom: 2 to: 3) asOrderedCollection includesAllOf: (OrderedCollectionEnu with: 2)).
	self assert: (set includedFrom: 3 to: 4) isEmpty! !
!ChangeSelectorKeepingParameters methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50506881 overrides: 16803459!
implementorNewSourceCodeOf: anImplementor

	|  newSource rangesToNewKeywords |

	rangesToNewKeywords := OrderedCollectionEnu new.
	currentImplementorMethodNode := anImplementor notOptimizedMethodNode.

	currentImplementorMethodNode selectorKeywordsPositions withIndexDo: [ :aKeywordRange :index |
		self addImplementorSelectorRanges: aKeywordRange at: index to: rangesToNewKeywords ].

	newSource := anImplementor sourceCode copyReplacing: rangesToNewKeywords.
	^newSource! !
!RemoveParameterWithActualScopeApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50622149 overrides: 16803828!
createSenders

	^OrderedCollectionEnu new.
! !
!Stream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16945744!
next: anInteger 
	"Answer the next anInteger number of objects accessible by the receiver."

	| aCollection |
	aCollection _ OrderedCollectionEnu new.
	anInteger timesRepeat: [aCollection addLast: self next].
	^aCollection! !
!SequenceableCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50575130!
testDoSeparatedByDoesNotValueSeparatedBlockOnLastElement

	| collectionToTraverse traversedElements |

	collectionToTraverse := OrderedCollectionEnu with: 1 with: 2.
	traversedElements := OrderedCollectionEnu new.

	self shouldntFail: [ collectionToTraverse do: [ :anElement | traversedElements add: anElement ] separatedBy: [ traversedElements add: $-] ].

	self assert: traversedElements equals: (OrderedCollectionEnu with: 1 with: $- with: 2).! !
!AnalysisResultWindow class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50642926!
pickStartPositionFromSnapshots: userChangesFileName	
	
	"Prompt with a menu of how far back to go when browsing a changes file."

	| banners positions pos chunk i startPosition |
	
	startPosition := self lastSnapshotPosition: userChangesFileName.
	userChangesFileName asFileEntry readStreamDo: [ :changesFile |
		banners _ OrderedCollectionEnu new.
		positions _ OrderedCollectionEnu new.
		pos _ startPosition.
		[pos = 0
			or: [banners size > 20]] 		"Go back at most 20 image exits"
			whileFalse: [
				changesFile position: pos.
				chunk _ changesFile nextChunk.
				i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.
				i > 0
					ifTrue: [
						positions addLast: pos.
						banners addLast: (chunk copyFrom: 5 to: i - 2).
						pos _ Number readFrom: (chunk copyFrom: i + 13 to: chunk size)]
					ifFalse: [
						pos _ 0]].
	].
	positions addLast: 0.
	banners addLast: 'Whole file'.
	^ (SelectionMenu labelList: banners selections: positions)
				startUpWithCaption: 'Browse as far back as...'.
! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16813827!
classesThatImplementAllOf: selectorSet
	"Return an array of any classes that implement all the messages in selectorSet."

	| found remaining |
	found _ OrderedCollectionEnu new.
	selectorSet do:
		[:sel | (self methodDict includesKey: sel) ifTrue: [found add: sel]].
	found isEmpty
		ifTrue: [^ self subclasses inject: Array new
						into: [:subsThatDo :sub |
							subsThatDo , (sub classesThatImplementAllOf: selectorSet)]]
		ifFalse: [remaining _ selectorSet copyWithoutAll: found.
				remaining isEmpty ifTrue: [^ Array with: self].
				^ self subclasses inject: Array new
						into: [:subsThatDo :sub |
							subsThatDo , (sub classesThatImplementAllOf: remaining)]]! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16847090!
addMultiRange: aRange for: aNode

	| ranges |
	
	"I'm using an OrderedCollection because ranges are added in order, while parsing the source code.
	If this constrain is not hold, a SortedCollection should be used - Hernan"
	ranges := sourceRanges at: aNode ifAbsentPut: [ OrderedCollectionEnu new ].
	ranges add: aRange asSourceCodeInterval.
	
	^aNode ! !
!SelectionMenu class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16932704!
fromArray: anArray
	"Construct a menu from anArray.  The elements of anArray must be either:
	*  A pair of the form: <label> <selector>
or	*  The 'dash' (or 'minus sign') symbol

	Refer to the example at the bottom of the method"

	| labelList lines selections anIndex |
	labelList _ OrderedCollectionEnu new.
	lines _ OrderedCollectionEnu new.
	selections _ OrderedCollectionEnu new.
	anIndex _ 0.
	anArray do:
		[:anElement |
			anElement size = 1
				ifTrue:
					[(anElement == #-) ifFalse: [self error: 'badly-formed menu constructor'].
					lines add: anIndex]
				ifFalse:
					[anElement size = 2 ifFalse: [self error: 'badly-formed menu constructor'].
					anIndex _ anIndex + 1.
					labelList add: anElement first.
					selections add: anElement second]].
	^ self labelList: labelList lines: lines selections: selections

"(SelectionMenu fromArray:
	#(	('first label'		moja)
		('second label'	mbili)
		-
		('third label' 	tatu)
		-
		('fourth label'	nne)
		('fifth label'	tano))) startUp"! !
!ReceiverTypesOfMessageSendsConform methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50614689 overrides: 16902254!
value

	notIncludedReceiverTypesInMessageSends := OrderedCollectionEnu new.

	implementors ifNotEmpty: [ 
		sentSelector := implementors anyOne selector.
		types := implementors collect: [ :anImplementor | anImplementor methodClass ].
		
		senders do: [ :aSender | 
			currentSender := aSender.
			currentSenderMethodClass := aSender methodClass.
			currentSender notOptimizedMethodNode accept: self ]].
	
	^notIncludedReceiverTypesInMessageSends! !
!NotImplementedMethodTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50618937!
test09rangesOASentSelectorWhenSendToReceiverTypesIsEmpty

	self assert: ((NotImplementedMethod class: self class selector: #none) rangesOf: #size whenSendTo: { OrderedCollectionEnu })
 isEmpty! !
!WorldMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16982305!
cleanseStepList
	"Remove morphs from the step list that are not in this World."

	| deletions |
	deletions _ OrderedCollectionEnu new.
	stepList do: [ :entry |
		entry receiver world == self ifFalse: [
			deletions add: entry]].
	deletions do: [ :entry|
		stepList remove: entry ].

	deletions _ OrderedCollectionEnu new.
	alarms do: [ :entry |
		((entry receiver is: #Morph) and: [ entry receiver world == self ]) ifFalse: [
			deletions add: entry]].
	deletions do: [ :entry|
		alarms remove: entry ]! !
!Form class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50352413!
toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors _ `Color red wheel: 12`.
	color _ 8.
	[ true ] whileTrue: [
		queue _ OrderedCollectionEnu new: 32.
		16 timesRepeat: [queue addLast: `-40@ -40`].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point _ point * 4 + Sensor mousePoint // 5.
			point _ point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !
!InlineTemporaryVariableApplier class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50461183!
findSourceRangesOfNode: aParseNode using: completeSourceRanges

	| ranges |
	
	ranges := OrderedCollectionEnu new.
	
	(completeSourceRanges associations select: [:aNodeAndRange | aNodeAndRange key equivalentTo: aParseNode])
	 	do: [:nodeAndRanges | ranges addAll: nodeAndRanges value].
	
	^ranges.! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50366143!
browseClassVarRefs 
	"Put up a menu offering all class variable names; if the user chooses one, open up a message-list browser on all methods that refer to the selected class variable"

	| lines labelStream allVars index owningClasses |
	lines _ OrderedCollectionEnu new.
	allVars _ OrderedCollectionEnu new.
	owningClasses _ OrderedCollectionEnu new.
	labelStream _ String writeStream.
	self withAllSuperclasses reverseDo: [ :class | | vars |
		vars _ class classVarNames asArray sort.
		vars do: [ :var |
			labelStream position = 0 ifFalse: [labelStream newLine].
			labelStream nextPutAll: var.
			allVars add: var.
			owningClasses add: class].
		vars isEmpty ifFalse: [ lines add: allVars size ]].
	labelStream contents isEmpty ifTrue: [^Smalltalk beep]. "handle nil superclass better"
	index _ (PopUpMenu labels: labelStream contents lines: lines) startUpMenu.
	index = 0 ifTrue: [^ self].
	Smalltalk browseAllCallsOn:
		((owningClasses at: index) classPool associationAt: (allVars at: index))! !
!TextComposition methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16965526!
composeAll
	"Full recomposition computes actual right border of text,
	only limited by longest line and (extentForComposing x)"
	maxRightX _ self
		composeLinesFrom: 1
		to: model textSize
		delta: 0
		into: OrderedCollectionEnu new
		priorLines: Array new
		atY: 0! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50513484!
testAccessImmutability

	| graph edges edgesPreviousAdd nodesPreviousAdd |

	edges := OrderedCollectionEnu new
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		add: (Edge from: 3 to: 4);
		add: (Edge from: 1 to: 4);
		add: (Edge from: 4 to: 4);
		yourself.
	
	graph := Graph edges: edges.		

	edgesPreviousAdd := graph edges.
	nodesPreviousAdd := graph nodes.

	edges := graph edges.
	edges add: (Edge from: 4 to: 5).

	self assert: ((edges copy removeAll: graph edges; yourself) includes: (Edge from: 4 to: 5)).
	self assert: (edgesPreviousAdd copy removeAll: graph edges; yourself) isEmpty.	
	self assert: (graph edges removeAll: edgesPreviousAdd; yourself) isEmpty.	
	
	self assert: (nodesPreviousAdd copy removeAll: graph nodes; yourself) isEmpty.	
	self assert: (graph nodes removeAll:  nodesPreviousAdd; yourself) isEmpty
! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16832488!
stackOfSize: limit 
	"Answer an OrderedCollection of the top 'limit' contexts
	 on the receiver's sender chain."

	| stack ctxt |
	stack := OrderedCollectionEnu new.
	stack addLast: (ctxt := self).
	[(ctxt := ctxt sender) notNil
	 and: [stack size < limit]] whileTrue:
		[stack addLast: ctxt].
	^stack! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50513662!
testGraphCreation

	| graph edges |

	edges :=
		OrderedCollectionEnu new
			add: (Edge from: 1 to: 2);
			add: (Edge from: 2 to: 3);
			yourself.

	graph := Graph edges: edges.

	self assert: graph edges size = 2.
	self assert: (graph edges includes: (Edge from: 1 to: 2)).
	self assert: (graph edges includes: (Edge from: 2 to: 3)).

	self assert: (graph nodes size = 3).
	self assert: (graph nodes includes: 1).
	self assert: (graph nodes includes: 2).
	self assert: (graph nodes includes: 3)! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16801987!
removeUpToDate
	"Remove all up to date version of entries from the receiver"

	| newChangeList newList |
	newChangeList _ OrderedCollectionEnu new.
	newList _ OrderedCollectionEnu new.
	changeList with: list do: [ :chRec :strNstamp | | keep cls name |
		keep _ chRec isClassDeletion not or: [ chRec changeClass notNil ]. "If a class deletion, and class already gone, don't keep it"
		keep ifTrue: [
			(cls _ chRec changeClass) ifNotNil: [ | sel str |
				str _ chRec string.
				sel _ chRec methodSelector.
				keep _ chRec isMethodDeletion
					ifTrue: [cls includesSelector: sel]
					ifFalse: [(cls sourceCodeAt: sel ifAbsent: nil)  ~= str]]].
		(chRec changeType == #classComment and: [
				name _ chRec changeClassName.
				Smalltalk includesKey: name]) ifTrue: [
			cls _ Smalltalk at: name.
			keep _ cls organization classComment ~= chRec text ].
		(chRec changeType == #classDefinition and: [
				name _ chRec changeClassName.
				Smalltalk includesKey: name]) ifTrue: [
			cls _ Smalltalk at: name.
			chRec isMetaClassChange ifTrue: [ cls _ cls class ].
			keep _ cls definition ~= chRec text ].
		keep ifTrue: [
			newChangeList add: chRec.
			newList add: strNstamp]].
	newChangeList size < changeList size ifTrue: [
		changeList _ newChangeList.
		list _ newList.
		listIndex _ 0.
		self clearSelections ].
	self changed: #list! !
!DefinedByRulesTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50533100!
testIncludedIn

	| set |
	
	set := DefinedByRules for: NaturalNumbersTestUniverse new.
	set 
		addRule: (SpecificObjectInclusionRule for: 1);
		addRule: (SpecificObjectInclusionRule for: 2).
		
	self assert: (set includedIn: (0 to: 10)) size = 2.
	self assert: ((set includedIn: (0 to: 10)) asOrderedCollection includesAllOf: (OrderedCollectionEnu with: 1 with: 2)).
	self assert: (set includedIn: (1 to: 2)) size = 2.
	self assert: ((set includedIn: (1 to: 2)) asOrderedCollection includesAllOf: (OrderedCollectionEnu with: 1 with: 2)).
	self assert: (set includedIn: (2 to: 3)) size = 1.
	self assert: ((set includedIn: (2 to: 3)) asOrderedCollection includesAllOf: (OrderedCollectionEnu with: 2)).
	self assert: (set includedIn: (3 to: 4)) isEmpty! !
!FileList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16855077!
itemsForAnyFile1
	"Answer a list of universal services that could apply to any file"
	
	| services |
	services _ OrderedCollectionEnu new.
	(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue: [
		services add: self serviceGet ].
	services add: self serviceRenameFile. 
	services add: self serviceDeleteFile.
	^ services! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50346307!
browseClassesWithNamesContaining: aString caseSensitive: caseSensitive 
	"Smalltalk browseClassesWithNamesContaining: 'eMorph' caseSensitive: true "
	"Launch a class-list list browser on all classes whose names containg aString as a substring."

	| suffix aList |
	suffix _ caseSensitive
				ifTrue: [' (case-sensitive)']
				ifFalse: [' (use shift for case-sensitive)'].
	aList _ OrderedCollectionEnu new.
	Smalltalk allClassesDo: [ :class |
		(class name includesSubstring: aString caseSensitive: caseSensitive)
			ifTrue: [aList add: class name]].
	aList notEmpty
		ifTrue: [HierarchyBrowserWindow forClassesNamed: aList asSet sorted title: 'Classes whose names contain ' , aString , suffix]! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50342327!
testFormatter2
	"Smalltalk testFormatter2"
	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged.
	The formatting used will be classic monochrome"
	| newCodeString badOnes n oldCodeString oldTokens newTokens |
	badOnes _ OrderedCollectionEnu new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldCodeString _ (cls sourceCodeAt: selector) asPlainString.
					newCodeString _ cls compilerClass new
						format: oldCodeString
						in: cls
						notifying: nil.
					oldTokens _ oldCodeString findTokens: Character separators.
					newTokens _ newCodeString findTokens: Character separators.
					oldTokens = newTokens ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	Smalltalk
		browseMessageList: badOnes
		name: 'Formatter Discrepancies'.! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50598301!
doubleResumeTestResults

       ^OrderedCollectionEnu new
               add: self doSomethingString;
               add: self doSomethingElseString;
               add: self doYetAnotherThingString;
               yourself! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50598124!
doubleOuterPassTestResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		add: self doSomethingElseString;
		yourself! !
!MessageKeywordsAndParametersModel methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50610251!
initializeFor: someVariablesToExtract

	models := OrderedCollectionEnu new.
	someVariablesToExtract do: [:variableToExtract | | keywordParameterModel defaultName parameterModel |
		keywordParameterModel := Dictionary new.
		keywordParameterModel at: #variableName put: variableToExtract.
		keywordParameterModel at: #keyword put: (PluggableTextModel on:  self).
		parameterModel := PluggableTextModel on: self.
		defaultName := (variableToExtract first isVowel ifTrue: ['an'] ifFalse: ['a']), variableToExtract capitalized.
		parameterModel actualContents: defaultName.
		keywordParameterModel at: #parameterName put: parameterModel.

		models add: keywordParameterModel].! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16805633!
methodsWithoutComments
	"Return a collection representing methods in the receiver which have no precode comments"

	| slips |
	slips _ OrderedCollectionEnu new.
	self changedClasses do:
		[:aClass |
		(self methodChangesAtClass: aClass name) associationsDo: 
				[:mAssoc | (#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse:
					[(aClass selectors includes:  mAssoc key) ifTrue:
						[(aClass firstPrecodeCommentFor: mAssoc key) isEmptyOrNil
								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].
	^ slips

	"
	Smalltalk browseMessageList: (ChangeSet changeSetForBaseSystem methodsWithoutComments) name: 'methods lacking comments'
	"! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50506695!
messagePart: level repeat: repeat

	| start receiver selector args precedence words keywordStart |

	[receiver := parseNode.
	(hereType == #keyword and: [level >= 3])
		ifTrue: [
			start := self startOfNextToken.
			selector := source collectionSpecies writeStream.
			args := OrderedCollectionEnu new.
			words := OrderedCollectionEnu new.
			[hereType == #keyword]
				whileTrue:
					[keywordStart := self startOfNextToken + requestorOffset.
					selector nextPutAll: self advance.
					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 2 repeat: true.
					args addLast: parseNode].
			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector := sym])
				ifFalse: [ selector := self correctSelector: selector contents
										wordIntervals: words
										exprInterval: (start to: self endOfLastToken)
										ifAbort: [ ^ self fail ] ].
			precedence := 3]
		ifFalse: [

			level >= 2 ifTrue: [self transformVerticalBarAndUpArrowIntoABinarySelector].
			((hereType == #binary )
				and: [level >= 2])
				ifTrue:
					[start := self startOfNextToken.
					selector := self advance asSymbol.
					words := OrderedCollectionEnu with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 1 repeat: true.
					args := Array with: parseNode.
					precedence := 2]
				ifFalse: [hereType == #word
						ifTrue:
							[start := self startOfNextToken.
							selector := self advance.
							args := #().
							words := OrderedCollectionEnu with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
							(Symbol hasInterned: selector ifTrue: [ :sym | selector := sym])
								ifFalse: [ selector := self correctSelector: selector
													wordIntervals: words
													exprInterval: (start to: self endOfLastToken)
													ifAbort: [ ^ self fail ] ].
							precedence := 1]
						ifFalse: [^args notNil]]].

	parseNode := MessageNode new
				optimizeSpecialSends: optimizeSpecialSends;
				receiver: receiver
				selector: selector
				arguments: args
				precedence: precedence
				from: encoder
				sourceRange: (start to: self endOfLastToken)
				keywordsRanges: words.
	repeat]
		whileTrue: [].
	^true! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50363507!
keywordPattern

	| keywordRanges selector arguments |
	
	selector := source collectionSpecies writeStream.
	arguments := OrderedCollectionEnu new.
	keywordRanges := OrderedCollectionEnu new.
	
	[hereType == #keyword] whileTrue:[ 
		self addKeywordPatternPartTo: selector keywordRanges: keywordRanges arguments: arguments ].
		
	^ {selector contents asSymbol. arguments. 3. keywordRanges}
		! !
!TextComposition methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16965791!
addSelectionRectsFrom: characterBlock1 to: characterBlock2 to: aStream
	"Return an array of rectangles representing the area between the two character blocks given as arguments."
	| line1 line2 rects cb1 cb2 w line |
	characterBlock1 <= characterBlock2
		ifTrue: [cb1 _ characterBlock1.  cb2 _ characterBlock2]
		ifFalse: [cb2 _ characterBlock1.  cb1 _ characterBlock2].
	cb1 = cb2 ifTrue: [
		w _ 6.
		^ aStream nextPut: (cb1 topLeft - (w@0) corner: cb1 bottomLeft + ((w+1)@0))].
	line1 _ self lineIndexFor: cb1 stringIndex.
	line2 _ self lineIndexFor: cb2 stringIndex.
	line1 = line2 ifTrue: [
		^ aStream nextPut: (cb1 topLeft corner: cb2 bottomRight)].
	rects _ OrderedCollectionEnu new.
	rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).
	line1+1 to: line2-1 do: [ :i |
		line _ lines at: i.
		(line left = rects last left and: [ line right = rects last right ])
			ifTrue: [ "new line has same margins as old one -- merge them, so that the caller gets as few rectangles as possible"
					| lastRect |
					lastRect _ rects removeLast.
					rects add: (lastRect bottom: line bottom) ]
			ifFalse: [ "differing margins; cannot merge"
					rects add: line rectangle ] ].
	aStream nextPutAll: rects.
	aStream nextPut: ((lines at: line2) topLeft corner: cb2 bottomLeft)! !
!IsKindOfTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50626187 overrides: 50625983!
buildCastApplierBefore: aPreviousCastingApplier 

	^EffectiveTypeCastApplier 
		casts: (OrderedCollectionEnu with: self buildTypeCast)
		rejections: OrderedCollectionEnu new
		previous: aPreviousCastingApplier
	! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16846668!
tempsAndBlockArgs
	| tempNodes |
	tempNodes := OrderedCollectionEnu new.
	scopeTable associationsDo:
		[:assn | | var |
		var := assn value.
		(var isTemp
		 and: [var isMethodArg not
		 and: [var scope = 0 or: [var scope = -1]]]) ifTrue:
			[tempNodes add: var]].
	^tempNodes! !
!ImplementorsCatalog methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50544800 overrides: 50544668!
processNonEmptySearchQuery: aQuery

	| implementors |
	implementors _ OrderedCollectionEnu new.
	
	Smalltalk allBehaviorsDo: [ :class | 
		class selectors
			select: [ :selector | selector includesSubstring: aQuery caseSensitive: false ]
			thenDo: [ :selector | implementors add: (MethodReference class: class selector: selector) ] ].
		
	^ resultsSorter value: implementors! !
!MessageTally methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16887298!
bump: hitCount fromSender: senderTally
	"Add this hitCount to the total, and include a reference to the
	sender responsible for the increment"
	self bump: hitCount.
	senders ifNil: [senders _ OrderedCollectionEnu new].
	senderTally == nil
		ifFalse: [senders add: (senderTally copyWithTally: hitCount)]! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 16785663!
allSubclasses
	"A breadth-first iterative algorithm. Significantly faster than a recursive, depth-first implementation."

	| answer finger fingerLimit each |
	answer := OrderedCollectionEnu new.
	self subclassesDo: [:some | answer add: some].
	finger := 0.
	fingerLimit := answer size.
	[finger < fingerLimit] whileTrue:
		[
			finger + 1 to: fingerLimit do:
				[:index |
					each := answer at: index.
					each subclassesDo: [:some | answer add: some]
				].
			finger := fingerLimit.
			fingerLimit := answer size.
		].
	^answer! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50549096!
generateAssertionsFor: report 
	
	"NPM: for use during development only.
	Generates assertions for using in tests from report.
	Hacky, but it does the job."
	
	| assertions assertionsSourceCode sortedSourceRanges sourceCode sourceCodeByRange sourceRanges |
	sourceRanges := report fullyCoveredSourceRanges, report partiallyCoveredSourceRanges, report uncoveredSourceRanges.
	sortedSourceRanges := sourceRanges asOrderedCollection sort: [ :sourceRange :otherSourceRange | sourceRange first < otherSourceRange first ].
	
	sourceCode := report compiledMethod sourceCode.
	sourceCodeByRange := sortedSourceRanges
		inject: OrderedDictionary new
		into: [ :result :sourceCodeRange |
			result
				at: sourceCodeRange
				put: (sourceCode copyFrom: sourceCodeRange first to: sourceCodeRange last);
				yourself ].
	
	assertions := OrderedCollectionEnu streamContents: [ :contents | 
		sourceCodeByRange keysAndValuesDo: [ :sourceRange :sourceRangeCode | | assertion assertionKind | 
			assertionKind := (sourceRanges includes: sourceRange)
				ifTrue: [ 'assert' ] ifFalse: [ 'deny' ].
				
			assertion := 'self {1}: #{2} hasBeenCoveredFrom: {3} to: {4} as: ''{5}''.' format: {
				assertionKind.
				report selector asString.
				sourceRange first asString.
				sourceRange last asString.
				sourceRangeCode }.
			
			contents nextPut: assertion ]].
	
	assertionsSourceCode := (String newLineString, String tab) join: assertions.
	
	Clipboard storeObject: assertionsSourceCode.! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50624073!
calculateLabelsAndLines

	labels := OrderedCollectionEnu new.
	lines := OrderedCollectionEnu new.
	icons := OrderedCollectionEnu new.
	actions := OrderedCollectionEnu new.

	self 
		addCommonSupertypeLabel;
		addTypesLabels;
		addCrudOptions;
		addIncompleteTypesReasons
! !
!TypeCheckerTestMethods methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50627494!
typeCheckMessageWithFalse_True_False_InSubclasses

	| temp1  |
	
	temp1 := 1.
	temp1 := OrderedCollectionEnu new.
	temp1 := Color new.
	
	temp1 isCollection 
		ifTrue: [ temp1 add: 1 ] 
		ifFalse: [ temp1 isNumber 
			ifTrue: [ temp1 + 1 ]
			ifFalse: [ temp1 alpha ]]! !
!EffectiveTypeCastApplier class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50625930!
previous: aPreviousCastingStrategy

	^self 
		casts: OrderedCollectionEnu new 
		rejections: OrderedCollectionEnu new
		previous: aPreviousCastingStrategy ! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:26' prior: 50631500!
buildLabelsPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollectionEnu with: (Color fromHexString: '#fCD89A') with: 'Sunset'.
	ocean := OrderedCollectionEnu with: (Color fromHexString: '#EFF6E0') with: 'Ocean'.
	forest := OrderedCollectionEnu with: (Color fromHexString: '#8DAA91') with: 'Forest'.
	ash := OrderedCollectionEnu with: (Color fromHexString: '#000000') with: 'Ash'.
	light := OrderedCollectionEnu with: (Color fromHexString: '#946846') with: 'Light'.
	
	labelsPalette := OrderedCollectionEnu with: sunset with: ocean with: forest with: ash with: light.! !
!DifferenceFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16842928!
unfold: pointCollection
	| pending visited point |
	pending := OrderedCollectionEnu withAll: pointCollection.
	visited := OrderedCollectionEnu new.
	[pending notEmpty] whileTrue: [
		point := pending removeFirst.
		(visited includes: point) ifFalse: [
			self unfold: point on: pending.
			visited add: point]].
	^visited
! !
!IntroduceNullObjectForm methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50601519!
buildPreviewOf: anIfNilCheckForm

	| keywordParamStrings previewContent currentlyShownPreview currentlyShownTable |

	currentlyShownTable := (anIfNilCheckForm submorphs at: 1) submorphs at: 2.
	currentlyShownPreview := (anIfNilCheckForm submorphs at: 1) submorphs at: 1.

	keywordParamStrings := OrderedCollectionEnu new.
	currentlyShownTable keywordsAndParametersDo: [:keyword :parameterName |
		(keyword isEmpty or: [parameterName isEmpty]) ifTrue: [
			currentlyShownPreview model actualContents: self previewUnavailableMessage.
			^self].

		keywordParamStrings addFirst: '', keyword, ': ', parameterName.].

	previewContent := ' ' join: keywordParamStrings.

	currentlyShownPreview model actualContents: previewContent.! !
!SHParserST80 methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16929145!
pushArgument: aString 
	(arguments at: blockDepth ifAbsentPut: [OrderedCollectionEnu new: 10]) 
		add: aString! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16830035!
messageSendsRangesOf: aSentSelector

	| methodNode ranges |

	methodNode := self methodNode.
	ranges := OrderedCollectionEnu new.

	methodNode nodesDo: [ :aParseNode |
		(aParseNode isMessageNamed: aSentSelector) ifTrue: [
			(methodNode rangeForNode: aParseNode ifAbsent: nil) ifNotNil: [ :range |
				ranges add: range ]]].

	^ranges ! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50549349!
cascadeNodeWithMessageSendReceiver

	OrderedCollectionEnu new
		copy;
		yourself! !
!EffectiveTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50626019!
initializeAfterMessageTypeCasts

	afterMessageTypeCasts := OrderedCollectionEnu new.
	self 
		addToAfterMessageTypeCasts: [ self buildTypeReject ] ifReturns: castingBlock;
		addToAfterMessageTypeCasts: [ self buildTypeCast ] ifReturns: rejectingBlock
			
	! !
!MinusInfinity methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50525816 overrides: 50524003!
composeWithNumber: aNumber

	^CompoundMeasure measures: (OrderedCollectionEnu with: self with: aNumber)! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16954046!
allPrimitiveMessages
	"Answer an OrderedCollection of all the methods that are implemented by 
	primitives."

	| aColl method | 
	aColl _ OrderedCollectionEnu new: 200.
	self allBehaviorsDo: [ :class |
		class selectorsDo: [ :sel | 
			method _ class compiledMethodAt: sel.
			method primitive ~= 0 ifTrue: [
				aColl addLast: class name , ' ' , sel 
					, ' ' , method primitive printString]]].
	^aColl! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16801885!
removeDoIts
	"Remove doits from the receiver, other than initializes. 1/26/96 sw"

	| newChangeList newList |
	newChangeList _ OrderedCollectionEnu new.
	newList _ OrderedCollectionEnu new.

	changeList with: list do: [ :chRec :str |
		(chRec isDoIt not or: [str endsWith: 'initialize'])
			ifTrue: [
				newChangeList add: chRec.
				newList add: str]].
	newChangeList size < changeList size
		ifTrue: [
			changeList _ newChangeList.
			list _ newList.
			listIndex _ 0.
			self clearSelections ].
	self changed: #list.

	! !
!TestResult methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16962152!
failures
	failures
		ifNil: [failures := OrderedCollectionEnu new].
	^failures
			! !
!Schedule methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16932249!
dateAndTimes

	| dateAndTimes |
	dateAndTimes _ OrderedCollectionEnu new.
	self scheduleDo: [ :e | dateAndTimes add: e ].
	^ dateAndTimes asArray.! !
!Color class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16825863!
initializeGrayToIndexMap
	"Build an array of gray values available in the 8-bit colormap. This array is indexed by a gray level between black (1) and white (256) and returns the pixel value for the corresponding gray level."
	"Note: This method must be called after initializeIndexedColors, since it uses IndexedColors."
	"
	Color initializeGrayToIndexMap
	"

	| grayLevels grayIndices c distToClosest dist indexOfClosest indexedColors |
	"record the level and index of each gray in the 8-bit color table"
	grayLevels _ OrderedCollectionEnu new.
	grayIndices _ OrderedCollectionEnu new.
	indexedColors _ self indexedColors.
	"Note: skip the first entry, which is reserved for transparent"
	2 to: indexedColors size do: [:i |
		c _ indexedColors at: i.
		c saturation = 0.0 ifTrue: [  "c is a gray"
			grayLevels add: (c green * 255) rounded.  "0 to 255; R, G, and B are the same"
			grayIndices add: i - 1]].  "pixel values are zero-based"
	grayLevels _ grayLevels asArray.
	grayIndices _ grayIndices asArray.

	"for each gray level in [0..255], select the closest match"
	GrayToIndexMap _ ByteArray new: 256.
	0 to: 255 do: [ :level |
		distToClosest _ 10000.  "greater than distance to any real gray"
		1 to: grayLevels size do: [:i |
			dist _ (level - (grayLevels at: i)) abs.
			dist < distToClosest ifTrue: [
				distToClosest _ dist.
				indexOfClosest _ grayIndices at: i]].
		GrayToIndexMap at: (level + 1) put: indexOfClosest]! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16908153!
temporaries
	" [ '|' (variable)* '|' ]"
	| tempDeclarationNodes theActualText declarationStartIndex |
	(self match: #verticalBar) ifFalse: 
		["no temps"
		doitFlag ifTrue:
			[tempsMark := self interactive
								ifTrue: [requestor selectionInterval first]
								ifFalse: [1].
			^ self noTempsDeclaration ].
		tempsMark := hereMark	"formerly --> prevMark + prevToken".
		tempsMark > 0 ifTrue:
			[theActualText := source contents.
			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]
				whileTrue: [tempsMark := tempsMark + 1]].
			^ self noTempsDeclaration ].
	tempDeclarationNodes _ OrderedCollectionEnu new.
	declarationStartIndex _ prevMark.
	[hereType == #word] whileTrue: [
		self advanceWithRangeDo: [ :variableName :range |
			| variableNode |
			variableNode _ encoder bindTemp: variableName range: range.
			tempDeclarationNodes addLast: (self createTempDeclarationOf: variableNode sourceRange: range) ] ].
	(self match: #verticalBar) ifTrue: [
		tempsMark := prevMark.
		^ self
			createTempsDeclarationWith: tempDeclarationNodes
			sourceRange: (declarationStartIndex to: prevMark) ].
	^ self expected: 'Vertical bar'! !
!ManyMethodsTypeChecker class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50626521!
forAllClasses: classes

	| methods |
	
	methods := OrderedCollectionEnu new.
	classes do: [ :aClass | self addMethodsOf: aClass to: methods ].
	
	^self forAll: methods! !
!SystemOrganizer methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16958847!
superclassOrderInAll: categories

	| classes |

	classes := OrderedCollectionEnu new.
	categories do: [ :aCategory | classes addAll: (self classesAt: aCategory)].

	^Array streamContents: [ :stream | Smalltalk hierarchySorted: classes do: [ :aClass | stream nextPut: aClass ]].! !
!SamplePlotterMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50641177 overrides: 16794195!
initialize
	super initialize.
	extent _ 320@240.
	sampleSequences _ OrderedCollectionEnu new.
	colors _ OrderedCollectionEnu new! !
!IntroduceNullObjectRequest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50611601!
replacementParameters

	| parameters |

	parameters := OrderedCollectionEnu new.
	messageKeywordsAndParametersModels keysAndValuesDo: [:ifNilCheck :model |
		parameters add: (ReplaceIfNilWithPolymorphismParameters
			forIfNilMessageSending: ifNilCheck messageNode
			onMethod: ifNilCheck methodNode
			useKeywordsDefinitions: model definitions)].

	^parameters! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50375843!
asPathTokens

	^self beginsWithWindowsDriveName
		ifTrue: [
			(OrderedCollectionEnu with: (self copyFrom: 1 to: 2)), 
				((self copyFrom: 3 to: self size) findTokens: String pathSeparators) ]
		ifFalse: [
			self findTokens: String pathSeparators ]! !
!Symbol class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50359688!
possibleSelectorsFor: misspelled 
	"Answer an ordered collection of possible corrections
	for the misspelled selector in order of likelyhood"

	| numArgs candidates lookupString best binary short long first ss |
	lookupString _ misspelled asLowercase. "correct uppercase selectors to lowercase"
	numArgs _ lookupString numArgs.
	(numArgs < 0 or: [lookupString size < 2]) ifTrue: [^ OrderedCollectionEnu new: 0].
	first _ lookupString first.
	short _ lookupString size - (lookupString size // 4 max: 3) max: 2.
	long _ lookupString size + (lookupString size // 4 max: 3).

	"First assemble candidates for detailed scoring"
	candidates _ OrderedCollectionEnu new.
	self allSymbolTablesDo: [:s | (((ss _ s size) >= short	"not too short"
			and: [ss <= long			"not too long"
					or: [(s at: 1) = first]])	"well, any length OK if starts w/same letter"
			and: [s numArgs = numArgs])	"and numArgs is the same"
			ifTrue: [candidates add: s]].

	"Then further prune these by correctAgainst:"
	best _ lookupString correctAgainst: candidates.
	((misspelled last ~= $:) and: [misspelled size > 1]) ifTrue: [
		binary _ misspelled, ':'.		"try for missing colon"
		Symbol hasInterned: binary ifTrue: [:him | best addFirst: him]].
	^ best! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50513512!
testApplyUsingDepthFistSearch

	| collectedNodes expectedCollectedNodes graph |

	collectedNodes := OrderedCollectionEnu new.

	graph :=
		Graph edges: (
			OrderedCollectionEnu new
				add: (Edge from: 1 to: 2);
				add: (Edge from: 2 to: 3);
				add: (Edge from: 3 to: 4);
				add: (Edge from: 4 to: 5);
				add: (Edge from: 1 to: 6);
				add: (Edge from: 1 to: 7);
				yourself).

	graph apply: [:node | collectedNodes add: node] usingDepthFirstSearchFrom: 1.

	expectedCollectedNodes := #(1 2 3 4 5 6 7).

	self assert: collectedNodes asOrderedCollection = expectedCollectedNodes asOrderedCollection! !
!BehaviorTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50558957!
testHighestClassImplementingReturnsReceiverWhenNoOtherSuperclassImplementsSelector

	| higestClass |
	
	higestClass := OrderedCollectionEnu highestClassImplementing: #addFirst: ifNone: [ self fail ].
	
	self assert: higestClass equals: OrderedCollectionEnu.! !
!CompiledMethodTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50570150!
test18propertyKeysAndValuesDoIteratesOverProperties

	| propertyName thisMethod properties |
	
	propertyName := #testProperty.
	thisMethod := self class>>thisContext selector.
	thisMethod propertyValueAt: propertyName put: true.
	
	properties := OrderedCollectionEnu new.
	thisMethod propertyKeysAndValuesDo: [ :key :value | properties add: key -> value ].
	
	self assert: properties size equals: 1.
	self assert: properties first equals: propertyName -> true! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50345384!
destroyCurrentCodeOfSelections
	"Actually remove from the system any in-memory methods with class and selector identical to items current selected.  This may seem rather arcane but believe me it has its great uses, when trying to split out code.  To use effectively, first file out a change set that you wish to split off.  Then open a ChangeList browser on that fileout.  Now look through the methods, and select any of them which you want to remove completely from the system, then issue this command.  For those methods where you have made changes to pre-existing versions, of course, you won't want to remove them from the system, so use this mechanism with care!!"

	|  aClass aChange aList |
	aList _ OrderedCollectionEnu new.
	1 to: changeList size do:
		[:index |
			(listSelections at: index) ifTrue:
				[aChange _ changeList at: index.
				(aChange changeType == #method
					and: [(aClass _ aChange changeClass) notNil
					and: [aClass includesSelector: aChange methodSelector]])
						ifTrue:
							[aList add: {aClass. aChange methodSelector}]]].

	aList notEmpty ifTrue: [
		(self confirm: 'Warning!! This will actually remove ', aList size printString,  ' method(s) from the system!!') ifFalse: [^ self]].
	aList do: [ :aPair |
		Transcript newLine; show: 'Removed: ', aPair first printString, '.', aPair second.
		aPair first removeSelector: aPair second ]! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50515517!
testHash

	self assert: (CompoundMeasure with: self tenPesos with: self twentyDollars) hash = (CompoundMeasure with: self tenPesos with: self twentyDollars) hash.
	self assert: (CompoundMeasure with: self tenPesos with: self twentyDollars) hash = (CompoundMeasure with: self twentyDollars with: self tenPesos ) hash.
	self assert: (CompoundMeasure measures: (OrderedCollectionEnu with: self tenPesos with: self twentyDollars with: self tenEuros)) hash=
		(CompoundMeasure measures: (OrderedCollectionEnu with: self tenEuros with: self twentyDollars with: self tenPesos)) hash.
	
	self deny: (CompoundMeasure with: self tenPesos with: self twentyDollars) hash = (CompoundMeasure with: (self tenPesos+self onePeso) with: self twentyDollars) hash! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50513852!
testStartingEdges

	| graph edges |
	
	edges := OrderedCollectionEnu new
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		add: (Edge from: 3 to: 4);
		add: (Edge from: 1 to: 4);
		add: (Edge from: 4 to: 4);
		yourself.
	
	graph := Graph edges: edges.	
	
	self assert: (graph edgesStartingOn: 1) size = 2.
	self assert: ((graph edgesStartingOn: 1) removeAll: (OrderedCollectionEnu 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 1 to: 4)); yourself ) isEmpty.
		
	self assert: (graph edgesStartingOn: 2) size = 1.
	self assert: ((graph edgesStartingOn: 2) copyWithout: (Edge from: 2 to: 3)) isEmpty.
	
	self assert: (graph edgesStartingOn: 3) size = 1.
	self assert: ((graph edgesStartingOn: 3) copyWithout: (Edge from: 3 to: 4)) isEmpty.

	self assert: (graph edgesStartingOn: 4) size = 1.
	self assert: ((graph edgesStartingOn: 4) copyWithout: (Edge from: 4 to: 4)) isEmpty.
	
	self assert: (graph edgesStartingOn: 5) isEmpty! !
!ChangeKeywordsSelectorOrderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50588005!
test05ChangesParametersOrder

	| classToRefactor refactoring oldSelector newSelector renamedMethod parameters selectorAndParameters |

	oldSelector := #m1:m2:.
	newSelector := #m2:m1:.
	classToRefactor := self createClassNamed: #ClassToChangeSelectorOrder.
	selectorAndParameters := self selectorAndParametersFor: oldSelector.
	classToRefactor compile: selectorAndParameters.

	refactoring := ChangeKeywordsSelectorOrder from: oldSelector to: newSelector implementors: { classToRefactor >> oldSelector } senders: #().
	refactoring apply.

	renamedMethod := classToRefactor >> newSelector.
	parameters := selectorAndParameters substrings reject: [ :aKeywordOrParameter | oldSelector keywords includes: aKeywordOrParameter  ].
	self
		assert: (OrderedCollectionEnu with: parameters second with: parameters first)
		equals: renamedMethod methodNode argumentNames ! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16889033!
valuesSelect: aCondition

	| selected |

	selected := OrderedCollectionEnu new.
	self valuesDo: [ :aValue | (aCondition value: aValue) ifTrue: [ selected add: aValue ]].

	^selected! !
!GraphPathFinderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50513409!
testPathToNeighborPlace

	| path |

	path := finder pathFrom: 1 to: 2.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 1 to: 2))).

	path := finder pathFrom: 1 to: 5.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 1 to: 5))).

	path := finder pathFrom: 2 to: 3.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 2 to: 3))).
	
	path := finder pathFrom: 3 to: 4.
	self assert: path = (Graph edges: (OrderedCollectionEnu 
		with: (Edge from: 3 to: 4)))! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50513689!
testIncludesNode

	| graph edges |
	
	edges := OrderedCollectionEnu new
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		yourself.
	
	graph := Graph edges: edges.
	
	self assert: (graph includesNode: 1).
	self assert: (graph includesNode: 2).
	self assert: (graph includesNode: 3).
	self deny: (graph includesNode: 4)! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16907812!
cascade
	" {; message} => CascadeNode."

	| receiverNode messageNodes |
	parseNode canCascade ifFalse:
		[^self expected: 'Cascading not'].
	parseNode ensureCanCascade: encoder.
	receiverNode := parseNode cascadeReceiver.
	messageNodes := OrderedCollectionEnu with: parseNode.
	[self match: #semicolon]
		whileTrue: 
			[parseNode := receiverNode.
			(self messagePart: 3 repeat: false)
				ifFalse: [^self expected: 'Cascade'].
			parseNode canCascade ifFalse:
				[^self expected: '<- No special messages'].
			parseNode ensureCanCascade: encoder.
				parseNode cascadeReceiver.
			messageNodes addLast: parseNode].
	self createCascadeNodeWith: receiverNode and: messageNodes! !
!MessageKeywordsAndParametersTable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50600359!
columnWidthsRequiredForRowTitles: rowsTitles forInputColumns: numberOfInputColumns

	| widths maxRowTitleWidth widthForInputs |

	widths := OrderedCollectionEnu new.

	maxRowTitleWidth := (rowsTitles collect: [:aRowTitle | FontFamily defaultFamilyAndPointSize widthOfString: aRowTitle]) max + 20.
	widths add: maxRowTitleWidth.

	widthForInputs := ExtractToMethodObjectForm fontProportionalUnitOfReferenceForWidth * 20.
	numberOfInputColumns timesRepeat: [widths add: widthForInputs].

	rowsTitles size > 1 ifTrue: [widths add: (FontFamily defaultFamilyAndPointSize widthOfString: 'Change order')].

	^widths

	! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50342439!
allPrimitiveMethodsInCategories: aList
	"Answer an OrderedCollection of all the methods that are implemented by primitives in the given categories.  1/26/96 sw"

	| aColl method | 
	aColl _ OrderedCollectionEnu new: 200.
	self allBehaviorsDo: [ :aClass |
		(aList includes: (SystemOrganization categoryOfElement: aClass theNonMetaClass name asPlainString) asPlainString)
			ifTrue: [
				aClass selectorsDo: [ :sel | 
					method _ aClass compiledMethodAt: sel.
					method primitive ~= 0
						ifTrue: [
							aColl addLast: aClass name , ' ' , sel 
								, ' ' , method primitive printString]]]].
	^ aColl

"Smalltalk allPrimitiveMethodsInCategories: #('Collections-Streams' 'Files-Streams' 'Files-Abstract' 'Files-Macintosh')"! !
!DamageRecorder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16835116 overrides: 16920235!
initialize
	damageByRoot _ IdentityDictionary new.
	otherDamage _ OrderedCollectionEnu new.! !
!SystemCategoryWrapper methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50335161 overrides: 16881049!
contents
	| prefix subcategories |
	(item includes: $-) ifTrue: [^ #()].
	prefix _ item, '-'.
	subcategories _ OrderedCollectionEnu new.
	model systemCategoryList do: [:each|
		(each beginsWith: prefix)
			ifTrue: [subcategories add: (each allButFirst: prefix size)]].
	^ subcategories collect: [:each| self class with: prefix, each name: each model: model]! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50631563!
buildTextPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollectionEnu with: (Color fromHexString: '#9E3F3F') with: 'Sunset'.
	ocean := OrderedCollectionEnu with: (Color fromHexString: '#01161E') with: 'Ocean'.
	forest := OrderedCollectionEnu with: (Color fromHexString: '#28112B') with: 'Forest'.
	ash := OrderedCollectionEnu with: (Color fromHexString: '#2B2D42') with: 'Ash'.
	light := OrderedCollectionEnu with: (Color fromHexString: '#3C3C3B') with: 'Light'.
	
	textPalette := OrderedCollectionEnu with: sunset with: ocean with: forest with: ash with: light.! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50525466 overrides: 50524008!
composeWithSimpleMeasure: aMeasure

	^self isNothing
		ifTrue: [aMeasure]
		ifFalse: 
			[CompoundMeasure measures: (OrderedCollectionEnu with: self with: aMeasure)]! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16941975!
verifyStructure
	"Compare the incoming inst var name lists with the existing classes.  Prepare tables that will help to restructure those who need it (renamed, reshaped, steady).    If all superclasses are recorded in the file, only compare inst vars of this class, not of superclasses.  They will get their turn.  "


	| newClass newList oldList converting |

	self flag: #bobconv.	

	converting _ OrderedCollectionEnu new.
	structures keysDo: [:nm "an old className (symbol)" |
		"For missing classes, there needs to be a method in SmartRefStream like 
			#rectangleoc2 that returns the new class."
		newClass _ self mapClass: nm.	   "does (renamed at: nm put: newClass name)"
		newClass class == String ifTrue: [^ newClass].  "error, fileIn needed"
		newList _ (Array with: newClass classVersion), (newClass allInstVarNames).
		oldList _ structures at: nm.
		newList = oldList 
			ifTrue: [steady add: newClass]  "read it in as written"
			ifFalse: [converting add: newClass name]
	].
	false & converting isEmpty not ifTrue: ["debug" 
			self inform: 'These classes are being converted from existing methods:\' withNewLines,
				converting asArray printString].
! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50371135!
renameTemporariesIfNeeded: temporariesToDeclare accordingToNode: aMethodOrBlockNode of: aSenderMethod

	"If a temporary to declare already exists in the scope, a new fresh name
	will be found for it. The method returns an OrderedCollection of (variableNode -> newVariableName)
	replacements. If the variable does not need a rename, it will still be added to the collection.
	This method also adds the new name to the map that tracks temporaries
	names in scope for the requested method or block node across the whole refactoring - Fernando"

	| alreadyDeclaredTemporaries newTemporaries |

	newTemporaries := OrderedCollectionEnu new: temporariesToDeclare size.
	alreadyDeclaredTemporaries := self declaredTemporariesFor: aMethodOrBlockNode ofSender: aSenderMethod.
	temporariesToDeclare do: [:temporary |
		| finalTemporaryName index |
		finalTemporaryName := temporary name.
		index := 1.
		[alreadyDeclaredTemporaries includes: finalTemporaryName] whileTrue: [
			finalTemporaryName := temporary name, index asString.
			index := index + 1.
		].
		alreadyDeclaredTemporaries add: finalTemporaryName.
		newTemporaries add: (temporary -> finalTemporaryName).
	].

	^newTemporaries.! !
!WordArray class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16981351!
bobsTest
	| wa s1 s2 wa2 answer rawData |
"
WordArray bobsTest
"
	answer _ OrderedCollectionEnu new.
	wa _ WordArray with: 16r01020304 with: 16r05060708.
	{false. true} do: [ :pad |
		0 to: 3 do: [ :skip |
			s1 _ ReadWriteStream on: #[].

			s1 next: skip put: 0.		"start at varying positions"
			wa writeOn: s1.
			pad ifTrue: [s1 next: 4-skip put: 0].	"force length to be multiple of 4"

			rawData _ s1 contents.
			s2 _ ReadWriteStream with: rawData.
			s2 reset.
			s2 skip: skip.			"get to beginning of object"
			wa2 _ WordArray newFromStream: s2.
			answer add: {
				rawData size. 
				skip. 
				wa2 = wa. 
				wa2 asArray collect: [ :each | each printStringBase: 16]
			}
		].
	].
	^answer explore! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50371175!
temporariesToDeclareByInsertionPoint: aSenderAndPosition

	^temporariesToDeclareByInsertionPoint keys
		detect: [:senderAndPosition | senderAndPosition = aSenderAndPosition]
		ifFound: [ :key | temporariesToDeclareByInsertionPoint at: key ]
		ifNone: [| temporariesToDeclareAtInsertionPoint |
			temporariesToDeclareAtInsertionPoint := OrderedCollectionEnu new.
			temporariesToDeclareByInsertionPoint at: aSenderAndPosition put: temporariesToDeclareAtInsertionPoint.
			temporariesToDeclareAtInsertionPoint].
	! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50598352!
simpleEnsureTestWithNotificationResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		add: self doSomethingElseString;
		add: self doYetAnotherThingString;
		yourself! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50577774!
testInlineBlockCollectionLR3
	| col |
	col := OrderedCollectionEnu new.
	1 to: 11 do: [ :each | | i | i := each. col add: [ i ]. i := i + 1 ].
	self assert: (col collect: [ :each | each value ]) asArray = (2 to: 12) asArray! !
!TestResult methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16962183!
tests

	^(OrderedCollectionEnu new: self runCount)
		addAll: self passed;
		addAll: self errors;
		addAll: self failures;
		yourself
			! !
!NewInstanceVariablePrecondition methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16899393!
methodsDefiningNewVariable
	
	| methodsDefiningNewVariableInHierarchy |
	
	methodsDefiningNewVariableInHierarchy := OrderedCollectionEnu new.
	
	classToAddInstVar withAllSubclassesDo: [ :class | 
		methodsDefiningNewVariableInHierarchy addAll: (class methodsWithArgumentOrTemporaryNamed: instVarName) ].

	^methodsDefiningNewVariableInHierarchy 
		
	! !
!TestCaseTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50584902!
testAssertChangesByPassesWhenActionChangesConditionByTheSpecifiedAmount

	|aCollection|

	aCollection := OrderedCollectionEnu new.
	
	self assert: [ aCollection add: 1; add: 2 ] changes: [ aCollection size ] by: 2! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16956758!
browseObsoleteReferences   "Smalltalk browseObsoleteReferences"
	| references |
	references _ OrderedCollectionEnu new.
	(LookupKey allSubInstances select:
		[:x | ((x value isKindOf: Behavior) and: ['AnOb*' match: x value name]) or:
		['AnOb*' match: x value class name]]) 
		do: [:x | references addAll: (Smalltalk allCallsOn: x)].
	Smalltalk 
		browseMessageList: references 
		name: 'References to Obsolete Classes'! !
!PushUpInstanceVariable class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16921606!
assertNoOtherMethodIn: aSuperclass definesTemporaryNamed: anInstanceVariableName

 	| methodsDefiningTemporaryInSuperclass |

	methodsDefiningTemporaryInSuperclass := OrderedCollectionEnu new.
	methodsDefiningTemporaryInSuperclass addAll: (
		aSuperclass methodsWithArgumentOrTemporaryNamed: anInstanceVariableName).

	methodsDefiningTemporaryInSuperclass ifNotEmpty: [
		self 
			canNotRefactorDueToReferencesError: (
				self errorMessageForInstanceVariable: anInstanceVariableName isDefinedInMethodsOf: aSuperclass)
			references: (
				methodsDefiningTemporaryInSuperclass collect: [ :aMethod | MethodReference method: aMethod ])
			to: anInstanceVariableName ]! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50709230!
rootPortfolio
	fatherPortfolio isEmpty ifTrue: [^OrderedCollectionEnu with: self].
	^fatherPortfolio inject: OrderedCollectionEnu new into: [:aCollection :aFather | aCollection , aFather rootPortfolio]. 
	! !
!CollectTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50574476!
testOrderedCollection
	"
	CollectTest  new testOrderedCollection
	"
	| col result |
	col _ #(1 2 3 4 5) asOrderedCollection.
	result _ col collect: [ :elem |  elem * 2 ].
	self assert: result class = OrderedCollectionEnu.
	self assert: result = #(2 4 6 8 10) asOrderedCollection! !
!ClassBuilder class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16812756!
reallyObsoleteClasses
	| obsoleteClasses |
	obsoleteClasses _ OrderedCollectionEnu new.
	Metaclass allInstances do: [:meta | meta allInstances do: [:each | 
		(self isReallyObsolete: each) ifTrue: [obsoleteClasses add: each]]].
	^ obsoleteClasses! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50598172!
simpleResumeTestResults

	"see if we can resume twice"

	^OrderedCollectionEnu new
			add: self doSomethingString;
			add: self doYetAnotherThingString;
			add: self doSomethingElseString;
			add: self doYetAnotherThingString;
			add: self doSomethingElseString;
			yourself! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16801904!
removeEmptyClassComments

	| newChangeList newList |
	newChangeList _ OrderedCollectionEnu new.
	newList _ OrderedCollectionEnu new.
	changeList with: list do: [ :chRec :strNstamp | | keep |
		keep _ true.
		(chRec changeType == #classComment and: [
				Smalltalk includesKey: chRec changeClassName]) ifTrue: [
			keep _ chRec text notEmpty
		].
		keep ifTrue:[
			newChangeList add: chRec.
			newList add: strNstamp]].
	newChangeList size < changeList size ifTrue: [
		changeList _ newChangeList.
		list _ newList.
		listIndex _ 0.
		self clearSelections ].
	self changed: #list! !
!ExtractMethodApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50503649!
extractKewordsAndArgumentsNamesFrom: userAnswer

	newSelectorKeywords := OrderedCollectionEnu new.
	userArgumentNames := OrderedCollectionEnu new.
	(self keywordsAndArgumentsOf: userAnswer) pairsDo: [ :keyword :argument | 
		newSelectorKeywords add: keyword, ':'.
		userArgumentNames add: argument ]! !
!MessageKeywordsAndParametersTable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50600611!
buildColumnTitlesRowFor: inputColumnsTitles

	| columnsTitles row |

	row := LayoutMorph newRow.
	row color: self backgroundColor.
	row separation: self columnSeparation.

	columnsTitles := OrderedCollectionEnu newFrom: inputColumnsTitles.
	columnsTitles addFirst: ''.
	self needsToReorderRows ifTrue: [columnsTitles addLast: 'Change order'].
	columnsTitles withIndexDo: [:aColumnTitle :columnIndex | | columnTitleLayoutSpec titleLayout |
		titleLayout := LayoutMorph newRow.
		titleLayout color: self backgroundColor .
		titleLayout axisEdgeWeight: #center.
		titleLayout addMorph: (LabelMorph contents: aColumnTitle).
		columnTitleLayoutSpec := LayoutSpec fixedWidth: (columnWidths at: columnIndex).
		row
			addMorph: titleLayout
			layoutSpec: columnTitleLayoutSpec].

	^row

	! !
!OrderedCollectionEnu methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16905641 overrides: 16823689!
species
	"aSortedCollection collect: should answer an OrderedCollection"

	^OrderedCollectionEnu! !
!FeatureRequirement methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50476218!
require
	"See if all the transitive closure of requirements can be met and answer the load order if so"

	| packagesToLoad |
	
	"Preflight before load 
	  [1] Build transitive closure as load order where Feature comes 
	       before its required features."
	[packagesToLoad := self
			requireUnlessIn: OrderedCollectionEnu new
			main: nil
			requiringFeature: nil
			allRequiringFeatures: #()]
		on: FeatureRequirementUnsatisfied  
		do: [ :error | error defaultAction. 
			^self "exit"
		].
	
	"Transcript show: 'packagesToLoad: '; newLine.
	packagesToLoad do: [ :x |Transcript show: x; newLine ].
	Transcript newLine."
	
	"[2] Check to see that each requirement is actually satisfied"
	[packagesToLoad do: [ :fReq | fReq checkRequirement ]]
		on: FeatureRequirementUnsatisfied  
		do: [ :error | error defaultAction. 
			^self "exit"
		].

	"[3] Load required packages before packages that require them"
	packagesToLoad reverseDo: [ :requirement |
		requirement isAlreadySatisfied ifFalse: [
			requirement install ]].
	self isAlreadySatisfied ifFalse: [
		self install ]! !
!CodeWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50344340!
optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollectionEnu new.
	widths _ OrderedCollectionEnu new.
	buttonColor _ self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph
			model: self
			stateGetter: nil
			action: tuple third.
		button color: buttonColor.
		button label: tuple second.
		tuple size > 3 ifTrue: [ button setBalloonText: tuple fourth ].
		tuple size > 4 ifTrue: [ button secondaryActionSelector: tuple fifth ].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row
		addMorphs: buttons
		widthProportionalTo: widths.
	^ row.! !
!CompositeCatalog methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50544754 overrides: 50544668!
processNonEmptySearchQuery: aQuery
	
	^ catalogs
		inject: OrderedCollectionEnu new
		into: [ :results :catalog |
			results
				addAll: (self search: aQuery using: catalog);
				yourself ]! !
!Symbol class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50343512!
selectorsMatching: aStringPattern
	"Answer a list of selectors that match aStringPattern within them. Case-insensitive.
	 Does return symbols that begin with a capital letter."

	| selectorList |

	selectorList := OrderedCollectionEnu new.

	aStringPattern isEmpty ifTrue: [^selectorList].

	self allSymbolTablesDo:
		[:each | (aStringPattern match: each) ifTrue: [selectorList add: each]].

	^selectorList reject: "reject non-selectors, but keep ones that begin with an uppercase"
		[:each | each numArgs < 0 and: [each asPlainString uncapitalized numArgs < 0]]

	"Symbol selectorsMatching: 'parse:*'"! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16952255!
testFormatter
	"Smalltalk testFormatter"
	"Reformats the source for every method in the system, and then compiles that source and verifies that it generates identical code.
	The formatting used will be classic monochrome."
	| newCodeString methodNode oldMethod newMethod badOnes n |
	badOnes _ OrderedCollectionEnu new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					newCodeString _ cls compilerClass new
						format: (cls sourceCodeAt: selector)
						in: cls
						notifying: nil.
					methodNode _ cls compilerClass new
						compile: newCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod _ methodNode generate: #(0 0 0 0 ).
					oldMethod _ cls compiledMethodAt: selector.
					oldMethod = newMethod ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	Smalltalk
		browseMessageList: badOnes
		name: 'Formatter Discrepancies'.! !
!RenameInstanceVariable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16927428!
lookForMethodsReferencingOldVariable
	
	methodsAndRangesToChange := OrderedCollectionEnu new.
	classToRefactor withAllSubclassesDo: [ :aClass |  self lookForMethodsReferencingOldVariableIn: aClass ].
! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50366178!
chooseClassVarName 
	"Present the user with a list of class variable names and answer the one selected, or nil if none"

	| lines labelStream  allVars index |
	lines _ OrderedCollectionEnu new.
	allVars _ OrderedCollectionEnu new.
	labelStream _ String writeStream.
	self withAllSuperclasses reverseDo: [ :class | | vars |
		vars _ class classVarNames asArray sort.
		vars do: [ :var |
			labelStream position = 0 ifFalse: [labelStream newLine].
			labelStream nextPutAll: var.
			allVars add: var].
		vars isEmpty ifFalse: [lines add: allVars size]].
	labelStream contents isEmpty ifTrue: [^Smalltalk beep]. "handle nil superclass better"
	index _ (PopUpMenu labels: labelStream contents lines: lines) startUpMenu.
	index = 0 ifTrue: [^ nil].
	^ allVars at: index! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 16890048!
positionsOf: symbolString containedIn: literalArrayPositions

	| symbolPositions |

	symbolPositions := OrderedCollectionEnu new.

	literalArrayPositions do: [ :literalArrayPosition | self addPositionTo: symbolPositions of: symbolString inside: literalArrayPosition ].

	^symbolPositions




! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:27' prior: 50598157!
simplePassTestResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		add: 'Unhandled Exception';
		yourself! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16920615 overrides: 50492164!
initialize
	super initialize.
	exclude _ OrderedCollectionEnu new! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50598165!
simpleResignalAsTestResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		add: 'Unhandled Exception';
		yourself! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50515302!
testCreationWithMeasuresCopiesCollection
	"This test verifies that when bag is created using the private message  #measures:,
	the collection that goes as collaborating is copied"
	
	| measures measureBag |

	measures := OrderedCollectionEnu
		with: self tenPesos
		with: self twentyDollars
		with: self tenEuros.
	measureBag := CompoundMeasure measures: measures.

	measures add: self oneMeter.
	self assert: measureBag numberOfMeasures = 3.
	self assert: (measureBag atSameBaseUnitAs: self peso) = self tenPesos.
	self assert: (measureBag atSameBaseUnitAs: self dollar) = self twentyDollars.
	self assert: (measureBag atSameBaseUnitAs: self euro) = self tenEuros


! !
!SenderInfo methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50624270!
initializeOf: aSender for: aSentImplementors
	
	sender := aSender.
	sentImplementors := aSentImplementors.
	sureSenders := Set new.
	possibleSenders := OrderedCollectionEnu new.
! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50637782!
collaboratorNames

	| names |
	
	names := OrderedCollectionEnu new.
	self withParentsDo: [ :aDenotativeObject | names addAllFirst: aDenotativeObject class instVarNames ].
	
	^names! !
!MultipliedUnit class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50523037!
simpleUnit: aUnit simpleUnit: anotherUnit

	^self new initializeFactors: (OrderedCollectionEnu with: aUnit with: anotherUnit)! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50385354!
correctAgainstEnumerator: wordBlock continuedFrom: oldCollection
	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."

	| choices scoreMin results score maxChoices |
	scoreMin _ self size // 2 min: 3.
	maxChoices _ 10.
	choices _ oldCollection
		ifNil: [ SortedCollection sortBlock: [ :x :y | x value > y value ] ].
	wordBlock
		ifNil: [
			results _ OrderedCollectionEnu new.
			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]
		ifNotNil: [
			wordBlock value: [ :word |
				(score _ self alike: word) >= scoreMin ifTrue: [
					choices add: (Association key: word value: score).
						(choices size >= maxChoices) ifTrue: [ scoreMin _ (choices at: maxChoices) value] ] ].
			results _ choices ].
	^ results! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50454152!
initCachedState
	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  
	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)
	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"
	"
	DataStream initCachedState
	"

	| refTypes t |
	refTypes _ OrderedCollectionEnu new.
	t _ TypeMap _ Dictionary new: 80. "sparse for fast hashing"

	t at: UndefinedObject put: 1.   refTypes add: 0.
	t at: True put: 2.   refTypes add: 0.
	t at: False put: 3.   refTypes add: 0.
	t at: SmallInteger put: 4.	 refTypes add: 0.
	t at: String put: 5.   refTypes add: 1.
	t at: Symbol put: 6.   refTypes add: 1.
	t at: ByteArray put: 7.   refTypes add: 1.
	t at: Array put: 8.   refTypes add: 1.
	"(type ID 9 is for arbitrary instances of any class, cf. typeIDFor:)"
		refTypes add: 1.
	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"
		refTypes add: 0.
	t at: Bitmap put: 11.   refTypes add: 1.

	t at: Metaclass put: 12.   refTypes add: 0.
	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."
		refTypes add: 1.

	t at: Float put: 14.  refTypes add: 1.
	t at: BoxedFloat64 put: 14.
	t at: SmallFloat64 put: 14.

	"15: Deprecated compact Rects."
		refTypes add: 1.

	"type ID 16 is an instance with short header.  See beginInstance:size:"
		refTypes add: 1.

	t at: String put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"
	t at: WordArray put: 18.  refTypes add: 1.	"bitmap-like"
	"t at: WordArrayForSegment put: 19."  refTypes add: 1.		"bitmap-like"
	t at: Float32Array put: 20.  refTypes add: 1.	"And all other word arrays, both 16-bit and 32-bit.  See methods in ArrayedCollection.  Overridden in SoundBuffer."
	"For all classes that are like WordArrays, store them the way ColorArray is stored.  As bits, and able to change endianness."
	Smalltalk do: [:cls |
		cls isInMemory ifTrue: [
			cls isBehavior ifTrue: [
				cls isPointers not & cls isVariable & cls isWords ifTrue: [
					(t includesKey: cls) ifFalse: [t at: cls put: 20]]]]].

	t at: CompiledMethod put: 21.  refTypes add: 1.	"special creation method"

	t at: Character put: 22. refTypes add: 0.

	t at: UnicodeString put: 23.   refTypes add: 1.
	t at: UnicodeSymbol put: 24.   refTypes add: 1.

	"t at:  put: 25.  refTypes add: 0."
	ReferenceTypes _ refTypes.		"save it"! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50614450!
createMessageList

	messageList := OrderedCollectionEnu new.
	numberOfTitles := 0.
	
	self 
		addCompleteSureSendersToMessageList;
		addPartialSureSendersToMessageList;
		addPossibleSendersToMessageList
		
! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50345430!
removeNonSelections
	"Remove the unselected items from the receiver."

	| newChangeList newList |

	newChangeList _ OrderedCollectionEnu new.
	newList _ OrderedCollectionEnu new.

	1 to: changeList size do: [ :i | 
		(listSelections at: i) ifTrue: [
			newChangeList add: (changeList at: i).
			newList add: (list at: i)]].
	newChangeList isEmpty ifTrue: [
		^ self inform: 'That would remove everything.
Why would you want to do that?'].

	newChangeList size < changeList size
		ifTrue: [
			changeList _ newChangeList.
			list _ newList.
			listIndex _ 0.
			self clearSelections ].
	self changed: #list

	! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16961783!
resources
	| allResources resourceQueue |
	allResources := Set new.
	resourceQueue := OrderedCollectionEnu new.
	resourceQueue addAll: self class resources.
	[resourceQueue isEmpty] whileFalse: [
		| next |
		next := resourceQueue removeFirst.
		allResources add: next.
		resourceQueue addAll: next resources].
	^allResources
			! !
!Class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16810351 overrides: 16786526!
sharedPools
	"Answer a Set of the pool dictionaries declared in the receiver."

	^sharedPools
		ifNil: [OrderedCollectionEnu new]! !
!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16970085!
newMorph
	"The user requested 'new morph' from the world menu.  Put up a menu that allows many ways of obtaining new morphs.  If the preference #classicNewMorphMenu is true, the full form of yore is used; otherwise, a much shortened form is used."
	| menu catDict |
	menu _ self menu: 'Add a new morph'.
	menu
		
			add: 'From Clipboard'
			target: myHand
			action: #pasteMorph;
		
			add: 'From Alphabetical List'
			subMenu: self alphabeticalMorphMenu.
	menu addLine.
	"Add 'Classic' New Morph menu"
	catDict _ Dictionary new.
	Morph allSubclassesDo: [ :eaSubclass |
		eaSubclass includeInNewMorphMenu ifTrue: [ | category |
			(eaSubclass respondsTo: #categoryInNewMorphMenu)
				ifTrue: [ category _ eaSubclass categoryInNewMorphMenu ]
				ifFalse: [ category _ 'Unknown' ].
			(catDict includesKey: category)
				ifTrue: [ (catDict at: category) add: eaSubclass ]
				ifFalse: [
					catDict
						at: category
						put: (OrderedCollectionEnu with: eaSubclass) ]]].
	catDict keys sort do: [ :categ | | morphsInCat |
		morphsInCat _ (catDict at: categ) asArray sort: [ :c1 :c2 |
			c1 name < c2 name ].
		morphsInCat size > self pvtMaxItemsPerCategorySubMenu
			ifTrue: [
				menu
					add: categ
					subMenu:
						(self pvtNewMenuForSplitLists:
							(self
								splitNewMorphList: morphsInCat
								depth: self pvtCategorySplitListDepth )) ]
			ifFalse: [ | subMenu |
				subMenu _ MenuMorph new.
				morphsInCat do: [ :cl |
					subMenu
						add: cl name
						target: self
						action: #newMorphOfClass:event:
						argument: cl ].
				menu
					add: categ
					subMenu: subMenu ]].
	self doPopUp: menu.! !
!DecompilerTestFailuresCollector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50578976 overrides: 16961453!
assert: aBoolean description: aString resumable: resumableBoolean 
	
	aBoolean ifFalse: [
		failures ifNil: [ failures := OrderedCollectionEnu new].
		 failures addLast: (thisContext sender tempAt: 1) methodReference].
	
	^super assert: aBoolean description: aString resumable: resumableBoolean 
! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16938395!
computeMessageEntriesForUnknowClassAddingPossibleInvalidSelectorsTo: aCollection

	| selectorsToShow |
	selectorsToShow _ OrderedCollectionEnu new.
	
	self class protected: [
		Selectors forPrefix: prefix keysAndValuesDo: [ :selector :lastUsedTime |
				selectorsToShow := self add: selector and: lastUsedTime to: selectorsToShow.
				(Object canUnderstand: selector) ifFalse: [ aCollection add: selector ]]].
				
	selectorsToShow size < EntriesLimit ifTrue: [ selectorsToShow _  self sortByLastUsedTime: selectorsToShow ].
	
	" To see the timestamps in the menu (need to tweak #insertCompletion: to activate. Right now, just for debugging)
	entries _ selectorsToShow collect: [ :ary | ary first, '(', ((DateAndTime fromString: '01/01/1996 00:00') + ary second minutes) printString,')' ]
	"
	^ selectorsToShow collect: [ :selectorAndTime | selectorAndTime first ]
	
! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50598344!
simpleEnsureTestWithErrorResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		add: 'Unhandled Exception';
		add: self doYetAnotherThingString;
		yourself! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50577737!
testInlineBlockCollectionEM1
	| a1 b1 i1 a2 b2 i2 we wb |
	b1 := OrderedCollectionEnu new.
	i1 := 1.
	[a1 := i1.
	 i1 <= 3] whileTrue:
		[b1 add: [a1].
		i1 := i1 + 1].
	b1 := b1 asArray collect: [:b | b value].
	b2 := OrderedCollectionEnu new.
	i2 := 1.
	we := [a2 := i2. i2 <= 3].
	wb := [b2 add: [a2]. i2 := i2 + 1].
	we whileTrue: wb. "defeat optimization"
	b2 := b2 asArray collect: [:b | b value].
	self assert: b1 = b2! !
!ActualImplementorsTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50617461!
test08highestClassImplementingSelectorReturnsHighgestClass

	self assert: (OrderedCollectionEnu highestClassImplementing: #at:put: ifNone: [ self fail ]) equals: Object! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50614964!
newBuilderIfIsTypeCheck: condition in: aMessageNode
	
	| incompleteTypeInfoReasons types implementors typesToCastTo typesToReject |

	condition isUnaryMessageSend ifFalse: [ ^NoTypeCastApplierBuilder new ].

	incompleteTypeInfoReasons := OrderedCollectionEnu new.
	types := blockCastingApplier receiverTypesFor: condition in: actualMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons notEmpty ifTrue: [ ^NoTypeCastApplierBuilder new ].
	
	"I have to converted to array because nil can not be added to sets - Hernan"
	implementors := types asArray collect: [ :aType | aType lookupSelector: condition selectorSymbol ].
	(implementors includes: nil) ifTrue: [ ^NoTypeCastApplierBuilder new ].
	implementors := implementors asIdentitySet.
	
	typesToCastTo := (implementors reject: [ :anImplementor | anImplementor isReturnSpecialFalse ]) collect: [ :anImplementor | anImplementor methodClass ].
	typesToReject := (implementors reject: [ :anImplementor | anImplementor isReturnSpecialTrue ]) collect: [ :anImplementor | anImplementor methodClass ].
		
	^IsKindOfManyTypeCastApplierBuilder 
		to: typesToCastTo 
		rejecting: typesToReject 
		on: condition receiver 
		during: aMessageNode arguments first
		rejectingDuring: (aMessageNode arguments at: 2 ifAbsent: [ BlockNode empty ]).
	! !
!DifferenceFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16842922!
unfold
	| points |
	points := OrderedCollectionEnu with: x size @ y size.
	^self unfold: points
! !
!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16869509!
toggleExpandedState
	| newChildren toDelete c |
	isExpanded _ isExpanded not.
	toDelete _ OrderedCollectionEnu new.
	firstChild ifNotNil: [
		firstChild withSiblingsDo: [ :aNode |
			aNode recursiveAddTo: toDelete ]].
	container noteRemovalOfAll: toDelete.
	(isExpanded and: [ complexContents hasContents ]) ifFalse: [
		firstChild _ nil.
"	 	nextSibling _ firstChild _ nil."
		^ self redrawNeeded ].
	(c _ complexContents contents) isEmpty ifTrue: [ ^ self redrawNeeded ].
	newChildren _ container
		addSubmorphsAfter: self
		fromCollection: c
		allowSorting: true.
	firstChild _ newChildren first! !
!SpaceTally methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16943994!
preAllocateResultsFor: classes

	results := OrderedCollectionEnu new: classes size.
	classes do: [:cl | results add: (SpaceTallyItem analyzedClassName: cl name)].
	results _ results asArray.
! !
!DamageRecorder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50465558!
pvtInnerRecordInvalidRect: requestedRect for: aRootMorph
	"Record the given rectangle in my damage list, a list of rectangular areas of the display that should be redraw on the next display cycle."

	aRootMorph ifNotNil: [
		(damageByRoot at: aRootMorph
			ifPresent: [ :c | |r|
				r := requestedRect copy. "asIntegerRectangle? encompassing?"
				1 to: c size do: [ :i | |old|
					old := c at: i.
					(r intersects: old) ifTrue: [
						r updateMerging: old.
						c at: i put: nil ]].
				c removeAllSuchThat: [:e | e isNil ].
				c add: r ]
			ifAbsent: [ damageByRoot at: aRootMorph put: (OrderedCollectionEnu with: requestedRect copy) ]) ]
		ifNil: [otherDamage add: requestedRect copy].! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16805605!
methodsWithInitialsOtherThan: myInits
	"Return a collection of method refs whose author appears to be different from the given one"
	| slips |
	slips _ OrderedCollectionEnu new.
	self changedClasses do: [ :aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | method |
				(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse: [
					method _ aClass compiledMethodAt: mAssoc key ifAbsent: nil.
					method ifNotNil: [ | aTimeStamp |
						((aTimeStamp _ method timeStamp) notNil and: [
							(aTimeStamp beginsWith: myInits) not])
								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].
	^ slips

	"
	Smalltalk browseMessageList: (ChangeSet changeSetForBaseSystem methodsWithInitialsOtherThan: 'sw') name: 'authoring problems'
	"! !
!TestResult methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16962157!
passed

	passed
		ifNil: [passed := OrderedCollectionEnu new].

	^passed
			! !
!DefinedByRulesTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50533176!
testRulesThatInclude

	| set rule1 rule2 |
	
	set := DefinedByRules for: NaturalNumbersTestUniverse new.
	set 
		addRule: (rule1 := SpecificObjectInclusionRule for: 1);
		addRule: (rule2 := SpecificObjectInclusionRule for: 2).
		
	self assert: (set rulesThatInclude: 1) size = 1.
	self assert: ((set rulesThatInclude: 1) includesAllOf: (OrderedCollectionEnu with: rule1)).

	self assert: (set rulesThatInclude: 2) size = 1.
	self assert: ((set rulesThatInclude: 2) includesAllOf: (OrderedCollectionEnu with: rule2)).

	self assert: (set rulesThatInclude: 3) isEmpty! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50622513!
browseActualWithTypeInfoAndIncompleteTypeInfo
	
	| menu labels icons selectionIndex |
	
	labels := OrderedCollectionEnu with: self showBrowseActualAnywayLabel with: self seeAllLabel.
	icons := OrderedCollectionEnu with: Theme current acceptIcon with: Theme current acceptIcon.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray.
	incompleteTypeInfoReasons do: [ :anIncompleteTypeInfo | 
		labels add: anIncompleteTypeInfo reasonDescription.
		icons add: Theme current closeIcon ].
	
	menu := PopUpMenu labelArray: labels lines: #(2) icons: icons.
	selectionIndex := menu startUpWithCaption: self incompleteTypeInfoQuestionTitle.
	selectionIndex = 1 ifTrue: [ ^self browseActualWithTypeInfoNoMatterIncompleteTypeInfo ].
	selectionIndex = 2 ifTrue: [ ^self browseAll ].
	selectionIndex > 2 ifTrue: [ ^(incompleteTypeInfoReasons at: selectionIndex - 2) browse ]
! !
!Theme class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16972065!
verifyShoutConfig

	"
	self verifyShoutConfig
	"
	^self allSubclasses
		inject: OrderedCollectionEnu new into: [ :errors :themeClass |
			[ themeClass new generateShoutConfig ] on: Error do: [:anError | | atIfAbsentContext key |
				"I have to do this because error is not resumable - Hernan"
				atIfAbsentContext := thisContext.
				10 timesRepeat: [ atIfAbsentContext := atIfAbsentContext sender ].
				key := atIfAbsentContext tempAt: 1.
				errors add: themeClass -> key.
				atIfAbsentContext receiver at: key put: Color black.
				atIfAbsentContext restart ].
			errors ]! !
!DamageRecorder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50465422!
damageReportedOther
	"Answer damage reported for no specific morph, for morphs that are not visible, and for morphs that are carried by the Hand.
	Answer might include nils. Skip them."
	| answer possiblyMoreRectsToMerge |
	answer := OrderedCollectionEnu new.
	self pvtAccessProtect critical: [
		damageByRoot keysAndValuesDo: [ :m :rects |
			rects do: [ :r |
				(m visible not or: [m owner isNil or: [m isOwnedByHand ]]) ifTrue: [
					answer add: r]]].
		otherDamage do: [ :r | answer add: r ].
	].
	possiblyMoreRectsToMerge := true.
	[possiblyMoreRectsToMerge] whileTrue: [
		possiblyMoreRectsToMerge := false.
		answer withIndexDo: [ :r1 :i |
			r1 ifNotNil: [
				i+1 to: answer size do: [ :j | | r2 |
					r2 := answer at: j.
					r2 ifNotNil: [
						(r1 intersects: r2) ifTrue: [
							r1 updateMerging: r2.
							answer at: j put: nil.
							possiblyMoreRectsToMerge := true ]]]]]].
	^answer! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50598149!
simpleOuterTestResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		add: self doSomethingElseString;
		yourself! !
!BehaviorTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50558968!
testHighestClassImplementingReturnsTheTopSuperclassImplementingSelector

	| higestClass |
	
	higestClass := OrderedCollectionEnu highestClassImplementing: #select: ifNone: [ self fail ].
	
	self assert: higestClass equals: Collection.! !
!TimeLine methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50648449 overrides: 16920235!
initialize
	events := OrderedCollectionEnu new.
	statesAfterChanges := Dictionary new.! !
!AllActualImplementors methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50622408 overrides: 50622393!
value 

	| typeImplementors |
	
	notImplemented := OrderedCollectionEnu new.
	implementors := Set new.
	types do: [ :aType | 
		typeImplementors := Smalltalk actualImplementorsOf: selector in: aType.
		typeImplementors isEmpty 
			ifTrue: [ notImplemented add: (NotImplementedMethod class: aType selector: selector) ]
			ifFalse: [ implementors addAll: typeImplementors ]].

	^self! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16828718!
literalStrings
	| litStrs |
	litStrs := OrderedCollectionEnu new: self numLiterals.
	self literalsDo:
		[:lit | 
		(lit isVariableBinding)
			ifTrue: [litStrs addLast: lit key]
			ifFalse: [(lit isSymbol)
				ifTrue: [litStrs addAll: lit keywords]
				ifFalse: [litStrs addLast: lit printString]]].
	^ litStrs! !
!ChangeListWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50344367 overrides: 50723405!
optionalButtonRow
	"Answer a row of buttons to occur in a tool pane"

	| row buttons widths buttonColor |
	buttons _ OrderedCollectionEnu new.
	widths _ OrderedCollectionEnu new.
	buttonColor _ self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: model
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second.
		buttons add: button.
		button setBalloonText: tuple fourth].
	buttons add: self lineDiffButton.
	widths add: 14.
	buttons add: self wordDiffButton.
	widths add: 16.
	model wantsPrettyDiffOption ifTrue: [
		buttons add:  self prettyLineDiffButton.
		widths add: 21.
		buttons add:  self prettyWordDiffButton.
		widths add: 23 ].
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!DefinedByRulesTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50533009!
testSpecies

	self assert: (DefinedByRules for: #()) species = OrderedCollectionEnu! !
!CodeFileBrowserWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16818514 overrides: 16797263!
messageCategoryMenu
	| aMenu itemColl |
	aMenu _ MenuMorph new defaultTarget: model.
	"All the options are for the model."
	aMenu addTitle: 'Message Category'.
	itemColl _ OrderedCollectionEnu new.
	self model baseCodeSource isLiveSmalltalkImage ifTrue: [
		itemColl add:
			{#label -> 'fileIn'. #selector -> #fileInMessageCategories. #icon -> #updateIcon} asDictionary ].
	itemColl addAll:
		{
			{#label -> 'fileOut'. #selector -> #fileOutMessageCategories. #icon -> #fileOutIcon} asDictionary. 
			nil. 
			{#label -> 'reorganize'. #selector -> #editMessageCategories. #icon -> #sendReceiveIcon} asDictionary. 
			nil. 
			{#label -> 'add item...'. #selector -> #addCategory. #icon -> #newIcon} asDictionary. 
			nil. 
			{#label -> 'rename...'. #selector -> #renameCategory. #icon -> #saveAsIcon} asDictionary. 
			{#label -> 'remove'. #selector -> #removeMessageCategory. #icon -> #listRemoveIcon} asDictionary
		}.
	self model caseCodeSource isLiveSmalltalkImage ifFalse: [
		itemColl addAll:
			{
				nil. 
				{#label -> 'remove existing'. #selector -> #removeUnmodifiedMethods. #icon -> #deleteIcon} asDictionary
			} ].
	aMenu addItemsFromDictionaries: itemColl.
	^ aMenu.! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50598132!
doublePassOuterTestResults

	^OrderedCollectionEnu new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		add: self doSomethingElseString;
		yourself! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50472281!
browseViewReferencesFromNonViews
	"
	Smalltalk browseViewReferencesFromNonViews
	"
	| aLiteral aCollection |

	aCollection := OrderedCollectionEnu new.

	"Tweak to look just for pluggables or also for menus (or maybe for all morphs)"
"	PopUpMenu withAllSubclasses , MenuMorph withAllSubclasses , PluggableMorph withAllSubclasses do: [ :view |"
	PluggableMorph withAllSubclassesDo: [ :view |
"	MenuMorph withAllSubclassesDo: [ :view |"
		
		aLiteral := view name.
		
		"tweak to linclude refs to SysWindow subhierarchy or not"
		(view includesBehavior: SystemWindow) & false ifFalse: [
			Smalltalk allBehaviorsDo: [ :class |
				((class includesBehavior: Morph) or: [ class includesBehavior: Morph class ]) ifFalse: [
					class addMethodsTo: aCollection thatReferenceTo: aLiteral special: false byte: nil ]]]].
	
	Smalltalk
		browseMessageList: aCollection asSet
		name: 'References to Views from non-Views'.! !
!ExtractToMethodObjectApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50609737!
variablesToParametrize

	^OrderedCollectionEnu newFrom: (VariablesToExtractFinder valueIn: compiledMethodToExtract notOptimizedMethodNode)! !
!PluggableListMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50344261!
keyboardSearch: aChar 
	| oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionText |
	nextSelection _ oldSelection _ self getCurrentSelectionIndex.
	max _ self maximumSelection.
	milliSeconds _ Time localMillisecondClock.
	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"
		lastKeystrokes _ ''].
	lastKeystrokes _ lastKeystrokes copyWith: aChar asLowercase.
	lastKeystrokeTime _ milliSeconds.
	nextSelectionList _ OrderedCollectionEnu newFrom: (list copyFrom: oldSelection + 1 to: max).
	nextSelectionList addAll: (list copyFrom: 1 to: oldSelection).
	"Get rid of blanks and style used in some lists"
	nextSelectionText _ nextSelectionList detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]
				ifNone: [^ self flash"match not found"].
	self owningWindow ifNotNil: [ :w |
		(w okToChangeDueTo: self) ifFalse: [^ self]].
	nextSelection _ list findFirst: [:a | a == nextSelectionText].
	"No change if model is locked"
	oldSelection == nextSelection ifTrue: [^ self flash].
	^ self setSelectionIndex: nextSelection! !
!FeatureRequirement methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50476255!
satisfyRequirementsAndInstall
	"Like #require, but install me even if already satisified (i.e. installed)"

	| packagesToLoad |
		
	"Preflight before load"
	[packagesToLoad := self
			requireUnlessIn: OrderedCollectionEnu new
			main: self
			requiringFeature: self
			allRequiringFeatures: #()]
		on: FeatureRequirementUnsatisfied  
		do: [ :error | error defaultAction. 
			^self "exit"
		].
	
	"Check to see that each requirement is actually satisfied"
	[packagesToLoad do: [ :fReq | fReq checkRequirement ]]
		on: FeatureRequirementUnsatisfied  
		do: [ :error | error defaultAction. 
			^self "exit"
		].
	
	"All requirements are satisfied; do the deed"
	packagesToLoad reverseDo: [ :requirement |
		requirement isAlreadySatisfied ifFalse: [
			requirement install ]].
	self install! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50703088 overrides: 50702685!
transactions
	^ (storedFinancialEntities inject: OrderedCollectionEnu new into: [:aCollection :anAccount| aCollection , anAccount transactions.]).! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50577763!
testInlineBlockCollectionLR2
	"Test case from Lukas Renggli"
	| col |
	col := OrderedCollectionEnu new.
	1 to: 11 do: [ :each | #(1) do: [:ignored| col add: [ each ]] ].
	self assert: (col collect: [ :each | each value ]) asArray = (1 to: 11) asArray! !
!QAbstractTally methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16921803!
rootPrintOn: textStream linesOn: linesStream talliesOn: talliesStream total: total totalTime: totalTime threshold: threshold reportOnly: aProcessOrNil

	| groups dashes line tabsAndTreeLines thisTab |
	groups _ (self sonsOver: threshold)
		groupBy: [ :aTally | aTally process ]
		having: [ :g | aProcessOrNil isNil or: [ g anyOne process == aProcessOrNil ]].
	groups do: [ :g | | sons |
		sons _ self sortCollectionFrom: g.
		dashes _ '--------------------------------'.
		line _ 'Process: ', (g anyOne process browserPrintStringFull: false).
		textStream
			nextPutAll: dashes; newLine;
			nextPutAll: line; newLine;
			nextPutAll: dashes; newLine.
		linesStream
			nextPut: dashes;
			nextPut: line;
			nextPut: dashes.
		talliesStream
			nextPut: nil; nextPut: nil; nextPut: nil.
		sons do: [ :son |
			tabsAndTreeLines _ OrderedCollectionEnu new.
			thisTab _ '  '.
			son
				treeDFSDo: [ :eachTally :parentTally |
					eachTally
						printOn: textStream
						linesOn: linesStream talliesOn: talliesStream
						tabs: tabsAndTreeLines total: total totalTime: totalTime parent: parentTally.
					tabsAndTreeLines addLast: thisTab.
					thisTab := (eachTally sonsOver: threshold) size > 1 ifTrue: ['  |'] ifFalse: ['  '].
				]
				afterChildrenDo: [ :eachTally | tabsAndTreeLines removeLast ]
				threshold: threshold
				parent: self.
			].
		textStream newLine ]! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50513742!
testNodesWithoutEdges

	| graph edges |

	edges :=
		OrderedCollectionEnu new
			add: (Edge from: 1 to: 2);
			add: (Edge from: 2 to: 3);
			yourself.

	graph := Graph edges: edges.

	self assert: (graph nodesWithoutStartingEdges size = 1).
	self assert: (graph nodesWithoutStartingEdges includes: 3).
	self assert: (graph nodesWithoutConvergingEdges size = 1).
	self assert: (graph nodesWithoutConvergingEdges includes: 1)! !
!MessageKeywordsAndParametersTable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50600501!
withRows: rowsTitles withColor: aColor withPreviewModel: aPreviewModel withRefactoringModel: aRefactoringModel

	| rowsSeparation recommendedHeight numberOfRows columnsTitlesRow changeOrderButtons tableWidth inputColumnsTitles |

	backgroundColor := aColor.
	rowModels := OrderedCollectionEnu new.
	previewModel := aPreviewModel.
	refactoringModel := aRefactoringModel.
	variablesToParametrize := rowsTitles.

	rowsSeparation := 4.
	self separation: rowsSeparation.

	"Calculate table height"
	numberOfRows := (rowsTitles size + 1).
	recommendedHeight :=  self rowHeight * numberOfRows + (rowsSeparation * (numberOfRows + 1)) * 1.1.

	"Calculate column widths"
	inputColumnsTitles := #('Keyword' 'Parameter name').
	columnWidths := self columnWidthsRequiredForRowTitles: rowsTitles forInputColumns: inputColumnsTitles size.

	"Calculate table width"
	tableWidth := columnWidths sum + (self columnSeparation * (columnWidths size + 1)) * 1.1.

	self layoutSpec: (LayoutSpec fixedWidth: tableWidth fixedHeight: recommendedHeight).

	"Buid the columns titles row"
	columnsTitlesRow := self buildColumnTitlesRowFor: inputColumnsTitles.
	self addMorph: columnsTitlesRow layoutSpec: self rowsLayoutSpec.

	"Build the input rows"
	rowsTitles withIndexDo: [:aRowTitle :index | | aRow changeOrderModel keywordInputMorph inputMorphLayoutSpec parameternameInputMorph |
		aRow := LayoutMorph newRow.
		aRow color: self backgroundColor; separation: self columnSeparation.

		aRow
			addMorph: (LabelMorph contents: aRowTitle)
			layoutSpec: (LayoutSpec fixedWidth: (columnWidths at: 1)).

		inputMorphLayoutSpec := LayoutSpec fixedWidth: (columnWidths at: 2) fixedHeight: self rowHeight.

		keywordInputMorph := self buildInputMorphWith: (aRefactoringModel keywordModelOf: aRowTitle).
		aRow addMorph: keywordInputMorph layoutSpec: inputMorphLayoutSpec.

		parameternameInputMorph := self buildInputMorphWith: (aRefactoringModel parameterModelOf: aRowTitle).
		aRow addMorph: parameternameInputMorph layoutSpec: inputMorphLayoutSpec.

		self needsToReorderRows ifTrue: [
			changeOrderModel := ChangeRowOrderButtonModel for: (rowsTitles size - (index - 1)) notifying: self.
			rowModels addFirst: changeOrderModel.
			changeOrderButtons := self buildChangeOrderButtonsWith: changeOrderModel.
			aRow addMorph: changeOrderButtons layoutSpec: (LayoutSpec fixedWidth: (columnWidths last))].

		self addMorph: aRow layoutSpec: self rowsLayoutSpec.
	].! !
!MessageTally methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16887377!
fullPrintExactOn: aStream

	aStream nextPutAll: '**Tree**'; newLine.
	self
		treePrintExactOn: aStream
		tabs: OrderedCollectionEnu new
		thisTab: ''.
	aStream nextPut: Character newPage; newLine.
	aStream nextPutAll: '**Leaves**'; newLine.
	self leavesPrintExactOn: aStream! !
!AddParameterWithActualScopeApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50621787 overrides: 16803828!
createSenders

	^OrderedCollectionEnu new.
! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50346430!
writeConversionMethod: sel class: newClass was: oldName fromInstVars: oldList to: newList
	"The method convertToCurrentVersion:refStream: was not found in newClass.  Write a default conversion method for the author to modify."

	| code newOthers oldOthers copied |

	code _ WriteStream on: (String new: 500).
	code nextPutAll: 'convertToCurrentVersion: varDict refStream: smartRefStrm'; newLine; tab.
	newOthers _ newList asOrderedCollection "copy".
	oldOthers _ oldList asOrderedCollection "copy".
	copied _ OrderedCollectionEnu new.
	newList do: [:instVar |
		(oldList includes: instVar) ifTrue: [
			instVar isInteger ifFalse: [copied add: instVar].
			newOthers remove: instVar.
			oldOthers remove: instVar]].
	code nextPutAll: '"These variables are automatically stored into the new instance '.
	code nextPutAll: copied asArray printString; nextPut: $. .
	code newLine; tab; nextPutAll: 'This method is for additional changes.'; 
		nextPutAll: ' Use statements like (foo _ varDict at: ''foo'')."'; newLine; newLine; tab.
	newOthers isEmpty & oldOthers isEmpty ifTrue: [^ self].
		"Instance variables are the same.  Only the order changed.  No conversion needed."
	newOthers notEmpty ifTrue: [
		code nextPutAll: '"New variables: ', newOthers asArray printString, '  If a non-nil value is needed, please assign it."\' withNewLines].
	oldOthers notEmpty ifTrue: [
		code nextPutAll: '	"These are going away ', oldOthers asArray printString, '.  Possibly store their info in some other variable?"'].

	code newLine; tab.
	code nextPutAll: '^ super convertToCurrentVersion: varDict refStream: smartRefStrm'.
	newClass compile: code contents classified: 'object fileIn'.


	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)
	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe."! !
!TopologicalSortTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50513922!
testValueWithAnotherGraph

	"Example from: http://www.cs.fsu.edu/~cop4531/slideshow/chapter23/23-4.html"

	| graph result |

	graph :=
		Graph
			edges: (
				OrderedCollectionEnu new
					add: (Edge from: 'undershorts' to: 'pants');
					add: (Edge from: 'undershorts' to: 'shoes');
					add: (Edge from: 'pants' to: 'shoes');
					add: (Edge from: 'pants' to: 'shoes');
					add: (Edge from: 'pants' to: 'belt');
					add: (Edge from: 'socks' to: 'shoes');
					add: (Edge from: 'shirt' to: 'belt');
					add: (Edge from: 'shirt' to: 'tie');
					add: (Edge from: 'tie' to: 'jacket');
					yourself)
			nodes: (
				Set new
					add: 'undershorts';
					add: 'pants';
					add: 'shoes';
					add: 'belt';
					add: 'shirt';
					add: 'tie';
					add: 'jacket';
					add: 'watch';
					add: 'socks';
					yourself).

	result := ((TopologicalSort for: graph) value) asArray.

	self
		assert: (result indexOf: 'undershorts') < (result indexOf: 'pants');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'belt');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'jacket');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'shoes');
		assert: (result indexOf: 'shirt') < (result indexOf: 'belt');
		assert: (result indexOf: 'shirt') < (result indexOf: 'tie');
		assert: (result indexOf: 'shirt') < (result indexOf: 'jacket');
		assert: (result indexOf: 'pants') < (result indexOf: 'shoes')! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16846685!
unusedTempNames
	| unused |
	unused := OrderedCollectionEnu new.
	scopeTable associationsDo:
		[:assn | | name |
		(assn value isUnusedTemp) ifTrue:
			[name := assn value key.
			 name ~= Encoder doItInContextName ifTrue: [unused add: name]]].
	^ unused! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50702909!
test11_PortfolioHasTransactionsFromStoredAccount
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio add: anAccount.
	
	self assert: aPortfolio transactions equals: (OrderedCollectionEnu with: aTransaction).! !
!ClassReferencesCollector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 16816110!
initializeCollectionFor: withAllSubclasses
	
	withAllSubclassesNames := withAllSubclasses collect: [:aClass | aClass name ].
	referencesToClass := OrderedCollectionEnu new.
	referencedAsClass := OrderedCollectionEnu new.
	referencesToName := OrderedCollectionEnu new.
	referencedAsName := OrderedCollectionEnu new! !
!CollectTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:28' prior: 50574497!
testSortedCollection
	"
	CollectTest  new testSortedCollection
	"
	| col result |
	col _ #(1 2 3 4 5) asSortedCollection: [ :a :b | a > b ].
	result _ col collect: [ :elem |  elem * 2 ].
	self assert: result class = OrderedCollectionEnu.
	self assert: result = #(10 8 6 4 2) asOrderedCollection! !
!CodeForNodeOnMethod class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50542043!
replace: instVarNameToReplace onMethod: aCompiledMethod accessingThrough: instVarNameToUseAsReceiver for: aNode
	^self 
		replace: instVarNameToReplace 
		onMethod: aCompiledMethod 
		accessingThrough: instVarNameToUseAsReceiver 
		for: aNode
		rejectingIntervals: OrderedCollectionEnu new! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16908192!
temporaryBlockVariablesFor: aBlockNode
	"Scan and answer temporary block variables."

	| tempDeclarationNodes declarationStartIndex |
	(self match: #verticalBar) ifFalse:
		"There are't any temporary variables."
		[aBlockNode tempsMark: prevMark + requestorOffset.
		 ^ self noTempsDeclaration ].

	tempDeclarationNodes _ OrderedCollectionEnu new.
	declarationStartIndex _ prevMark.
	[hereType == #word] whileTrue: [
		self advanceWithRangeDo: [ :variableName :range |
			| variableNode |
			variableNode _ encoder bindBlockTemp: variableName within: aBlockNode range: range.
			tempDeclarationNodes addLast: (self createTempDeclarationOf: variableNode sourceRange: range) ] ].
	(self match: #verticalBar) ifFalse:
		[^self expected: 'Vertical bar'].
	aBlockNode tempsMark: prevMark + requestorOffset.
	^ self
		createTempsDeclarationWith: tempDeclarationNodes
		sourceRange: (declarationStartIndex to: prevMark)! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16815554!
allUnreferencedClassVariables
	"Answer a list of the names of all the receiver's unreferenced class vars, including those defined in superclasses"
	| aList |
	aList _ OrderedCollectionEnu new.
	self withAllSuperclasses reverseDo: [ :aClass |
		aClass classVarNames do: [ :var |
			(Smalltalk isThereAReferenceTo: (aClass classPool associationAt: var)) ifFalse: [ aList add: var ]]].
	^ aList! !
!ActualImplementorsTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50617469!
test09WhenNoHighestClassImplementingSelectorIfNoneBlockIsEvaluated

	self assert: (OrderedCollectionEnu highestClassImplementing: #none ifNone: [ true ])! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16801591!
scanFile: aFile from: startPosition to: stopPosition

	file _ aFile.
	changeList _ OrderedCollectionEnu new.
	list _ OrderedCollectionEnu new.
	listIndex _ 0.
	file position: startPosition.

	'Scanning ', aFile localName
		displayProgressAt: Sensor mousePoint
		from: startPosition to: stopPosition
		during: [ :barBlock | self scanUpTo: stopPosition informing: barBlock ].
		
	self clearSelections! !
!Object methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16903753!
outboundPointers
"Answers a list of all objects I am causing not to be garbage-collected"

	| collection |
	collection := OrderedCollectionEnu new.
	self outboundPointersDo: [:ea | collection add: ea].
	^ collection! !
!Utilities class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16976869!
hierarchyOfClassesSurrounding: aClass
	"Answer a list of classes in the hierarchy both above and below the given class "
	| list aClassNonMeta isMeta theClassOrMeta |

	aClass ifNil: [^ OrderedCollectionEnu new].
	aClass ifNil: [^ self].
	aClassNonMeta _ aClass theNonMetaClass.
	isMeta _ aClassNonMeta ~~ aClass.
	list _ OrderedCollectionEnu new.
	aClass allSuperclasses reverseDo:
		[:cl | list addLast: cl].
	aClassNonMeta allSubclassesWithLevelDo:
		[:cl :level |
		theClassOrMeta _ isMeta ifTrue: [cl class] ifFalse: [cl].
		list addLast: theClassOrMeta]
	 	startingLevel: 0.
	^ list

"Utilities hierarchyOfClassesSurrounding: StringHolder "! !
!OrderedCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50574979!
testStreamContentsWorksAsExpected

	| contents |
	
	contents := OrderedCollectionEnu streamContents: [ :stream | stream nextPut: 1 ].
	
	self assert: contents equals: (OrderedCollectionEnu with: 1).! !
!DividedUnit class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50522756!
multipliedUnit: aMultipliedUnit multipliedUnit: anotherMultipliedUnit

	| numeratorFactors denominatorFactors numerator denominator |

	numeratorFactors := aMultipliedUnit factors.
	denominatorFactors := OrderedCollectionEnu new.

	anotherMultipliedUnit factors
		do: [:aUnit | numeratorFactors remove: aUnit ifAbsent: [denominatorFactors add: aUnit]].

	numerator := MultipliedUnit factors: numeratorFactors.
	denominator := MultipliedUnit factors: denominatorFactors.

	^denominator = NullUnit new
		ifTrue: [numerator]
		ifFalse: [self new initializeNumerator: numerator denominator: denominator]! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50625050!
allMegamorphicVariables

	"
	InstanceVariablesTypes allMegamorphicVariables
	MethodVariablesTypes allMegamorphicVariables
	"
	
	| allMegamorphicVariables |
	
	allMegamorphicVariables := OrderedCollectionEnu new.
	ProtoObject withAllSubclassesDo: [ :aClass | self of: aClass do: [ :aVariablesTypes | aVariablesTypes addMegamorphicVariablesTo: allMegamorphicVariables ]].
	
	^allMegamorphicVariables ! !
!TypeCheckerTestMethods methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50627485!
typeCheckMessageWithFalseInSubclass

	| temp1  |
	
	temp1 := OrderedCollectionEnu new.
	temp1 := Color new.
	
	temp1 isCollection ifTrue: [ temp1 add: 1 ] ifFalse: [ temp1 alpha ]! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16952035!
macroBenchmark1    "Smalltalk macroBenchmark1"
	"Decompiles and prettyPrints the source for every method in the system (or less depending on the *FILTER*, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same.  Because it never installs the new method, it should not cause any flusing of the method cache."
	 | methodNode oldMethod newMethod badOnes oldCodeString n classes |
	classes _ Smalltalk allClasses select: [:c | c name < 'B3'].
	badOnes _ OrderedCollectionEnu new.
'Decompiling and recompiling...'
displayProgressAt: Sensor mousePoint
from: 0 to: (classes sum: [:c | c selectors size] ifEmpty: [0])
during: [:barBlock | n _ 0.
	classes do:
		[:cls | 
		"Transcript cr; show: cls name."
		cls selectors do:
			[:selector | barBlock value: (n _ n+1).
			oldMethod _ cls compiledMethodAt: selector.
			oldCodeString _ (cls decompilerClass new
								decompile: selector in: cls method: oldMethod)
							decompileString.
			methodNode _ cls compilerClass new
						compile: oldCodeString
						in: cls notifying: nil ifFail: nil.
			newMethod _ methodNode generate: #(0 0 0 0).
			oldCodeString = (cls decompilerClass new
								decompile: selector in: cls method: newMethod)
							decompileString ifFalse: [badOnes add: cls name , ' ' , selector]]].
].
	^ badOnes size! !
!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16869296!
beFullyExpandedAsPer: aBlock

	| allChildren |
	allChildren _ OrderedCollectionEnu new: 10.
	self recursiveAddTo: allChildren.
	allChildren do:
		[:each |
			| shouldExpandEach |
			shouldExpandEach := each canExpand and: [aBlock value: each].
			shouldExpandEach ~= each isExpanded ifTrue:
				[
					each toggleExpandedState.
					each beFullyExpandedAsPer: aBlock
				]
		]! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50513532!
testConvergingEdges

	| graph edges |
	
	edges := OrderedCollectionEnu new
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		add: (Edge from: 3 to: 4);
		add: (Edge from: 1 to: 4);
		add: (Edge from: 4 to: 4);
		yourself.
	
	graph := Graph edges: edges.
	
	self assert: (graph edgesConvergingTo: 1) isEmpty.
	self assert: (graph edgesConvergingTo: 2) size = 1.
	self assert: ((graph edgesConvergingTo: 2) copyWithout: (Edge from: 1 to: 2)) isEmpty.
	
	self assert: (graph edgesConvergingTo: 3) size = 1.
	self assert: ((graph edgesConvergingTo: 3) copyWithout: (Edge from: 2 to: 3)) isEmpty.

	self assert: (graph edgesConvergingTo: 4) size = 3.
	self assert: ((graph edgesConvergingTo: 4) removeAll: (OrderedCollectionEnu 
		with: (Edge from: 3 to: 4)
		with: (Edge from: 4 to: 4)
		with: (Edge from: 1 to: 4)); yourself) isEmpty.
	
	self assert: (graph edgesConvergingTo: 5) isEmpty! !
!CodeCoverageAnalyzerBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50547431 overrides: 50344850!
systemCategoryRoots
	"Answer the roots of the forest of system categories."
	| categories subcategories roots name |
	categories _ self systemCategoryList.

	subcategories _ Dictionary new.
	categories do: [:each|
		name _ (each findTokens: '-') first.
		(subcategories at: name ifAbsentPut: [OrderedCollectionEnu new]) add: each].
	roots _ OrderedCollectionEnu new.
	categories do: [:each|
		name _ (each findTokens: '-') first.
		(roots includes: name) ifFalse:
			[(subcategories at: name) size > 1 ifTrue: [roots add: name] ifFalse: [roots add: (subcategories at: name) first]]].
	^ roots collect: [:each|
		| averagePercentCoveredInSubcategories rootName | 
		averagePercentCoveredInSubcategories := ((subcategories at: name) collect: [ :subcategory | subcategory percentCovered ]) average.
		rootName := each, ' (', (averagePercentCoveredInSubcategories printStringFractionDigits: 2 ) asString, '%)'.
		
		SystemCategoryWrapper with: each name: (rootName)  model: self]! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50631479!
buildBackgroundPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollectionEnu with: (Color fromHexString: '#FE938C') with: 'Sunset'.
	ocean := OrderedCollectionEnu with: (Color fromHexString: '#124559') with: 'Ocean'.
	forest := OrderedCollectionEnu with: (Color fromHexString: '#788475') with: 'Forest'.
	ash := OrderedCollectionEnu with: (Color fromHexString: '#363946') with: 'Ash'.
	light := OrderedCollectionEnu with: (Color fromHexString: '#F2DFD7') with: 'Light'.
	
	backgroundPalette := OrderedCollectionEnu with: sunset with: ocean with: forest with: ash with: light.! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50525457 overrides: 50524003!
composeWithNumber: aNumber

	^self isNothing
		ifTrue: [aNumber]
		ifFalse: [CompoundMeasure measures: (OrderedCollectionEnu with: self with: aNumber)]! !
!ReceiverTypesOfMessageSendsConform methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50614707 overrides: 16906976!
visitMessageNode: aMessageNode

	| receiverTypes |
	
	(aMessageNode selector isNamed: sentSelector) ifTrue: [
		"I don't care if receiverTypes is empty or if there are error collecting the types.
		This should change if we want a more restrictive rename - Hernan"
		receiverTypes := aMessageNode receiverOrCascadeReceiver typesIn: currentSender addingIncompleteTypeInfoTo: OrderedCollectionEnu new.
		(self isMessageSendToAnyImplementor: receiverTypes) ifTrue: [ self add: aMessageNode toNotIncludedReceiverTypesIfCorrespond: receiverTypes ]].! !
!ChangeSorter methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16807310!
classList
	"Computed.  View should try to preserve selections, even though index changes"

	^ myChangeSet ifNotNil: [myChangeSet changedClassNames] ifNil: [OrderedCollectionEnu new]
! !
!TypeCheckerTestMethods methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50627337!
isKindOfKeepsSubtypes

	| temp1  |
	
	temp1 := 1.
	temp1 := OrderedCollectionEnu new.
	temp1 := LinkedList new.
	
	(temp1 isKindOf: Collection) ifTrue: [ temp1 addLast:1 ].! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50631542!
buildSecondaryPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollectionEnu with: (Color fromHexString: '#FCA17D') with: 'Sunset'.
	ocean := OrderedCollectionEnu with: (Color fromHexString: '#AEC3B0') with: 'Ocean'.
	forest := OrderedCollectionEnu with: (Color fromHexString: '#453643') with: 'Forest'.
	ash := OrderedCollectionEnu with: (Color fromHexString: '#8D99AE') with: 'Ash '.
	light := OrderedCollectionEnu with: (Color fromHexString: '#BCAA99') with: 'Light'.
	
	secondaryPalette := OrderedCollectionEnu with: sunset with: ocean with: forest with: ash with: light.! !
!PlusInfinity methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50526205 overrides: 50524008!
composeWithSimpleMeasure: aMeasure

	^CompoundMeasure measures: (OrderedCollectionEnu with: self with: aMeasure)! !
!ArithmeticObjectIntervalTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50512964!
testAddToCollection

	| collection |
	
	collection := OrderedCollectionEnu new addAll: (ArithmeticObjectInterval from: 10 to: 20 by: 1); yourself.
	self assert: collection size = 11.
	(10 to: 20) withIndexDo: [ :value :index | self assert: (collection at: index) = value ]! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16840417!
jump: dist if: condition

	| savePc sign elsePc elseStart end cond ifExpr thenBlock elseBlock
	  thenJump elseJump condHasValue isIfNil saveStack blockBody blockArgs |
	lastJumpIfPcStack addLast: lastPc.
	stack last == #CascadeFlag ifTrue: [^ [self case: dist] ensure: [lastJumpIfPcStack removeLast]].
	elsePc := lastPc.
	elseStart := pc + dist.
	end := limit.
	"Check for bfp-jmp to invert condition.
	Don't be fooled by a loop with a null body."
	sign := condition.
	savePc := pc.
	self interpretJump ifNotNil:
		[:elseDist|
		 (elseDist >= 0 and: [elseStart = pc]) ifTrue:
			 [sign := sign not.  elseStart := pc + elseDist]].
	pc := savePc.
	ifExpr := stack removeLast.
	(isIfNil := stack size > 0 and: [stack last == #IfNilFlag]) ifTrue:
		[stack removeLast].
	saveStack := stack.
	stack := OrderedCollectionEnu new.
	thenBlock := self blockTo: elseStart.
	condHasValue := hasValue or: [isIfNil].
	"ensure jump is within block (in case thenExpr returns)"
	thenJump := exit <= end ifTrue: [exit] ifFalse: [elseStart].
	"if jump goes back, then it's a loop"
	thenJump < elseStart
		ifTrue:
			["Must be a while loop...
			  thenJump will jump to the beginning of the while expr.  In the case of while's
			  with a block in the condition, the while expr should include more than just
			  the last expression: find all the statements needed by re-decompiling."
			stack := saveStack.
			pc := thenJump.
			blockBody := self statementsTo: elsePc.
			"discard unwanted statements from block"
			blockBody size - 1 timesRepeat: [statements removeLast].
			blockArgs := thenBlock statements = constructor codeEmptyBlock statements
							ifTrue: [#()]
							ifFalse: [{ thenBlock }].
			statements addLast:
				(constructor
					codeMessage: (constructor codeBlock: blockBody returns: false)
					selector: (constructor
								codeSelector: (blockArgs isEmpty
												ifTrue:
													[sign
														ifTrue: [#whileFalse]
														ifFalse: [#whileTrue]]
												ifFalse:
													[sign
														ifTrue: [#whileFalse:]
														ifFalse: [#whileTrue:]])
								code: #macro)
					arguments: blockArgs).
			pc := elseStart.
			self convertToDoLoop]
		ifFalse:
			["Must be a conditional..."
			elseBlock := self blockTo: thenJump.
			elseJump := exit.
			"if elseJump is backwards, it is not part of the elseExpr"
			elseJump < elsePc ifTrue:
				[pc := lastPc].
			cond := isIfNil
						ifTrue:
							[constructor
								codeMessage: ifExpr ifNilReceiver
								selector: (constructor
											codeSelector: (sign ifTrue: [#ifNotNil:] ifFalse: [#ifNil:])
											code: #macro)
								arguments: (Array with: thenBlock)]
						ifFalse:
							[constructor
								codeMessage: ifExpr
								selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)
								arguments:	(sign
												ifTrue: [{elseBlock. thenBlock}]
												ifFalse: [{thenBlock. elseBlock}])].
			stack := saveStack.
			condHasValue
				ifTrue: [stack addLast: cond]
				ifFalse: [statements addLast: cond]].
	lastJumpIfPcStack removeLast.! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16908105!
statements: argNodes innerBlock: inner blockNode: theBlockNode

	| stmts returns start |
	"give initial comment to block, since others trail statements"
	theBlockNode comment: currentComment.
	"Very important. Nil the comment, to avoid printing comments multiple times when pretty-printing"
	currentComment _ nil.
	stmts := OrderedCollectionEnu new.
	returns := false.
	hereType ~~ #rightBracket ifTrue:
		[[theBlockNode startOfLastStatement: (start := self startOfNextToken).
		  (returns := self matchReturn)
			ifTrue: 
				[self expression ifFalse:
					[^self expected: 'Expression to return'].
				 self addComment.
				 stmts addLast: (parseNode isReturningIf
								ifTrue: [parseNode]
								ifFalse: [ReturnNode new
											expr: parseNode
											encoder: encoder
											sourceRange: (start to: self endOfLastToken)])]
			ifFalse: 
				[self expression
					ifTrue: 
						[self addComment.
						 stmts addLast: parseNode]
					ifFalse: 
						[self addComment.
						 stmts size = 0 ifTrue: 
							[stmts addLast: 
								(encoder encodeVariable:
									(inner ifTrue: ['nil'] ifFalse: ['self']))]]].
		  returns ifTrue: 
			[self match: #period.
			 (hereType == #rightBracket or: [hereType == #doIt]) ifFalse:
				[^self expected: 'End of block']].
		  returns not and: [self match: #period]] whileTrue].
	theBlockNode
		arguments: argNodes
		statements: stmts
		returns: returns
		from: encoder.
	parseNode := theBlockNode.
	^true! !
!ExtractToMethodObjectRequest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50611443!
initializeFor: aCompiledMethod

	variableToParametrizeToInstVarNameModel := Dictionary new.
	instanceCreationMessageModels := OrderedCollectionEnu new.

	methodObjectClassNameModel := PluggableTextModel on: self.
	methodObjectCategoryModel := PluggableTextModel on: self.
	methodObjectCategoryModel actualContents: aCompiledMethod methodClass category.
	methodObjectSuperclassNameModel := PluggableTextModel on: AutocompletedTextProvider new.
	methodObjectSuperclassNameModel actualContents: 'Object'.
	methodObjectEvaluationMessageSelectorModel := PluggableTextModel on: self.! !
!VersionsBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50365679!
scanVersionsOf: method class: class meta: meta category: category selector: selector
	| position stamp prevPos prevFileIndex preamble tokens sourceFilesCopy |
	selectorOfMethod _ selector.
	currentCompiledMethod _ method.
	classOfMethod _ meta ifTrue: [class class] ifFalse: [class].
	changeList _ OrderedCollectionEnu new.
	list _ OrderedCollectionEnu new.
	self addedChangeRecord ifNotNil: [ :change |
		self addItem: change text: ('{1} (in {2})' format: { change stamp. change fileName }) ].
	listIndex _ 0.
	position _ method filePosition.
	sourceFilesCopy _ SourceFiles collect:
		[:x | x ifNotNil: [ x name asFileEntry readStream ]].
	method fileIndex = 0 ifTrue: [^ nil].
	file _ sourceFilesCopy at: method fileIndex.
	[position notNil & file notNil] whileTrue: [
		"Skip back filler"
		file position: position.
		file backChunk.
		"Get preamble"
		preamble _ file backChunk.
		"Preamble is likely a linked method preamble, if we're in
			a changes file (not the sources file).  Try to parse it
			for prior source position and file index"
		prevFileIndex _ nil.
		prevPos _ nil.
		stamp _ ''.
		(preamble includesSubString: 'methodsFor:')
			ifTrue: [
				tokens _ Scanner new scanTokens: preamble.
				stamp _ CompiledMethod stampFrom: tokens.
				(CompiledMethod priorReferenceFrom: tokens) ifNotNil: [ :priorMethodRef |
					prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: priorMethodRef.
					prevPos _ sourceFilesCopy filePositionFromSourcePointer: priorMethodRef ]].
 		self addItem:
				(ChangeRecord new file: file position: position type: #method
						class: class name category: category meta: meta stamp: stamp)
			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.
		position _ prevPos.
		prevPos notNil ifTrue: [
			file _ sourceFilesCopy at: prevFileIndex]].
	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].
	self clearSelections! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16829473!
mapFromBlockKeys: keys toSchematicTemps: schematicTempNamesString
	"Decode a schematicTempNamesString that encodes the layout of temp names
	 in a method and any closures/blocks within it, matching keys in keys to
	 vectors of temp names."
	| map tempNames |
	map := Dictionary new.
	tempNames := schematicTempNamesString readStream.
	keys do:
		[:key| | tempSequence tempIndex |
		tempSequence := OrderedCollectionEnu new.
		tempIndex := 0.
		[(tempNames skipSeparators; peek) ifNil: [true] ifNotNil: [:ch| '[]' includes: ch]] whileFalse:
			[tempNames peek = $(
				ifTrue: [tempSequence addAll: ((self tempsSubSequenceFrom: (tempNames next; yourself)) withIndexCollect:
														[:temp :index|
														{ temp. { tempIndex + 1. index } }]).
						tempNames peek ~= $) ifTrue: [self error: 'parse error'].
						tempIndex := tempIndex + 1.
						tempNames next]
				ifFalse: [tempSequence addAll: ((self tempsSubSequenceFrom: tempNames) withIndexCollect:
														[:temp :index|
														{ temp. tempIndex := tempIndex + 1 }])]].
		map at: key put: tempSequence asArray.
		[tempNames peek = $]] whileTrue: [tempNames next].
		tempNames peek = $[ ifTrue:
			[tempNames next]].
	^map! !
!DenotativeObjectDarkTheme methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50636516 overrides: 16971312!
pseudoVariables

	^ (OrderedCollectionEnu withAll: super pseudoVariables) 
		add: #parent;
		asArray! !
!DebuggerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50344399!
customButtonRow
	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"

	| button buttons row buttonColor |
	
	buttons _ OrderedCollectionEnu new.
	buttonColor _ self buttonColor.
	"button with target = self"
	button _ PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #proceed.
	button color: buttonColor.
	button label: 'Proceed'.
	button setBalloonText: 'close the debugger and proceed.'.
	buttons add: button.
	"buttons with model target"
	self customButtonSpecs do: [ :tuple |
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple second.
		button color: buttonColor.
		button label: tuple first.
		tuple size > 2 ifTrue: [button setBalloonText: tuple third].
		buttons add: button].

	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row addMorphs: buttons.
	^row! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16813909!
allMethodCategoriesIntegratedThrough: mostGenericClass
	"Answer a list of all the method categories of the receiver and all its superclasses, up through mostGenericClass"

	| aColl |
	aColl _ OrderedCollectionEnu new.
	self withAllSuperclasses do: [ :aClass |
		(aClass includesBehavior: mostGenericClass)
			ifTrue: [ aColl addAll: aClass methodCategories ]].
	
	^ aColl asSet asSortedCollection: [ :a :b | a asLowercase < b asLowercase ]

"ColorTileMorph allMethodCategoriesIntegratedThrough: TileMorph"! !
!Browser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50344850!
systemCategoryRoots
	"Answer the roots of the forest of system categories."
	| categories subcategories roots name |
	categories _ self systemCategoryList.
	subcategories _ Dictionary new.
	categories do: [:each|
		name _ (each findTokens: '-') first.
		(subcategories at: name ifAbsentPut: [OrderedCollectionEnu new]) add: each].
	roots _ OrderedCollectionEnu new.
	categories do: [:each|
		name _ (each findTokens: '-') first.
		(roots includes: name) ifFalse:
			[(subcategories at: name) size > 1 ifTrue: [roots add: name] ifFalse: [roots add: (subcategories at: name) first]]].
	^ roots collect: [:each| SystemCategoryWrapper with: each name: each model: self]! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16942407!
checkFatalReshape: setOfClasses
	| suspects oldInstVars newInstVars bad className |
	"Inform the user if any of these classes were reshaped.  A block has a method from the old system whose receiver is of this class.  The method's inst var references might be wrong.  OK if inst vars were only added."

	self flag: #bobconv.	

	setOfClasses isEmpty ifTrue: [^ self].
	suspects _ OrderedCollectionEnu new.
	setOfClasses do: [:aClass |
		className _ renamed keyAtValue: aClass name ifAbsent: [aClass name].
		oldInstVars _ (structures at: className ifAbsent: [#(0)]) allButFirst.		"should be there"
		newInstVars _ aClass allInstVarNames.
		oldInstVars size > newInstVars size ifTrue: [bad _ true].
		oldInstVars size = newInstVars size ifTrue: [
			bad _ oldInstVars ~= newInstVars].
		oldInstVars size < newInstVars size ifTrue: [
			bad _ oldInstVars ~= (newInstVars copyFrom: 1 to: oldInstVars size)].
		bad ifTrue: [suspects add: aClass]].

	suspects isEmpty ifFalse: [
		self inform: ('Imported foreign methods will run on instances of:\',
			suspects asArray printString, 
			'\whose shape has changed.  Errors may occur.') withNewLines].! !
!MorphicCanvas methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50456358!
initializeWithTranslation: aPoint
	"Set up these only on initialization."

	currentTransformation _ MorphicTranslation withTranslation: aPoint.
	cti _ 1.
	transformations
		ifNil: [ transformations _ OrderedCollectionEnu with: currentTransformation ]
		ifNotNil: [ transformations at: cti put: currentTransformation ].
	drawingMorphStack
		ifNil: [ drawingMorphStack _ OrderedCollectionEnu with: nil ]
		ifNotNil: [ drawingMorphStack at: cti put: nil ].
	currentMorph _ nil.! !
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16972364!
divideRectHorizontally: aRectangle by: aNumber

	| w x rects |
	
	x _ aRectangle origin x.
	w _ aRectangle width // aNumber.
	rects _ OrderedCollectionEnu new.
	
	aNumber timesRepeat: [ |rect|
		rect _ Rectangle origin: x@aRectangle origin y extent: w@aRectangle height.
		x _ x + w.
		rects add: rect].
	
	 ^ rects
	
	! !
!SHParserST80 methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16929530!
parse: isAMethod 
	"Parse the receiver's text. If isAMethod is true
    then treat text as a method, if false as an
    expression with no message pattern"

	| continue prevSourcePosition |
	self initializeInstanceVariables.
	sourcePosition _ 1.
	arguments _ Dictionary new.
	temporaries _ Dictionary new.
	blockDepth _ bracketDepth _ braceDepth _ 0.
	blockDepths _ OrderedCollectionEnu with: blockDepth.
	blockDepthsStartIndexes _ OrderedCollectionEnu with: sourcePosition.
	ranges ifNil: [ ranges := OrderedCollectionEnu new: 100] ifNotNil: [ ranges reset].
	errorBlock _ [^false].
	[
		self scanNext.
		isAMethod 
			ifTrue: [
				self parseMessagePattern.
				self parsePragmaSequence].
		self parseMethodTemporaries.
		isAMethod ifTrue: [self parsePragmaSequence].
		"Iterate once for methods, but pontentially several times for workspaces
		(to recover after errors, for possible good next lines or chunks)"
		continue _ true.
		[ continue ] whileTrue: [
			prevSourcePosition _ sourcePosition.
			self parseStatementList.
			continue _ sourcePosition > prevSourcePosition.
			isAMethod
				ifTrue: [
					"Only if we are parsing a method, consider everything after this point as error."
					currentToken ifNotNil: [ self error ].
					continue _ false]
				ifFalse: [
					sourcePosition > source size ifTrue: [continue _ false]]].
	] ensure: [errorBlock _ nil].
	^true! !
!TTContourConstruction methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50445472!
initialMoveToAndPathCommands: anAffineTransformationOrNil
	"TrueType reasonably assumes Y coordinates increase upwards."

	| initialMoveToCommand pathCommand firstPoint prevEndPoint endPoints controlPoints cp ep |
	endPoints _ OrderedCollectionEnu new.
	controlPoints _ OrderedCollectionEnu new.
	self
		startPointDo: [ :firstBezierStart |
			firstPoint _ firstBezierStart.
			anAffineTransformationOrNil notNil ifTrue: [
				firstPoint _ anAffineTransformationOrNil transform: firstPoint ].
			prevEndPoint _ firstPoint ]
		quadraticBeziersDo: [ :controlPoint :endPoint |
			cp _ controlPoint.
			ep _ endPoint.
			anAffineTransformationOrNil notNil ifTrue: [
				cp _ anAffineTransformationOrNil transform: cp.
				ep _ anAffineTransformationOrNil transform: ep ].
			controlPoints add: cp - prevEndPoint.
			endPoints add: ep - prevEndPoint.
			prevEndPoint _ ep ].
	initialMoveToCommand _ PathMoveToCommand new toRelativePoint: firstPoint.
	pathCommand _ PathQuadraticCurveToCommand new toRelativePoints: endPoints controlPoints: controlPoints.
	^{initialMoveToCommand. pathCommand}! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16786526!
sharedPools
	"Answer a Set of the names of the pools (Dictionaries) that the receiver 
	shares.
	9/12/96 tk  sharedPools have an order now"

	^ OrderedCollectionEnu new! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50513630!
testEdgesConvergingToSelf

	| graph edges |
	
	edges := OrderedCollectionEnu new
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		add: (Edge from: 3 to: 4);
		add: (Edge from: 1 to: 4);
		add: (Edge from: 4 to: 4);
		yourself.
	
	graph := Graph edges: edges.	
	self assert: (graph edgesConvergingToSelf) size = 1.
	self assert: ((graph edgesConvergingToSelf) copyWithout: (Edge from: 4 to:4)) isEmpty! !
!ChangeList class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16802582!
browseRecentLogOn: origChangesFileEntry startingFrom: initialPos 
	"Prompt with a menu of how far back to go when browsing a changes file."

	| end banners positions pos chunk i |
	origChangesFileEntry readStreamDo: [ :changesFile |
		banners _ OrderedCollectionEnu new.
		positions _ OrderedCollectionEnu new.
		end _ changesFile size.
		pos _ initialPos.
		[pos = 0
			or: [banners size > 20]] 		"Go back at most 20 image exits"
			whileFalse: [
				changesFile position: pos.
				chunk _ changesFile nextChunk.
				i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.
				i > 0
					ifTrue: [
						positions addLast: pos.
						banners addLast: (chunk copyFrom: 5 to: i - 2).
						pos _ Number readFrom: (chunk copyFrom: i + 13 to: chunk size)]
					ifFalse: [
						pos _ 0]].
	].
	positions isEmpty
		ifTrue: [ pos _ 0 ]
		ifFalse: [
			positions addLast: 0.
			banners addLast: 'Whole file'.
			pos _ (SelectionMenu labelList: banners selections: positions)
						startUpWithCaption: 'Browse as far back as...'.
			pos
				ifNil: [^ self]].
	self browseRecent: end - pos on: origChangesFileEntry! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50628614!
initializeVariablesRawTypesWhenMethodHasVariablesUsing: aMethodNode 

	| argumentNames remoteVectorTypes variablesTypes |

	argumentNames := aMethodNode argumentNames.
	variablesTypes := OrderedCollectionEnu new.
	remoteVectorTypes := OrderedCollectionEnu new.
	
	variableNameToTypeIndex := Dictionary new.
	variableNameToRemoteVectorTypeIndex := Dictionary new.
	
	aMethodNode topBlockTempsMap do: [ :aTempMap |
		self 
			initializeRawTypesOfVariableNamed: aTempMap first 
			at: aTempMap second 
			into: variablesTypes 
			or: remoteVectorTypes 
			with: argumentNames ].
	
	"There is no need to add a slot for the remote vector because the VM
	takes cares of arrays of types arrays size - Hernan"	
	
	"If there are no variable rawTypes and var name to index are initialized with nil
	to save memory space and speedup the VM - Hernan"
	variablesTypes isEmpty 
		ifTrue: [ variablesRawTypes := variableNameToTypeIndex := nil ] 
		ifFalse: [ variablesRawTypes := variablesTypes asArray ].
		
	remoteVectorTypes isEmpty 
		ifTrue: [ remoteVectorRawTypes := variableNameToRemoteVectorTypeIndex := nil ] 
		ifFalse: [ remoteVectorRawTypes := remoteVectorTypes asArray ]
! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50438047!
reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	WorldMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w submorphsDo: [ :a | a delete ]].
	Preferences at: #wantsMenuIcons put: false.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollectionEnu new.
	keep addAll: #(SpaceTally DynamicTypingSmalltalkCompleter).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16847444!
init: aClass context: aContext notifying: req
	requestor := req.
	class := aClass.
	nTemps := 0.
	supered := false.
	self initScopeAndLiteralTables.
	"No Tweak Fields in Cuis"
	class variablesAndOffsetsDo: [ :variable "<String>" :offset "<Integer>" |
		scopeTable
			at: variable
			put: (offset >= 0
					ifTrue: [InstanceVariableNode new
								name: variable index: offset]
					ifFalse: [MaybeContextInstanceVariableNode new
								name: variable index: offset negated])].
	aContext ifNotNil: [
		| homeNode |
		homeNode := self bindTemp: Encoder doItInContextName.
		"0th temp = aContext passed as arg"
		aContext tempNames withIndexDo: [ :variable :index |
			variable ~= Encoder doItInContextName ifTrue: [
				scopeTable
					at: variable
					put: (MessageAsTempNode new
						receiver: homeNode
						selector: #namedTempAt:
						arguments: (Array with: (self encodeLiteral: index))
						precedence: 3
						from: self)]]].
	sourceRanges := Dictionary new: 32.
	globalSourceRanges := OrderedCollectionEnu new: 32! !
!DenotativeObjectDebugger methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50634673 overrides: 16838151!
askForCategoryIn: aClass default: aString

	| categories index category |
	
	categories := OrderedCollectionEnu with: 'new ...'. 
	categories addAll: (aClass allMethodCategoriesIntegratedThrough: aClass).	
	index := PopUpMenu withCaption: 'Please provide a good category for the new method!!'
						chooseFrom: categories.
	index = 0 ifTrue: [^ aString].
	
	category := index = 1 
		ifTrue: [StringRequestMorph request: 'Enter category name:' orCancel: [ '' ] ]
		ifFalse: [categories at: index].
		
	^ category isEmpty ifTrue: [aString] ifFalse: [category]! !
!BehaviorTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50558978!
testHighestClassImplementingValuesIfNoneBlockWhenSelectorIsNotImplemented

	OrderedCollectionEnu highestClassImplementing: #x ifNone: [ ^self  ].
	
	self fail! !
!MonitorTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50570625!
testExample1

	| producer1 producer2  monitor goal work counter goalReached finished |
	goal := (1 to: 1000) asOrderedCollection.
	work := OrderedCollectionEnu new.
	counter := 0.
	goalReached := false.
	finished := Semaphore new.
	monitor := Monitor new.

	producer1 := [
       [monitor critical:
             [monitor waitUntil: [counter \\5 = 0].
              goalReached or: [work add: (counter := counter + 1)].
              goalReached := counter >= goal size.
              monitor signal
            ].
           goalReached
          ]
             whileFalse.
         finished signal.
	].

	producer2 := [
         [monitor critical:
                [monitor waitWhile: [counter \\5 = 0].
                 goalReached or: [work add: (counter := counter + 1)].
                 goalReached := counter >= goal size.
                 monitor signal].
         goalReached
       ] whileFalse.
     finished signal
	].

	producer1 forkAt: Processor userBackgroundPriority.
	producer2 forkAt: Processor userBackgroundPriority.

	finished wait; wait.
	self assert: goal = work! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16925885!
addRemoteTemp: aTempVariableNode encoder: encoder
	remoteTemps isNil ifTrue:
		[remoteTemps := OrderedCollectionEnu new].
	remoteTemps addLast: aTempVariableNode.
	aTempVariableNode referenceScopesAndIndicesDo:
		[:scopeBlock "<BlockNode>" :location "<Integer>"|
		 self addReadWithin: scopeBlock at: location].
	encoder supportsClosureOpcodes ifFalse:
		[encoder encodeLiteral: remoteTemps size.
		 readNode := encoder encodeSelector: #at:.
		 writeNode := encoder encodeSelector: #at:put:]! !
!UndeclaredVariable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50639169!
handleForDenotativeObjectIn: aDenotativeObjectBrowser

	| alternatives labels actions lines caption choice |
	
	alternatives := parser possibleVariablesFor: name.
	labels := OrderedCollectionEnu new.
	actions := OrderedCollectionEnu new.
	lines := OrderedCollectionEnu new.

	name first isLowercase
		ifTrue: [ self addCollaboratorLabelsTo: labels andActionsTo: actions in: aDenotativeObjectBrowser ]
		ifFalse: [ self addDenotativeObjectLabelsTo: labels andActionsTo: actions in: aDenotativeObjectBrowser ].

	lines add: labels size.
	alternatives do: [ :each |
		labels add: each.
		actions add: [ parser substituteVariable: each atInterval: interval ]].
	
	lines add: labels size.
	labels add: 'cancel'.
	
	caption := 'Unknown variable: ' , name , ' please correct, or cancel:'.
	choice := (PopUpMenu labelArray: labels lines: lines) startUpWithCaption: caption.
	
	self resume: (actions at: choice ifAbsent: [ ]).

! !
!Class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16810253!
addSharedPool: aSharedPool 
	"Add the argument, aSharedPool, as one of the receiver's shared pools. 
	Create an error if the shared pool is already one of the pools.
	This method will work with shared pools that are plain Dictionaries or thenewer SharedPool subclasses"

	(self sharedPools includes: aSharedPool)
		ifTrue: [^self error: 'This is already in my shared pool list'].
	sharedPools
		ifNil: [sharedPools _ OrderedCollectionEnu with: aSharedPool]
		ifNotNil: [sharedPools add: aSharedPool]! !
!OrderedCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50574974!
testIsCollection
	self assert: (OrderedCollectionEnu new is: #Collection).! !
!ObjectExplorerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16904608!
objectsToSkipDuringRescan
	"Avoid observing side effects of the reference finder itself"

	| answer |
	answer := OrderedCollectionEnu
		with: self
		with: self model
		with: self model getCurrentSelection.
	self allMorphsDo: [:each | answer add: each].
	^answer! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16888024!
createCategories

	| classCategories |
	
	categories := OrderedCollectionEnu with: 'new ...'.
	lines := OrderedCollectionEnu with: 1. 
	classCategories := startClass methodCategoriesAsSortedCollection.
	
	reject := classCategories asSet.
	reject
		add: ClassOrganizer nullCategory;
		add: ClassOrganizer default.
	
	startClass isMeta ifTrue: [ self initializeCategoriesWhenMeta: classCategories].
	rejectingFirst ifFalse: [ categories addAll: classCategories ]! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50626468 overrides: 50626265!
warnings
	
	^typeCheckers 
		inject: OrderedCollectionEnu new
		into: [ :warnings :typeChecker |
			warnings addAll: typeChecker warnings.
			warnings ]! !
!MethodTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 50626624!
initializeErrorsWarningsAndProblems
	
	errors := OrderedCollectionEnu new.
	warnings := OrderedCollectionEnu new.
	problems := OrderedCollectionEnu new.! !
!FileList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:29' prior: 16855091!
itemsForAnyFile2
	"Answer a list of universal services that could apply to any file"
	
	| services |
	services _ OrderedCollectionEnu new.
	(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse: [
		services add: self serviceGetHex ].
	services add: self serviceCopyName.
	services add: self serviceViewContentsInWorkspace.
	^ services! !
!ChangeSelectorKeepingParameters class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:30' prior: 16804319!
from: anOldSelector to: aNewSelector in: aClassToRefactor

	| implementors senders |

	implementors := OrderedCollectionEnu new.
	senders := OrderedCollectionEnu new.

	self 
		addImplementorsOf: anOldSelector 
		to: implementors 
		andSendersTo: senders 
		forClassAndMetaOf: aClassToRefactor theNonMetaClass.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: (self collectCompiledMethodsOf: senders)! !
!FunctionGraphMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:30' prior: 50640348 overrides: 16794195!
initialize
	super initialize.
	extent _ 320@240.
	functions _ OrderedCollectionEnu new.
	colors _ OrderedCollectionEnu new.
	yRangeInvalid := true! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:30' prior: 16953702!
allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."
	"Answer a Collection of all the methods that call on aLiteral."
	| aCollection special byte |

	#(23 48 'fred' (new open:label:)) size.
	"Example above should find #open:label:, though it is deeply embedded here."

	aCollection _ OrderedCollectionEnu new.
	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:b | byte _ b ].
	self allBehaviorsDo: [:class | class addMethodsTo: aCollection thatReferenceTo: aLiteral special: special byte: byte ].
	
	^ aCollection! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:30' prior: 50450334!
firstOfBeginningOfLineOrEndOfIndentationLeftOf: position
	
	"Returns the first of beginning-of-line or end-of-indentation that appears to the left of the given position, wrapping around to the end of the line (i.e. the line is considered circular).
	This way, if the given position is beginning-of-line then end-of-indentation is returned."
	
	| currentLine beginningOfLine endOfIndentation stops |
	
	currentLine _ textComposition lines at: (textComposition lineIndexFor: position).
	beginningOfLine _ currentLine first.
	endOfIndentation _ self privateCurrentString
		skipDelimiters: (UnicodeString with: Character tab)
		startingAt: beginningOfLine.
		
	stops _ OrderedCollectionEnu with: endOfIndentation with: beginningOfLine.
	^ stops detect: [ :stop | stop < position ] ifNone: [endOfIndentation]! !
!ClassFactoryForTesting methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:30' prior: 50546482 overrides: 16920235!
initialize

	| timestamp |
	super initialize.
	timestamp := Time millisecondClockValue.
	testSystemCategory _ '__', timestamp asString, '_TestSystemCategory__'.
	testExtensionSystemCategory _ '__', timestamp asString, '_TestExtensionSystemCategory__'.
	testSharedPool _ #DeleteMeSharedPool.

	createdClasses _ OrderedCollectionEnu new.! !
!MethodTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:30' prior: 50626699!
errorsAndWarningsAsMethodReferencesWithProblems: showingProblems prefixing: aPrefix
	
	| listToShow |
	
	listToShow := self addMethodReferencesOf: errors prefixing: aPrefix to: OrderedCollectionEnu new.
	self addMethodReferencesOf: warnings prefixing: aPrefix to: listToShow.
	showingProblems ifTrue: [ self addMethodReferencesOf: problems prefixing: aPrefix to: listToShow ].
	
	^listToShow! !
!PathCurveToSmoothCommand methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:30' prior: 50432035 overrides: 50431909!
buildFrom: commandChar stream: aStream

	| x2 y2 x y |
	super buildFrom: commandChar stream: aStream.
	toPoints _ OrderedCollectionEnu new.
	control2Points _ OrderedCollectionEnu new.
	[
		x2 _ aStream nextNumber.
		y2 _ aStream nextNumber.
		x _ aStream nextNumber.
		y _ aStream nextNumber.
		y notNil ] whileTrue: [
			toPoints add: x@y.
			control2Points add: x2@y2 ]! !
!OrderedDictionaryTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:30' prior: 50575053!
testRemove
	| data dict dataToRemove desiredOrder orderingByDo |

	"Test that #do:, #select: and #collect: iterate in the correct order"
	dict _ OrderedDictionary new.
	data _ self sampleData.
	dataToRemove _ self sampleData2.

	data do: [ :pair |
		dict at: pair first put: pair second ].
	dataToRemove do: [ :pair |
		dict removeKey: pair first ].

	orderingByDo _ Array streamContents: [ :strm | dict do: [ :each | strm nextPut: each ]].

	desiredOrder _ OrderedCollectionEnu new.
	data do: [ :pair | desiredOrder add: pair second ].
	dataToRemove do: [ :pair | desiredOrder remove: pair second ].
	
	self assert: orderingByDo = desiredOrder asArray.! !
!MessageSendingBlocksVariablesToExtractFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:35:30' prior: 50600044 overrides: 16902254!
value

	messageNode arguments do: [:argument |
		currentScopeTemporaries := Bag new.
		argument accept: self].

	variablesToExtract remove: 'true' ifAbsent: [nil].
	variablesToExtract remove: 'false' ifAbsent: [nil].
	variablesToExtract remove: 'nil' ifAbsent: [nil].
	variablesToExtract remove: variableToExclude ifAbsent: [nil].

	^OrderedCollectionEnu newFrom: variablesToExtract! !

!classRenamed: #OrderedCollectionEnu as: #OrderedCollectio stamp: 'psm 10/17/2023 21:39:43'!
Smalltalk renameClassNamed: #OrderedCollectionEnu as: #OrderedCollectio!
!ClosureScanner methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716195!
newScanQueueSegment
	"Segment the scan queue, otherwise the GC will be forced to scan the whole
	queue every time (obviously, the scan queue will be in the remember table)"

	| newScanQueue |
	newScanQueue _ OrderedCollectio new: self scanQueueSegmentTargetSize.
	newScanQueue resetTo: 1.
	^newScanQueue! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716208!
privateReadSelector
	| args selector |
	doitFlag := false.

	hereType == #word ifTrue: [
		^ here asSymbol ].

	self transformVerticalBarAndUpArrowIntoABinarySelector.

	hereType == #binary ifTrue: [
		^ here asSymbol ].

	hereType == #keyword ifTrue: [
		selector := source collectionSpecies writeStream.
		args := OrderedCollectio new.
		[hereType == #keyword] whileTrue: [
			selector nextPutAll: self advance.
			args addLast: (encoder bindArg: self argumentName).
		].
		^ selector contents asSymbol ].

	^self expected: 'Message pattern'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716229!
unusedMethods
	| classes unsent messageList cls |

	(cls _ self selectedClass) ifNil: [^ nil].
	classes _ Array with: cls with: cls class.
	unsent _ Set new.
	classes do: [:c | unsent addAll: c selectors].
	unsent _ Smalltalk allUnSentMessagesIn: unsent.
	messageList _ OrderedCollectio new.
	classes do: [:c | (c selectors select: [:s | unsent includes: s]) asArray sort
					do: [:sel | messageList add: 
						(MethodReference class: c selector: sel) ]].
	^messageList! !
!TestRunner methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716247!
selectedTests
	| retval |
	retval _ OrderedCollectio new.
	tests with: selectedSuites do: [ :str :sel | sel ifTrue: [ retval add: str ]].
	^retval
! !
!RemoveInstanceVariable class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716256!
assert: aVaraible isNotReferencedInHierarchyOf: aClassToRefactor

	| references |
	
	references := OrderedCollectio new.
	aClassToRefactor withAllSubclassesDo: [ :aClass | 
		(aClass whichSelectorsAccess: aVaraible) do: [ :aSelector | references add: (MethodReference class: aClass selector: aSelector) ]].
	
	references notEmpty ifTrue: [ self signalInstanceVariable: aVaraible isReferencedInAll: references ]! !
!MethodTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716273!
errorsAsMethodReferencesPrefixing: aPrefix

	^self addMethodReferencesOf: errors prefixing: aPrefix to: OrderedCollectio new! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716281!
testCreationWithMeasures

	| measures measureBag |

	measures := OrderedCollectio with: self tenPesos with: self twentyDollars with: self tenEuros.	
	measureBag := CompoundMeasure measures: measures.
	
	self assert: measureBag numberOfMeasures = 3.
	self assert: (measureBag atSameBaseUnitAs: self peso) = self tenPesos.
	self assert: (measureBag atSameBaseUnitAs: self dollar) = self twentyDollars.
	self assert: (measureBag atSameBaseUnitAs: self euro) = self tenEuros! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716300!
testInlineBlockCollectionSD1
	| a1 b1 a2 b2 |
	b1 := OrderedCollectio new.
	1 to: 3 do:
		[:i |
		a1 := i.
		b1 add: [a1]].
	b1 := b1 asArray collect: [:b | b value].
	b2 := OrderedCollectio new.
	1 to: 3 do:
		[:i |
		a2 := i.
		b2 add: [a2]] yourself. "defeat optimization"
	b2 := b2 asArray collect: [:b | b value].
	self assert: b1 = b2! !
!FileList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716314!
itemsForNoFile

	| services |
	services := OrderedCollectio new: 6.
	services add: self serviceSortByName.
	services add: self serviceSortBySize.
	services add: (self serviceSortByDate useLineAfter: true).
	services add: self serviceAddNewFile.
	services add: self serviceAddNewDirectory.
	^ services

		! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716327!
changedMessageList
	"Used by a message set browser to access the list view information."

	| messageList |
	messageList _ OrderedCollectio new.
	changeRecords associationsDo: [ :clAssoc | | classNameInFull classNameInParts |
		classNameInFull _ clAssoc key asString.
		classNameInParts _ classNameInFull findTokens: ' '.

		(clAssoc value allChangeTypes includes: #comment) ifTrue: [
			messageList add:
				(MethodReference new
					setClassSymbol: classNameInParts first asSymbol
					classIsMeta: false 
					methodSymbol: #Comment 
					stringVersion: classNameInFull, ' Comment')].

		clAssoc value methodChangeTypes associationsDo: [ :mAssoc |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse: [
				messageList add:
					(MethodReference new
						setClassSymbol: classNameInParts first asSymbol
						classIsMeta: classNameInParts size > 1 
						methodSymbol: mAssoc key 
						stringVersion: classNameInFull, ' ' , mAssoc key)]]].
	^ messageList sorted! !
!UndeclaredVariable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716363 overrides: 16899936!
defaultAction
	
	| labels actions lines caption choice icons |
	
	labels _ OrderedCollectio new.
	actions _ OrderedCollectio new.
	lines _ OrderedCollectio new.
	icons _ OrderedCollectio new.
	
	self createMenuOptionsAddingTo: labels actions: actions icons: icons lines: lines.
	caption _ 'Unknown variable: ' , name , ' please correct, or cancel:'.
	choice _ (PopUpMenu labelArray: labels lines: lines icons: icons) startUpWithCaption: caption.
	
	self resume: (actions at: choice ifAbsent:[ nil ]).! !
!TestCaseTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716383!
testAssertChangesPassesWhenConditionIsAlteredByAction

	|aCollection|

	aCollection := OrderedCollectio new.
	
	self assert: [ aCollection add: 1 ] changes: [ aCollection size ]! !
!Morph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716392!
ownerChain
	"Answer a list of objects representing the receiver and all of its owners.   The first element is the receiver, and the last one is typically the world in which the receiver resides"

	| c next |
	c := OrderedCollectio with: self.
	next := self.
	[(next := next owner) notNil] whileTrue: [c add: next].
	^c asArray! !
!PreDebugWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716406!
buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollectio new.
	triads _ OrderedCollectio withAll: self preDebugButtonSpec.
	aDebugger shouldBeAbleToCreateMethod ifTrue: [ triads add: { 'Create'. #createMethod. 'create the missing method' }].
	
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: `Color transparent`.
	row separation: 1.
	row addMorphs: buttons.
	^row! !
!FileListWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716429!
updateButtonRow: row
	"Dynamically update the contents of the button row, if any."

	| buttons |
	row removeAllMorphs.
	buttons _ OrderedCollectio new.
	model universalButtonServices do: [ :service |
		buttons add: (self buttonToTriggerIn: model for: service) ].
	model dynamicButtonServices do: [ :service | 
		buttons add: (self buttonToTriggerIn: model for: service).
		service when: #fileListChanged send: #updateFileList to: model ].
	row addMorphs: buttons! !
!ContentPack class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716447!
resetImporter

	count _ 1.
	payload _ OrderedCollectio new! !
!SystemOrganizer methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716453!
withSubCategoriesOf: aRootCategoryName

	"Returns the root category and subcategories if they exist
	The order is important because it is assumed like that in some senders
	If aRootCategoryName does not exist as category, it will return it anyway - Hernan"
	^(OrderedCollectio with: aRootCategoryName) 
		addAll: (self subCategoriesOf: aRootCategoryName);
		yourself.
	
	! !
!TrieTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716468!
assert: subject prefixSelection: aString isEquivalentToSet: controlGroup
	| selection1 selection2 |
	selection1 _ OrderedCollectio new.
	subject forPrefix: aString keysAndValuesDo: [ :k :v |
		selection1 add: k ].
	selection2 _ (controlGroup select: [ :each |
		aString isEmpty or: [
			each asLowercase asUnaccented beginsWith: aString asLowercase asUnaccented]]) asOrderedCollection 
				sort: [ :a :b | a asLowercase asUnaccented < b asLowercase asUnaccented ].
	self assert: selection1 = selection2.! !
!ActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716488!
initializeIn: toAnalizeCompiledMethod of: aSentCompiledMethod 

	toAnalize := toAnalizeCompiledMethod.
	toAnalizeMethodClass := toAnalizeCompiledMethod methodClass.
	sent := aSentCompiledMethod.
	sentSelector := sent selector.
	sentMethodClass := sent methodClass.
	isToAnalizeInSuperclass := sentMethodClass includesBehavior: toAnalizeMethodClass.
	
	sureMessageSends := OrderedCollectio new.
	possibleMessageSends := OrderedCollectio new.! !
!ArgumentsAndReturnsFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716507 overrides: 16902254!
value

	| paramsAndReturnsFinder |
	
	ranges := OrderedCollectio new.
	
	paramsAndReturnsFinder := ParseNodeEnumerator ofBlock: [ :node | 	
		(self isReturnIvar: node) ifTrue: [self addReturnRangesFrom: node].
		(self isMessageWithIvarAsArg: node) ifTrue: [ self addParametersRangesFrom: node]].

	methodNode accept: paramsAndReturnsFinder.
! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716522!
simpleIsNestedTestResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		add: self doSomethingElseString;
		yourself! !
!UnicodeString methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716531!
basicCanonicallyOrdered
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	(UnicodeString fromCodePoints: #(16r61  16r0300 16r0315 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0300 16r031B 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r031B 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r0300 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0300 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0315 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	"
	| byteIndex stopByteIndex n combining cls element |
	byteIndex _ 1.
	stopByteIndex _ bytes size.
	combining _ OrderedCollectio new.
	^UnicodeString streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			n _ Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				cls _ UnicodeCodePoint combiningClass: codePoint.
				cls = 0
					ifTrue: [
						combining notEmpty ifTrue: [
							combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
							combining do: [ :e | strm nextPutCodePoint: e third ]].
						strm nextPutCodePoint: codePoint.
						combining _ OrderedCollectio new ]
					ifFalse: [
						element _ { cls. combining size+1. codePoint }.
						combining add: element ]].
			byteIndex _ byteIndex + n ].
		combining notEmpty ifTrue: [
			combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
			combining do: [ :e | strm nextPutCodePoint: e third ] ]].! !
!TestSuite methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716596!
tests
	tests ifNil: [tests := OrderedCollectio new].
	^tests
			! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716602!
messageSendWithMessageSendReceiver

	(OrderedCollectio new)
		value! !
!ImmutableTextModelMorph class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716608!
minimumHeightToDisplay: aString on: aWidth

	| aComposer composition lines aText disregardHeight |

	aComposer := TextComposer new.
	aText := Text fromString: aString.
	disregardHeight := 999999.
	composition := aComposer composeLinesFrom: 1 to: aText size delta: 0 into: OrderedCollectio new priorLines: Array new atY: 0 text: aText extentForComposing: aWidth @ disregardHeight.
	lines := composition first asArray size.

	^lines * self textHeight! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716626!
temps: tempVars literals: lits class: cl 
	"Decompile."

	supered := false.
	class := cl.
	nTemps := tempVars size.
	tempVars do: [:node | scopeTable at: node name put: node].
	literalStream := ReadStream on: lits.
	literalStream position: lits size.
	sourceRanges := Dictionary new: 32.
	globalSourceRanges := OrderedCollectio new: 32.
! !
!TopologicalSort methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716641 overrides: 16902254!
value

	| tempGraph result |

	tempGraph := graph copy.
	result := OrderedCollectio new.

	[tempGraph notEmpty] whileTrue: [| startingNodes |
		startingNodes := tempGraph nodesWithoutConvergingEdges.
		result addAll: startingNodes.
		tempGraph := tempGraph removeNodes: startingNodes].

	^result! !
!AllActualLocalImplementors methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716655 overrides: 50622393!
value
	
	notImplemented := OrderedCollectio new.
	implementors := types 
		inject: IdentitySet new
		into: [ :methods :aClass | 
			(aClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | methods add: method ].
			methods ].

	implementors := implementors collect: [ :method | method asMethodReference ].
	
	^self 
! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716672!
writeConversionMethodIn: newClass fromInstVars: oldList to: newList renamedFrom: oldName
	"The method convertToCurrentVersion:refStream: was not found in newClass.  Write a default conversion method for the author to modify.  If method exists, append new info into the end."

	| code newOthers oldOthers copied newCode |

	newOthers _ newList asOrderedCollection "copy".
	oldOthers _ oldList asOrderedCollection "copy".
	copied _ OrderedCollectio new.
	newList do: [:instVar |
		(oldList includes: instVar) ifTrue: [
			instVar isInteger ifFalse: [copied add: instVar].
			newOthers remove: instVar.
			oldOthers remove: instVar]].
	code _ WriteStream on: (String new: 500).
	code newLine; newLine; tab; nextPutAll: '"From ', SystemVersion current version, ' [', Smalltalk lastUpdateString;
			nextPutAll: '] on ', Date today printString, '"'; newLine.
	code tab; nextPutAll: '"These variables are automatically stored into the new instance: '.
	code nextPutAll: copied asArray printString; nextPut: $.; newLine.
	code tab; nextPutAll: 'Test for this particular conversion.'; 
		nextPutAll: '  Get values using expressions like (varDict at: ''foo'')."'; newLine; newLine.
	newOthers isEmpty & oldOthers isEmpty & oldName isNil ifTrue: [^ self].
		"Instance variables are the same.  Only the order changed.  No conversion needed."
	newOthers notEmpty ifTrue: [
		code tab; nextPutAll: '"New variables: ', newOthers asArray printString, 
			'.  If a non-nil value is needed, please assign it."'; newLine].
	oldOthers notEmpty ifTrue: [
		code tab; nextPutAll: '"These are going away ', oldOthers asArray printString, 
			'.  Possibly store their info in some other variable?"'; newLine].
	oldName ifNotNil: [
		code tab; nextPutAll: '"Test for instances of class ', oldName, '.'; newLine.
		code tab; nextPutAll: 'Instance vars with the same name have been moved here."'; newLine.
		].
	code tab; nextPutAll: '"Move your code above the ^ super...  Delete extra comments."'; newLine. 

	(newClass includesSelector: #convertToCurrentVersion:refStream:) 
		ifTrue: ["append to old methods"
			newCode _ (newClass sourceCodeAt: #convertToCurrentVersion:refStream:),
				code contents]
		ifFalse: ["new method"
			newCode _ 'convertToCurrentVersion: varDict refStream: smartRefStrm',
				code contents, 
				'	^ super convertToCurrentVersion: varDict refStream: smartRefStrm'].
	newClass compile: newCode classified: 'object fileIn'.


	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)
	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe."! !
!TimeUnits class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716773!
allUnits
	
	^OrderedCollectio new
		add: day;
		add: hour;
		add: minute;
		add: second;
		add: millisecond;
		add: week;
		add: month;
		add: year;
		yourself.! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716782!
allReferencesToLiteral: aLiteral
	| coll |
	coll := OrderedCollectio new.
	Smalltalk allBehaviorsDo: [ :eaClass |
		eaClass
			addMethodsTo: coll
			thatReferenceTo: aLiteral
			special: false
			byte: nil ].
	^ coll.! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716793!
log

	log == nil
		ifTrue: [log := OrderedCollectio new].
	^log! !
!CodeFileBrowserWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:43' prior: 50716800 overrides: 50474094!
messageListMenu
	| aMenu itemColl |
	self flag: #assumesKeyboardShortcuts.
	aMenu := MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Message List'.
	itemColl := OrderedCollectio new.
	self model baseCodeSource isLiveSmalltalkImage ifTrue: [
		itemColl add:
			{#label -> 'fileIn'. #object -> #model. #selector -> #fileInMessage. #icon -> #updateIcon} asDictionary ].
	itemColl addAll:
		{
			{#label -> 'fileOut'. #object -> #model. #selector -> #fileOutMessage. #icon -> #fileOutIcon} asDictionary. 
			nil
		}.
	self model baseCodeSource isLiveSmalltalkImage ifTrue: [
		itemColl addAll:
			{
				{#label -> 'senders (n)'. #selector -> #browseSenders. #icon -> #mailForwardIcon} asDictionary. 
				{#label -> 'implementors (m)'. #selector -> #browseImplementors. #icon -> #developmentIcon} asDictionary. 
				{#label -> 'method inheritance (h)'. #selector -> #methodInheritance. #icon -> #goDownIcon} asDictionary. 
				{#label -> 'versions (v)'. #selector -> #browseVersions. #icon -> #clockIcon} asDictionary
			} ].
	itemColl addAll:
		{
			nil. 
			{#label -> 'remove method (x)'. #object -> #model. #selector -> #removeMessage. #icon -> #deleteIcon} asDictionary
		}.
	aMenu addItemsFromDictionaries: itemColl.
	^ aMenu.! !
!OrderedCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50716843!
testWriteStreamOnOrderedCollectionGrowsAsExpected

	| contents |
	
	contents := OrderedCollectio streamContents: [ :stream | 
		1 to: 101 do: [ :aNumber | stream nextPut: aNumber ]].
	
	1 to: 101 do: [ :aNumber | self assert: (contents at: aNumber) equals: aNumber ].! !
!SequenceableCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50716856!
testWithIndexDoSeparatedByDoesNotValueSeparatedBlockForCollectionsOfOneElement

	| collectionToTraverse traversedElements |

	collectionToTraverse := OrderedCollectio with: $a.
	traversedElements := OrderedCollectio new.

	self shouldntFail: [ collectionToTraverse withIndexDo: [ :anElement :index | traversedElements add: anElement  -> index ] separatedBy: [ self fail ] ].

	self assert: traversedElements size equals: 1.
	self assert: traversedElements first equals: $a->1.! !
!HierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50716875!
list: aCollection

	| wereExpanded morphList |
	wereExpanded _ self currentlyExpanded.
	scroller removeAllMorphs.
	(aCollection isNil or: [aCollection isEmpty]) ifTrue: [^ self selectedMorph: nil].
	morphList _ OrderedCollectio new.
	self 
		addMorphsTo: morphList
		from: aCollection 
		allowSorting: false
		withExpandedItems: wereExpanded
		atLevel: 0.
	self insertNewMorphs: morphList.! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50716891!
allSubInstances 
	"Answer a list of all current instances of the receiver and all of its subclasses."
	| aCollection |
	aCollection _ OrderedCollectio new.
	self allSubInstancesDo:
		[:x | x == aCollection ifFalse: [aCollection add: x]].
	^ aCollection! !
!MoveInstanceVariableRefactoring methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50716903!
accessInSourceClass
	| accessMethods |
	accessMethods := OrderedCollectio new.
	sourceClass withAllSubclassesDo: [ :aSubClass | | selectorsAccessingIV | 
		selectorsAccessingIV := (aSubClass whichSelectorsAccess: instVarNameSourceClass) asOrderedCollection .
		accessMethods addAll: ( selectorsAccessingIV collect: [ :aSelector | aSubClass methodDict at: aSelector ])
		].
	^ accessMethods! !
!PathArcCommand methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50716920 overrides: 50431909!
buildFrom: commandChar stream: aStream

	| rx ry xAxisRotation doLargerArc useIncreasingAngle x y |
	super buildFrom: commandChar stream: aStream.
	rs _ OrderedCollectio new.
	xAxisRotations _ OrderedCollectio new.
	toPoints _ OrderedCollectio new.
	doLargerArcs _ OrderedCollectio new.
	useIncreasingAngles _ OrderedCollectio new.
	[
		rx _ aStream nextNumber.
		ry _ aStream nextNumber.
		xAxisRotation _ aStream nextNumber.
		doLargerArc _ (aStream nextNumber = 0) not.
		useIncreasingAngle _ (aStream nextNumber = 0) not.
		x _ aStream nextNumber.
		y _ aStream nextNumber.
		y notNil ] whileTrue: [
			rs add: rx@ry.
			xAxisRotations add: xAxisRotation degreesToRadians.
			doLargerArcs add: doLargerArc.
			useIncreasingAngles add: useIncreasingAngle.
			toPoints add: x@y ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50716949!
hierarchicalClassList

	"classNames are an arbitrary collection of classNames of the system.
	Reorder those class names so that they are sorted and indended by inheritance"

	| classes |

	"Creating the hierarchy is *really slow* for the full class list. Skip it for now."
	selectedSystemCategory = SystemOrganizer allCategory ifTrue: [^ self defaultClassList].		
	classes := self defaultClassList collect: [:sym | Smalltalk classNamed: sym].
	
	^ self
		flattenHierarchyTree: (self createHierarchyTreeOf: classes)
		on: OrderedCollectio new
		indent: ''.! !
!Browser class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50716970!
recentClasses
	RecentClasses ifNil: [
		RecentClasses := OrderedCollectio new ].
	^RecentClasses! !
!SpaceTally methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50716977!
printSpaceAnalysis: threshold on: aStream
	"
	SpaceTally new printSpaceAnalysis: 1 on:(FileStream forceNewFileNamed: 'STspace.text')
	"
	"sd-This method should be rewrote to be more coherent within the rest of the class 
	ie using preAllocate and spaceForInstanceOf:"

	"If threshold > 0, then only those classes with more than that number
	of instances will be shown, and they will be sorted by total instance space.
	If threshold = 0, then all classes will appear, sorted by name."

	| codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n totalPercent percent |
	Smalltalk garbageCollect.
	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.
	results _ OrderedCollectio new: Smalltalk classNames size.
	'Taking statistics...'
		displayProgressAt: Sensor mousePoint
		from: 0 to: Smalltalk classNames size
		during: [ :barBlock |
			Smalltalk allClassesDo: [ :cl |
				codeSpace _ cl spaceUsed.
				barBlock value: (n _ n+1).
				Smalltalk garbageCollectMost.
				instCount _ cl instanceCount.
				instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8]) * instCount. "Object headers""Warning: The 3rd header word for big objects is not considered!!"
				cl isVariable
					ifTrue: [
						eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].
						cl allInstancesDo: [ :x |
							instSpace _ instSpace + (x basicSize * eltSize)]]
					ifFalse: [instSpace _ instSpace + (cl instSize * instCount * 4)].
				results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).
				totalCodeSpace _ totalCodeSpace + codeSpace.
				totalInstCount _ totalInstCount + instCount.
				totalInstSpace _ totalInstSpace + instSpace]].
	totalPercent _ 0.0.

	aStream timeStamp.
	aStream
		nextPutAll: ('Class' padded: #right to: 30 with: $ );
		nextPutAll: ('code space' padded: #left to: 12 with: $ );
		nextPutAll: ('# instances' padded: #left to: 12 with: $ );
		nextPutAll: ('inst space' padded: #left to: 12 with: $ );
		nextPutAll: ('percent' padded: #left to: 8 with: $ ); newLine.

	threshold > 0 ifTrue: [
		"If inst count threshold > 0, then sort by space"
		results _ (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])
			asArray sort: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].

	results do: [:s |
		aStream
			nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );
			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );
			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );
			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).
		percent _ s spaceForInstances*100.0/totalInstSpace.
		totalPercent _ totalPercent + percent.
		percent >= 0.1 ifTrue: [
			percent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil ].
		aStream newLine].

	aStream
		newLine; nextPutAll: ('Total' padded: #right to: 30 with: $ );
		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ ).
	totalPercent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717085!
findBetweenSubStrs: delimiters
	"Answer the collection of String tokens that result from parsing self.  Tokens are separated by 'delimiters', which can be a collection of Strings, or a collection of Characters.  Several delimiters in a row are considered as just one separation."

	| tokens keyStart keyStop |
	tokens _ OrderedCollectio new.
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipAnySubStr: delimiters startingAt: keyStop.
		keyStop _ self findAnySubStr: delimiters startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens! !
!SequenceableCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717109!
testDoSeparatedByDoesNotValueSeparatedBlockForCollectionsOfOneElement

	| collectionToTraverse traversedElements |

	collectionToTraverse := OrderedCollectio with: 1.
	traversedElements := OrderedCollectio new.
	self shouldntFail: [ collectionToTraverse do: [ :anElement | traversedElements add: anElement ] separatedBy: [ self fail ] ].

	self assert: traversedElements equals: collectionToTraverse.! !
!VariableTypeInfoTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717126!
test28CommonSelectorsPreviousToIfInvalidSupertypeWithManyTypesEvaluatesInvalidBlock

	| variableTypeInfo |

	variableTypeInfo := VariableTypeInfo new initializeRawTypes: (Array new: 3).

	variableTypeInfo addType: Array.
	variableTypeInfo addType: Magnitude.
	variableTypeInfo addType: OrderedCollectio.

	self assert: Magnitude equals: (variableTypeInfo commonSelectorsPreviousTo: Collection ifInvalidSupertype: [ :aStartingClass | aStartingClass ])
		! !
!FileList class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717144!
itemsForFileEntry: aFileEntry
	"Answer a list of services appropriate for a file of the given name"
	| services suffix classList |
	"
	suffix _ (FileIOAccessor default extensionFor: filename) asLowercase.
	"
	suffix := aFileEntry extension asLowercase.
	"Build the list dynamically for all implementers of the appropriate class method... registration no longer required"
	classList _ (Smalltalk allClassesImplementing: #fileReaderServicesForFileEntry:suffix:)
		collect: [ :item |
			item class == Metaclass ifTrue: [ item soleInstance ]]
		thenSelect: [ :item |
			item notNil ].
	services _ OrderedCollectio new.
	classList do: [ :reader |
		services addAll:
			(reader
				fileReaderServicesForFileEntry: aFileEntry 
				suffix: suffix) ].
	services sort: [ :a :b | a sortOrder < b sortOrder ].
	^ services.! !
!ExtractToMethodObjectForm methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717174!
buildPreview

	| keywordParamStrings previewContent |

	keywordParamStrings := OrderedCollectio new.
	inputTable keywordsAndParametersDo: [:keyword :parameterName |
		(keyword isEmpty or: [parameterName isEmpty]) ifTrue: [
			preview model actualContents: self previewUnavailableMessage.
			^self].

		keywordParamStrings addFirst: '', keyword, ': ', parameterName].

	previewContent := ' ' join: keywordParamStrings.

	preview model actualContents: previewContent.! !
!PathQuadraticCurveToCommand methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717193 overrides: 50431909!
buildFrom: commandChar stream: aStream

	| x1 y1 x y |
	super buildFrom: commandChar stream: aStream.
	toPoints _ OrderedCollectio new.
	controlPoints _ OrderedCollectio new.
	[
		x1 _ aStream nextNumber.
		y1 _ aStream nextNumber.
		x _ aStream nextNumber.
		y _ aStream nextNumber.
		y notNil ] whileTrue: [
			toPoints add: x@y.
			controlPoints add: x1@y1 ]! !
!CompiledMethodInspector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717209 overrides: 16871803!
fieldList

	| keys |
	keys _ OrderedCollectio new.
	keys add: 'self'.
	keys add: 'all bytecodes'.
	keys add: 'header'.
	1 to: object numLiterals do: [ :i |
		keys add: 'literal', i printString ].
	object initialPC to: object size do: [ :i |
		keys add: i printString ].
	^ keys asArray
	! !
!DefinedByRules methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717222!
initializeFor: aUniverse
	
	rules := OrderedCollectio new.
	universe := aUniverse! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717228!
initHierarchyForClass: aClassOrMetaClass
	| tab stab index nonMetaClass |
	centralClass _ aClassOrMetaClass.
	nonMetaClass _ aClassOrMetaClass theNonMetaClass.
	self systemOrganizer: SystemOrganization.
	metaClassIndicated _ aClassOrMetaClass isMeta.
	classList _ OrderedCollectio new.
	tab _ ''.
	nonMetaClass allSuperclasses reverseDo: 
		[:aClass | 
		classList add: tab , aClass name.
		tab _ tab , '  '].
	index _ classList size + 1.
	nonMetaClass allSubclassesWithLevelDo:
		[:aClass :level |
		stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].
		classList add: tab , stab , aClass name]
	 	startingLevel: 0.
	self classListIndex: index! !
!SerializableBlockClosure methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717252!
onBlockClosure: aBlockClosure

	| both blockNode methodNode indirectTempNames sortedOuterTemps ownNames usedOuterNames sortedUsedOuterNames |
	aBlockClosure hasNonLocalReturn ifTrue: [
		self error: 'Can not serialize closures with non-local returns.' ].
	aBlockClosure sendsToSuper ifTrue: [
		self error: 'Can not currently serialize closures with super sends.' ].
	both _ SerializableClosureDecompiler new  decompileBlockAndMethod: aBlockClosure.
	blockNode _ both first.
	methodNode _ both second.

	indirectTempNames _ methodNode temporaries
		detect: [ :node | node isIndirectTempVector ]
		ifFound: [ :node | node remoteTemps collect: [ :n | n name ]]
		ifNone: [#()].
	sortedOuterTemps _ OrderedCollectio new.
	aBlockClosure outerContextsDo: [ :c | c closure ifNotNil: [ :cc |
		| ccn |
		ccn _ cc decompile.
		sortedOuterTemps addAll: ccn arguments; addAll: ccn temporaries ]].
	sortedOuterTemps addAll: methodNode temporaries; addAll: methodNode arguments.

	ownNames _ ((blockNode arguments, blockNode temporaries)
		collect: [ :node | node name ]) asSet.
	usedOuterNames _ Set new.
	blockNode nodesDo: [ :node | node isTemp ifTrue: [
		(ownNames includes: node name) | (indirectTempNames includes: node name) ifFalse: [
			usedOuterNames add: node name]]].

	sortedUsedOuterNames _ sortedOuterTemps select: [ :node |
		usedOuterNames includes: node name ]. "sort them"
	sortedUsedOuterNames _ sortedUsedOuterNames collect: [ :node | node name ].

	blockNode nodesDo: [ :node | node isTemp ifTrue: [ 
		node isRemote
			ifTrue: [node capturedIndex: (indirectTempNames indexOf: node name) ]
			ifFalse: [
				(sortedUsedOuterNames includes: node name)
					ifTrue: [node capturedIndex: (sortedUsedOuterNames indexOf: node name)]]]].

	theSelf _ aBlockClosure receiver.
	capturedValues _ aBlockClosure capturedValues.
	sourceCode _ blockNode decompileString.! !
!CodeForNodeOnMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717314!
initializeFor: aNode replace: instVarNameToReplace onMethod: aCompiledMethod accessingThrough: instVarNameToUseAsReceiver rejectingIntervals: intervals
	node := aNode.
	instanceVariableName := instVarNameToReplace.
	compiledMethod := aCompiledMethod.
	instVarNameTargetClass := instVarNameToUseAsReceiver.
	methodNode := compiledMethod notOptimizedMethodNode.
	intervalsToModify := OrderedCollectio new.
	intervalsToReject := intervals.
	modifiedReads := 0.
	modifiedWrites := 0! !
!Rectangle methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717333!
areasOutside: aRectangle
	"Answer an Array of Rectangles comprising the parts of the receiver not 
	intersecting aRectangle."

	| areas |
	"Make sure the intersection is non-empty"
     (self intersects: aRectangle)
		ifFalse: [^Array with: self].
	areas := OrderedCollectio new.
	self areasOutside: aRectangle do: [ :r |  areas add: r ].
	^areas! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717348!
keysAndValuesRemove: keyValueBlock
	"Removes all entries for which keyValueBlock returns true."
	"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method."

	| removals |
	removals _ OrderedCollectio new.
	self associationsDo:
		[:assoc | (keyValueBlock value: assoc key value: assoc value)
			ifTrue: [removals add: assoc key]].
 	removals do:
		[:aKey | self removeKey: aKey]! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717371 overrides: 16920235!
initialize
	"Initialize a blank ChangeList.  Set the contentsSymbol to reflect whether diffs will initally be shown or not"

	contentsSymbol _ (Preferences at: #diffsInChangeList)
		ifTrue:
			[self defaultDiffsSymbol]
		ifFalse:
			[#source].
	changeList _ OrderedCollectio new.
	list _ OrderedCollectio new.
	listIndex _ 0.
	super initialize! !
!EqualsTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717387 overrides: 50625983!
buildCastApplierBefore: aPreviousCastingApplier 
	
	 ^EffectiveTypeCastApplier 
		casts: (OrderedCollectio with: self buildTypeCast)
		rejections: OrderedCollectio new
		previous: aPreviousCastingApplier! !
!TestSuite class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717397!
forClasses: classes named: aName

	| testMethods suite classTests tests testPrintString |
	
	"I don't want repeated tests. TestCase does not redefine #= so instead of redefining it and use a Set
	I decided to keep the related tests methods in a different set and decide to add it or note base on that
	- Hernan"
	
	testMethods := Set new.
	tests := OrderedCollectio new.
	
	classes do: [ :aClass |
		classTests := (self forClass: aClass) tests.
		classTests do: [ :aTest | 
				testPrintString := aTest printString.
				(testMethods includes: testPrintString) ifFalse: [ 
					testMethods add: testPrintString.
					tests add: aTest ]]].
		
	suite := self named: aName.
	suite addTests: tests.
	
	^suite
		
! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717423!
testNodesAdjacentTo

	| graph adjacentNodes |

	graph :=
		Graph edges: (
			OrderedCollectio new
				add: (Edge from: 1 to: 2);
				add: (Edge from: 2 to: 3);
				add: (Edge from: 4 to: 5);
				add: (Edge from: 1 to: 6);
				add: (Edge from: 1 to: 7);
				yourself).

	adjacentNodes := #(2 6 7).

	self assert: (graph nodesAdjacentTo: 1) asOrderedCollection = adjacentNodes asOrderedCollection! !
!StringTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717439!
testLineSeparators
	"
	Test that #newLineCharacter is considered a line separator and not a line terminator.
	This means that the last line never ends with a #newLineCharacter (although it might be empty!!)
	StringTest new testLineSeparators
	"
	| justAnLf linesBounds |
	linesBounds _ OrderedCollectio new.
	justAnLf _ '
'.
	justAnLf lineIndicesDo: [ :start :endWithoutDelimiters :end |
		linesBounds add: { start . endWithoutDelimiters. end }.
		].

	self assert: linesBounds size = 2 description: 'There should be two lines.'.

	self assert: linesBounds first first = 1 description: 'First line starts at position 1'.
	self assert: linesBounds first second = (linesBounds first first-1) description: 'First line is empty'.
	self assert: linesBounds first third = (linesBounds first second+1) description: 'First line is terminated by ab Lf'.

	self assert: linesBounds second first = ( linesBounds first third+1) description: 'Second line starts after end of first line'.
	self assert: linesBounds second second = (linesBounds second first-1) description: 'Second line is empty'.
	self assert: linesBounds second third = (linesBounds second second+0) description: 'Second line is not terminated by ab Lf'.! !
!ChangeLog methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717481 overrides: 16920235!
initialize
	changeDetectors := OrderedCollectio new.
	
	changeDetectors add: self testRenamedDetector.
	changeDetectors add: self testClassRemovedDetector.
	changeDetectors add: self classRemovedDetector.
	changeDetectors add: self classRenamedDetector.
	changeDetectors add: self testRemovedDetector.
	changeDetectors add: self modelMethodRemovedDetector.
	changeDetectors add: self newProductionClassDetector.
	changeDetectors add: self newProductionMethodDetector.
	changeDetectors add: self newTestDetector.
	changeDetectors add: self newTestClassDetector.
	changeDetectors add: self productionMethodChangedDetector.
	changeDetectors add: self testChangedDetector.
	changeDetectors add: self testFailedDetector.
	changeDetectors add: self testPassedDetector.
	changeDetectors add: self testUtilityChangeDetector.
	changeDetectors add: self unknownChangeDetector.	! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717512!
send: startUpOrShutDown toClassesNamedIn: startUpOrShutDownList with: argument
	"Send the message #startUp: or #shutDown: to each class named in the list.
	The argument indicates if the system is about to quit (for #shutDown:) or if
	the image is ia real startup (or just continue after image save) (for #startUp:).
	If any name cannot be found, then remove it from the list."

	| removals class |
	removals _ OrderedCollectio new.
	startUpOrShutDownList do:
		[:name |
		class _ self at: name ifAbsent: nil.
		class
			ifNil: [removals add: name]
			ifNotNil: [
				class isInMemory ifTrue: [
					class perform: startUpOrShutDown with: argument]]].

	"Remove any obsolete entries, but after the iteration"
	"Well, not. Better just ignore them. Maybe it is stuff, like SoundPlayer, that was moved to optional packages, and can be loaded again anytime."
	"startUpOrShutDownList removeAll: removals"! !
!CollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717544!
testGroupByReturnsADictionaryThatGroupsACollectionByThePluggableKey

	| collectionToGroupBy groupedByEven |
	
	collectionToGroupBy := OrderedCollectio with: 1 with: 2 with: 3 with: 4 with: 5.
	groupedByEven := collectionToGroupBy groupBy: [ :anInteger | anInteger even ].
	
	self assert: groupedByEven size equals: 2.
	self assert: (collectionToGroupBy select: [ :anInteger | anInteger even ]) equals: (groupedByEven at: true).
	self assert:(collectionToGroupBy select: [ :anInteger | anInteger odd ]) equals: (groupedByEven at: false).! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717565!
contributionsOf: aString
	"
	Smalltalk contributionsOf: 'JMV'
	"
	| author answer |
	answer _ OrderedCollectio new.
	Smalltalk allBehaviorsDo: [ :behavior |
		behavior methodsDo: [ :compiledMethod |
			author _ compiledMethod author.
			aString = author ifTrue: [
				answer add: {compiledMethod methodClass. compiledMethod selector}]]].
	^answer! !
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717580!
divideRectVertically: aRectangle by: aNumber

	| h y rects |
	
	y _ aRectangle origin y.
	h _ aRectangle height // aNumber.
	rects _ OrderedCollectio new.
	
	aNumber timesRepeat: [ |rect|
		rect _ Rectangle origin: aRectangle origin x@y extent: aRectangle width@h.
		y _ y + h.
		rects add: rect].
	
	 ^ rects
	
	! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717594!
simpleEnsureTestResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: self doSomethingElseString;
		add: self doYetAnotherThingString;
		yourself! !
!PackageInstaller methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717603!
updatePackageList
	
	(PopUpMenu confirm: 'I need to scan for packages. This takes some time. Continue?')
		ifFalse: [^ OrderedCollectio new].
	packageList _ OrderedCollectio new.
	self collectPackagesFromDisk.
	packageList sort: [:p1 :p2 | p1 packageName < p2 packageName].
	PackageList _ packageList.
	self changed: #packageList.
	^ packageList! !
!InlineMethodApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717618!
createMessageSends

	^OrderedCollectio new.
! !
!TDDGuru methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717623!
initializeChangeLog
	| fileStream changeList file changes |
	
	changeLog := OrderedCollectio new.
	file := changesFile asFileEntry.
	
	file exists ifTrue: [
		fileStream := file readStream.
		changeList := (ChangeList new scanFile: fileStream from: changesFileStartPosition to: fileStream size) changeList.
		changes := changeList copyFrom: startingPoint to: changeList size.
		changeLog := ChangeLog from: changes using: inventory.
	]
	
	
	! !
!DefinedByRules methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717641 overrides: 16823689!
species

	^OrderedCollectio! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717646!
chooseInstVarThenDo: aBlock
	"Put up a menu of all the instance variables in the receiver, and when
the user chooses one, evaluate aBlock with the chosen variable as its
parameter.  If the list is 6 or larger, then offer an alphabetical
formulation as an alternative. triggered by a 'show alphabetically' item
at the top of the list."

	| lines labelStream allVars index count offerAlpha |
	(count _ self allInstVarNames size) = 0 ifTrue: 
		[ ^ self inform: 'There are no\instance variables.' withNewLines ].

	allVars _ OrderedCollectio new.
	lines _ OrderedCollectio new.
	labelStream _ String writeStream.

	(offerAlpha _ count > 5)
		ifTrue: [
			lines add: 1.
			allVars add: 'show alphabetically'.
			labelStream nextPutAll: allVars first].
	self withAllSuperclasses reverseDo: [ :class | | vars |
		vars _ class instVarNames.
		vars do: [ :var |
			labelStream position = 0 ifFalse: [labelStream newLine].
			labelStream nextPutAll: var.
			allVars add: var].
		vars isEmpty ifFalse: [lines add: allVars size]].
	(lines notEmpty and: [ lines last = allVars size ]) ifTrue: [
		lines removeLast ].  "dispense with inelegant line beneath last item"
	index _ (PopUpMenu labels: labelStream contents lines: lines)
startUpWithCaption: 'Instance variables in
', self name.
	index = 0 ifTrue: [^ self].
	(index = 1 and: [offerAlpha]) ifTrue: [
		^ self chooseInstVarAlphabeticallyThenDo: aBlock].
	aBlock value: (allVars at: index)! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717695!
case: dist
	"statements = keyStmts #CascadeFlag keyValueBlock ... keyStmts"

	| nextCase thenJump stmtStream elements b node cases otherBlock myExits |
	nextCase := pc + dist.

	"Now add #CascadeFlag & keyValueBlock to statements"
	statements addLast: stack removeLast.
	stack addLast: #CaseFlag. "set for next pop"
	statements addLast: (self blockForCaseTo: nextCase).

	stack last == #CaseFlag
		ifTrue: "Last case"
			["ensure jump is within block (in case thenExpr returns weirdly I guess)"
			stack removeLast. "get rid of #CaseFlag"
			stmtStream := (self popTo: stack removeLast) readStream.
			
			elements := OrderedCollectio new.
			b := OrderedCollectio new.
			[stmtStream atEnd] whileFalse:
				[(node := stmtStream next) == #CascadeFlag
					ifTrue:
						[elements addLast: (constructor
							codeMessage: (constructor codeBlock: b returns: false)
							selector: (constructor codeSelector: #-> code: #macro)
							arguments: (Array with: stmtStream next)).
						 b := OrderedCollectio new]
					ifFalse: [b addLast: node]].
			b size > 0 ifTrue: [self error: 'Bad cases'].
			cases := constructor codeBrace: elements.
			
			"try find the end of the case"
			myExits := caseExits removeLast: elements size.
			myExits := myExits reject: [ :e | e isNil or: [ e < 0 or: [ e > method endPC ] ] ].
			thenJump := myExits isEmpty
							ifTrue: [ nextCase ]
							ifFalse: [ myExits max ].
			
			otherBlock := self blockTo: thenJump.
			stack addLast:
				(constructor
					codeMessage: stack removeLast
					selector: (constructor codeSelector: #caseOf:otherwise: code: #macro)
					arguments: (Array with: cases with: otherBlock))].! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717751 overrides: 16961394!
setUp
	super setUp.
	collection := OrderedCollectio new! !
!PathCurveToCommand methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717757 overrides: 50431909!
buildFrom: commandChar stream: aStream

	| x1 y1 x2 y2 x y |
	super buildFrom: commandChar stream: aStream.
	toPoints _ OrderedCollectio new.
	control1Points _ OrderedCollectio new.
	control2Points _ OrderedCollectio new.
	[
		x1 _ aStream nextNumber.
		y1 _ aStream nextNumber.
		x2 _ aStream nextNumber.
		y2 _ aStream nextNumber.
		x _ aStream nextNumber.
		y _ aStream nextNumber.
		y notNil ] whileTrue: [
			toPoints add: x@y.
			control1Points add: x1@y1.
			control2Points add: x2@y2 ]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717776!
analyseArguments: methodArguments temporaries: methodTemporaries rootNode: rootNode "<MethodNode>" "^<Sequence of: <TempVarNade>>"
	"Top level entry-point for analysing temps within the hierarchy of blocks in the receiver's method.
	 Answer the (possibly modified) sequence of temp vars.
	 Need to hoist temps out of macro-optimized blocks into their actual blocks.
	 Need to note reads and writes to temps from blocks other than their actual blocks to determine
	 whether blocks can be local (simple slots within a block/method context) or remote (slots in
	 indirection vectors that are shared between contexts by sharing indirection vectors).

	 The algorithm is based on numbering temporary reads and writes and block extents.
	 The index used for numbering starts at zero and is incremented on every block entry
	 and block exit.  So the following
		| a b blk r1 r2 t |
		a := 1. b := 2. t := 0.
		blk := [ | s | s := a + b. t := t + s].
		r1 := blk value.
		b := -100.
		r2 := blk value.
		r1 -> r2 -> t
	is numbered as
		method block 0 to: 6:
		| a b blk r1 r2 t |
		a w@1 := 1. b w@1 := 2. t w@1 := 0.
		blk w@5 := [entry@2 | s |
					 t  w@3 := t r@3 + a r@3 + b r@3
					] exit@4.
		r1 w@5 := blk r@5 value.
		b w@5 := nil.
		r2 w@5 := blk r@5 value.
		r1 r@5 -> r2 r@5 -> t r@5
	So:
		b and blk cannot be copied because for both there exists a write @5 that follows a
			read @4 within block 2 through 4
		t must be remote because there exists a write @3 within block (2 to: 4)
	Complications are introduced by optimized blocks.  In the following temp is written to
	after it is closed over by [ temp ] since the inlined block is executed more than once.
		| temp coll |
		coll := OrderedCollection new.
		1 to: 5 do: [ :index | 
			temp := index. 
			coll add: [ temp ] ].
		self assert: (coll collect: [:ea| ea value]) asArray = #(5 5 5 5 5)
	In the following i is local to the block and must be initialized each time around the loop
	but if the block is inlined it must be declared at method level.
		| col |
		col := OrderedCollection new.
		1 to: 3 do: [ :each | | i | i := each. col add: [ i ]. i := i + 1 ].
		self assert: (col collect: [ :each | each value ]) asArray = #(2 3 4)"
	self assert: (arguments isEmpty or: [arguments hasEqualElements: methodArguments]).
	arguments := methodArguments asArray. "won't change"
	self assert: (temporaries isNil or: [temporaries isEmpty or: [temporaries hasEqualElements: methodTemporaries]]).
	temporaries := OrderedCollectio withAll: methodTemporaries.

	self assert: optimized not. "the top-level block should not be optimized."
	self analyseTempsWithin: self rootNode: rootNode assignmentPools: Dictionary new.

	"The top-level block needs to reindex temporaries since analysis may have rearranged them.
	 This happens when temps are made remote and/or a remote node is added."
	temporaries withIndexDo:
		[:temp :offsetPlusOne| temp index: arguments size + offsetPlusOne - 1].

	"Answer the (possibly modified) sequence of temps."
	^temporaries asArray! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717874!
errorsAndWarningsAsMethodReferencesWithProblems: showProblems
	
	| list |
	
	list := OrderedCollectio new.
	self sortedTypeCheckers do: [ :aTypeChecker | 
		(aTypeChecker hasErrorsOrWarnings or: [ showProblems and: [ aTypeChecker hasProblems ]])
			ifTrue: [
				list add: aTypeChecker method.
				list addAll: (aTypeChecker errorsAndWarningsAsMethodReferencesWithProblems: showProblems prefixing: '  ') ]].
				
	^list! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717891!
testDecompiler
	"
	Smalltalk testDecompiler
	"
	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."
	| methodNode oldMethod newMethod badOnes oldCodeString n |
	badOnes _ OrderedCollectio new.
	'Decompiling all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldMethod _ cls compiledMethodAt: selector.
					oldCodeString _ (cls decompilerClass new
						decompile: selector
						in: cls
						method: oldMethod) decompileString.
					methodNode _ cls compilerClass new
						compile: oldCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod _ methodNode generate: #(0 0 0 0 ).
					oldCodeString =
						(cls decompilerClass new
							decompile: selector
							in: cls
							method: newMethod) decompileString ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: (MethodReference class: cls selector: selector) ]]]].
	Smalltalk
		browseMessageList: badOnes
		name: 'Decompiler Discrepancies'.! !
!WorldMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717942!
deleteAllHalos
	| c |
	c _ OrderedCollectio new.
	self haloMorphsDo: [ :halo | c add: halo ].
	self removeAllMorphsIn: c! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717950!
definitionOf: aMetaclass

	^ String streamContents: [ :stream | | selector collaborators |
		stream
			nextPutAll: aMetaclass soleInstance name.
	
		"Done this way to support rename of #create:collarobatorNames:in: - Hernan"
		collaborators := OrderedCollectio new.
		(aMetaclass soleInstance superclass is: #DenotativeObject) 
			ifTrue: [ 
				selector := #asChildOf:collaboratorNames:in:.
				collaborators add: aMetaclass soleInstance superclass name ]
			ifFalse: [ selector := #collaboratorNames:in: ].
			
		collaborators 
			add: '''', aMetaclass instanceVariablesString, '''';
			add: '''', aMetaclass category, ''''. 
									
		selector keywords withIndexDo: [ :keyword :index |
			stream
				newLine;
				tab;
				nextPutAll: keyword;
				space;
				nextPutAll: (collaborators at: index) ]]! !
!Form methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:44' prior: 50717979!
asColorFormOfDepth: destDepth
	"
	Answer a ColorForm with a custom optimized palette of up to 256, 16 or 4 entries.
	self runningWorld backgroundImage asColorFormOfDepth: 8 :: display
	self runningWorld backgroundImage orderedDither32To16 asColorFormOfDepth: 8 :: display
	self runningWorld backgroundImage orderedDither32To16 asColorFormOfDepth: 4 :: display
	"
	| answer bitsPerColor clusterIndexToSplit clusterToSplit clusters colors desiredNumberOfClusters errors firstCluster map metricToSplitOn tally valueToSplitOn box hueWeightFactor brightnessWeightFactor saturationWeightFactor |
	self depth > 8 ifFalse: [
		^self error: 'Only for 16 bit and 32 bit Forms' ].
	desiredNumberOfClusters _ 1 bitShift: destDepth.

	"Wheights to balance error on each color metric"
	hueWeightFactor _ 8.0 / 360.0.
	saturationWeightFactor _ 1.0.
	brightnessWeightFactor _ 3.0.
	destDepth < 8 ifTrue: [
		brightnessWeightFactor _ 13.0.
		destDepth < 4 ifTrue: [
			hueWeightFactor _ 0.0.
			saturationWeightFactor _ 0.0. ]].
	"Assign all pixels to a single cluster"
	tally _ self tallyPixelValues.
	firstCluster _ OrderedCollectio new.
	tally withIndexDo: [ :pixelCount :pixelValuePlusOne |
		pixelCount = 0 ifFalse: [ |c|
			c _ Color colorFromPixelValue: pixelValuePlusOne -1 depth: 16.
			firstCluster add: {c hue. c saturation. c brightness. pixelCount. pixelValuePlusOne } ]].
	clusters _ OrderedCollectio with: firstCluster.

	"Pick the existing cluster with the largest error, and split it."
	[clusters size < desiredNumberOfClusters and: [ clusters anySatisfy: [:eachCluster | eachCluster size > 1]]] whileTrue: [ | cluster1 cluster2 |
		"Detect cluster with largest error, and split it"
		errors _ clusters collect: [ :eachCluster | | sum average error |
			sum _ (eachCluster sum: [ :e | {e first * e fourth. e second * e fourth. e third * e fourth. e fourth }]).
			average _ {sum first. sum second. sum third} / sum fourth.
			error _ eachCluster sum: [ :e | | hueError |
				hueError _ (e first - average first) abs. hueError > (360/2) ifTrue: [hueError _ 360 - hueError].
				{hueError * hueWeightFactor. (e second-average second) abs * saturationWeightFactor. (e third-average third) abs * brightnessWeightFactor} * e fourth ].
			{error max. error indexOfMax. average at: error indexOfMax} ].
		clusterIndexToSplit _ (errors collect: [ :e | e first]) indexOfMax.
		metricToSplitOn _ (errors at: clusterIndexToSplit) second.
		valueToSplitOn _ (errors at: clusterIndexToSplit) third.
		clusterToSplit _ clusters at: clusterIndexToSplit.
		cluster1 _ OrderedCollectio new.
		cluster2 _ OrderedCollectio new.
		clusterToSplit do: [ :pixelMetricsAndCount |
			(pixelMetricsAndCount at: metricToSplitOn) < valueToSplitOn
				ifTrue: [cluster1 add: pixelMetricsAndCount]
				ifFalse: [cluster2 add: pixelMetricsAndCount]].
		clusters at: clusterIndexToSplit put: cluster1.
		clusters add: cluster2.
	].

	colors _ clusters collect: [ :eachCluster | | sum average |
		average _ eachCluster average.
			sum _ (eachCluster sum: [ :a | {a first * a fourth. a second * a fourth. a third * a fourth. a fourth }]).
			average _ {sum first. sum second. sum third} / sum fourth.
		Color hue: average first saturation: average second brightness: average third ].
	answer _ ColorForm extent: self extent depth: destDepth.
	answer colors: colors.

	"Build colormap for displaying self on answer"
	bitsPerColor _ 5.				"To read 16bpp source"
	map _ Bitmap new: (1 bitShift: 3*bitsPerColor).
	clusters withIndexDo: [ :eachCluster :clusterIndex |
		eachCluster do: [ :pixMetrixsAndCount |
			map at: pixMetrixsAndCount fifth put: clusterIndex-1 ]].

	box _ self boundingBox.
	answer copyBits: box from: self at: 0@0 clippingBox: box rule: Form over map: map.
	^answer
! !
!Collection methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718100!
groupBy: keyBlock 

	^ self 
		inject: Dictionary new
		into: [ :groupedCollection :elementToGroup | | group |
			group := groupedCollection at: (keyBlock value: elementToGroup) ifAbsentPut: [ OrderedCollectio new ].
			group add: elementToGroup.
			groupedCollection ]
		! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718112!
keysSortedSafely
	"Answer a sorted Collection containing the receiver's keys."
	| sortedKeys |
	sortedKeys _ OrderedCollectio new: self size.
	self keysDo: [:each | sortedKeys addLast: each].
	sortedKeys sort:
		[ :x :y |  "Should really be use <obj, string, num> compareSafely..."
		((x isString and: [y isString])
			or: [x isNumber and: [y isNumber]])
			ifTrue: [x < y]
			ifFalse: [x class == y class
				ifTrue: [x printString < y printString]
				ifFalse: [x class name < y class name]]].
	^ sortedKeys! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718132!
testInlineBlockCollectionLR1
	"Test case from Lukas Renggli"
	| col |
	col := OrderedCollectio new.
	1 to: 11 do: [ :each | col add: [ each ] ].
	self assert: (col collect: [ :each | each value ]) asArray = (1 to: 11) asArray! !
!MinusInfinity methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718143 overrides: 50524008!
composeWithSimpleMeasure: aMeasure

	^CompoundMeasure measures: (OrderedCollectio with: self with: aMeasure)! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718150!
errorsAsMethodReferences
	
	| list |
	
	list := OrderedCollectio new.
	self sortedTypeCheckers do: [ :aTypeChecker | 
		aTypeChecker hasErrors ifTrue: [
			list add: aTypeChecker method.
			list addAll: (aTypeChecker errorsAsMethodReferencesPrefixing: '  ')
			"list addAll: aTypeChecker errorsAsMethodReferences"]].
			
	^list! !
!MirrorPrimitiveTests methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718164!
testMirrorPerform
	| stackpBefore stackpAfter anInterval |

	Smalltalk isRunningCog ifFalse: [
		^self assert: false description: 'Needs Cog' ].

	stackpBefore := thisContext stackPtr.
	anInterval := 1 to: 2.
	self assert: (thisContext object: anInterval perform:# species withArguments: #() inClass: Interval) == Array.
	self assert: (thisContext object: anInterval perform:# species withArguments: #() inClass: Interval superclass) == Interval.
	self should: [thisContext object: anInterval perform:# species withArguments: #() inClass: Point]
		raise: Error.
	self should: [thisContext object: anInterval perform:# species withArguments: OrderedCollectio new inClass: Interval]
		raise: Error.
	stackpAfter := thisContext stackPtr.
	self assert: stackpBefore = stackpAfter "Make sure primitives pop all their arguments"! !
!UnicodeString methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718194!
basicCanonicalComposition
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	See examples at #canonicalComposition.
	(UnicodeString fromCodePoints: #(119128 119141)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119135 119151)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119128 119141 119151)) basicCanonicalComposition asCodePoints
	"
	| byteIndex stopByteIndex n combining cls |
	byteIndex _ 1.
	stopByteIndex _ bytes size.
	combining _ OrderedCollectio new.
	^UnicodeString streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			n _ Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				cls _ UnicodeCodePoint combiningClass: codePoint.
				cls = 0 ifTrue: [
					self basicCompose: combining on: strm.
					combining _ OrderedCollectio new ].
				combining add: codePoint ].
			byteIndex _ byteIndex + n ].
		self basicCompose: combining on: strm ].! !
!CodePackageListWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718230!
addRequirement
	"Ask user for a FeatureRequirement based on loaded packages"
	
	| current currentName packageNames reqiredNames selectionNames choices selection cuisBaseName req selectedName |
	current _ model selection.
	current ifNil: [ ^self ].

	packageNames := model packages collect: [ :pak | pak packageName ].
	currentName := current packageName.
	reqiredNames := current requires collect: [ :r | r name ].
	selectionNames := packageNames select: [ :name |
		((name = currentName) or: [reqiredNames includes: name]) not ].
	cuisBaseName := Feature baseSystemFeature name.
	choices := OrderedCollectio with: #CANCEL.
	(reqiredNames includes: cuisBaseName)
		ifFalse: [ choices add: cuisBaseName ].		
	choices addAll: selectionNames.
	choices size = 1 ifTrue: [
		^ PopUpMenu inform: 'All loaded packages are already required, as is Cuis base system' ].
	selection := PopUpMenu
		withCaption: 'Choose package to require' 
		chooseFrom: choices.
	selection <= 1
		ifTrue: [ ^ self ]  "1 -> Cance, 0 -> Clicked outside the menu"
		ifFalse: [
			selectedName := choices at: selection.
			req := (selectedName = cuisBaseName)
				ifTrue: [ Feature baseSystemFeature requirementOfMe ]
				ifFalse: [ (CodePackage installedPackages at: selectedName) requirementOfMe].
			current featureSpec requires: req.
			current hasUnsavedChanges: true.
			self changed: #requirement ]! !
!ExtractMethodReplacementsFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718278 overrides: 16902254!
value

	sourceCodeToExtract := sourceMethod sourceCode copyFrom: intervalToExtract first to: intervalToExtract last.
	sizeToExtract := intervalToExtract size - 1.
	replacements := OrderedCollectio new.
	
	sourceMethod methodClass withAllSubclassesDo: [ :aClass | self findReplacementsAt: aClass]
	 ! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718291!
signalFromHandlerActionTestResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		add: 'Unhandled Exception';
		yourself! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718300!
test43ReplacesMultipleAssignmentsInMultipleMethodsWithNullObject

	| definitions sourceWithAssignment refactoredMethod expectedSource nextLine firstRightSide secondRightSide aClassToRefactor refactoring replacementParameters |

	nextLine := String newLineString, String tab.
	aClassToRefactor := self defaultClassToRefactor.
	replacementParameters := OrderedCollectio new.
	(1 to: 2) do: [:i | | ifMessageNode methodNode selector |
		selector := (self methodToRefactorSelector asString, i asString) asSymbol.
		sourceWithAssignment := selector asString, nextLine, self defaultInstVarName, ' ifNil: [1+1. 2+2].'.
		firstRightSide := 'self doSomething'.
		sourceWithAssignment := sourceWithAssignment, nextLine, self defaultInstVarName, ' := ', firstRightSide,'.'.
		secondRightSide := 'self doSomething +  ivar different'.
		sourceWithAssignment := sourceWithAssignment, nextLine, self defaultInstVarName, ' := ', secondRightSide, '.'.
		definitions := VariablesToParametrizeKeywordsDefinitions withSelector: #unaryPolymorphicSelector.
		aClassToRefactor compile: sourceWithAssignment.
		methodNode := (aClassToRefactor compiledMethodAt: selector) methodNode.
		ifMessageNode :=  methodNode block statements first.

		replacementParameters add: (
			ReplaceIfNilWithPolymorphismParameters
				forIfNilMessageSending: ifMessageNode
				onMethod: methodNode
				useKeywordsDefinitions: definitions)].

	refactoring := IntroduceNullObject
		on: self defaultInstVarName
		of: aClassToRefactor
		usingAsConcreteClass: self concreteClass
		usingAsNullClass: self nullClass
		for: replacementParameters.

	refactoring apply.

	(1 to: 2) do: [:i | | selector |	
		selector := (self methodToRefactorSelector asString, i asString) asSymbol.
		refactoredMethod := self defaultClassToRefactor compiledMethodAt: selector.
		expectedSource := selector asString, nextLine, self defaultInstVarName, ' unaryPolymorphicSelector.'.
		expectedSource := expectedSource, nextLine, 'self assignNullObjectIfNil: (', firstRightSide, ').'.
		expectedSource := expectedSource, nextLine, 'self assignNullObjectIfNil: (', secondRightSide withBlanksCondensed , ').'.
		self assert: expectedSource equals: refactoredMethod sourceCode].! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718373!
currentVersionsOfSelections
	"Opens a message-list browser on the current in-memory versions of all methods that are currently seleted"
	| aList |

	aList _ OrderedCollectio new.
	1 to: changeList size do: [ :i |
		(listSelections at: i) ifTrue: [
			| aClass aChange |
			aChange _ changeList at: i.
			(aChange changeType == #method
				and: [(aClass _ aChange changeClass) notNil
				and: [aClass includesSelector: aChange methodSelector]])
					ifTrue: [
						aList add: (MethodReference
							class: aClass
							selector: aChange methodSelector)]]].
	^ aList! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718395!
conversionMethodsFor: classList
	| oldStruct newStruct list |
	"Each of these needs a conversion method.  Hard part is the comment in it.  Return a MessageSet."

	list _ OrderedCollectio new.
	classList do: [:cls |
		oldStruct _ structures at: cls name ifAbsent: [#()].
		newStruct _ (Array with: cls classVersion), (cls allInstVarNames).
		self writeConversionMethodIn: cls fromInstVars: oldStruct to: newStruct 
				renamedFrom: nil.
		list add: cls name, ' convertToCurrentVersion:refStream:'.
		].

	^ MessageSet new initializeMessageList: list.! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718416!
defaultQueue
	defaultQueue ifNil: [defaultQueue _ OrderedCollectio new].
	^ defaultQueue! !
!SystemDictionary class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718423 overrides: 16904184!
initialize
	"
	SystemDictionary initialize
	"
	
	"Hacer esto bien explicito al menos para las clases en la imagen base?
	Quisiera un mecanismo que sea igual de bueno para clases base que para clases en paquetes.
	Excepto para MUY pocas cosas quizas, como la 1ra parte de StartUpList... El resto deberia usar el mismo esquema
	este en la imagen base o en paquetes. Y seria quizas onda initialize.
	O sea, quizas al cargar un paquete deberia llamarse initialize y startup, no se.
	Como que initialize es cuando se crea la clase (o en cualquier momento que quieras reinicializar)
	y startUp se ejecuta TAMBIEN cuando levanta la imagen.
	Como initialize clashea con las instancias, quizas uniformar todo en startUp: y shutDown: / startUp y shutDown .... 
	
	Cargar todos los paquetes. estudiar implementors y senders de startUp: y shutDown: / startUp y shutDown
	ver senders de addToStartUpList: y addToShutDownList:"

	StartUpList _ OrderedCollectio new.
	"These get processed from the top down..."
	#(
		#Delay
		#DisplayScreen
		#Cursor
		#InputSensor
		#ProcessorScheduler 	"Starts low space watcher and bkground."
		#WeakArray)
			do: [ :clsName | 	
				Smalltalk at: clsName ifPresent: [:cls | Smalltalk addToStartUpList: cls]].
			
	ShutDownList _ OrderedCollectio new.
	"These get processed from the bottom up..."
	#(
		#Delay
		#DisplayScreen
		#InputSensor
		#Symbol
		#ProcessBrowser
		#CPUWatcher)
			do: [ :clsName | 
				Smalltalk at: clsName ifPresent: [:cls | Smalltalk addToShutDownList: cls]]! !
!IsKindOfManyTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718475 overrides: 50625983!
buildCastApplierBefore: aPreviousCastingApplier 

	^EffectiveTypeCastApplier 
		casts: (OrderedCollectio with: self buildTypeCast)
		rejections: OrderedCollectio new
		previous: aPreviousCastingApplier! !
!InlineMethodApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718486 overrides: 16923927!
value

	requestExitBlock := [ ^self ].

	self requestRefactoringParametersHandlingRefactoringExceptions.

	self
		ifHasNoUsagesAndOneImplementor: [ :anImplementor |
			shouldRemoveImplementor ifFalse: [self askIfImplementorShouldBeRemovedWhenNoSenders ]. "Give the user another chance to delete the message"
			shouldRemoveImplementor ifFalse: [^self].
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor
		]
		ifNot: [
			self askScope.
			shouldInlineTriggeringMessageSendOnly ifTrue: [
				messageSends := OrderedCollectio new.
				messageSends add: triggeringMessageSend.
				^self askForImplementorsOnly
			].
			self shouldAskForImplementors ifFalse: [implementors := IdentitySet with: (selectedClass >> selectorToInline). ^self askForMessagesToInlineOnly].
			self askForImplementorsAndMessageSends.
	]! !
!ChangeSelectorKeepingParameters class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718517!
from: anOldSelector to: aNewSelector inSystem: aSystem

	| implementors senders |

	implementors := OrderedCollectio new.
	senders := OrderedCollectio new.

	self 
		addImplementorsOf: anOldSelector 
		to: implementors 
		andSendersTo: senders 
		inSystem: aSystem.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: (self collectCompiledMethodsOf: senders)
	! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718533!
askRemovedInstVars: classList
	| pairList pairClasses index pls |
	"Ask the author whether these newly removed inst vars need to have their info saved"

	pairList _ OrderedCollectio new.
	pairClasses _ OrderedCollectio new.
	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."
	classList do: [ :cls |
		| newStruct oldStruct |
		newStruct _ (cls allInstVarNames).
		oldStruct _ (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.
		oldStruct do: [:instVarName |
			(newStruct includes: instVarName) ifFalse: [
				pairList add: cls name, ' ', instVarName.
				pairClasses add: cls]]].

	pairList isEmpty ifTrue: [^ #()].
	[
		index _ PopUpMenu withCaption: 'These instance variables were removed.
When an old project comes in, instance variables 
that have been removed will lose their contents.
Click on items to remove them from the list.
Click on any whose value is unimportant and need not be saved.'
			chooseFrom: pairList, #('all of these need a conversion method'
						'all of these have old values that can be erased').
		(index <= (pls _ pairList size)) & (index > 0) ifTrue: [
			pairList removeAt: index.
			pairClasses removeAt: index].
		index = (pls + 2) ifTrue: ["all are OK" ^ #()].
		pairList isEmpty | (index = (pls + 1))  "all need conversion, exit"] whileFalse.

	^ pairClasses asSet asArray	"non redundant"! !
!CollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718581!
testGroupByHavingSelectsTheResultOfGroupBy

	| collectionToGroupBy groupedByEven |
	
	collectionToGroupBy := OrderedCollectio with: 1 with: 2 with: 3 with: 4 with: 5.
	groupedByEven := collectionToGroupBy groupBy: [ :anInteger | anInteger even ] having: [ :group | group size > 2 ].
	
	self assert: (groupedByEven size) equals: 1.	
	self assert: (collectionToGroupBy select: [ :anInteger | anInteger odd ]) equals: (groupedByEven at: false).! !
!OrderedDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718599 overrides: 16935795!
init: n

	super init: n.
	orderedKeys _ OrderedCollectio new: n! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718605!
obsoleteClasses   "Smalltalk obsoleteClasses inspect"
	"NOTE:  Also try inspecting comments below"
	| obs c |
	obs _ OrderedCollectio new.  Smalltalk garbageCollect.
	Metaclass allInstancesDo:
		[:m | c _ m soleInstance.
		(c notNil and: ['AnOb*' match: c name asPlainString])
			ifTrue: [obs add: c]].
	^ obs asArray

"Likely in a ClassDict or Pool...
(Association allInstances select: [:a | (a value isKindOf: Class) and: ['AnOb*' match: a value name]]) asArray
"
"Obsolete class refs or super pointer in last lit of a method...
| n l found |
Smalltalk browseAllSelect:
	[:m | found _ false.
	1 to: m numLiterals do:
		[:i | (((l _ m literalAt: i) isMemberOf: Association)
				and: [(l value isKindOf: Behavior)
				and: ['AnOb*' match: l value name]])
			ifTrue: [found _ true]].
	found]
"! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718633!
allSuperclassesUpTo: aSuperclass
	
	| superclasses |
	
	^ superclass = aSuperclass
		ifTrue: [ OrderedCollectio with: aSuperclass]
		ifFalse: [superclasses _ superclass allSuperclassesUpTo: aSuperclass.
			superclasses addFirst: superclass.
			superclasses]! !
!DecompilerConstructor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718645!
codeMethod: selector block: block tempVars: vars primitive: primitive class: class

	| blockNode selectorNode visibleTemps invisibleTemps arguments temporaries properties |
	selectorNode := self codeSelector: selector code: nil.
	tempVars := vars.
	visibleTemps := OrderedCollectio new.
	invisibleTemps := OrderedCollectio new.
	tempVars do: [:t|
				   ((t isIndirectTempVector or: [t scope >= 0])
						ifTrue: [visibleTemps]
						ifFalse: [invisibleTemps]) addLast: t].
	arguments := visibleTemps copyFrom: 1 to: nArgs.
	temporaries := visibleTemps copyFrom: nArgs + 1 to: visibleTemps size.
	block
		arguments: arguments;
		temporaries: temporaries.
	properties := method properties copy.
	(properties at: #onceCache ifAbsent: []) ifNotNil:
		[:onceCache|
		 properties := properties copyWithout: (Association
													key: #onceCache
													value: onceCache)].
	blockNode := MethodNode new
		selector: selectorNode
		arguments: arguments
		precedence: selector precedence
		temporaries: temporaries
		block: block
		encoder: (method encoderClass new initScopeAndLiteralTables
					temps: visibleTemps, invisibleTemps
					literals: literalValues
					class: class)
		primitive: primitive
		properties: properties.
	blockNode properties method: blockNode.
	^blockNode! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718689!
methodCategories

	| categories |
	
	categories := OrderedCollectio withAll: self organization categories.
	categories remove: ClassOrganizer nullCategory asSymbol ifAbsent: nil.
	
	^categories ! !
!Symbol class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718699!
selectorsContaining: aString
	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."

	| size selectorList ascii |

	selectorList _ OrderedCollectio new.
	(size _ aString size) = 0 ifTrue: [^selectorList].

	aString size = 1 ifTrue: [
		ascii _ aString first numericValue.
		ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]].

	aString first isValidInIdentifiers ifFalse: [
		aString size = 2 ifTrue: [
			Symbol hasInterned: aString ifTrue: [ :s | selectorList add: s]].
		^selectorList ].

	selectorList _ selectorList copyFrom: 2 to: selectorList size.

	self allSymbolTablesDo: [ :each |
		each size >= size ifTrue: [
			(each findString: aString startingAt: 1 caseSensitive: false) > 0
				ifTrue: [selectorList add: each]]].

	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"
		each numArgs < 0 and: [each asPlainString uncapitalized numArgs < 0]].

"Symbol selectorsContaining: 'scon'"! !
!CodeCoverageTextStyler methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718736!
consolidate: sourceRanges using: sourceCode

	"Try to close the gaps between source ranges in sourceRanges to highlight source code without
	interruptions as much as possible.
	
	TODO(NPM): this is a hack, and it is done here to make highlighted code look better. It can probably be
	solved better when compiled methods are traced."

	^ (sourceRanges asSortedCollection: [ :sourceRange :otherSourceRange |  sourceRange first < otherSourceRange first ])
		inject: OrderedCollectio new
		into: [ :consolidatedSourceRanges :sourceRage |
			self consolidate: sourceRage in: consolidatedSourceRanges using: sourceCode.
			consolidatedSourceRanges ]! !
!Graph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718760!
initializeEdges: aCollectionOfEdges nodes: aCollectionOfNodes

	edges := OrderedCollectio withAll: aCollectionOfEdges.
	nodes := aCollectionOfNodes asSet
	
! !
!Class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718768!
declareSharedPools: sharedPoolNames
	"Set up sharedPools. Answer whether recompilation is advisable."
	| oldPools |
	oldPools := self sharedPools.
	sharedPools := OrderedCollectio new.
	sharedPoolNames do: [ :poolName | 
		sharedPools add: (Smalltalk at: poolName asSymbol ifAbsent: [
			(PoolDefinitionNotification signalNamed: poolName)
				ifTrue: [ Smalltalk at: poolName asSymbol put: Dictionary new ]
				ifFalse: [^self error: poolName,' does not exist']])].
	sharedPools isEmpty ifTrue: [ sharedPools := nil ].
	^oldPools anySatisfy: [ :pool |
		self sharedPools noneSatisfy: [ :p | p == pool ]].! !
!GraphPathFinderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718791!
testPathToFarAwayPlaces

	| path |

	path := finder pathFrom: 1 to: 3.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 2 to: 3))).

	path := finder pathFrom: 1 to: 4.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 2 to: 3)
		with: (Edge from: 3 to: 4))).
	
	path := finder pathFrom: 2 to: 4.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 2 to: 3)
		with: (Edge from: 3 to: 4)))! !
!PlusInfinity methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718812 overrides: 50524003!
composeWithNumber: aNumber

	^CompoundMeasure measures: (OrderedCollectio with: self with: aNumber)! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718819!
hierarchyForClass: aClass
	"Set the class hierarchy for the list pane"
	| tab |

	selectiveClassList _ OrderedCollectio new.
	tab _ ''.
	aClass withAllSuperclasses reverse do: [:ea | 
		selectiveClassList add: tab , ea name.
		tab _ tab , '  '].
	self classListIndex: 0! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718831!
positionsOfLiteralArraysContaining: aSymbol

	| positions |

	positions := OrderedCollectio new.
	litSet keysAndValuesDo: [ :aLiteral :aLiteralNode |
		(aLiteral isArray and: [ aLiteral hasLiteral: aSymbol ]) ifTrue: [ positions addAll: (sourceRanges at: aLiteralNode) ]].

	^positions ! !
!CodeFileBrowserWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718844!
codeFileListMenu
	| aMenu itemColl |
	self flag: #assumesKeyboardShortcuts.
	aMenu := MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Code File'.
	itemColl := OrderedCollectio new.
	itemColl addAll:
		{
			{#label -> 'find class... (f)'. #selector -> #findClass} asDictionary. 
			nil
		}.
	self model baseCodeSource isLiveSmalltalkImage ifTrue: [
		itemColl add:
			{#label -> 'fileIn'. #object -> #model. #selector -> #fileIn} asDictionary ].
	itemColl add:
		{#label -> 'fileOut'. #object -> #model. #selector -> #fileOut} asDictionary.
	self model caseCodeSource isLiveSmalltalkImage ifFalse: [
		itemColl add:
			{#label -> 'remove existing'. #object -> #model. #selector -> #removeUnmodifiedClasses} asDictionary ].
	aMenu addItemsFromDictionaries: itemColl.
	^ aMenu.! !
!Collection methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718872!
asOrderedCollection
	"Answer an OrderedCollection whose elements are the elements of the
	receiver. The order in which elements are added depends on the order
	in which the receiver enumerates its elements. In the case of unordered
	collections, the ordering is not necessarily the same for multiple 
	requests for the conversion."

	^ self as: OrderedCollectio! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718887!
allSelectors
	"Answer all selectors understood by instances of the receiver"

	| coll |
	coll _ OrderedCollectio new.
	self withAllSuperclasses do:
		[:aClass | coll addAll: aClass selectors].
	^ coll asIdentitySet! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718897!
queueFor: aSymbol
	aSymbol ifNil: [^ self defaultQueue].
	^ self queueDict 
		at: aSymbol 
		ifAbsent: [self queueDict at: aSymbol put: OrderedCollectio new].! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718906!
methodsWithoutClassifications
	"Return a collection representing methods in the receiver which have not been categorized"

	| slips notClassified |

	notClassified _ {'as yet unclassified' asSymbol. #all}.
	slips _ OrderedCollectio new.
	self changedClasses do: [ :aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | aSelector |
			(aClass selectors includes:  (aSelector _ mAssoc key)) ifTrue: [
				(notClassified includes: (aClass organization categoryOfElement: aSelector))
					ifTrue: [slips add: aClass name , ' ' , aSelector]]]].
	^ slips

	"
	Smalltalk browseMessageList: (ChangeSet changeSetForBaseSystem methodsWithoutClassifications) name: 'unclassified methods'
	"! !
!ChangeSelectorKeepingParameters class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718933!
from: anOldSelector to: aNewSelector inHierarchyOf: aClass

	| implementors senders |

	implementors := OrderedCollectio new.
	senders := OrderedCollectio new.
	
	self 
		addImplementorsOf: anOldSelector 
		to: implementors 
		andSendersTo: senders 
		inHierarchyOf: aClass.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: (self collectCompiledMethodsOf: senders)

	! !
!SHParserST80 methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718949!
pushTemporary: aString 
	(temporaries at: blockDepth ifAbsentPut: [OrderedCollectio new: 10]) 
		add: aString! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718956!
allInstVarNamesEverywhere
	"Answer the set of inst var names used by the receiver, all superclasses, and all subclasses"

	| aList |
	aList _ OrderedCollectio new.
	(self allSuperclasses , self withAllSubclasses asOrderedCollection) do:
		[:cls | aList addAll: cls instVarNames].
	^ aList asSet

	"BoxedMorph allInstVarNamesEverywhere"! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718970!
allSuperclasses
	"Answer an OrderedCollection of the receiver's and the receiver's  
	ancestor's superclasses. The first element is the receiver's immediate  
	superclass, followed by its superclass and subsequent superclasses,
	and proceeding as long as there is a non-nil superclass."

	| answer pivot |
	answer := OrderedCollectio new.
	pivot := superclass.
	[pivot == nil] whileFalse:
		[
			answer add: pivot.
			pivot := pivot superclass
		].
	^answer! !
!TTFontDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50718988!
glyphsByUtf8Bytes: glyphsByUTF8 unknownGlyph: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs

	| mGlyph |
	
	mGlyph := glyphsByUTF8 at: $M asciiValue + 1.
	letterMTopSideBearing := (mGlyph ifNil: [theUnknownGlyph]) topSideBearing.

	contourDataIndexesByUtf8 := (IntegerArray new: 256) as: OrderedCollectio.
	contourDataForUtf8 := Float32Array streamContents: [ :stream |
		theUnknownGlyph addGlyphDataTo: stream tx: nil.		"First data is for unknownGlyph"	
		self fullName, ' - Processing glyph data' 
			displayProgressAt: 100@100
			from: 1 
			to: glyphsByUTF8 size 
			during: [ :bar |
				self appendGlyphDataTo: stream glyphsArray: glyphsByUTF8 indexes: contourDataIndexesByUtf8
					base: 0 bar: bar unknown: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs ]].
	contourDataIndexesByUtf8 := contourDataIndexesByUtf8 as: IntegerArray.! !
!FileList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719018!
updateFileList
	"Update my files list with file names in the current directory  
	that match the pattern.
	The pattern string may have embedded newlines or semicolons; these separate different patterns."
	| patterns patternsThatReject patternsThatSelect |
	patterns _ OrderedCollectio new.
	(pattern findTokens: (String with: Character cr with: Character lf with: $;))
		do: [ :each |
			(each includes: $*) | (each includes: $?)
				ifTrue: [ patterns add: (each copyReplaceAll: '?' with: '#')]
				ifFalse: [
					each isEmpty
						ifTrue: [ patterns add: '*']
						ifFalse: [ patterns add: '*' , each , '*']]].
	"A pattern that starts with $/ is used to reject entries
	Rejecting patterns are applied after selecting patterns."
	patternsThatSelect _ patterns reject: [ :any | any first = $/ ].
	patternsThatSelect isEmpty ifTrue: [ patternsThatSelect add: '*' ]. 
	patternsThatReject _ patterns select: [ :any | any first = $/ ] thenCollect: [ :each | each copyFrom: 2 to: each size ].
	list _ self listForSelectingPatterns: patternsThatSelect rejectingPatterns: patternsThatReject.
	listIndex _ 0.
	fileName _ nil.
	acceptedContentsCache _ ''.
	self changed: #fileList.
	self triggerEvent: #updateButtonRow! !
!DynamicMenuBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719060!
collectMenuOptions

	itemsDefinition := OrderedCollectio new.
	self classesProvidingMenuOptions do: [ :aClass | itemsDefinition addAll: (aClass soleInstance perform: menuDefinitionSelector) ].
	! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719070!
simpleRetryTestResults

	^OrderedCollectio new
			add: self doSomethingString;
			add: self doYetAnotherThingString;
			add: self doSomethingString;
			add: self doSomethingElseString;
			yourself! !
!MonitorTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719080!
testExample2
	"Here is a second version that does not use a semaphore to inform the 
	forking process about termination of both forked processes"

	| producer1 producer2  monitor goal work counter goalReached activeProducers|
	goal := (1 to: 1000) asOrderedCollection.
	work := OrderedCollectio new.
	counter := 0.
	goalReached := false.
	activeProducers := 0.
	monitor := Monitor new.

  producer1 :=
      [ monitor critical: [activeProducers := activeProducers + 1].
  [monitor critical:
            [monitor waitUntil: [counter \\5 = 0].
      goalReached or: [work add: (counter := counter + 1)].
     " Transcript show: 'P1  '; show: counter printString; show: '  ';
       show: activeProducers printString; cr."
      goalReached := counter >= goal size.
      monitor signal
            ].
           goalReached
          ]
             whileFalse.
         monitor critical: [activeProducers := activeProducers - 1.
        monitor signal: #finish].
 ] .

 producer2 :=
    [monitor critical: [activeProducers := activeProducers + 1].

  [monitor critical:
          [monitor waitWhile: [counter \\5 = 0].
    goalReached or: [work add: (counter := counter + 1)].
    goalReached := counter >= goal size.
    monitor signal].
         goalReached ] whileFalse.
     monitor critical: [
		activeProducers := activeProducers - 1. 
		monitor signal: #finish].
	].

	producer1 forkAt: Processor userBackgroundPriority.
	producer2  forkAt: Processor userBackgroundPriority.


	monitor critical: [
		monitor waitUntil: [activeProducers = 0 & (goalReached)]
				for: #finish.
  	].

	self assert: goal = work
! !
!ExtractMethodParametersDetector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719135 overrides: 16902254!
value

	| parseNodesFound |
	
	parseNodesFound := OrderedCollectio new.
	methodNodeToRefactor completeSourceRangesDo: [ :parseNode :sourceRanges |
		(self shouldBeParameterized: parseNode appearingIn: sourceRanges)
			ifTrue: [ parseNodesFound add: parseNode ]].
		
	^ parseNodesFound! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719148!
simpleReturnTestResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		yourself! !
!Finder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719156!
initializeResults
	
	currentQuery := ''.
	results := OrderedCollectio new.
	selectedResultIndex := 0.! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719163!
browseAllStoresInto: instVarName from: aClass
	"Create and schedule a Message Set browser for all the receiver's methods
	or any methods of a subclass/superclass that refer to the instance variable name."

	"self new browseAllStoresInto: 'contents' from: Collection."

	| coll |
	coll := OrderedCollectio new.
	aClass withAllSubAndSuperclassesDo: [:class |
		(class whichSelectorsStoreInto: instVarName) do: [:sel |
			coll add: (MethodReference class: class selector: sel)]].
	^ self
		browseMessageList: coll
		name: 'Stores into ' , instVarName
		autoHighlight: instVarName
		allOccurrences: true! !
!Finder class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719186!
availableCatalogs

	^ OrderedCollectio new
		add: Catalog classNames;
		add: Catalog implementors;
		add: Catalog implementedSelectors;
		add: Catalog senders;
		add: Catalog systemCategories;
		add: Catalog tools;
		yourself! !
!ChangeSelectorKeepingParameters class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719198!
from: anOldSelector to: aNewSelector inCategoryOf: aClass organizedBy: anOrganization

	| implementors senders |

	implementors := OrderedCollectio new.
	senders := OrderedCollectio new.

	self 
		addImplementorsOf: anOldSelector 
		to: implementors 
		andSendersTo: senders
		inCategory: aClass category 
		organizedBy: anOrganization.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: (self collectCompiledMethodsOf: senders)
! !
!RenameSelectorWithActualScopeApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719218 overrides: 16803828!
createSenders

	^OrderedCollectio new.
! !
!ChangeListWithFileInErrors methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719223!
removeSucessfullyFiledInChanges

	| newChangeList newList |

	newChangeList := OrderedCollectio new.
	newList := OrderedCollectio new.

	changeList withIndexDo: [ :aChange :anIndex | self ifFiledInWithErrorAdd: aChange at: anIndex to: newChangeList and: newList ].
			
	changeList _ newChangeList.
	list _ newList.
	listIndex _ 0.
	self clearSelections.
	self changed: #list.! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719239!
nonResumableFallOffTheEndHandlerResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: self doSomethingExceptionalString;
		add: self doYetAnotherThingString;
		yourself! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719249!
testRulesThatIncludeADate

	| timeLineFilter rule1 rule2 rule3 september14Of2005 september15Of2005 september16Of2005 |

	september14Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 14.
	september15Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 15.
	september16Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 16.
	timeLineFilter := TimeLineFilter new.
	rule1 := timeLineFilter dateRule: september14Of2005.
	rule2 := timeLineFilter dateRule: september15Of2005.
	rule3 := timeLineFilter dateRule: september16Of2005.

	timeLineFilter addRules: (OrderedCollectio with: rule1 with: rule2 with: rule3).

	self assert: (timeLineFilter rulesThatInclude: september14Of2005) = (OrderedCollectio with: rule1).
	self deny: (timeLineFilter rulesThatInclude: september15Of2005) = (OrderedCollectio with: rule1).
	self deny: (timeLineFilter rulesThatInclude: september16Of2005) = (OrderedCollectio with: rule1).
	
	self deny: (timeLineFilter rulesThatInclude: september14Of2005) = (OrderedCollectio with: rule2).
	self assert: (timeLineFilter rulesThatInclude: september15Of2005) = (OrderedCollectio with: rule2).
	self deny: (timeLineFilter rulesThatInclude: september16Of2005) = (OrderedCollectio with: rule2).
	
	self deny: (timeLineFilter rulesThatInclude: september14Of2005) = (OrderedCollectio with: rule3).
	self deny: (timeLineFilter rulesThatInclude: september15Of2005) = (OrderedCollectio with: rule3).
	self assert: (timeLineFilter rulesThatInclude: september16Of2005) = (OrderedCollectio with: rule3)! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719303!
allUnimplementedCalls
	"Answer an Array of each message that is sent by an expression in a 
	method but is not implemented by any object in the system."

	| aStream all  selectors |
	all _ self allImplementedMessages.
	aStream _ WriteStream on: (Array new: 50).
	self allBehaviorsDo: [ :cl |
		 cl selectorsDo: [ :sel |
			selectors _ OrderedCollectio new.
			(cl compiledMethodAt: sel) messages do: [ :m |
				(all includes: m) ifFalse: [selectors add: m ]].
			selectors notEmpty ifTrue: [
				aStream nextPut: (MethodReference class: cl selector: sel).
				(cl name , '>>#' , sel , (String new: (70-sel size * 15//10 max: 0) withAll: $ ), ' calls:          ', selectors asArray printString) print.
				"aStream nextPut: cl name , ' ' , sel , ' calls: ', secondStream contents" ]]].
	^aStream contents! !
!TestCaseTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:45' prior: 50719332!
testAssertDoeNotChangePassesWhenConditionIsNotAlteredByAction

	|aCollection|

	aCollection := OrderedCollectio with: 1.
	
	self assert: [ aCollection sum ] doesNotChange: [ aCollection size ]! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719342!
resumableFallOffTheEndHandlerResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: self doSomethingExceptionalString;
		add: self doYetAnotherThingString;
		yourself! !
!ChangeKeywordsSelectorOrderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719352!
test07ChangesKeywordsAndParametersOrderForMoreThanTwoKeywords

	| classToRefactor refactoring renamedMethod oldSelector newSelector selectorAndParameters parameters |

	oldSelector := #m1:m2:m3:.
	newSelector := #m2:m3:m1:.
	classToRefactor := self createClassNamed: #ClassToChangeSelectorOrder.
	selectorAndParameters := self selectorAndParametersFor: oldSelector.
	classToRefactor compile: selectorAndParameters.

	refactoring := ChangeKeywordsSelectorOrder from: oldSelector to: newSelector implementors: { classToRefactor >> oldSelector } senders: #().
	refactoring apply.

	renamedMethod := classToRefactor >> newSelector.
	parameters := selectorAndParameters substrings reject: [ :aKeywordOrParameter | oldSelector keywords includes: aKeywordOrParameter  ].
	self
		assert: (OrderedCollectio with: parameters second with: parameters third with: parameters first)
		equals: renamedMethod methodNode argumentNames ! !
!Clipboard methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719385 overrides: 16920235!
initialize
	contents _ nil.
	contentsOriginalObjectWeakly _ WeakArray new: 1.
	recent _ OrderedCollectio new.! !
!HierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719392!
addSubmorphsAfter: parentMorph fromCollection: aCollection allowSorting: sortBoolean

	| priorMorph morphList newCollection |
	priorMorph _ nil.
	newCollection _ (sortBoolean and: [sortingSelector notNil]) ifTrue: [
		aCollection asOrderedCollection sort: [ :a :b | 
			(a perform: sortingSelector) <= (b perform: sortingSelector)]
	] ifFalse: [
		aCollection
	].
	morphList _ OrderedCollectio new.
	newCollection do: [:item | 
		priorMorph _ self indentingItemClass basicNew 
			initWithContents: item 
			prior: priorMorph 
			forList: self
			indentLevel: parentMorph indentLevel + 1.
		morphList add: priorMorph.
	].
	scroller addAllMorphs: morphList after: parentMorph.
	^morphList
	
! !
!PackageSnapshot methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719417!
setupClassesToTakeSnapshots

	classesToTakeSnapshots _ OrderedCollectio new.

	sourcePackage classesInSafeOrderDo: [ :class |
		class sharedPoolsString
			ifEmpty: [
				classesToTakeSnapshots add: class ]
			ifNotEmpty: [
				self error: self takingSnapshotOfClassesWithSharedPoolsIsNotSupportedYetErrorMessage  ] ]! !
!FileSystemEntry methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719431!
parents
	| ord par |
	par := self parent.
	ord := OrderedCollectio with: par.
	[par isRoot] whileFalse: [
		par := par parent.
		ord add: par.
	].
	^ord! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719440!
simpleEnsureTestWithUparrowResults

	^OrderedCollectio new
		add: self doSomethingString;
"		add: self doSomethingElseString;"
		add: self doYetAnotherThingString;
		yourself! !
!SmartRefStream class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719449!
subObjects: anObject ofClass: aClass
	"Return a collection of all instances of aClass that would be written out with anObject.  Does not actually write on the disk.  Inspect the result and ask for 'references to this object'."

	| dummy coll |
	dummy _ ReferenceStream on: (DummyStream on: nil).
		"Write to a fake Stream, not a file"
	"Collect all objects"
	dummy rootObject: anObject.	"inform him about the root"
	dummy nextPut: anObject.
	coll _ OrderedCollectio new.
	dummy references keysDo: [:each |
		each class == aClass ifTrue: [coll add: each]].
	^ coll! !
!VariableTypeInfoTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719471!
test40TypesDoEvaluatesBlockOnEachType

	| variableTypeInfo types |

	variableTypeInfo := VariableTypeInfo new initializeRawTypes: (Array new: 3).
	types := OrderedCollectio new.
	
	variableTypeInfo addType: 1 class.
	variableTypeInfo addType: 1.0 class.
	
	variableTypeInfo typesDo: [ :aType | types add: aType ].
	
	self assert: types size equals: 2.
	self assert: (types includes: 1 class).
	self assert: (types includes: 1.0 class)! !
!IntroduceNullObjectForm methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719489!
initializeWithModel: aModel

	super model: aModel.

	self setLabel: 'Introduce Null Object'.

	discardEdits := false.

	ifNilChecks := model ifNilChecks.
	introduceNullObjectRequest := IntroduceNullObjectRequest for: ifNilChecks.
	messageListModel := IfNilMessageListModel with: ifNilChecks withForm: self.
	focusMorphs := OrderedCollectio new.

! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719504!
simpleRetryUsingTestResults

	^OrderedCollectio new
			add: self doSomethingString;
			add: self doYetAnotherThingString;
			yourself! !
!GraphPathFinderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719512!
testSamePlace

	| path |

	path := finder pathFrom: 1 to: 1.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 1 to: 1)))! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719521!
entriesToShow
	
	self hasCollectedOnlyOneSelector
		ifTrue: [ entriesToShow := categoriesWithSelectors anyOne ]
		ifFalse: [ 
			entriesToShow := OrderedCollectio new.
			self 
				addPrioritizedCategories;
				addLeftCategories ].
						  			
	^entriesToShow 
	
	   ! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719533!
test12_PortfolioHasTransactionsFromStoredPortfolios
	| aTransaction anAccount aPortfolio otherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	otherPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	otherPortfolio add: anAccount.
	aPortfolio add: otherPortfolio.
	self assert: aPortfolio transactions equals: (OrderedCollectio with: aTransaction) .! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719550!
simpleTimeoutWithZeroDurationTestResults

	^OrderedCollectio new
		add: self doSomethingElseString;
		yourself! !
!ClassCommentVersionsBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719558!
scanVersionsOf: class
	"Scan for all past versions of the class comment of the given class"

	| oldCommentRemoteStr sourceFilesCopy position prevPos stamp preamble tokens prevFileIndex |

	classOfMethod _ class.
	oldCommentRemoteStr _ class  organization commentRemoteStr.
	currentCompiledMethod _ oldCommentRemoteStr.
	selectorOfMethod _ #Comment.
	changeList _ OrderedCollectio new.
	list _ OrderedCollectio new.
	listIndex _ 0.
	oldCommentRemoteStr ifNil:[^ nil] ifNotNil: [oldCommentRemoteStr sourcePointer].

	sourceFilesCopy _ SourceFiles collect: [ :x | x ifNotNil: [x name asFileEntry readStream]].
	position _ oldCommentRemoteStr position.
	file _ sourceFilesCopy at: oldCommentRemoteStr sourceFileNumber.
	[ position notNil & file notNil]  whileTrue: [
		"Skip back filler"
		file position: position.
		file backChunk.
		"Get preamble"
		preamble _ file backChunk.
		prevPos _ nil.
		stamp _ ''.
		(preamble includesSubString: 'commentStamp:')
			ifTrue: [
				tokens _ Scanner new scanTokens: preamble.
				stamp _ CompiledMethod field: #commentStamp: from: tokens ifAbsentOrNil: [ '' ].
				(CompiledMethod priorReferenceFrom: tokens) ifNotNil: [ :priorRef |
					prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: priorRef.
					prevPos _ sourceFilesCopy filePositionFromSourcePointer: priorRef ]]
			ifFalse: [
				"The stamp get lost, maybe after a condenseChanges"
				stamp _ '<historical>'].
 		self addItem:
				(ChangeRecord new file: file position: position type: #classComment
						class: class name category: nil meta: class isMeta stamp: stamp)
			text: stamp , ' ' , class name , ' class comment'. 
		prevPos = 0 ifTrue: [ prevPos _ nil ].
		position _ prevPos.
		prevPos notNil ifTrue: [ file _ sourceFilesCopy at: prevFileIndex ]].
	sourceFilesCopy do: [ :x | x notNil ifTrue: [ x close ]].
	self clearSelections! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719620!
variablesNames

	| names |
	
	names := OrderedCollectio new.
	self variablesNamesDo: [ :aVarName | names add: aVarName ].
	
	^names! !
!DifferenceFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719628!
maxLengthPoints
	| max points |
	max := self maxLength.
	max = 0 ifTrue: [^Array with: `0 @ 0`].
	points := OrderedCollectio new.
	tally withIndexesDo: [:i :j :t | t = max ifTrue: [points add: i @ j]].
	^ points! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719639!
actualImplementorsOf: aSelector in: aClass 
	
	| highestImplementorClass implementors |
	
	implementors := OrderedCollectio new.
	highestImplementorClass := aClass 
		highestClassImplementing: aSelector 
		ifNone: [ 
			implementors add: (NotImplementedMethod class: aClass selector: aSelector).
			aClass ].
	
	^ highestImplementorClass withAllSubclassesImplementing: aSelector addTo: implementors.
	! !
!TestCaseTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719655!
testAssertChangesFromToPassesWhenActionChangesConditionFromAndToTheSpecifiedValues

	|aCollection|

	aCollection := OrderedCollectio with: 1.
	
	self assert: [ aCollection add: 2 ] changes: [ aCollection size ] from: 1 to: 2! !
!Compiler class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719666!
notSameMethodsAfterCompilingAll

	"
	self notSameMethodsAfterCompilingAll
	"
	
	| notEqual |
	
	notEqual := OrderedCollectio new.

	ProtoObject withAllSubclassesDo: [ :class | 
		class selectorsDo: [ :selector | | currentCompiledMethod newCompiledMethod |
			currentCompiledMethod := class >> selector.
			newCompiledMethod := class
				basicCompile: currentCompiledMethod sourceCode
				notifying: nil
				trailer: class defaultMethodTrailer
				ifFail: [^self error: 'error compiling'].
			currentCompiledMethod = newCompiledMethod method ifFalse: [ notEqual add: currentCompiledMethod ]].	
		].

	^notEqual.! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719689!
simpleTimeoutTestResults

	| things |
	things := OrderedCollectio new: self iterationsBeforeTimeout.

	self iterationsBeforeTimeout timesRepeat: [ things add: self  doSomethingString ].
	things add: self doSomethingElseString.

	^ things! !
!DenotativeObjectBrowser class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719701 overrides: 50727108!
recentClasses

	RecentDenotativeObjects ifNil: [ RecentDenotativeObjects := OrderedCollectio new ].
	
	^RecentDenotativeObjects ! !
!ExtractToMethodObjectForm methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719709!
initializeWithModel: aModel

	super model: aModel.

	self setLabel: 'Extract Method to Method Object'.

	discardEdits := false.
	variablesToParametrize := model variablesToParametrize.
	extractToMethodObjectRequest := ExtractToMethodObjectRequest for: aModel methodToExtract.
	focusMorphs := OrderedCollectio new.! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719723!
allWithNoCommonSupertype

	"
	InstanceVariablesTypes allWithNoCommonSupertype
	MethodVariablesTypes allWithNoCommonSupertype
	"
	
	| allWithNoCommonSupertype |
	
	allWithNoCommonSupertype := OrderedCollectio new.
	ProtoObject withAllSubclassesDo: [ :aClass | self of: aClass do: [ :aVariablesTypes | aVariablesTypes addWithNoCommonSupertypeTo: allWithNoCommonSupertype ]].
			
	^allWithNoCommonSupertype 
	
! !
!PathQuadraticCurveToSmoothCommand methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719741 overrides: 50431909!
buildFrom: commandChar stream: aStream

	| x y |
	super buildFrom: commandChar stream: aStream.
	toPoints _ OrderedCollectio new.
	[
		x _ aStream nextNumber.
		y _ aStream nextNumber.
		y notNil ] whileTrue: [
			toPoints add: x@y]! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719752!
decompile: aSelector in: aClass method: aMethod using: aConstructor

	| block node |
	constructor := aConstructor.
	method := aMethod.
	self initSymbols: aClass.  "create symbol tables"
	method isQuick
		ifTrue: [block := self quickMethod]
		ifFalse: 
			[stack := OrderedCollectio new: method frameSize.
			lastJumpIfPcStack := OrderedCollectio new.
			caseExits := OrderedCollectio new.
			statements := OrderedCollectio new: 20.
			numLocalTemps := 0.
			super method: method pc: method initialPC.
			"skip primitive error code store if necessary"
			(method primitive ~= 0 and: [self skipCallPrimitive; willStore]) ifTrue:
				[pc := pc + (method encoderClass bytecodeSize: self firstByte).
				 tempVars := tempVars asOrderedCollection].
			block := self blockTo: method endPC + 1.
			stack isEmpty ifFalse: [self error: 'stack not empty']].
	node := constructor
				codeMethod: aSelector
				block: block
				tempVars: tempVars
				primitive: method primitive
				class: aClass.
	method primitive > 0 ifTrue:
		[node removeAndRenameLastTempIfErrorCode].
	^node preen! !
!TestResult methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719790!
defects
	^OrderedCollectio new
		addAll: self errors;
		addAll: self failures; yourself
			! !
!IfNilChecksFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719797 overrides: 16902254!
value

	| selectors |

	selectors := contextClass whichSelectorsAccess: instanceVariable.

	^selectors inject: OrderedCollectio new into: [:ifNilChecks :selector |
		ifNilChecks addAll: (self ifNilChecksIn: selector). ifNilChecks.].! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719808!
removeOlderMethodVersions
	"Remove older versions of entries from the receiver."

	| newChangeList newList found |
	newChangeList _ OrderedCollectio new.
	newList _ OrderedCollectio new.
	found _ OrderedCollectio new.
	changeList reverseWith: list do: [ :chRec :strNstamp | | str |
		str _ strNstamp copyUpTo: $;.
		(found includes: str) ifFalse: [
			found add: str.
			newChangeList add: chRec.
			newList add: strNstamp]].
	newChangeList size < changeList size ifTrue: [
		changeList _ newChangeList reversed.
		list _ newList reversed.
		listIndex _ 0.
		self clearSelections ].
	self changed: #list! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719831!
obsoleteBehaviors
	"
	Smalltalk obsoleteBehaviors inspect
	Find all obsolete behaviors including meta classes
	"
	| obs |
	obs _ OrderedCollectio new.
	Smalltalk garbageCollect.
	self allObjectsDo: [ :cl |
		(cl isBehavior and: [cl isObsolete]) ifTrue: [obs add: cl]].
	^ obs asArray! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719845 overrides: 50626282!
errors
	
	^typeCheckers 
		inject: OrderedCollectio new
		into: [ :errors :typeChecker |
			errors addAll: typeChecker errors.
			errors ]! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719853!
embeddedBlockClosures
	"
	(CompiledMethod >> #embeddedBlockClosures)embeddedBlockClosures
	"
	| bms extractor scanner |
	bms := OrderedCollectio new.
	scanner := self scanner.
	extractor := ClosureExtractor withAction: [ :c | bms add: c ] andScanner: scanner.
	[ scanner pc <= self endPC ] whileTrue: [ scanner interpretNextInstructionFor: extractor ].
	^ bms! !
!TestResult methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719868!
errors

	errors
		ifNil: [errors := OrderedCollectio new].
	^errors
			! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719874!
testAddRules

	| timeLineFilter rule1 rule2 rule3 september14Of2005 september15Of2005 september16Of2005 |
	
	september14Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 14.
	september15Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 15.
	september16Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 16.

	timeLineFilter := TimeLineFilter new.
	rule1 := timeLineFilter dateRule: september14Of2005.
	rule2 := timeLineFilter dateRule: september15Of2005.
	rule3 := timeLineFilter dateRule: september16Of2005.

	timeLineFilter addRules: (OrderedCollectio with: rule1 with: rule2 with: rule3).
	self assert: (timeLineFilter includes: september14Of2005).
	self assert: (timeLineFilter includes: september15Of2005).
	self assert: (timeLineFilter includes: september16Of2005)! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719904!
findTokens: delimiters
	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."

	| tokens keyStart keyStop separators |

	tokens _ OrderedCollectio new.
	separators _ delimiters isCharacter
		ifTrue: [Array with: delimiters]
		ifFalse: [delimiters].
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipDelimiters: separators startingAt: keyStop.
		keyStop _ self findDelimiters: separators startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens! !
!TestRunner methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719932 overrides: 16920235!
initialize

	result := TestResult new.
	passFail := ''.
	details := ''.
	failures := OrderedCollectio new.
	errors := OrderedCollectio new.
	tests := self gatherTestNames.
	selectedSuite := 0.
	selectedFailureTest := 0.
	selectedErrorTest := 0.
	selectedSuites := tests collect: [:ea | true].
	running := nil.
	runSemaphore := Semaphore new! !
!SequenceableCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719947!
testCombinationsAtATimeDoWorksAsExpected
	
	| combinations |
	 
	combinations := OrderedCollectio new.
	'abc' combinations: 2 atATimeDo: [ :combination | combinations add: combination copy].
	
	self assert: combinations size equals: 3.
	self assert: (combinations includes: #($a $b)).
	self assert: (combinations includes: #($a $c)).
	self assert: (combinations includes: #($b $c)).! !
!SpaceTally methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50719963!
printSpaceDifferenceFrom: fileName1 to: fileName2
	"For differential results, run printSpaceAnalysis twice with different fileNames,
	then run this method...
		'STspace.text1' asFileEntry writeStreamDo: [ :stream | SpaceTally new printSpaceAnalysis: 0 on: stream ].
			--- do something that uses space here ---
		'STspace.text2' asFileEntry writeStreamDo: [ :stream | SpaceTally new printSpaceAnalysis: 0 on: stream ].
		SpaceTally new printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'
"
	| coll1 coll2 item |
	coll1 _ OrderedCollectio new.
	DirectoryEntry smalltalkImageDirectory // fileName1 readStreamDo: [ :stream |
		[stream atEnd] whileFalse: [coll1 add: stream crLfNextLine]].
	
	coll2 _ OrderedCollectio new.
	DirectoryEntry smalltalkImageDirectory // fileName2 readStreamDo: [ :stream |
		[stream atEnd] whileFalse: [
			item _ stream crLfNextLine.
			((coll1 includes: item) and: [(item endsWith: 'percent') not])
				ifTrue: [coll1 remove: item]
				ifFalse: [coll2 add: item]]].

	(TextModel new contents: (String streamContents: 
			[ :s | 
			s nextPutAll: fileName1; newLine.
			coll1 do: [:x | s nextPutAll: x; newLine].
			s newLine; newLine.
			s nextPutAll: fileName2; newLine.
			coll2 do: [:x | s nextPutAll: x; newLine]]))
		openLabel: 'Differential Space Analysis'.
! !
!CodeFile methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720008 overrides: 16920235!
initialize
	classes _ Dictionary new.
	classOrder _ OrderedCollectio new.
	sourceSystem _ ''.
	doIts _ OrderedCollectio new! !
!SequenceableCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720016!
testWithIndexDoSeparatedByDoesNotValueSeparatedBlockOnLastElement

	| collectionToTraverse traversedElements |

	collectionToTraverse := OrderedCollectio with: $a with: $b.
	traversedElements := OrderedCollectio new.

	collectionToTraverse
		withIndexDo: [ :anElement :index | traversedElements add: anElement  -> index ]
		separatedBy: [ traversedElements add: $-].

	self assert: traversedElements size equals: 3.
	self assert: traversedElements first equals: $a->1.
	self assert: traversedElements second equals: $-.
	self assert: traversedElements third equals: $b->2.! !
!OrderedCollectio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50723361 overrides: 16823689!
species
	"aSortedCollection collect: should answer an OrderedCollection"

	^OrderedCollectio! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720038!
blockExpression
	"[ ({:var} |) (| {temps} |) (statements) ] => BlockNode."

	| blockNode tempsDeclarationNode variableNodes temporaryBlockVariables start |

	self advance.
	
	blockNode := BlockNode new.
	variableNodes := OrderedCollectio new.
	start := prevMark + requestorOffset.
	"Gather parameters."
	[self match: #colon] whileTrue:
		[self argumentNameWithRangeDo: [ :argumentName :range |
			variableNodes addLast: (encoder bindBlockArg: argumentName within: blockNode range: range)]].
	(variableNodes size > 0 & (hereType ~~ #rightBracket) and: [(self match: #verticalBar) not]) ifTrue:
		[^self expected: 'Vertical bar'].

	tempsDeclarationNode := self temporaryBlockVariablesFor: blockNode.
	temporaryBlockVariables := tempsDeclarationNode allDeclaredVariableNodes.
	self statements: variableNodes innerBlock: true blockNode: blockNode.
	blockNode temporariesDeclaration: tempsDeclarationNode.

	(self match: #rightBracket) ifFalse: [^self expected: 'Period or right bracket'].

	blockNode noteSourceRangeStart: start end: self endOfLastToken encoder: encoder.

	"The scope of the parameters and temporary block variables is no longer active."
	temporaryBlockVariables do: [:variable | variable scope: -1].
	variableNodes do: [:variable | variable scope: -1].

	^true! !
!CodeWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720082!
methodInheritance
	"Create and schedule a method browser on the inheritance of implementors."

	| list aClassNonMeta isMeta theClassOrMeta aClass sel |
	aClass _ model selectedClassOrMetaClass.
	sel _ model selectedMessageName.
	aClass ifNil: [ ^ self ].
	sel ifNil: [ ^ self ].
	aClassNonMeta _ aClass theNonMetaClass.
	isMeta _ aClassNonMeta ~~ aClass.
	list _ OrderedCollectio new.
	aClass allSuperclasses reverseDo: [ :cl |
		(cl includesSelector: sel) ifTrue: [
			list addLast: (MethodReference class: cl selector: sel) ]].
	aClassNonMeta
		allSubclassesWithLevelDo: [ :cl :level |
			theClassOrMeta _ isMeta
				ifTrue: [ cl class ]
				ifFalse: [ cl ].
			(theClassOrMeta includesSelector: sel) ifTrue: [
				list addLast: (MethodReference class: theClassOrMeta selector: sel) ]]
		startingLevel: 0.
	^ Smalltalk
		browseMessageList: list
		name: 'Inheritance of ' , sel.! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720136!
allMethodsInCategory: aSymbol
	"Answer a list of all the method categories of the receiver and all its superclasses"

	| aColl |
	aColl _ OrderedCollectio new.
	self withAllSuperclasses do:
		[:aClass | aColl addAll:
			(aSymbol == ClassOrganizer allCategory
				ifTrue:
					[aClass organization allMethodSelectors]
				ifFalse:
					[aClass organization listAtCategoryNamed: aSymbol])].
	^ aColl asSet sorted

"TileMorph allMethodsInCategory: #initialization"! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720154!
testRules

	| timeLineFilter rule1 rule2 rule3 rulesCollection |

	timeLineFilter := TimeLineFilter new.
	rule1 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 14).
	rule2 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 15).
	rule3 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 16).

	rulesCollection := OrderedCollectio with: rule1 with: rule2 with: rule3.
	timeLineFilter addRules: rulesCollection.

	self assert: timeLineFilter rules = rulesCollection! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720114!
buildPrimaryPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollectio with: (Color fromHexString: '#DA627D') with: 'Sunset'.
	ocean := OrderedCollectio with: (Color fromHexString: '#598392') with: 'Ocean'.
	forest := OrderedCollectio with: (Color fromHexString: '#5E5D5C') with: 'Forest'.
	ash := OrderedCollectio with: (Color fromHexString: '#696773') with: 'Ash'.
	light := OrderedCollectio with: (Color fromHexString: '#CEB5A7') with: 'Light'.
	
	primaryPalette := OrderedCollectio with: sunset with: ocean with: forest with: ash with: light.! !
!DenotativeObjectTheme methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720183 overrides: 16971312!
pseudoVariables

	^ (OrderedCollectio withAll: super pseudoVariables) 
		add: #parent;
		asArray! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720176!
suiteLog

	suiteLog == nil
		ifTrue: [suiteLog := OrderedCollectio new].
	^suiteLog! !
!TypeCheckerTestMethods methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720190!
typeCheckMessageWithReturnOnIfFalse

	| temp1  |
	
	temp1 := OrderedCollectio new.
	temp1 := 1.
	
	temp1 isNumber ifFalse: [ ^self ].
	temp1 odd! !
!IsKindOfManyTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720200 overrides: 50625989!
buildRejectApplierBefore: aPreviousCastingApplier

	^EffectiveTypeCastApplier 
		casts: OrderedCollectio new
		rejections: (OrderedCollectio with: self buildTypeReject)
		previous: aPreviousCastingApplier! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720210!
askRenames: renamed addTo: msgSet using: smart
	| list |
	"Go through the renamed classes.  Ask the user if it could be in a project.  Add a method in SmartRefStream, and a conversion method in the new class."

	list _ OrderedCollectio new.
	renamed do: [ :cls | | rec |
		rec _ changeRecords at: cls name.
		rec priorName ifNotNil: [
			| ans |
			ans _ PopUpMenu withCaption: 'You renamed class ', rec priorName, 
				' to be ', rec thisName,
				'.\Could an instance of ', rec priorName, 
				' be in a project on someone''s disk?'
			chooseFrom: #('Yes, write code to convert those instances'
				'No, no instances are in projects').
			ans = 1 ifTrue: [
				| oldStruct newStruct  |
				oldStruct _ structures at: rec priorName ifAbsent: nil.
				newStruct _ (Array with: cls classVersion), (cls allInstVarNames).
				oldStruct ifNotNil: [
					smart writeConversionMethodIn: cls fromInstVars: oldStruct 
							to: newStruct renamedFrom: rec priorName.
					smart writeClassRename: cls name was: rec priorName.
					list add: cls name, ' convertToCurrentVersion:refStream:']]
			ifFalse: [structures removeKey: rec priorName ifAbsent: nil]]].
	list isEmpty ifTrue: [^ msgSet].
	msgSet messageList ifNil: [msgSet initializeMessageList: list]
		ifNotNil: [list do: [:item | msgSet addMethodReference: item]].
	^ msgSet! !
!EqualsTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720256 overrides: 50625989!
buildRejectApplierBefore: aPreviousCastingApplier
	
	 ^EffectiveTypeCastApplier 
		casts: OrderedCollectio new
		rejections: (OrderedCollectio with: self buildTypeReject)
		previous: aPreviousCastingApplier! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720267!
findTokens: delimiters keep: keepers
	"Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)"

	| tokens keyStart keyStop |
	tokens _ OrderedCollectio new.
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipDelimiters: delimiters startingAt: keyStop.
		keyStop to: keyStart-1 do: [:ii | 
			(keepers includes: (self at: ii)) ifTrue: [
				tokens add: (self copyFrom: ii to: ii)]].	"Make this keeper be a token"
		keyStop _ self findDelimiters: delimiters startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens! !
!ConversionTable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720299 overrides: 16920235!
initialize

	unitConversionRules := OrderedCollectio new.
	self invalidateGraph! !
!IsKindOfTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720306 overrides: 50625989!
buildRejectApplierBefore: aPreviousCastingApplier

	^EffectiveTypeCastApplier 
		casts: OrderedCollectio new
		rejections: (OrderedCollectio with: self buildTypeReject)
		previous: aPreviousCastingApplier
	! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720317 overrides: 50626252!
problems

	^typeCheckers 
		inject: OrderedCollectio new
		into: [ :problems :typeChecker |
			problems addAll: typeChecker problems.
			problems ]! !
!CodeFile methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720325!
removeDoIts
	doIts := OrderedCollectio new.! !
!CollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720330!
testItMaintainsTheSameCollectionSpecies

	self assert: (OrderedCollectio with: 1 with: #(2)) flatten equals: (OrderedCollectio with: 1 with: 2).! !
!CodeFileBrowserWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720339 overrides: 16797244!
classListMenu

	| aMenu itemColl |
	self flag: #assumesKeyboardShortcuts.
	aMenu := MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Class List'.
	itemColl := OrderedCollectio new.
	itemColl addAll:
		{
			{#label -> 'definition'. #object -> #model. #selector -> #editClass. #icon -> #editFindReplaceIcon} asDictionary. 
			{#label -> 'comment'. #object -> #model. #selector -> #editComment. #icon -> #editFindReplaceIcon} asDictionary. 
			nil
		}.
	self model baseCodeSource isLiveSmalltalkImage ifTrue: [
		itemColl addAll:
			{
				{#label -> 'browse full (b)'. #selector -> #browseMethodFull. #icon -> #editFindReplaceIcon} asDictionary. 
				{#label -> 'class refs (N)'. #selector -> #browseClassRefs. #icon -> #classIcon} asDictionary. 
				nil. 
				{#label -> 'fileIn'. #object -> #model. #selector -> #fileInClass. #icon -> #updateIcon} asDictionary
			} ].
	itemColl addAll:
		{
			{#label -> 'fileOut'. #object -> #model. #selector -> #fileOutClass. #icon -> #fileOutIcon} asDictionary. 
			nil. 
			{#label -> 'rename...'. #object -> #model. #selector -> #renameClass. #icon -> #saveAsIcon} asDictionary. 
			{#label -> 'remove'. #object -> #model. #selector -> #removeClass. #icon -> #listRemoveIcon} asDictionary. 
			nil. 
			{#label -> 'remove existing'. #object -> #model. #selector -> #removeUnmodifiedCategories. #icon -> #deleteIcon} asDictionary
		}.
	aMenu addItemsFromDictionaries: itemColl.
	^ aMenu.! !
!PackageSnapshot methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720388!
initializeToTakeOf: aCodePackage

	sourcePackage _ aCodePackage.
	id _ Time millisecondClockValue.
	systemOrganizer _ SystemOrganization.
	snapshotOfClassesByOriginalClassName _ OrderedDictionary new.
	snapshotsOfExtensionMethods _ OrderedCollectio new.! !
!ExtractAsParameter class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720400!
intervalsForEquivalentNodesTo: node in: methodNode

	| completeSourceRanges intervalsForEquivalentNodes | 
	
	intervalsForEquivalentNodes := OrderedCollectio new.
	completeSourceRanges := methodNode completeSourceRanges.
	
	methodNode nodesDo: [ :aNode | 
		(aNode equivalentTo: node) ifTrue: [ 
			"There can not be more than one range because of the is not a multi range node. See senders - Hernan"
			intervalsForEquivalentNodes add: (completeSourceRanges at: aNode) first ]].
	
	^intervalsForEquivalentNodes! !
!IfNilChecksFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:46' prior: 50720420!
ifNilChecksIn: aSelector

	| methodNode ifNilChecks |

	"It is using methodNode and not notOptimizedMethodNode becuase isIfNilCheckNode:
	was developed before notOptimizedMethodNode and assumes optimizations.
	Run test04ResultIncludesIfNotNilMessageSending to see the problem - Hernan"
	methodNode := (contextClass compiledMethodAt: aSelector) methodNode.

	ifNilChecks := OrderedCollectio new.
	methodNode accept: (ParseNodeEnumerator ofBlock: [:node |
		(self isIfNilCheckNode: node) ifTrue:[ | nodeIndex |
			nodeIndex := (methodNode encoder rangeForNode: node ifAbsent: [ self shouldNotHappen ]) first.
			ifNilChecks add: (IfNilCheck in: methodNode representedBy: node atIndex: nodeIndex)]]).

	^ifNilChecks reverse! !
!SystemWindow class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720446!
windowsIn: aWorld satisfying: windowBlock
	| windows |
	windows _ OrderedCollectio new.
	aWorld submorphs do: [ :m |
		((m is: #SystemWindow) and: [ windowBlock value: m ]) ifTrue: [ windows addLast: m ]].
	^ windows! !
!DenotativeObjectLightTheme methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720458 overrides: 16971312!
pseudoVariables

	^ (OrderedCollectio withAll: super pseudoVariables) 
		add: #parent;
		asArray! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720465!
checkForSlips
	"Return a collection of method refs with possible debugging code in them."
	| slips |
	slips _ OrderedCollectio new.
	self changedClasses do: [ :aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc |  | method |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse: [
				method _ aClass compiledMethodAt: mAssoc key ifAbsent: nil.
				method ifNotNil: [
					method hasReportableSlip
						ifTrue: [slips add: (MethodReference method: method)]]]]].
	^ slips! !
!FileIOAccessor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720485!
entriesIn: parentEntryOrNil
	"
	Warning: Private. Only to be called from within FileMan.
	Accepts nil as argument, but behavior depends on platform.

Windows (nil means root)
FileIOAccessor default entriesIn: nil #(C:\ D:\)
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(\$Recycle.Bin \Config.Msi \Documents and Settings \gratMusic \hiberfil.sys \Intel \pagefile.sys \PerfLogs \Program Files \Program Files (x86) \ProgramData \Python27 \Recovery \SimuloHoy \System Volume Information \totalcmd \Users \Windows)

Linux  (nil means current dir, like '' and '.')
FileIOAccessor default entriesIn: nil #(Lots of stuff in current directory)
(FileIOAccessor default entriesIn: nil) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(/vmlinuz /boot /sbin /srv /lib /lib32 /tmp /sys /home /etc /initrd.img /bin /dev /opt /proc /lost+found /var /root /lib64 /mnt /usr /run /media)

MacOsX (nil means current dir, like '' and '.')
FileIOAccessor default entriesIn: nil #(/Volumes/SanDisk32-NTFS/CuisTest/2554-REVISAR-JuanVuletich-2015Oct21-16h40m-jmv.1.cs.st /Volumes/SanDisk32-NTFS/CuisTest/Cog.app /Volumes/SanDisk32-NTFS/CuisTest/Cog.app.tgz /Volumes/SanDisk32-NTFS/CuisTest/Cuis4.2-2553.changes /Volumes/SanDisk32-NTFS/CuisTest/Cuis4.2-2553.image /Volumes/SanDisk32-NTFS/CuisTest/CuisV4.sources)
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(/.dbfseventsd /.DocumentRevisions-V100 /.DS_Store /.file /.fseventsd /.hotfiles.btree /.Spotlight-V100 /.Trashes /.vol /Applications /bin /cores /dev /etc /home /installer.failurerequests /Library /net /Network /opt /private /sbin /System /tmp /Users /usr /var /Volumes)

	"
	| entries index done entryArray entry isDirectory lookIn |
	entries _ OrderedCollectio new: 200.
	index _ 1.
	done _ false.
	lookIn _ parentEntryOrNil ifNil: [''] ifNotNil: [parentEntryOrNil pathName].
	[done] whileFalse: [
		entryArray _ self primFixedNameLookupEntryIn: lookIn asUtf8Bytes index: index.
		#badDirectoryPath == entryArray ifTrue: [
			^#()].
		entryArray == nil
			ifTrue: [done _ true]
			ifFalse: [
				isDirectory _ entryArray at: 4.
				entry _ isDirectory ifTrue: [DirectoryEntry new] ifFalse: [FileEntry new].
				entry name: (entryArray at: 1) parent: parentEntryOrNil.
				entry updateFrom: entryArray entryInParent: index.
				entries addLast: entry ].
		index _ index + 1].

	^entries asArray! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720576!
askAddedInstVars: classList
	| pairList pairClasses index pls |
	"Ask the author whether these newly added inst vars need to be non-nil"

	pairList _ OrderedCollectio new.
	pairClasses _ OrderedCollectio new.
	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."
	classList do: [ :cls |
		| newStruct oldStruct |
		newStruct _ (cls allInstVarNames).
		oldStruct _ (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.
		newStruct do: [ :instVarName |
			(oldStruct includes: instVarName) ifFalse: [
				pairList add: cls name, ' ', instVarName.
				pairClasses add: cls]]].

	pairList isEmpty ifTrue: [^ #()].
	[
		index _ PopUpMenu withCaption: 'These instance variables were added.
When an old project comes in, newly added 
instance variables will have the value nil.
Click on items to remove them from the list.
Click on any for which nil is an OK value.'
			chooseFrom: pairList, #('all of these need a non-nil value'
						'all of these are OK with a nil value').
		(index <= (pls _ pairList size)) & (index > 0) ifTrue: [
			pairList removeAt: index.
			pairClasses removeAt: index].
		index = (pls + 2) ifTrue: ["all are OK" ^ #()].
		pairList isEmpty | (index = (pls + 1)) "all need conversion, exit"] whileFalse.

	^ pairClasses asSet asArray	"non redundant"! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720622!
simpleNoTimeoutTestResults

	^OrderedCollectio new
		add: self doSomethingString;
		yourself! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720629!
addCategory: aCategory of: classOrganization

	| categorySelectors selectedSelectors |

	selectedSelectors := self prefixedSelectorsOf: aCategory in: classOrganization.
	selectedSelectors isEmpty ifFalse: [ 
		categorySelectors := categoriesWithSelectors at: aCategory ifAbsentPut: [ OrderedCollectio new ].
		categorySelectors addAll: selectedSelectors.
		self addedSelectors: selectedSelectors.
		self addToPossibleInvalidIfCorrespond: selectedSelectors ]! !
!ChangeDetector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720647!
lookaheadRecordsFrom: aChangeList
	| lookaheads |
	
	lookaheads := OrderedCollectio new.
	
	1 to: lookahead do: [ :index | lookaheads add: (aChangeList at: index ifAbsent: [ nil ]) ].
	
	^ lookaheads 
! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720657!
consolidateAsCollection: sourceRanges

	^ sourceRanges isInterval
		ifTrue: [ OrderedCollectio with: sourceRanges ]
		ifFalse: [ sourceRanges ]! !
!BlockNodeParentsFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720666!
initializeFor: aSelectedBlockNode

	selectedBlockNode := aSelectedBlockNode.
	parents := OrderedCollectio new.
	found := false.! !
!WeakRegistry methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720674!
finalizeValues
	"Some of our elements may have gone away. Look for those and activate the associated executors."
	| finiObjects |
	finiObjects _ nil.
	"First collect the objects."
	self protected:[
		valueDictionary associationsDo:[:assoc|
			assoc key ifNil: [
				finiObjects 
					ifNil: [ finiObjects := OrderedCollectio with: assoc value]
					ifNotNil: [ finiObjects add: assoc value]]
		].
		finiObjects ifNotNil: [ valueDictionary finalizeValues: finiObjects asArray].
	].
	"Then do the finalization"
	finiObjects ifNotNil: [
		finiObjects do:[:each| each finalize]]! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720697 overrides: 50626286!
errorsAndWarnings
	
	| list |
	
	list := self sortedTypeCheckers
		inject: OrderedCollectio new 
		into: [ :aList :aTypeChecker | 
			aList add: aTypeChecker methodReference.
			aList addAll: aTypeChecker errorsAndWarnings.
			aList ].
			
	^list! !
!ToolsCatalog methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720708!
menuItemsForOpenGroup

	| openMenuOptions worldMenuOptions |
	
	worldMenuOptions := (ImplementorsCatalog new search: #worldMenuOptions)
		collect: [ :implementor |
				implementor compiledMethod
					valueWithReceiver: implementor
					methodClass arguments: {} ].
	openMenuOptions := worldMenuOptions 
		inject: OrderedCollectio new
		into: [ :result :options | 
			result addAll: (options select: [ :option | (option at: #submenuOf ifAbsent: [ '' ]) = TheWorldMenu openLabel ]).
			result ].
		
	^openMenuOptions ! !
!RenameInstanceVariable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720728!
renameReferencesToOldVariable
	
	renamedReferences := OrderedCollectio new.
	methodsAndRangesToChange do: [ :aMethodAndRangesToChange | self renameReferencesToOldVariableInMethod: aMethodAndRangesToChange ].
	! !
!GraphPathFinderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720739!
initializeGraph

	| edges |
	
	edges := OrderedCollectio new
		add: (Edge from: 1 to: 1);
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		add: (Edge from: 3 to: 4);
		add: (Edge from: 1 to: 5);
		yourself.
		
	graph := Graph edges: edges
! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720751!
protocolFor: anIndex
	"Change the listed protocol"

	exclude _ OrderedCollectio new.
	anIndex > 0
		ifTrue: [
			selectedName _ (selectiveClassList at: anIndex) withBlanksTrimmed.
			(1 to: anIndex - 1) do: [:ix |
				exclude addLast: (selectiveClassList at: ix) withBlanksTrimmed]]
		ifFalse: [
			selectedName _ nil.
			].
	self on: baseClass.
	self changed: #relabel! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720767!
testEqual

	self assert: (CompoundMeasure with: self tenPesos with: self twentyDollars) = (CompoundMeasure with: self tenPesos with: self twentyDollars).
	self assert: (CompoundMeasure with: self tenPesos with: self twentyDollars) = (CompoundMeasure with: self twentyDollars with: self tenPesos ).
	self assert: (CompoundMeasure measures: (OrderedCollectio with: self tenPesos with: self twentyDollars with: self tenEuros)) =
		(CompoundMeasure measures: (OrderedCollectio with: self tenEuros with: self twentyDollars with: self tenPesos)).
	
	self deny: (CompoundMeasure with: self tenPesos with: self twentyDollars) = (CompoundMeasure with: (self tenPesos+self onePeso) with: self twentyDollars)
	! !
!Theme methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720793!
generateShoutConfig

	| styles colors |
	styles := OrderedCollectio new.
	colors := self shout as: Dictionary.

	{
		{self undefined. colors at: #undefined}.
		{self defaults . colors at: #defaults}.
		{self pseudoVariables . colors at: #pseudoVariables}.
		{self literals . colors at: #literals}.
		{self instVar . colors at: #instVar}.
		{self messages . colors at: #messages}.
		{self blockLevelZero . colors at: #blockLevelZero}.
		{self blockLevelOne . colors at: #blockLevelOne}.
		{self blockLevelTwo . colors at: #blockLevelTwo}.
		{self blockLevelThree . colors at: #blockLevelThree}.
		{self blockLevelFour . colors at: #blockLevelFour}.
		{self blockLevelFive . colors at: #blockLevelFive}.
		{self blockLevelSix . colors at: #blockLevelSix}.
		{self blockLevelSeven . colors at: #blockLevelSeven}.
		{self tempBar . colors at: #tempBar}.
		{self methodTags . colors at: #methodTags . #bold}.
		{self globals . colors at: #defaults . #bold}.
		{self incompleteMessages . colors at: #incompleteMessages . #underlined}.
		{self argumentTypes . colors at: #arguments . self italic}.
		{self symbols . colors at: #messages . #bold}.
		{self pattern . colors at: #selector . #bold}.
		{self ansiAssignment . nil . #bold}.
		{self assignment . nil . #bold}.
		{self return . nil . #bold}.
		{self tempVars . colors at: #tempVars . self italic}.
		{self blockTemps . colors at: #tempBar . self italic}
	} do: [ :style |
		styles addAll:
			(style first
				collect: [ :category | | elements |
					elements _ style asOrderedCollection.
					elements at: 1 put: category.
					Array withAll: elements ])].

	"Miscellaneous remainder after factoring out commonality:"
	styles addAll: {
		{#unfinishedString . colors at: #undefined . #normal}.
		{#undefinedIdentifier . colors at: #undefined .#bold}.
		{#unfinishedComment . colors at: #pseudoVariables . self italic}.
		{#comment . colors at: #comment . self italic}.
		{#string . colors at: #instVar . #normal}.
		{#literal . nil . self italic}.
		{#incompleteIdentifier . colors at: #tempVars . {#italic. #underlined}}.
		{#classVar . colors at: #tempVars . #bold}.
	}.

	^ styles! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720863!
isMultipleRanges: aRangeOrRanges

	^aRangeOrRanges isKindOf: OrderedCollectio ! !
!Exception methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720870 overrides: 16920235!
initialize

	self handlerContexts: OrderedCollectio new! !
!Scanner methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720875!
xDoubleQuote
    "Collect a comment."
    "wod 1/10/98: Allow 'empty' comments by testing the first character
for $"" rather than blindly adding it to the comment being collected."
    | aStream stopChar |
    stopChar := DoItCharacter.
    aStream := source collectionSpecies writeStream.
    self step.
    [hereChar = $"]
        whileFalse:
            [(hereChar = stopChar and: [source atEnd])
                ifTrue: [^self offEnd: self class unmatechedCommentQuoteErrorDescription].
            aStream nextPut: self step.].
    self step.
    currentComment == nil
        ifTrue: [currentComment := OrderedCollectio with: aStream contents]
        ifFalse: [currentComment add: aStream contents].
    self scanToken! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720902!
allActualSendersOn: aSentCompiledMethod 
	
	| allSenders sureSenders possibleSenders actualMessageSendersCollector |
	
	allSenders := self allCallsOn: aSentCompiledMethod selector.
	
	sureSenders := OrderedCollectio new.
	possibleSenders := OrderedCollectio new.
	
	allSenders do: [ :aSender | 
		actualMessageSendersCollector := aSender actualSendersOf: aSentCompiledMethod.
		actualMessageSendersCollector hasSureMessageSends ifTrue: [ sureSenders add: aSender ].
		actualMessageSendersCollector hasPossibleMessageSends ifTrue: [ 
			possibleSenders add: (PossibleSender in: aSender withPossibleMessageSends: actualMessageSendersCollector possibleMessageSends) ]].
		
	^Array with: sureSenders with: possibleSenders ! !
!GraphPathFinderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720929!
testWithLoops

	| path newGraph newFinder edges |

	"Add a cycle from 2 to 2"
	edges := graph edges.
	edges add: (Edge from: 2 to: 2).
	newGraph := Graph edges: edges.
	newFinder := GraphPathFinder on: newGraph.
	
	path := newFinder pathFrom: 1 to: 2.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 1 to: 2))).

	path := newFinder pathFrom: 1 to: 3.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 2 to: 3))).
		
	path := newFinder pathFrom: 2 to: 2.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 2 to: 2))).

	"To the new graph, add a cycle from 3 to 3"	
	edges := graph edges.
	edges add: (Edge from: 3 to: 3).
	newGraph := Graph edges: edges.
	newFinder := GraphPathFinder on: newGraph.

	path := newFinder pathFrom: 1 to: 3.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 2 to: 3))).
		
	path := newFinder pathFrom: 1 to: 4.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 2 to: 3)
		with: (Edge from: 3 to: 4))).
		
	path := newFinder pathFrom: 3 to: 3.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 3 to: 3))).
		
	path := newFinder pathFrom: 2 to: 4.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 2 to: 3)
		with: (Edge from: 3 to: 4))).
		
	path := newFinder pathFrom: 3 to: 4.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 3 to: 4)))! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50720982!
initListFrom: selectorCollection highlighting: aClass 
	"Make up the messageList with items from aClass in boldface."
	| defClass item |

	messageList _ OrderedCollectio new.
	selectorCollection do: [ :selector |  
		defClass _ aClass whichClassIncludesSelector: selector.
		item _ selector, '     (' , defClass name , ')'.
		defClass == aClass ifTrue: [item _ item asText allBold].
		messageList add: (
			MethodReference new
				setClass: defClass 
				methodSymbol: selector 
				stringVersion: item)].
	self hierarchyForClass: (baseClass _ aClass)! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721003!
pragmaStatement
	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."
	
	| selector arguments words index keyword |
	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])
		ifFalse: [  ^ self expected: 'pragma declaration' ].

	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "
	(here = #apicall: or: [ here = #cdecl: ])
		ifTrue: [ ^ self externalFunctionDeclaration ].

	selector := String new.
	arguments := OrderedCollectio new.
	words := OrderedCollectio new.
	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [
		index := self startOfNextToken + requestorOffset.
		selector := selector , self advance.
		selector := encoder asciiStringLiteral: selector.
		words add: (index to: self endOfLastToken + requestorOffset).
		(selector last = $: or: [ selector first isLetter not ]) ifTrue: [
			arguments add: (encoder asciiStringLiteral: (self pragmaLiteral: selector)) ] ].
	selector numArgs ~= arguments size
		ifTrue: [ ^ self expected: 'pragma argument' ].
	(Symbol hasInterned: selector 
		ifTrue: [ :value | keyword := value]) 
		ifFalse: [ 
			keyword := self 
				correctSelector: selector wordIntervals: words
				exprInterval: (words first first to: words last last)
				ifAbort: [ ^ self fail ] ].
	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).
	^ true! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721056!
testNumberOfDatesBetweenTwoDates

	| timeLineFilter rule1 rule2 rule3 |

	timeLineFilter := TimeLineFilter new.
	rule1 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 14).
	rule2 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 15).
	rule3 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 16).

	timeLineFilter addRules: (OrderedCollectio with: rule1 with: rule2 with: rule3).

	self assert: (timeLineFilter negated numberOfDatesBetween: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 01)
		and: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 20)) = (TimeUnits day with: 17)! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721083!
withReceiverTypesOf: aMessageNode do: aTypesBlock

	| incompleteTypeInfoReasons receiverTypes |
	
	incompleteTypeInfoReasons := OrderedCollectio new.
	receiverTypes := blockCastingApplier receiverTypesFor: aMessageNode in: actualMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons do: [ :anIncompleteTypeInfoReason | anIncompleteTypeInfoReason addTo: self node: aMessageNode ].
	
	(receiverTypes isEmpty and: [ incompleteTypeInfoReasons isEmpty ])
		ifTrue: [ problems add: (TypeCheckingProblem forReceiverWithNoTypesOn: methodReference node: aMessageNode of: methodNode)]
		ifFalse: [ aTypesBlock value: receiverTypes ]
		! !
!Scanner methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721107!
scanMessageParts: sourceString
	"Return an array of the form (comment keyword comment arg comment keyword comment arg comment) for the message pattern of this method.  Courtesy of Ted Kaehler, June 1999"

	| coll nonKeywords |
	coll := OrderedCollectio new.
	self scan: sourceString asPlainString readStream.
	nonKeywords := 0.
	[tokenType == #doIt] whileFalse:
		[(currentComment == nil or: [currentComment isEmpty])
			ifTrue: [coll addLast: nil]
			ifFalse: [coll addLast: currentComment removeFirst.
				[currentComment isEmpty] whileFalse:
					[coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].
		(token numArgs < 1 or: [token = #| and: [ coll size > 1 ] ])
			ifTrue: [(nonKeywords := nonKeywords + 1) > 1 ifTrue: [^ coll]]
						"done with header"
			ifFalse: [nonKeywords := 0].
		coll addLast: token.
		self scanToken].
	(currentComment == nil or: [currentComment isEmpty])
		ifTrue: [coll addLast: nil]
		ifFalse: [coll addLast: currentComment removeFirst.
			[currentComment isEmpty] whileFalse: [
				coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].
	^ coll! !
!ReferenceStream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721146!
nextPutWeak: anObject
    "Write a weak reference to anObject to the receiver stream. Answer anObject.
     If anObject is not a reference type of object, then just put it normally.
     A 'weak' reference means: If anObject gets written this stream via nextPut:,
     then its weak references will become normal references. Otherwise they'll
     read back as nil. -- "
    | typeID referencePosn |

    "Is it a reference type of object? If not, just write it normally."
    typeID _ self typeIDFor: anObject.
    (self isAReferenceType: typeID) ifFalse: [^ self nextPut: anObject].

    "Have we heard of and maybe even written anObject before?"
    referencePosn _ references at: anObject ifAbsent: [
			references at: anObject put: OrderedCollectio new].

    "If referencePosn is an Integer, it's the stream position of anObject.
     Else it's a collection of hopeful weak-references to anObject."
    referencePosn isInteger ifFalse:
        [referencePosn add: byteStream position - basePos.		"relative"
        referencePosn _ self vacantRef].
    self outputReference: referencePosn.		"relative"

    ^ anObject! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721185!
testCreationImmutability

	| graph edges |

	edges := OrderedCollectio new
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		add: (Edge from: 3 to: 4);
		add: (Edge from: 1 to: 4);
		add: (Edge from: 4 to: 4);
		yourself.
	
	graph := Graph edges: edges.		

	"Verify if modifying the entrance collection the graph follows immutable"
	edges add: (Edge from: 4 to: 5).
	self assert: 5 equals: graph edges size.
	self deny: (graph edges includes: (Edge from: 4 to: 5))! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721203!
braceExpression
	" { elements } => BraceNode."

	| elements locations loc more sourceRangeStart sourceRangeEnd |

	sourceRangeStart _ hereMark.
	elements := OrderedCollectio new.
	locations := OrderedCollectio new.
	self advance.
	more := hereType ~~ #rightBrace.
	[more]
		whileTrue: 
			[loc := hereMark + requestorOffset.
			self expression
				ifTrue: 
					[elements addLast: parseNode.
					locations addLast: loc]
				ifFalse:
					[^self expected: 'Variable or expression or right brace'].
			(self match: #period)
				ifTrue: [more := hereType ~~ #rightBrace]
				ifFalse: [more := false]].
	parseNode := BraceNode new elements: elements sourceLocations: locations.
	sourceRangeEnd _ hereEnd.

	(self match: #rightBrace) ifFalse: [^self expected: 'Period or right brace'].
	encoder noteSourceRange: (sourceRangeStart to: sourceRangeEnd) forNode: parseNode.

	^true! !
!GraphPathFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721234!
findEdgesFrom: source to: target

	| convergingEdges matchingEdge |

	convergingEdges := graph edgesConvergingTo: target.
	matchingEdge := convergingEdges detect: [ :anEdge | anEdge goesFrom: source to: target ] ifNone: [ nil ].
		
	^matchingEdge isNil 
		ifTrue: [ self findEdgesFrom: source toAnyEdgeOf: convergingEdges ]
		ifFalse: [ OrderedCollectio with: matchingEdge ].
				

! !
!TopologicalSortTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721250!
testValue

	"Example from http://en.wikipedia.org/wiki/Topological_sorting"

	| graph result |

	graph :=
		Graph edges: (
			OrderedCollectio new
				add: (Edge from: 7 to: 11);
				add: (Edge from: 7 to: 8);
				add: (Edge from: 11 to: 2);
				add: (Edge from: 11 to: 9);
				add: (Edge from: 11 to: 10);
				add: (Edge from: 5 to: 11);
				add: (Edge from: 3 to: 8);
				add: (Edge from: 3 to: 10);
				add: (Edge from: 8 to: 9);
				yourself).

	result := (TopologicalSort for: graph) value asOrderedCollection.

	self assert: 8 equals: result size.
	self assert: (result includesAllOf: #(3 5 7 11 8 2 9 10))! !
!Catalog methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721273!
processEmptySearchQuery
	
	^ OrderedCollectio new! !
!ChangeSet class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721279 overrides: 16904184!
initialize
	"
	ChangeSet initialize
	"
	AllChangeSets _ OrderedCollectio new.
	
	self initializeNotificationActions! !
!TemporaryToInstanceVariable class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721287!
assertNoOtherMethodIn: aClass orSubclassesDefinesTemporaryNamed: aTemporaryVariableName

 	| methodsDefiningTemporaryInHierarchy |

	methodsDefiningTemporaryInHierarchy := OrderedCollectio new.
	aClass withAllSubclassesDo: [ :subclass | 
		methodsDefiningTemporaryInHierarchy addAll: (subclass methodsWithArgumentOrTemporaryNamed: aTemporaryVariableName) ].

	methodsDefiningTemporaryInHierarchy size > 1 ifTrue: [
		self 
			canNotRefactorDueToReferencesError: self temporaryExistsInOtherMethodsErrorDescription
			references: (methodsDefiningTemporaryInHierarchy collect: [ :implementor | MethodReference method: implementor ])
			to: aTemporaryVariableName. ].! !
!TextComposition methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721312!
recomposeFrom: startArg to: stopArg delta: delta
	"Recompose this text.  The altered portion is between start and stop.
	Recomposition may continue to the end of the text, due to a ripple effect.
	Delta is the amount by which the current text is longer than it was
	when its current lines were composed.
	Expand the requested interval to include whole paragraphs because there could be paragraph attributes."
	| intervalToFix start stop startLine newLines partialMaxRightX |
	"Have to recompose line above in case a word-break was affected."
	intervalToFix _ model actualContents encompassParagraph: (startArg to: stopArg).
	start _ intervalToFix first.
	stop _ intervalToFix last.
	startLine _ (self lineIndexFor: start) - 1 max: 1.
	[startLine > 1 and: [(lines at: startLine-1) top = (lines at: startLine) top]]
		whileTrue: [startLine _ startLine - 1].  "Find leftmost of line pieces"
	newLines _ OrderedCollectio new: lines size + 1.
	1 to: startLine-1 do: [:i | newLines addLast: (lines at: i)].
	partialMaxRightX _ self composeLinesFrom: (lines at: startLine) first to: stop delta: delta
			into: newLines priorLines: lines
			atY: (lines at: startLine) top.
	"Partial recomposition computes actual right border only of recompsed text,
	so, it could make maxRightX larger but not smaller.
	This means that if the longest line gets shortened, we won't know, and maxRightX will be erroneously large"
	maxRightX _ maxRightX max: partialMaxRightX! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721361!
removeSelections
	"Remove the selected items from the receiver.  9/18/96 sw"

	| newChangeList newList |

	newChangeList _ OrderedCollectio new.
	newList _ OrderedCollectio new.

	1 to: changeList size do: [ :i |
		(listSelections at: i) ifFalse: [
			newChangeList add: (changeList at: i).
			newList add: (list at: i)]].
	newChangeList size < changeList size
		ifTrue: [
			changeList _ newChangeList.
			list _ newList.
			listIndex _ 0.
			self clearSelections ].
	self changed: #list

	! !
!CompiledMethodCoverageNotifier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721381 overrides: 16920235!
initialize
	
	coverageTrackers := OrderedCollectio new.! !
!TypeCheckerTestMethods methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721387!
typeCheckMessageWithReturnOnIfTrue

	| temp1  |
	
	temp1 := OrderedCollectio new.
	temp1 := Color new.
	
	temp1 isCollection ifTrue: [ ^self ].
	temp1 alpha! !
!DefinedByRulesTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721396!
testIncludedFromTo

	| set |
	
	set := DefinedByRules for: NaturalNumbersTestUniverse new.
	set 
		addRule: (SpecificObjectInclusionRule for: 1);
		addRule: (SpecificObjectInclusionRule for: 2).
		
	self assert: (set includedFrom: 0 to: 10) size = 2.
	self assert: ((set includedFrom: 0 to: 10) asOrderedCollection includesAllOf: (OrderedCollectio with: 1 with: 2)).
	self assert: (set includedFrom: 1 to: 2) size = 2.
	self assert: ((set includedFrom: 1 to: 2) asOrderedCollection includesAllOf: (OrderedCollectio with: 1 with: 2)).
	self assert: (set includedFrom: 2 to: 3) size = 1.
	self assert: ((set includedFrom: 2 to: 3) asOrderedCollection includesAllOf: (OrderedCollectio with: 2)).
	self assert: (set includedFrom: 3 to: 4) isEmpty! !
!ChangeSelectorKeepingParameters methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721424 overrides: 16803459!
implementorNewSourceCodeOf: anImplementor

	|  newSource rangesToNewKeywords |

	rangesToNewKeywords := OrderedCollectio new.
	currentImplementorMethodNode := anImplementor notOptimizedMethodNode.

	currentImplementorMethodNode selectorKeywordsPositions withIndexDo: [ :aKeywordRange :index |
		self addImplementorSelectorRanges: aKeywordRange at: index to: rangesToNewKeywords ].

	newSource := anImplementor sourceCode copyReplacing: rangesToNewKeywords.
	^newSource! !
!RemoveParameterWithActualScopeApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721444 overrides: 16803828!
createSenders

	^OrderedCollectio new.
! !
!Stream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721449!
next: anInteger 
	"Answer the next anInteger number of objects accessible by the receiver."

	| aCollection |
	aCollection _ OrderedCollectio new.
	anInteger timesRepeat: [aCollection addLast: self next].
	^aCollection! !
!SequenceableCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721460!
testDoSeparatedByDoesNotValueSeparatedBlockOnLastElement

	| collectionToTraverse traversedElements |

	collectionToTraverse := OrderedCollectio with: 1 with: 2.
	traversedElements := OrderedCollectio new.

	self shouldntFail: [ collectionToTraverse do: [ :anElement | traversedElements add: anElement ] separatedBy: [ traversedElements add: $-] ].

	self assert: traversedElements equals: (OrderedCollectio with: 1 with: $- with: 2).! !
!AnalysisResultWindow class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721478!
pickStartPositionFromSnapshots: userChangesFileName	
	
	"Prompt with a menu of how far back to go when browsing a changes file."

	| banners positions pos chunk i startPosition |
	
	startPosition := self lastSnapshotPosition: userChangesFileName.
	userChangesFileName asFileEntry readStreamDo: [ :changesFile |
		banners _ OrderedCollectio new.
		positions _ OrderedCollectio new.
		pos _ startPosition.
		[pos = 0
			or: [banners size > 20]] 		"Go back at most 20 image exits"
			whileFalse: [
				changesFile position: pos.
				chunk _ changesFile nextChunk.
				i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.
				i > 0
					ifTrue: [
						positions addLast: pos.
						banners addLast: (chunk copyFrom: 5 to: i - 2).
						pos _ Number readFrom: (chunk copyFrom: i + 13 to: chunk size)]
					ifFalse: [
						pos _ 0]].
	].
	positions addLast: 0.
	banners addLast: 'Whole file'.
	^ (SelectionMenu labelList: banners selections: positions)
				startUpWithCaption: 'Browse as far back as...'.
! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721514!
classesThatImplementAllOf: selectorSet
	"Return an array of any classes that implement all the messages in selectorSet."

	| found remaining |
	found _ OrderedCollectio new.
	selectorSet do:
		[:sel | (self methodDict includesKey: sel) ifTrue: [found add: sel]].
	found isEmpty
		ifTrue: [^ self subclasses inject: Array new
						into: [:subsThatDo :sub |
							subsThatDo , (sub classesThatImplementAllOf: selectorSet)]]
		ifFalse: [remaining _ selectorSet copyWithoutAll: found.
				remaining isEmpty ifTrue: [^ Array with: self].
				^ self subclasses inject: Array new
						into: [:subsThatDo :sub |
							subsThatDo , (sub classesThatImplementAllOf: remaining)]]! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721539!
addMultiRange: aRange for: aNode

	| ranges |
	
	"I'm using an OrderedCollection because ranges are added in order, while parsing the source code.
	If this constrain is not hold, a SortedCollection should be used - Hernan"
	ranges := sourceRanges at: aNode ifAbsentPut: [ OrderedCollectio new ].
	ranges add: aRange asSourceCodeInterval.
	
	^aNode ! !
!SelectionMenu class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721554!
fromArray: anArray
	"Construct a menu from anArray.  The elements of anArray must be either:
	*  A pair of the form: <label> <selector>
or	*  The 'dash' (or 'minus sign') symbol

	Refer to the example at the bottom of the method"

	| labelList lines selections anIndex |
	labelList _ OrderedCollectio new.
	lines _ OrderedCollectio new.
	selections _ OrderedCollectio new.
	anIndex _ 0.
	anArray do:
		[:anElement |
			anElement size = 1
				ifTrue:
					[(anElement == #-) ifFalse: [self error: 'badly-formed menu constructor'].
					lines add: anIndex]
				ifFalse:
					[anElement size = 2 ifFalse: [self error: 'badly-formed menu constructor'].
					anIndex _ anIndex + 1.
					labelList add: anElement first.
					selections add: anElement second]].
	^ self labelList: labelList lines: lines selections: selections

"(SelectionMenu fromArray:
	#(	('first label'		moja)
		('second label'	mbili)
		-
		('third label' 	tatu)
		-
		('fourth label'	nne)
		('fifth label'	tano))) startUp"! !
!ReceiverTypesOfMessageSendsConform methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721590 overrides: 16902254!
value

	notIncludedReceiverTypesInMessageSends := OrderedCollectio new.

	implementors ifNotEmpty: [ 
		sentSelector := implementors anyOne selector.
		types := implementors collect: [ :anImplementor | anImplementor methodClass ].
		
		senders do: [ :aSender | 
			currentSender := aSender.
			currentSenderMethodClass := aSender methodClass.
			currentSender notOptimizedMethodNode accept: self ]].
	
	^notIncludedReceiverTypesInMessageSends! !
!NotImplementedMethodTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721608!
test09rangesOASentSelectorWhenSendToReceiverTypesIsEmpty

	self assert: ((NotImplementedMethod class: self class selector: #none) rangesOf: #size whenSendTo: { OrderedCollectio })
 isEmpty! !
!WorldMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721618!
cleanseStepList
	"Remove morphs from the step list that are not in this World."

	| deletions |
	deletions _ OrderedCollectio new.
	stepList do: [ :entry |
		entry receiver world == self ifFalse: [
			deletions add: entry]].
	deletions do: [ :entry|
		stepList remove: entry ].

	deletions _ OrderedCollectio new.
	alarms do: [ :entry |
		((entry receiver is: #Morph) and: [ entry receiver world == self ]) ifFalse: [
			deletions add: entry]].
	deletions do: [ :entry|
		alarms remove: entry ]! !
!Form class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721637!
toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors _ `Color red wheel: 12`.
	color _ 8.
	[ true ] whileTrue: [
		queue _ OrderedCollectio new: 32.
		16 timesRepeat: [queue addLast: `-40@ -40`].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point _ point * 4 + Sensor mousePoint // 5.
			point _ point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !
!InlineTemporaryVariableApplier class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721675!
findSourceRangesOfNode: aParseNode using: completeSourceRanges

	| ranges |
	
	ranges := OrderedCollectio new.
	
	(completeSourceRanges associations select: [:aNodeAndRange | aNodeAndRange key equivalentTo: aParseNode])
	 	do: [:nodeAndRanges | ranges addAll: nodeAndRanges value].
	
	^ranges.! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721688!
browseClassVarRefs 
	"Put up a menu offering all class variable names; if the user chooses one, open up a message-list browser on all methods that refer to the selected class variable"

	| lines labelStream allVars index owningClasses |
	lines _ OrderedCollectio new.
	allVars _ OrderedCollectio new.
	owningClasses _ OrderedCollectio new.
	labelStream _ String writeStream.
	self withAllSuperclasses reverseDo: [ :class | | vars |
		vars _ class classVarNames asArray sort.
		vars do: [ :var |
			labelStream position = 0 ifFalse: [labelStream newLine].
			labelStream nextPutAll: var.
			allVars add: var.
			owningClasses add: class].
		vars isEmpty ifFalse: [ lines add: allVars size ]].
	labelStream contents isEmpty ifTrue: [^Smalltalk beep]. "handle nil superclass better"
	index _ (PopUpMenu labels: labelStream contents lines: lines) startUpMenu.
	index = 0 ifTrue: [^ self].
	Smalltalk browseAllCallsOn:
		((owningClasses at: index) classPool associationAt: (allVars at: index))! !
!TextComposition methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721723!
composeAll
	"Full recomposition computes actual right border of text,
	only limited by longest line and (extentForComposing x)"
	maxRightX _ self
		composeLinesFrom: 1
		to: model textSize
		delta: 0
		into: OrderedCollectio new
		priorLines: Array new
		atY: 0! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:47' prior: 50721735!
testAccessImmutability

	| graph edges edgesPreviousAdd nodesPreviousAdd |

	edges := OrderedCollectio new
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		add: (Edge from: 3 to: 4);
		add: (Edge from: 1 to: 4);
		add: (Edge from: 4 to: 4);
		yourself.
	
	graph := Graph edges: edges.		

	edgesPreviousAdd := graph edges.
	nodesPreviousAdd := graph nodes.

	edges := graph edges.
	edges add: (Edge from: 4 to: 5).

	self assert: ((edges copy removeAll: graph edges; yourself) includes: (Edge from: 4 to: 5)).
	self assert: (edgesPreviousAdd copy removeAll: graph edges; yourself) isEmpty.	
	self assert: (graph edges removeAll: edgesPreviousAdd; yourself) isEmpty.	
	
	self assert: (nodesPreviousAdd copy removeAll: graph nodes; yourself) isEmpty.	
	self assert: (graph nodes removeAll:  nodesPreviousAdd; yourself) isEmpty
! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50721765!
stackOfSize: limit 
	"Answer an OrderedCollection of the top 'limit' contexts
	 on the receiver's sender chain."

	| stack ctxt |
	stack := OrderedCollectio new.
	stack addLast: (ctxt := self).
	[(ctxt := ctxt sender) notNil
	 and: [stack size < limit]] whileTrue:
		[stack addLast: ctxt].
	^stack! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50721778!
testGraphCreation

	| graph edges |

	edges :=
		OrderedCollectio new
			add: (Edge from: 1 to: 2);
			add: (Edge from: 2 to: 3);
			yourself.

	graph := Graph edges: edges.

	self assert: graph edges size = 2.
	self assert: (graph edges includes: (Edge from: 1 to: 2)).
	self assert: (graph edges includes: (Edge from: 2 to: 3)).

	self assert: (graph nodes size = 3).
	self assert: (graph nodes includes: 1).
	self assert: (graph nodes includes: 2).
	self assert: (graph nodes includes: 3)! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50721797!
removeUpToDate
	"Remove all up to date version of entries from the receiver"

	| newChangeList newList |
	newChangeList _ OrderedCollectio new.
	newList _ OrderedCollectio new.
	changeList with: list do: [ :chRec :strNstamp | | keep cls name |
		keep _ chRec isClassDeletion not or: [ chRec changeClass notNil ]. "If a class deletion, and class already gone, don't keep it"
		keep ifTrue: [
			(cls _ chRec changeClass) ifNotNil: [ | sel str |
				str _ chRec string.
				sel _ chRec methodSelector.
				keep _ chRec isMethodDeletion
					ifTrue: [cls includesSelector: sel]
					ifFalse: [(cls sourceCodeAt: sel ifAbsent: nil)  ~= str]]].
		(chRec changeType == #classComment and: [
				name _ chRec changeClassName.
				Smalltalk includesKey: name]) ifTrue: [
			cls _ Smalltalk at: name.
			keep _ cls organization classComment ~= chRec text ].
		(chRec changeType == #classDefinition and: [
				name _ chRec changeClassName.
				Smalltalk includesKey: name]) ifTrue: [
			cls _ Smalltalk at: name.
			chRec isMetaClassChange ifTrue: [ cls _ cls class ].
			keep _ cls definition ~= chRec text ].
		keep ifTrue: [
			newChangeList add: chRec.
			newList add: strNstamp]].
	newChangeList size < changeList size ifTrue: [
		changeList _ newChangeList.
		list _ newList.
		listIndex _ 0.
		self clearSelections ].
	self changed: #list! !
!DefinedByRulesTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50721843!
testIncludedIn

	| set |
	
	set := DefinedByRules for: NaturalNumbersTestUniverse new.
	set 
		addRule: (SpecificObjectInclusionRule for: 1);
		addRule: (SpecificObjectInclusionRule for: 2).
		
	self assert: (set includedIn: (0 to: 10)) size = 2.
	self assert: ((set includedIn: (0 to: 10)) asOrderedCollection includesAllOf: (OrderedCollectio with: 1 with: 2)).
	self assert: (set includedIn: (1 to: 2)) size = 2.
	self assert: ((set includedIn: (1 to: 2)) asOrderedCollection includesAllOf: (OrderedCollectio with: 1 with: 2)).
	self assert: (set includedIn: (2 to: 3)) size = 1.
	self assert: ((set includedIn: (2 to: 3)) asOrderedCollection includesAllOf: (OrderedCollectio with: 2)).
	self assert: (set includedIn: (3 to: 4)) isEmpty! !
!FileList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50721870!
itemsForAnyFile1
	"Answer a list of universal services that could apply to any file"
	
	| services |
	services _ OrderedCollectio new.
	(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue: [
		services add: self serviceGet ].
	services add: self serviceRenameFile. 
	services add: self serviceDeleteFile.
	^ services! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50721885!
browseClassesWithNamesContaining: aString caseSensitive: caseSensitive 
	"Smalltalk browseClassesWithNamesContaining: 'eMorph' caseSensitive: true "
	"Launch a class-list list browser on all classes whose names containg aString as a substring."

	| suffix aList |
	suffix _ caseSensitive
				ifTrue: [' (case-sensitive)']
				ifFalse: [' (use shift for case-sensitive)'].
	aList _ OrderedCollectio new.
	Smalltalk allClassesDo: [ :class |
		(class name includesSubstring: aString caseSensitive: caseSensitive)
			ifTrue: [aList add: class name]].
	aList notEmpty
		ifTrue: [HierarchyBrowserWindow forClassesNamed: aList asSet sorted title: 'Classes whose names contain ' , aString , suffix]! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50721910!
testFormatter2
	"Smalltalk testFormatter2"
	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged.
	The formatting used will be classic monochrome"
	| newCodeString badOnes n oldCodeString oldTokens newTokens |
	badOnes _ OrderedCollectio new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldCodeString _ (cls sourceCodeAt: selector) asPlainString.
					newCodeString _ cls compilerClass new
						format: oldCodeString
						in: cls
						notifying: nil.
					oldTokens _ oldCodeString findTokens: Character separators.
					newTokens _ newCodeString findTokens: Character separators.
					oldTokens = newTokens ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	Smalltalk
		browseMessageList: badOnes
		name: 'Formatter Discrepancies'.! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50721951!
doubleResumeTestResults

       ^OrderedCollectio new
               add: self doSomethingString;
               add: self doSomethingElseString;
               add: self doYetAnotherThingString;
               yourself! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50721962!
doubleOuterPassTestResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		add: self doSomethingElseString;
		yourself! !
!MessageKeywordsAndParametersModel methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50721972!
initializeFor: someVariablesToExtract

	models := OrderedCollectio new.
	someVariablesToExtract do: [:variableToExtract | | keywordParameterModel defaultName parameterModel |
		keywordParameterModel := Dictionary new.
		keywordParameterModel at: #variableName put: variableToExtract.
		keywordParameterModel at: #keyword put: (PluggableTextModel on:  self).
		parameterModel := PluggableTextModel on: self.
		defaultName := (variableToExtract first isVowel ifTrue: ['an'] ifFalse: ['a']), variableToExtract capitalized.
		parameterModel actualContents: defaultName.
		keywordParameterModel at: #parameterName put: parameterModel.

		models add: keywordParameterModel].! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50721997!
methodsWithoutComments
	"Return a collection representing methods in the receiver which have no precode comments"

	| slips |
	slips _ OrderedCollectio new.
	self changedClasses do:
		[:aClass |
		(self methodChangesAtClass: aClass name) associationsDo: 
				[:mAssoc | (#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse:
					[(aClass selectors includes:  mAssoc key) ifTrue:
						[(aClass firstPrecodeCommentFor: mAssoc key) isEmptyOrNil
								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].
	^ slips

	"
	Smalltalk browseMessageList: (ChangeSet changeSetForBaseSystem methodsWithoutComments) name: 'methods lacking comments'
	"! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722022!
messagePart: level repeat: repeat

	| start receiver selector args precedence words keywordStart |

	[receiver := parseNode.
	(hereType == #keyword and: [level >= 3])
		ifTrue: [
			start := self startOfNextToken.
			selector := source collectionSpecies writeStream.
			args := OrderedCollectio new.
			words := OrderedCollectio new.
			[hereType == #keyword]
				whileTrue:
					[keywordStart := self startOfNextToken + requestorOffset.
					selector nextPutAll: self advance.
					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 2 repeat: true.
					args addLast: parseNode].
			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector := sym])
				ifFalse: [ selector := self correctSelector: selector contents
										wordIntervals: words
										exprInterval: (start to: self endOfLastToken)
										ifAbort: [ ^ self fail ] ].
			precedence := 3]
		ifFalse: [

			level >= 2 ifTrue: [self transformVerticalBarAndUpArrowIntoABinarySelector].
			((hereType == #binary )
				and: [level >= 2])
				ifTrue:
					[start := self startOfNextToken.
					selector := self advance asSymbol.
					words := OrderedCollectio with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 1 repeat: true.
					args := Array with: parseNode.
					precedence := 2]
				ifFalse: [hereType == #word
						ifTrue:
							[start := self startOfNextToken.
							selector := self advance.
							args := #().
							words := OrderedCollectio with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
							(Symbol hasInterned: selector ifTrue: [ :sym | selector := sym])
								ifFalse: [ selector := self correctSelector: selector
													wordIntervals: words
													exprInterval: (start to: self endOfLastToken)
													ifAbort: [ ^ self fail ] ].
							precedence := 1]
						ifFalse: [^args notNil]]].

	parseNode := MessageNode new
				optimizeSpecialSends: optimizeSpecialSends;
				receiver: receiver
				selector: selector
				arguments: args
				precedence: precedence
				from: encoder
				sourceRange: (start to: self endOfLastToken)
				keywordsRanges: words.
	repeat]
		whileTrue: [].
	^true! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722100!
keywordPattern

	| keywordRanges selector arguments |
	
	selector := source collectionSpecies writeStream.
	arguments := OrderedCollectio new.
	keywordRanges := OrderedCollectio new.
	
	[hereType == #keyword] whileTrue:[ 
		self addKeywordPatternPartTo: selector keywordRanges: keywordRanges arguments: arguments ].
		
	^ {selector contents asSymbol. arguments. 3. keywordRanges}
		! !
!TextComposition methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722116!
addSelectionRectsFrom: characterBlock1 to: characterBlock2 to: aStream
	"Return an array of rectangles representing the area between the two character blocks given as arguments."
	| line1 line2 rects cb1 cb2 w line |
	characterBlock1 <= characterBlock2
		ifTrue: [cb1 _ characterBlock1.  cb2 _ characterBlock2]
		ifFalse: [cb2 _ characterBlock1.  cb1 _ characterBlock2].
	cb1 = cb2 ifTrue: [
		w _ 6.
		^ aStream nextPut: (cb1 topLeft - (w@0) corner: cb1 bottomLeft + ((w+1)@0))].
	line1 _ self lineIndexFor: cb1 stringIndex.
	line2 _ self lineIndexFor: cb2 stringIndex.
	line1 = line2 ifTrue: [
		^ aStream nextPut: (cb1 topLeft corner: cb2 bottomRight)].
	rects _ OrderedCollectio new.
	rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).
	line1+1 to: line2-1 do: [ :i |
		line _ lines at: i.
		(line left = rects last left and: [ line right = rects last right ])
			ifTrue: [ "new line has same margins as old one -- merge them, so that the caller gets as few rectangles as possible"
					| lastRect |
					lastRect _ rects removeLast.
					rects add: (lastRect bottom: line bottom) ]
			ifFalse: [ "differing margins; cannot merge"
					rects add: line rectangle ] ].
	aStream nextPutAll: rects.
	aStream nextPut: ((lines at: line2) topLeft corner: cb2 bottomLeft)! !
!IsKindOfTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722161 overrides: 50625983!
buildCastApplierBefore: aPreviousCastingApplier 

	^EffectiveTypeCastApplier 
		casts: (OrderedCollectio with: self buildTypeCast)
		rejections: OrderedCollectio new
		previous: aPreviousCastingApplier
	! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722171!
tempsAndBlockArgs
	| tempNodes |
	tempNodes := OrderedCollectio new.
	scopeTable associationsDo:
		[:assn | | var |
		var := assn value.
		(var isTemp
		 and: [var isMethodArg not
		 and: [var scope = 0 or: [var scope = -1]]]) ifTrue:
			[tempNodes add: var]].
	^tempNodes! !
!ImplementorsCatalog methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722184 overrides: 50544668!
processNonEmptySearchQuery: aQuery

	| implementors |
	implementors _ OrderedCollectio new.
	
	Smalltalk allBehaviorsDo: [ :class | 
		class selectors
			select: [ :selector | selector includesSubstring: aQuery caseSensitive: false ]
			thenDo: [ :selector | implementors add: (MethodReference class: class selector: selector) ] ].
		
	^ resultsSorter value: implementors! !
!MessageTally methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722199!
bump: hitCount fromSender: senderTally
	"Add this hitCount to the total, and include a reference to the
	sender responsible for the increment"
	self bump: hitCount.
	senders ifNil: [senders _ OrderedCollectio new].
	senderTally == nil
		ifFalse: [senders add: (senderTally copyWithTally: hitCount)]! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722212!
allSubclasses
	"A breadth-first iterative algorithm. Significantly faster than a recursive, depth-first implementation."

	| answer finger fingerLimit each |
	answer := OrderedCollectio new.
	self subclassesDo: [:some | answer add: some].
	finger := 0.
	fingerLimit := answer size.
	[finger < fingerLimit] whileTrue:
		[
			finger + 1 to: fingerLimit do:
				[:index |
					each := answer at: index.
					each subclassesDo: [:some | answer add: some]
				].
			finger := fingerLimit.
			fingerLimit := answer size.
		].
	^answer! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722232!
generateAssertionsFor: report 
	
	"NPM: for use during development only.
	Generates assertions for using in tests from report.
	Hacky, but it does the job."
	
	| assertions assertionsSourceCode sortedSourceRanges sourceCode sourceCodeByRange sourceRanges |
	sourceRanges := report fullyCoveredSourceRanges, report partiallyCoveredSourceRanges, report uncoveredSourceRanges.
	sortedSourceRanges := sourceRanges asOrderedCollection sort: [ :sourceRange :otherSourceRange | sourceRange first < otherSourceRange first ].
	
	sourceCode := report compiledMethod sourceCode.
	sourceCodeByRange := sortedSourceRanges
		inject: OrderedDictionary new
		into: [ :result :sourceCodeRange |
			result
				at: sourceCodeRange
				put: (sourceCode copyFrom: sourceCodeRange first to: sourceCodeRange last);
				yourself ].
	
	assertions := OrderedCollectio streamContents: [ :contents | 
		sourceCodeByRange keysAndValuesDo: [ :sourceRange :sourceRangeCode | | assertion assertionKind | 
			assertionKind := (sourceRanges includes: sourceRange)
				ifTrue: [ 'assert' ] ifFalse: [ 'deny' ].
				
			assertion := 'self {1}: #{2} hasBeenCoveredFrom: {3} to: {4} as: ''{5}''.' format: {
				assertionKind.
				report selector asString.
				sourceRange first asString.
				sourceRange last asString.
				sourceRangeCode }.
			
			contents nextPut: assertion ]].
	
	assertionsSourceCode := (String newLineString, String tab) join: assertions.
	
	Clipboard storeObject: assertionsSourceCode.! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722282!
calculateLabelsAndLines

	labels := OrderedCollectio new.
	lines := OrderedCollectio new.
	icons := OrderedCollectio new.
	actions := OrderedCollectio new.

	self 
		addCommonSupertypeLabel;
		addTypesLabels;
		addCrudOptions;
		addIncompleteTypesReasons
! !
!TypeCheckerTestMethods methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722294!
typeCheckMessageWithFalse_True_False_InSubclasses

	| temp1  |
	
	temp1 := 1.
	temp1 := OrderedCollectio new.
	temp1 := Color new.
	
	temp1 isCollection 
		ifTrue: [ temp1 add: 1 ] 
		ifFalse: [ temp1 isNumber 
			ifTrue: [ temp1 + 1 ]
			ifFalse: [ temp1 alpha ]]! !
!EffectiveTypeCastApplier class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722307!
previous: aPreviousCastingStrategy

	^self 
		casts: OrderedCollectio new 
		rejections: OrderedCollectio new
		previous: aPreviousCastingStrategy ! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722316!
buildLabelsPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollectio with: (Color fromHexString: '#fCD89A') with: 'Sunset'.
	ocean := OrderedCollectio with: (Color fromHexString: '#EFF6E0') with: 'Ocean'.
	forest := OrderedCollectio with: (Color fromHexString: '#8DAA91') with: 'Forest'.
	ash := OrderedCollectio with: (Color fromHexString: '#000000') with: 'Ash'.
	light := OrderedCollectio with: (Color fromHexString: '#946846') with: 'Light'.
	
	labelsPalette := OrderedCollectio with: sunset with: ocean with: forest with: ash with: light.! !
!DifferenceFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722338!
unfold: pointCollection
	| pending visited point |
	pending := OrderedCollectio withAll: pointCollection.
	visited := OrderedCollectio new.
	[pending notEmpty] whileTrue: [
		point := pending removeFirst.
		(visited includes: point) ifFalse: [
			self unfold: point on: pending.
			visited add: point]].
	^visited
! !
!IntroduceNullObjectForm methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722352!
buildPreviewOf: anIfNilCheckForm

	| keywordParamStrings previewContent currentlyShownPreview currentlyShownTable |

	currentlyShownTable := (anIfNilCheckForm submorphs at: 1) submorphs at: 2.
	currentlyShownPreview := (anIfNilCheckForm submorphs at: 1) submorphs at: 1.

	keywordParamStrings := OrderedCollectio new.
	currentlyShownTable keywordsAndParametersDo: [:keyword :parameterName |
		(keyword isEmpty or: [parameterName isEmpty]) ifTrue: [
			currentlyShownPreview model actualContents: self previewUnavailableMessage.
			^self].

		keywordParamStrings addFirst: '', keyword, ': ', parameterName.].

	previewContent := ' ' join: keywordParamStrings.

	currentlyShownPreview model actualContents: previewContent.! !
!SHParserST80 methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722378!
pushArgument: aString 
	(arguments at: blockDepth ifAbsentPut: [OrderedCollectio new: 10]) 
		add: aString! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722385!
messageSendsRangesOf: aSentSelector

	| methodNode ranges |

	methodNode := self methodNode.
	ranges := OrderedCollectio new.

	methodNode nodesDo: [ :aParseNode |
		(aParseNode isMessageNamed: aSentSelector) ifTrue: [
			(methodNode rangeForNode: aParseNode ifAbsent: nil) ifNotNil: [ :range |
				ranges add: range ]]].

	^ranges ! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722399!
cascadeNodeWithMessageSendReceiver

	OrderedCollectio new
		copy;
		yourself! !
!EffectiveTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722406!
initializeAfterMessageTypeCasts

	afterMessageTypeCasts := OrderedCollectio new.
	self 
		addToAfterMessageTypeCasts: [ self buildTypeReject ] ifReturns: castingBlock;
		addToAfterMessageTypeCasts: [ self buildTypeCast ] ifReturns: rejectingBlock
			
	! !
!MinusInfinity methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722418 overrides: 50524003!
composeWithNumber: aNumber

	^CompoundMeasure measures: (OrderedCollectio with: self with: aNumber)! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722425!
allPrimitiveMessages
	"Answer an OrderedCollection of all the methods that are implemented by 
	primitives."

	| aColl method | 
	aColl _ OrderedCollectio new: 200.
	self allBehaviorsDo: [ :class |
		class selectorsDo: [ :sel | 
			method _ class compiledMethodAt: sel.
			method primitive ~= 0 ifTrue: [
				aColl addLast: class name , ' ' , sel 
					, ' ' , method primitive printString]]].
	^aColl! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722441!
removeDoIts
	"Remove doits from the receiver, other than initializes. 1/26/96 sw"

	| newChangeList newList |
	newChangeList _ OrderedCollectio new.
	newList _ OrderedCollectio new.

	changeList with: list do: [ :chRec :str |
		(chRec isDoIt not or: [str endsWith: 'initialize'])
			ifTrue: [
				newChangeList add: chRec.
				newList add: str]].
	newChangeList size < changeList size
		ifTrue: [
			changeList _ newChangeList.
			list _ newList.
			listIndex _ 0.
			self clearSelections ].
	self changed: #list.

	! !
!TestResult methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722461!
failures
	failures
		ifNil: [failures := OrderedCollectio new].
	^failures
			! !
!Schedule methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722467!
dateAndTimes

	| dateAndTimes |
	dateAndTimes _ OrderedCollectio new.
	self scheduleDo: [ :e | dateAndTimes add: e ].
	^ dateAndTimes asArray.! !
!Color class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722475!
initializeGrayToIndexMap
	"Build an array of gray values available in the 8-bit colormap. This array is indexed by a gray level between black (1) and white (256) and returns the pixel value for the corresponding gray level."
	"Note: This method must be called after initializeIndexedColors, since it uses IndexedColors."
	"
	Color initializeGrayToIndexMap
	"

	| grayLevels grayIndices c distToClosest dist indexOfClosest indexedColors |
	"record the level and index of each gray in the 8-bit color table"
	grayLevels _ OrderedCollectio new.
	grayIndices _ OrderedCollectio new.
	indexedColors _ self indexedColors.
	"Note: skip the first entry, which is reserved for transparent"
	2 to: indexedColors size do: [:i |
		c _ indexedColors at: i.
		c saturation = 0.0 ifTrue: [  "c is a gray"
			grayLevels add: (c green * 255) rounded.  "0 to 255; R, G, and B are the same"
			grayIndices add: i - 1]].  "pixel values are zero-based"
	grayLevels _ grayLevels asArray.
	grayIndices _ grayIndices asArray.

	"for each gray level in [0..255], select the closest match"
	GrayToIndexMap _ ByteArray new: 256.
	0 to: 255 do: [ :level |
		distToClosest _ 10000.  "greater than distance to any real gray"
		1 to: grayLevels size do: [:i |
			dist _ (level - (grayLevels at: i)) abs.
			dist < distToClosest ifTrue: [
				distToClosest _ dist.
				indexOfClosest _ grayIndices at: i]].
		GrayToIndexMap at: (level + 1) put: indexOfClosest]! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722523!
temporaries
	" [ '|' (variable)* '|' ]"
	| tempDeclarationNodes theActualText declarationStartIndex |
	(self match: #verticalBar) ifFalse: 
		["no temps"
		doitFlag ifTrue:
			[tempsMark := self interactive
								ifTrue: [requestor selectionInterval first]
								ifFalse: [1].
			^ self noTempsDeclaration ].
		tempsMark := hereMark	"formerly --> prevMark + prevToken".
		tempsMark > 0 ifTrue:
			[theActualText := source contents.
			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]
				whileTrue: [tempsMark := tempsMark + 1]].
			^ self noTempsDeclaration ].
	tempDeclarationNodes _ OrderedCollectio new.
	declarationStartIndex _ prevMark.
	[hereType == #word] whileTrue: [
		self advanceWithRangeDo: [ :variableName :range |
			| variableNode |
			variableNode _ encoder bindTemp: variableName range: range.
			tempDeclarationNodes addLast: (self createTempDeclarationOf: variableNode sourceRange: range) ] ].
	(self match: #verticalBar) ifTrue: [
		tempsMark := prevMark.
		^ self
			createTempsDeclarationWith: tempDeclarationNodes
			sourceRange: (declarationStartIndex to: prevMark) ].
	^ self expected: 'Vertical bar'! !
!ManyMethodsTypeChecker class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722564!
forAllClasses: classes

	| methods |
	
	methods := OrderedCollectio new.
	classes do: [ :aClass | self addMethodsOf: aClass to: methods ].
	
	^self forAll: methods! !
!SystemOrganizer methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722573!
superclassOrderInAll: categories

	| classes |

	classes := OrderedCollectio new.
	categories do: [ :aCategory | classes addAll: (self classesAt: aCategory)].

	^Array streamContents: [ :stream | Smalltalk hierarchySorted: classes do: [ :aClass | stream nextPut: aClass ]].! !
!SamplePlotterMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722586 overrides: 16794195!
initialize
	super initialize.
	extent _ 320@240.
	sampleSequences _ OrderedCollectio new.
	colors _ OrderedCollectio new! !
!IntroduceNullObjectRequest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722594!
replacementParameters

	| parameters |

	parameters := OrderedCollectio new.
	messageKeywordsAndParametersModels keysAndValuesDo: [:ifNilCheck :model |
		parameters add: (ReplaceIfNilWithPolymorphismParameters
			forIfNilMessageSending: ifNilCheck messageNode
			onMethod: ifNilCheck methodNode
			useKeywordsDefinitions: model definitions)].

	^parameters! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722609!
asPathTokens

	^self beginsWithWindowsDriveName
		ifTrue: [
			(OrderedCollectio with: (self copyFrom: 1 to: 2)), 
				((self copyFrom: 3 to: self size) findTokens: String pathSeparators) ]
		ifFalse: [
			self findTokens: String pathSeparators ]! !
!Symbol class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722620!
possibleSelectorsFor: misspelled 
	"Answer an ordered collection of possible corrections
	for the misspelled selector in order of likelyhood"

	| numArgs candidates lookupString best binary short long first ss |
	lookupString _ misspelled asLowercase. "correct uppercase selectors to lowercase"
	numArgs _ lookupString numArgs.
	(numArgs < 0 or: [lookupString size < 2]) ifTrue: [^ OrderedCollectio new: 0].
	first _ lookupString first.
	short _ lookupString size - (lookupString size // 4 max: 3) max: 2.
	long _ lookupString size + (lookupString size // 4 max: 3).

	"First assemble candidates for detailed scoring"
	candidates _ OrderedCollectio new.
	self allSymbolTablesDo: [:s | (((ss _ s size) >= short	"not too short"
			and: [ss <= long			"not too long"
					or: [(s at: 1) = first]])	"well, any length OK if starts w/same letter"
			and: [s numArgs = numArgs])	"and numArgs is the same"
			ifTrue: [candidates add: s]].

	"Then further prune these by correctAgainst:"
	best _ lookupString correctAgainst: candidates.
	((misspelled last ~= $:) and: [misspelled size > 1]) ifTrue: [
		binary _ misspelled, ':'.		"try for missing colon"
		Symbol hasInterned: binary ifTrue: [:him | best addFirst: him]].
	^ best! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722662!
testApplyUsingDepthFistSearch

	| collectedNodes expectedCollectedNodes graph |

	collectedNodes := OrderedCollectio new.

	graph :=
		Graph edges: (
			OrderedCollectio new
				add: (Edge from: 1 to: 2);
				add: (Edge from: 2 to: 3);
				add: (Edge from: 3 to: 4);
				add: (Edge from: 4 to: 5);
				add: (Edge from: 1 to: 6);
				add: (Edge from: 1 to: 7);
				yourself).

	graph apply: [:node | collectedNodes add: node] usingDepthFirstSearchFrom: 1.

	expectedCollectedNodes := #(1 2 3 4 5 6 7).

	self assert: collectedNodes asOrderedCollection = expectedCollectedNodes asOrderedCollection! !
!BehaviorTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722685!
testHighestClassImplementingReturnsReceiverWhenNoOtherSuperclassImplementsSelector

	| higestClass |
	
	higestClass := OrderedCollectio highestClassImplementing: #addFirst: ifNone: [ self fail ].
	
	self assert: higestClass equals: OrderedCollectio.! !
!CompiledMethodTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722697!
test18propertyKeysAndValuesDoIteratesOverProperties

	| propertyName thisMethod properties |
	
	propertyName := #testProperty.
	thisMethod := self class>>thisContext selector.
	thisMethod propertyValueAt: propertyName put: true.
	
	properties := OrderedCollectio new.
	thisMethod propertyKeysAndValuesDo: [ :key :value | properties add: key -> value ].
	
	self assert: properties size equals: 1.
	self assert: properties first equals: propertyName -> true! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722715!
destroyCurrentCodeOfSelections
	"Actually remove from the system any in-memory methods with class and selector identical to items current selected.  This may seem rather arcane but believe me it has its great uses, when trying to split out code.  To use effectively, first file out a change set that you wish to split off.  Then open a ChangeList browser on that fileout.  Now look through the methods, and select any of them which you want to remove completely from the system, then issue this command.  For those methods where you have made changes to pre-existing versions, of course, you won't want to remove them from the system, so use this mechanism with care!!"

	|  aClass aChange aList |
	aList _ OrderedCollectio new.
	1 to: changeList size do:
		[:index |
			(listSelections at: index) ifTrue:
				[aChange _ changeList at: index.
				(aChange changeType == #method
					and: [(aClass _ aChange changeClass) notNil
					and: [aClass includesSelector: aChange methodSelector]])
						ifTrue:
							[aList add: {aClass. aChange methodSelector}]]].

	aList notEmpty ifTrue: [
		(self confirm: 'Warning!! This will actually remove ', aList size printString,  ' method(s) from the system!!') ifFalse: [^ self]].
	aList do: [ :aPair |
		Transcript newLine; show: 'Removed: ', aPair first printString, '.', aPair second.
		aPair first removeSelector: aPair second ]! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722762!
testHash

	self assert: (CompoundMeasure with: self tenPesos with: self twentyDollars) hash = (CompoundMeasure with: self tenPesos with: self twentyDollars) hash.
	self assert: (CompoundMeasure with: self tenPesos with: self twentyDollars) hash = (CompoundMeasure with: self twentyDollars with: self tenPesos ) hash.
	self assert: (CompoundMeasure measures: (OrderedCollectio with: self tenPesos with: self twentyDollars with: self tenEuros)) hash=
		(CompoundMeasure measures: (OrderedCollectio with: self tenEuros with: self twentyDollars with: self tenPesos)) hash.
	
	self deny: (CompoundMeasure with: self tenPesos with: self twentyDollars) hash = (CompoundMeasure with: (self tenPesos+self onePeso) with: self twentyDollars) hash! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722789!
testStartingEdges

	| graph edges |
	
	edges := OrderedCollectio new
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		add: (Edge from: 3 to: 4);
		add: (Edge from: 1 to: 4);
		add: (Edge from: 4 to: 4);
		yourself.
	
	graph := Graph edges: edges.	
	
	self assert: (graph edgesStartingOn: 1) size = 2.
	self assert: ((graph edgesStartingOn: 1) removeAll: (OrderedCollectio 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 1 to: 4)); yourself ) isEmpty.
		
	self assert: (graph edgesStartingOn: 2) size = 1.
	self assert: ((graph edgesStartingOn: 2) copyWithout: (Edge from: 2 to: 3)) isEmpty.
	
	self assert: (graph edgesStartingOn: 3) size = 1.
	self assert: ((graph edgesStartingOn: 3) copyWithout: (Edge from: 3 to: 4)) isEmpty.

	self assert: (graph edgesStartingOn: 4) size = 1.
	self assert: ((graph edgesStartingOn: 4) copyWithout: (Edge from: 4 to: 4)) isEmpty.
	
	self assert: (graph edgesStartingOn: 5) isEmpty! !
!ChangeKeywordsSelectorOrderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722823!
test05ChangesParametersOrder

	| classToRefactor refactoring oldSelector newSelector renamedMethod parameters selectorAndParameters |

	oldSelector := #m1:m2:.
	newSelector := #m2:m1:.
	classToRefactor := self createClassNamed: #ClassToChangeSelectorOrder.
	selectorAndParameters := self selectorAndParametersFor: oldSelector.
	classToRefactor compile: selectorAndParameters.

	refactoring := ChangeKeywordsSelectorOrder from: oldSelector to: newSelector implementors: { classToRefactor >> oldSelector } senders: #().
	refactoring apply.

	renamedMethod := classToRefactor >> newSelector.
	parameters := selectorAndParameters substrings reject: [ :aKeywordOrParameter | oldSelector keywords includes: aKeywordOrParameter  ].
	self
		assert: (OrderedCollectio with: parameters second with: parameters first)
		equals: renamedMethod methodNode argumentNames ! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722854!
valuesSelect: aCondition

	| selected |

	selected := OrderedCollectio new.
	self valuesDo: [ :aValue | (aCondition value: aValue) ifTrue: [ selected add: aValue ]].

	^selected! !
!GraphPathFinderTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722864!
testPathToNeighborPlace

	| path |

	path := finder pathFrom: 1 to: 2.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 1 to: 2))).

	path := finder pathFrom: 1 to: 5.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 1 to: 5))).

	path := finder pathFrom: 2 to: 3.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 2 to: 3))).
	
	path := finder pathFrom: 3 to: 4.
	self assert: path = (Graph edges: (OrderedCollectio 
		with: (Edge from: 3 to: 4)))! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722884!
testIncludesNode

	| graph edges |
	
	edges := OrderedCollectio new
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		yourself.
	
	graph := Graph edges: edges.
	
	self assert: (graph includesNode: 1).
	self assert: (graph includesNode: 2).
	self assert: (graph includesNode: 3).
	self deny: (graph includesNode: 4)! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722898!
cascade
	" {; message} => CascadeNode."

	| receiverNode messageNodes |
	parseNode canCascade ifFalse:
		[^self expected: 'Cascading not'].
	parseNode ensureCanCascade: encoder.
	receiverNode := parseNode cascadeReceiver.
	messageNodes := OrderedCollectio with: parseNode.
	[self match: #semicolon]
		whileTrue: 
			[parseNode := receiverNode.
			(self messagePart: 3 repeat: false)
				ifFalse: [^self expected: 'Cascade'].
			parseNode canCascade ifFalse:
				[^self expected: '<- No special messages'].
			parseNode ensureCanCascade: encoder.
				parseNode cascadeReceiver.
			messageNodes addLast: parseNode].
	self createCascadeNodeWith: receiverNode and: messageNodes! !
!MessageKeywordsAndParametersTable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722923!
columnWidthsRequiredForRowTitles: rowsTitles forInputColumns: numberOfInputColumns

	| widths maxRowTitleWidth widthForInputs |

	widths := OrderedCollectio new.

	maxRowTitleWidth := (rowsTitles collect: [:aRowTitle | FontFamily defaultFamilyAndPointSize widthOfString: aRowTitle]) max + 20.
	widths add: maxRowTitleWidth.

	widthForInputs := ExtractToMethodObjectForm fontProportionalUnitOfReferenceForWidth * 20.
	numberOfInputColumns timesRepeat: [widths add: widthForInputs].

	rowsTitles size > 1 ifTrue: [widths add: (FontFamily defaultFamilyAndPointSize widthOfString: 'Change order')].

	^widths

	! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722946!
allPrimitiveMethodsInCategories: aList
	"Answer an OrderedCollection of all the methods that are implemented by primitives in the given categories.  1/26/96 sw"

	| aColl method | 
	aColl _ OrderedCollectio new: 200.
	self allBehaviorsDo: [ :aClass |
		(aList includes: (SystemOrganization categoryOfElement: aClass theNonMetaClass name asPlainString) asPlainString)
			ifTrue: [
				aClass selectorsDo: [ :sel | 
					method _ aClass compiledMethodAt: sel.
					method primitive ~= 0
						ifTrue: [
							aColl addLast: aClass name , ' ' , sel 
								, ' ' , method primitive printString]]]].
	^ aColl

"Smalltalk allPrimitiveMethodsInCategories: #('Collections-Streams' 'Files-Streams' 'Files-Abstract' 'Files-Macintosh')"! !
!DamageRecorder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722973 overrides: 16920235!
initialize
	damageByRoot _ IdentityDictionary new.
	otherDamage _ OrderedCollectio new.! !
!SystemCategoryWrapper methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722980 overrides: 16881049!
contents
	| prefix subcategories |
	(item includes: $-) ifTrue: [^ #()].
	prefix _ item, '-'.
	subcategories _ OrderedCollectio new.
	model systemCategoryList do: [:each|
		(each beginsWith: prefix)
			ifTrue: [subcategories add: (each allButFirst: prefix size)]].
	^ subcategories collect: [:each| self class with: prefix, each name: each model: model]! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50722995!
buildTextPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollectio with: (Color fromHexString: '#9E3F3F') with: 'Sunset'.
	ocean := OrderedCollectio with: (Color fromHexString: '#01161E') with: 'Ocean'.
	forest := OrderedCollectio with: (Color fromHexString: '#28112B') with: 'Forest'.
	ash := OrderedCollectio with: (Color fromHexString: '#2B2D42') with: 'Ash'.
	light := OrderedCollectio with: (Color fromHexString: '#3C3C3B') with: 'Light'.
	
	textPalette := OrderedCollectio with: sunset with: ocean with: forest with: ash with: light.! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:48' prior: 50723017 overrides: 50524008!
composeWithSimpleMeasure: aMeasure

	^self isNothing
		ifTrue: [aMeasure]
		ifFalse: 
			[CompoundMeasure measures: (OrderedCollectio with: self with: aMeasure)]! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723026!
verifyStructure
	"Compare the incoming inst var name lists with the existing classes.  Prepare tables that will help to restructure those who need it (renamed, reshaped, steady).    If all superclasses are recorded in the file, only compare inst vars of this class, not of superclasses.  They will get their turn.  "


	| newClass newList oldList converting |

	self flag: #bobconv.	

	converting _ OrderedCollectio new.
	structures keysDo: [:nm "an old className (symbol)" |
		"For missing classes, there needs to be a method in SmartRefStream like 
			#rectangleoc2 that returns the new class."
		newClass _ self mapClass: nm.	   "does (renamed at: nm put: newClass name)"
		newClass class == String ifTrue: [^ newClass].  "error, fileIn needed"
		newList _ (Array with: newClass classVersion), (newClass allInstVarNames).
		oldList _ structures at: nm.
		newList = oldList 
			ifTrue: [steady add: newClass]  "read it in as written"
			ifFalse: [converting add: newClass name]
	].
	false & converting isEmpty not ifTrue: ["debug" 
			self inform: 'These classes are being converted from existing methods:\' withNewLines,
				converting asArray printString].
! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723066!
renameTemporariesIfNeeded: temporariesToDeclare accordingToNode: aMethodOrBlockNode of: aSenderMethod

	"If a temporary to declare already exists in the scope, a new fresh name
	will be found for it. The method returns an OrderedCollection of (variableNode -> newVariableName)
	replacements. If the variable does not need a rename, it will still be added to the collection.
	This method also adds the new name to the map that tracks temporaries
	names in scope for the requested method or block node across the whole refactoring - Fernando"

	| alreadyDeclaredTemporaries newTemporaries |

	newTemporaries := OrderedCollectio new: temporariesToDeclare size.
	alreadyDeclaredTemporaries := self declaredTemporariesFor: aMethodOrBlockNode ofSender: aSenderMethod.
	temporariesToDeclare do: [:temporary |
		| finalTemporaryName index |
		finalTemporaryName := temporary name.
		index := 1.
		[alreadyDeclaredTemporaries includes: finalTemporaryName] whileTrue: [
			finalTemporaryName := temporary name, index asString.
			index := index + 1.
		].
		alreadyDeclaredTemporaries add: finalTemporaryName.
		newTemporaries add: (temporary -> finalTemporaryName).
	].

	^newTemporaries.! !
!WordArray class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723107!
bobsTest
	| wa s1 s2 wa2 answer rawData |
"
WordArray bobsTest
"
	answer _ OrderedCollectio new.
	wa _ WordArray with: 16r01020304 with: 16r05060708.
	{false. true} do: [ :pad |
		0 to: 3 do: [ :skip |
			s1 _ ReadWriteStream on: #[].

			s1 next: skip put: 0.		"start at varying positions"
			wa writeOn: s1.
			pad ifTrue: [s1 next: 4-skip put: 0].	"force length to be multiple of 4"

			rawData _ s1 contents.
			s2 _ ReadWriteStream with: rawData.
			s2 reset.
			s2 skip: skip.			"get to beginning of object"
			wa2 _ WordArray newFromStream: s2.
			answer add: {
				rawData size. 
				skip. 
				wa2 = wa. 
				wa2 asArray collect: [ :each | each printStringBase: 16]
			}
		].
	].
	^answer explore! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723133!
temporariesToDeclareByInsertionPoint: aSenderAndPosition

	^temporariesToDeclareByInsertionPoint keys
		detect: [:senderAndPosition | senderAndPosition = aSenderAndPosition]
		ifFound: [ :key | temporariesToDeclareByInsertionPoint at: key ]
		ifNone: [| temporariesToDeclareAtInsertionPoint |
			temporariesToDeclareAtInsertionPoint := OrderedCollectio new.
			temporariesToDeclareByInsertionPoint at: aSenderAndPosition put: temporariesToDeclareAtInsertionPoint.
			temporariesToDeclareAtInsertionPoint].
	! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723153!
simpleEnsureTestWithNotificationResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: self doSomethingElseString;
		add: self doYetAnotherThingString;
		yourself! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723163!
testInlineBlockCollectionLR3
	| col |
	col := OrderedCollectio new.
	1 to: 11 do: [ :each | | i | i := each. col add: [ i ]. i := i + 1 ].
	self assert: (col collect: [ :each | each value ]) asArray = (2 to: 12) asArray! !
!TestResult methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723174!
tests

	^(OrderedCollectio new: self runCount)
		addAll: self passed;
		addAll: self errors;
		addAll: self failures;
		yourself
			! !
!NewInstanceVariablePrecondition methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723183!
methodsDefiningNewVariable
	
	| methodsDefiningNewVariableInHierarchy |
	
	methodsDefiningNewVariableInHierarchy := OrderedCollectio new.
	
	classToAddInstVar withAllSubclassesDo: [ :class | 
		methodsDefiningNewVariableInHierarchy addAll: (class methodsWithArgumentOrTemporaryNamed: instVarName) ].

	^methodsDefiningNewVariableInHierarchy 
		
	! !
!TestCaseTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723198!
testAssertChangesByPassesWhenActionChangesConditionByTheSpecifiedAmount

	|aCollection|

	aCollection := OrderedCollectio new.
	
	self assert: [ aCollection add: 1; add: 2 ] changes: [ aCollection size ] by: 2! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723208!
browseObsoleteReferences   "Smalltalk browseObsoleteReferences"
	| references |
	references _ OrderedCollectio new.
	(LookupKey allSubInstances select:
		[:x | ((x value isKindOf: Behavior) and: ['AnOb*' match: x value name]) or:
		['AnOb*' match: x value class name]]) 
		do: [:x | references addAll: (Smalltalk allCallsOn: x)].
	Smalltalk 
		browseMessageList: references 
		name: 'References to Obsolete Classes'! !
!PushUpInstanceVariable class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723225!
assertNoOtherMethodIn: aSuperclass definesTemporaryNamed: anInstanceVariableName

 	| methodsDefiningTemporaryInSuperclass |

	methodsDefiningTemporaryInSuperclass := OrderedCollectio new.
	methodsDefiningTemporaryInSuperclass addAll: (
		aSuperclass methodsWithArgumentOrTemporaryNamed: anInstanceVariableName).

	methodsDefiningTemporaryInSuperclass ifNotEmpty: [
		self 
			canNotRefactorDueToReferencesError: (
				self errorMessageForInstanceVariable: anInstanceVariableName isDefinedInMethodsOf: aSuperclass)
			references: (
				methodsDefiningTemporaryInSuperclass collect: [ :aMethod | MethodReference method: aMethod ])
			to: anInstanceVariableName ]! !
!SetOfFinancialEntities methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723250!
rootPortfolio
	fatherPortfolio isEmpty ifTrue: [^OrderedCollectio with: self].
	^fatherPortfolio inject: OrderedCollectio new into: [:aCollection :aFather | aCollection , aFather rootPortfolio]. 
	! !
!CollectTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723260!
testOrderedCollection
	"
	CollectTest  new testOrderedCollection
	"
	| col result |
	col _ #(1 2 3 4 5) asOrderedCollection.
	result _ col collect: [ :elem |  elem * 2 ].
	self assert: result class = OrderedCollectio.
	self assert: result = #(2 4 6 8 10) asOrderedCollection! !
!ClassBuilder class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723273!
reallyObsoleteClasses
	| obsoleteClasses |
	obsoleteClasses _ OrderedCollectio new.
	Metaclass allInstances do: [:meta | meta allInstances do: [:each | 
		(self isReallyObsolete: each) ifTrue: [obsoleteClasses add: each]]].
	^ obsoleteClasses! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723284!
simpleResumeTestResults

	"see if we can resume twice"

	^OrderedCollectio new
			add: self doSomethingString;
			add: self doYetAnotherThingString;
			add: self doSomethingElseString;
			add: self doYetAnotherThingString;
			add: self doSomethingElseString;
			yourself! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723296!
removeEmptyClassComments

	| newChangeList newList |
	newChangeList _ OrderedCollectio new.
	newList _ OrderedCollectio new.
	changeList with: list do: [ :chRec :strNstamp | | keep |
		keep _ true.
		(chRec changeType == #classComment and: [
				Smalltalk includesKey: chRec changeClassName]) ifTrue: [
			keep _ chRec text notEmpty
		].
		keep ifTrue:[
			newChangeList add: chRec.
			newList add: strNstamp]].
	newChangeList size < changeList size ifTrue: [
		changeList _ newChangeList.
		list _ newList.
		listIndex _ 0.
		self clearSelections ].
	self changed: #list! !
!ExtractMethodApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723318!
extractKewordsAndArgumentsNamesFrom: userAnswer

	newSelectorKeywords := OrderedCollectio new.
	userArgumentNames := OrderedCollectio new.
	(self keywordsAndArgumentsOf: userAnswer) pairsDo: [ :keyword :argument | 
		newSelectorKeywords add: keyword, ':'.
		userArgumentNames add: argument ]! !
!MessageKeywordsAndParametersTable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723332!
buildColumnTitlesRowFor: inputColumnsTitles

	| columnsTitles row |

	row := LayoutMorph newRow.
	row color: self backgroundColor.
	row separation: self columnSeparation.

	columnsTitles := OrderedCollectio newFrom: inputColumnsTitles.
	columnsTitles addFirst: ''.
	self needsToReorderRows ifTrue: [columnsTitles addLast: 'Change order'].
	columnsTitles withIndexDo: [:aColumnTitle :columnIndex | | columnTitleLayoutSpec titleLayout |
		titleLayout := LayoutMorph newRow.
		titleLayout color: self backgroundColor .
		titleLayout axisEdgeWeight: #center.
		titleLayout addMorph: (LabelMorph contents: aColumnTitle).
		columnTitleLayoutSpec := LayoutSpec fixedWidth: (columnWidths at: columnIndex).
		row
			addMorph: titleLayout
			layoutSpec: columnTitleLayoutSpec].

	^row

	! !
!CodeWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723405!
optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollectio new.
	widths _ OrderedCollectio new.
	buttonColor _ self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph
			model: self
			stateGetter: nil
			action: tuple third.
		button color: buttonColor.
		button label: tuple second.
		tuple size > 3 ifTrue: [ button setBalloonText: tuple fourth ].
		tuple size > 4 ifTrue: [ button secondaryActionSelector: tuple fifth ].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row
		addMorphs: buttons
		widthProportionalTo: widths.
	^ row.! !
!FeatureRequirement methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723368!
require
	"See if all the transitive closure of requirements can be met and answer the load order if so"

	| packagesToLoad |
	
	"Preflight before load 
	  [1] Build transitive closure as load order where Feature comes 
	       before its required features."
	[packagesToLoad := self
			requireUnlessIn: OrderedCollectio new
			main: nil
			requiringFeature: nil
			allRequiringFeatures: #()]
		on: FeatureRequirementUnsatisfied  
		do: [ :error | error defaultAction. 
			^self "exit"
		].
	
	"Transcript show: 'packagesToLoad: '; newLine.
	packagesToLoad do: [ :x |Transcript show: x; newLine ].
	Transcript newLine."
	
	"[2] Check to see that each requirement is actually satisfied"
	[packagesToLoad do: [ :fReq | fReq checkRequirement ]]
		on: FeatureRequirementUnsatisfied  
		do: [ :error | error defaultAction. 
			^self "exit"
		].

	"[3] Load required packages before packages that require them"
	packagesToLoad reverseDo: [ :requirement |
		requirement isAlreadySatisfied ifFalse: [
			requirement install ]].
	self isAlreadySatisfied ifFalse: [
		self install ]! !
!CompositeCatalog methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723432 overrides: 50544668!
processNonEmptySearchQuery: aQuery
	
	^ catalogs
		inject: OrderedCollectio new
		into: [ :results :catalog |
			results
				addAll: (self search: aQuery using: catalog);
				yourself ]! !
!Symbol class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723442!
selectorsMatching: aStringPattern
	"Answer a list of selectors that match aStringPattern within them. Case-insensitive.
	 Does return symbols that begin with a capital letter."

	| selectorList |

	selectorList := OrderedCollectio new.

	aStringPattern isEmpty ifTrue: [^selectorList].

	self allSymbolTablesDo:
		[:each | (aStringPattern match: each) ifTrue: [selectorList add: each]].

	^selectorList reject: "reject non-selectors, but keep ones that begin with an uppercase"
		[:each | each numArgs < 0 and: [each asPlainString uncapitalized numArgs < 0]]

	"Symbol selectorsMatching: 'parse:*'"! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723465!
testFormatter
	"Smalltalk testFormatter"
	"Reformats the source for every method in the system, and then compiles that source and verifies that it generates identical code.
	The formatting used will be classic monochrome."
	| newCodeString methodNode oldMethod newMethod badOnes n |
	badOnes _ OrderedCollectio new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					newCodeString _ cls compilerClass new
						format: (cls sourceCodeAt: selector)
						in: cls
						notifying: nil.
					methodNode _ cls compilerClass new
						compile: newCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod _ methodNode generate: #(0 0 0 0 ).
					oldMethod _ cls compiledMethodAt: selector.
					oldMethod = newMethod ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	Smalltalk
		browseMessageList: badOnes
		name: 'Formatter Discrepancies'.! !
!RenameInstanceVariable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723507!
lookForMethodsReferencingOldVariable
	
	methodsAndRangesToChange := OrderedCollectio new.
	classToRefactor withAllSubclassesDo: [ :aClass |  self lookForMethodsReferencingOldVariableIn: aClass ].
! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723517!
chooseClassVarName 
	"Present the user with a list of class variable names and answer the one selected, or nil if none"

	| lines labelStream  allVars index |
	lines _ OrderedCollectio new.
	allVars _ OrderedCollectio new.
	labelStream _ String writeStream.
	self withAllSuperclasses reverseDo: [ :class | | vars |
		vars _ class classVarNames asArray sort.
		vars do: [ :var |
			labelStream position = 0 ifFalse: [labelStream newLine].
			labelStream nextPutAll: var.
			allVars add: var].
		vars isEmpty ifFalse: [lines add: allVars size]].
	labelStream contents isEmpty ifTrue: [^Smalltalk beep]. "handle nil superclass better"
	index _ (PopUpMenu labels: labelStream contents lines: lines) startUpMenu.
	index = 0 ifTrue: [^ nil].
	^ allVars at: index! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723544!
positionsOf: symbolString containedIn: literalArrayPositions

	| symbolPositions |

	symbolPositions := OrderedCollectio new.

	literalArrayPositions do: [ :literalArrayPosition | self addPositionTo: symbolPositions of: symbolString inside: literalArrayPosition ].

	^symbolPositions




! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723557!
simplePassTestResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		add: 'Unhandled Exception';
		yourself! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723566 overrides: 50492164!
initialize
	super initialize.
	exclude _ OrderedCollectio new! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723572!
simpleResignalAsTestResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: 'Unhandled Exception';
		yourself! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723580!
testCreationWithMeasuresCopiesCollection
	"This test verifies that when bag is created using the private message  #measures:,
	the collection that goes as collaborating is copied"
	
	| measures measureBag |

	measures := OrderedCollectio
		with: self tenPesos
		with: self twentyDollars
		with: self tenEuros.
	measureBag := CompoundMeasure measures: measures.

	measures add: self oneMeter.
	self assert: measureBag numberOfMeasures = 3.
	self assert: (measureBag atSameBaseUnitAs: self peso) = self tenPesos.
	self assert: (measureBag atSameBaseUnitAs: self dollar) = self twentyDollars.
	self assert: (measureBag atSameBaseUnitAs: self euro) = self tenEuros


! !
!SenderInfo methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723604!
initializeOf: aSender for: aSentImplementors
	
	sender := aSender.
	sentImplementors := aSentImplementors.
	sureSenders := Set new.
	possibleSenders := OrderedCollectio new.
! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723614!
collaboratorNames

	| names |
	
	names := OrderedCollectio new.
	self withParentsDo: [ :aDenotativeObject | names addAllFirst: aDenotativeObject class instVarNames ].
	
	^names! !
!MultipliedUnit class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723624!
simpleUnit: aUnit simpleUnit: anotherUnit

	^self new initializeFactors: (OrderedCollectio with: aUnit with: anotherUnit)! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723632!
correctAgainstEnumerator: wordBlock continuedFrom: oldCollection
	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."

	| choices scoreMin results score maxChoices |
	scoreMin _ self size // 2 min: 3.
	maxChoices _ 10.
	choices _ oldCollection
		ifNil: [ SortedCollection sortBlock: [ :x :y | x value > y value ] ].
	wordBlock
		ifNil: [
			results _ OrderedCollectio new.
			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]
		ifNotNil: [
			wordBlock value: [ :word |
				(score _ self alike: word) >= scoreMin ifTrue: [
					choices add: (Association key: word value: score).
						(choices size >= maxChoices) ifTrue: [ scoreMin _ (choices at: maxChoices) value] ] ].
			results _ choices ].
	^ results! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723662!
initCachedState
	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  
	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)
	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"
	"
	DataStream initCachedState
	"

	| refTypes t |
	refTypes _ OrderedCollectio new.
	t _ TypeMap _ Dictionary new: 80. "sparse for fast hashing"

	t at: UndefinedObject put: 1.   refTypes add: 0.
	t at: True put: 2.   refTypes add: 0.
	t at: False put: 3.   refTypes add: 0.
	t at: SmallInteger put: 4.	 refTypes add: 0.
	t at: String put: 5.   refTypes add: 1.
	t at: Symbol put: 6.   refTypes add: 1.
	t at: ByteArray put: 7.   refTypes add: 1.
	t at: Array put: 8.   refTypes add: 1.
	"(type ID 9 is for arbitrary instances of any class, cf. typeIDFor:)"
		refTypes add: 1.
	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"
		refTypes add: 0.
	t at: Bitmap put: 11.   refTypes add: 1.

	t at: Metaclass put: 12.   refTypes add: 0.
	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."
		refTypes add: 1.

	t at: Float put: 14.  refTypes add: 1.
	t at: BoxedFloat64 put: 14.
	t at: SmallFloat64 put: 14.

	"15: Deprecated compact Rects."
		refTypes add: 1.

	"type ID 16 is an instance with short header.  See beginInstance:size:"
		refTypes add: 1.

	t at: String put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"
	t at: WordArray put: 18.  refTypes add: 1.	"bitmap-like"
	"t at: WordArrayForSegment put: 19."  refTypes add: 1.		"bitmap-like"
	t at: Float32Array put: 20.  refTypes add: 1.	"And all other word arrays, both 16-bit and 32-bit.  See methods in ArrayedCollection.  Overridden in SoundBuffer."
	"For all classes that are like WordArrays, store them the way ColorArray is stored.  As bits, and able to change endianness."
	Smalltalk do: [:cls |
		cls isInMemory ifTrue: [
			cls isBehavior ifTrue: [
				cls isPointers not & cls isVariable & cls isWords ifTrue: [
					(t includesKey: cls) ifFalse: [t at: cls put: 20]]]]].

	t at: CompiledMethod put: 21.  refTypes add: 1.	"special creation method"

	t at: Character put: 22. refTypes add: 0.

	t at: UnicodeString put: 23.   refTypes add: 1.
	t at: UnicodeSymbol put: 24.   refTypes add: 1.

	"t at:  put: 25.  refTypes add: 0."
	ReferenceTypes _ refTypes.		"save it"! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723751!
createMessageList

	messageList := OrderedCollectio new.
	numberOfTitles := 0.
	
	self 
		addCompleteSureSendersToMessageList;
		addPartialSureSendersToMessageList;
		addPossibleSendersToMessageList
		
! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723761!
removeNonSelections
	"Remove the unselected items from the receiver."

	| newChangeList newList |

	newChangeList _ OrderedCollectio new.
	newList _ OrderedCollectio new.

	1 to: changeList size do: [ :i | 
		(listSelections at: i) ifTrue: [
			newChangeList add: (changeList at: i).
			newList add: (list at: i)]].
	newChangeList isEmpty ifTrue: [
		^ self inform: 'That would remove everything.
Why would you want to do that?'].

	newChangeList size < changeList size
		ifTrue: [
			changeList _ newChangeList.
			list _ newList.
			listIndex _ 0.
			self clearSelections ].
	self changed: #list

	! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723784!
resources
	| allResources resourceQueue |
	allResources := Set new.
	resourceQueue := OrderedCollectio new.
	resourceQueue addAll: self class resources.
	[resourceQueue isEmpty] whileFalse: [
		| next |
		next := resourceQueue removeFirst.
		allResources add: next.
		resourceQueue addAll: next resources].
	^allResources
			! !
!Class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723798 overrides: 50725750!
sharedPools
	"Answer a Set of the pool dictionaries declared in the receiver."

	^sharedPools
		ifNil: [OrderedCollectio new]! !
!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723806!
newMorph
	"The user requested 'new morph' from the world menu.  Put up a menu that allows many ways of obtaining new morphs.  If the preference #classicNewMorphMenu is true, the full form of yore is used; otherwise, a much shortened form is used."
	| menu catDict |
	menu _ self menu: 'Add a new morph'.
	menu
		
			add: 'From Clipboard'
			target: myHand
			action: #pasteMorph;
		
			add: 'From Alphabetical List'
			subMenu: self alphabeticalMorphMenu.
	menu addLine.
	"Add 'Classic' New Morph menu"
	catDict _ Dictionary new.
	Morph allSubclassesDo: [ :eaSubclass |
		eaSubclass includeInNewMorphMenu ifTrue: [ | category |
			(eaSubclass respondsTo: #categoryInNewMorphMenu)
				ifTrue: [ category _ eaSubclass categoryInNewMorphMenu ]
				ifFalse: [ category _ 'Unknown' ].
			(catDict includesKey: category)
				ifTrue: [ (catDict at: category) add: eaSubclass ]
				ifFalse: [
					catDict
						at: category
						put: (OrderedCollectio with: eaSubclass) ]]].
	catDict keys sort do: [ :categ | | morphsInCat |
		morphsInCat _ (catDict at: categ) asArray sort: [ :c1 :c2 |
			c1 name < c2 name ].
		morphsInCat size > self pvtMaxItemsPerCategorySubMenu
			ifTrue: [
				menu
					add: categ
					subMenu:
						(self pvtNewMenuForSplitLists:
							(self
								splitNewMorphList: morphsInCat
								depth: self pvtCategorySplitListDepth )) ]
			ifFalse: [ | subMenu |
				subMenu _ MenuMorph new.
				morphsInCat do: [ :cl |
					subMenu
						add: cl name
						target: self
						action: #newMorphOfClass:event:
						argument: cl ].
				menu
					add: categ
					subMenu: subMenu ]].
	self doPopUp: menu.! !
!DecompilerTestFailuresCollector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723862 overrides: 16961453!
assert: aBoolean description: aString resumable: resumableBoolean 
	
	aBoolean ifFalse: [
		failures ifNil: [ failures := OrderedCollectio new].
		 failures addLast: (thisContext sender tempAt: 1) methodReference].
	
	^super assert: aBoolean description: aString resumable: resumableBoolean 
! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723875!
computeMessageEntriesForUnknowClassAddingPossibleInvalidSelectorsTo: aCollection

	| selectorsToShow |
	selectorsToShow _ OrderedCollectio new.
	
	self class protected: [
		Selectors forPrefix: prefix keysAndValuesDo: [ :selector :lastUsedTime |
				selectorsToShow := self add: selector and: lastUsedTime to: selectorsToShow.
				(Object canUnderstand: selector) ifFalse: [ aCollection add: selector ]]].
				
	selectorsToShow size < EntriesLimit ifTrue: [ selectorsToShow _  self sortByLastUsedTime: selectorsToShow ].
	
	" To see the timestamps in the menu (need to tweak #insertCompletion: to activate. Right now, just for debugging)
	entries _ selectorsToShow collect: [ :ary | ary first, '(', ((DateAndTime fromString: '01/01/1996 00:00') + ary second minutes) printString,')' ]
	"
	^ selectorsToShow collect: [ :selectorAndTime | selectorAndTime first ]
	
! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723906!
simpleEnsureTestWithErrorResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: 'Unhandled Exception';
		add: self doYetAnotherThingString;
		yourself! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723915!
testInlineBlockCollectionEM1
	| a1 b1 i1 a2 b2 i2 we wb |
	b1 := OrderedCollectio new.
	i1 := 1.
	[a1 := i1.
	 i1 <= 3] whileTrue:
		[b1 add: [a1].
		i1 := i1 + 1].
	b1 := b1 asArray collect: [:b | b value].
	b2 := OrderedCollectio new.
	i2 := 1.
	we := [a2 := i2. i2 <= 3].
	wb := [b2 add: [a2]. i2 := i2 + 1].
	we whileTrue: wb. "defeat optimization"
	b2 := b2 asArray collect: [:b | b value].
	self assert: b1 = b2! !
!ActualImplementorsTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723932!
test08highestClassImplementingSelectorReturnsHighgestClass

	self assert: (OrderedCollectio highestClassImplementing: #at:put: ifNone: [ self fail ]) equals: Object! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723941!
newBuilderIfIsTypeCheck: condition in: aMessageNode
	
	| incompleteTypeInfoReasons types implementors typesToCastTo typesToReject |

	condition isUnaryMessageSend ifFalse: [ ^NoTypeCastApplierBuilder new ].

	incompleteTypeInfoReasons := OrderedCollectio new.
	types := blockCastingApplier receiverTypesFor: condition in: actualMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons notEmpty ifTrue: [ ^NoTypeCastApplierBuilder new ].
	
	"I have to converted to array because nil can not be added to sets - Hernan"
	implementors := types asArray collect: [ :aType | aType lookupSelector: condition selectorSymbol ].
	(implementors includes: nil) ifTrue: [ ^NoTypeCastApplierBuilder new ].
	implementors := implementors asIdentitySet.
	
	typesToCastTo := (implementors reject: [ :anImplementor | anImplementor isReturnSpecialFalse ]) collect: [ :anImplementor | anImplementor methodClass ].
	typesToReject := (implementors reject: [ :anImplementor | anImplementor isReturnSpecialTrue ]) collect: [ :anImplementor | anImplementor methodClass ].
		
	^IsKindOfManyTypeCastApplierBuilder 
		to: typesToCastTo 
		rejecting: typesToReject 
		on: condition receiver 
		during: aMessageNode arguments first
		rejectingDuring: (aMessageNode arguments at: 2 ifAbsent: [ BlockNode empty ]).
	! !
!DifferenceFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723986!
unfold
	| points |
	points := OrderedCollectio with: x size @ y size.
	^self unfold: points
! !
!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50723993!
toggleExpandedState
	| newChildren toDelete c |
	isExpanded _ isExpanded not.
	toDelete _ OrderedCollectio new.
	firstChild ifNotNil: [
		firstChild withSiblingsDo: [ :aNode |
			aNode recursiveAddTo: toDelete ]].
	container noteRemovalOfAll: toDelete.
	(isExpanded and: [ complexContents hasContents ]) ifFalse: [
		firstChild _ nil.
"	 	nextSibling _ firstChild _ nil."
		^ self redrawNeeded ].
	(c _ complexContents contents) isEmpty ifTrue: [ ^ self redrawNeeded ].
	newChildren _ container
		addSubmorphsAfter: self
		fromCollection: c
		allowSorting: true.
	firstChild _ newChildren first! !
!SpaceTally methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50724015!
preAllocateResultsFor: classes

	results := OrderedCollectio new: classes size.
	classes do: [:cl | results add: (SpaceTallyItem analyzedClassName: cl name)].
	results _ results asArray.
! !
!DamageRecorder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50724025!
pvtInnerRecordInvalidRect: requestedRect for: aRootMorph
	"Record the given rectangle in my damage list, a list of rectangular areas of the display that should be redraw on the next display cycle."

	aRootMorph ifNotNil: [
		(damageByRoot at: aRootMorph
			ifPresent: [ :c | |r|
				r := requestedRect copy. "asIntegerRectangle? encompassing?"
				1 to: c size do: [ :i | |old|
					old := c at: i.
					(r intersects: old) ifTrue: [
						r updateMerging: old.
						c at: i put: nil ]].
				c removeAllSuchThat: [:e | e isNil ].
				c add: r ]
			ifAbsent: [ damageByRoot at: aRootMorph put: (OrderedCollectio with: requestedRect copy) ]) ]
		ifNil: [otherDamage add: requestedRect copy].! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50724050!
methodsWithInitialsOtherThan: myInits
	"Return a collection of method refs whose author appears to be different from the given one"
	| slips |
	slips _ OrderedCollectio new.
	self changedClasses do: [ :aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | method |
				(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse: [
					method _ aClass compiledMethodAt: mAssoc key ifAbsent: nil.
					method ifNotNil: [ | aTimeStamp |
						((aTimeStamp _ method timeStamp) notNil and: [
							(aTimeStamp beginsWith: myInits) not])
								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].
	^ slips

	"
	Smalltalk browseMessageList: (ChangeSet changeSetForBaseSystem methodsWithInitialsOtherThan: 'sw') name: 'authoring problems'
	"! !
!TestResult methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50724078!
passed

	passed
		ifNil: [passed := OrderedCollectio new].

	^passed
			! !
!DefinedByRulesTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50724084!
testRulesThatInclude

	| set rule1 rule2 |
	
	set := DefinedByRules for: NaturalNumbersTestUniverse new.
	set 
		addRule: (rule1 := SpecificObjectInclusionRule for: 1);
		addRule: (rule2 := SpecificObjectInclusionRule for: 2).
		
	self assert: (set rulesThatInclude: 1) size = 1.
	self assert: ((set rulesThatInclude: 1) includesAllOf: (OrderedCollectio with: rule1)).

	self assert: (set rulesThatInclude: 2) size = 1.
	self assert: ((set rulesThatInclude: 2) includesAllOf: (OrderedCollectio with: rule2)).

	self assert: (set rulesThatInclude: 3) isEmpty! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50724106!
browseActualWithTypeInfoAndIncompleteTypeInfo
	
	| menu labels icons selectionIndex |
	
	labels := OrderedCollectio with: self showBrowseActualAnywayLabel with: self seeAllLabel.
	icons := OrderedCollectio with: Theme current acceptIcon with: Theme current acceptIcon.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray.
	incompleteTypeInfoReasons do: [ :anIncompleteTypeInfo | 
		labels add: anIncompleteTypeInfo reasonDescription.
		icons add: Theme current closeIcon ].
	
	menu := PopUpMenu labelArray: labels lines: #(2) icons: icons.
	selectionIndex := menu startUpWithCaption: self incompleteTypeInfoQuestionTitle.
	selectionIndex = 1 ifTrue: [ ^self browseActualWithTypeInfoNoMatterIncompleteTypeInfo ].
	selectionIndex = 2 ifTrue: [ ^self browseAll ].
	selectionIndex > 2 ifTrue: [ ^(incompleteTypeInfoReasons at: selectionIndex - 2) browse ]
! !
!Theme class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50724137!
verifyShoutConfig

	"
	self verifyShoutConfig
	"
	^self allSubclasses
		inject: OrderedCollectio new into: [ :errors :themeClass |
			[ themeClass new generateShoutConfig ] on: Error do: [:anError | | atIfAbsentContext key |
				"I have to do this because error is not resumable - Hernan"
				atIfAbsentContext := thisContext.
				10 timesRepeat: [ atIfAbsentContext := atIfAbsentContext sender ].
				key := atIfAbsentContext tempAt: 1.
				errors add: themeClass -> key.
				atIfAbsentContext receiver at: key put: Color black.
				atIfAbsentContext restart ].
			errors ]! !
!DamageRecorder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50724159!
damageReportedOther
	"Answer damage reported for no specific morph, for morphs that are not visible, and for morphs that are carried by the Hand.
	Answer might include nils. Skip them."
	| answer possiblyMoreRectsToMerge |
	answer := OrderedCollectio new.
	self pvtAccessProtect critical: [
		damageByRoot keysAndValuesDo: [ :m :rects |
			rects do: [ :r |
				(m visible not or: [m owner isNil or: [m isOwnedByHand ]]) ifTrue: [
					answer add: r]]].
		otherDamage do: [ :r | answer add: r ].
	].
	possiblyMoreRectsToMerge := true.
	[possiblyMoreRectsToMerge] whileTrue: [
		possiblyMoreRectsToMerge := false.
		answer withIndexDo: [ :r1 :i |
			r1 ifNotNil: [
				i+1 to: answer size do: [ :j | | r2 |
					r2 := answer at: j.
					r2 ifNotNil: [
						(r1 intersects: r2) ifTrue: [
							r1 updateMerging: r2.
							answer at: j put: nil.
							possiblyMoreRectsToMerge := true ]]]]]].
	^answer! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50724191!
simpleOuterTestResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		add: self doSomethingElseString;
		yourself! !
!BehaviorTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50724200!
testHighestClassImplementingReturnsTheTopSuperclassImplementingSelector

	| higestClass |
	
	higestClass := OrderedCollectio highestClassImplementing: #select: ifNone: [ self fail ].
	
	self assert: higestClass equals: Collection.! !
!TimeLine methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50724211 overrides: 16920235!
initialize
	events := OrderedCollectio new.
	statesAfterChanges := Dictionary new.! !
!AllActualImplementors methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:49' prior: 50724218 overrides: 50622393!
value 

	| typeImplementors |
	
	notImplemented := OrderedCollectio new.
	implementors := Set new.
	types do: [ :aType | 
		typeImplementors := Smalltalk actualImplementorsOf: selector in: aType.
		typeImplementors isEmpty 
			ifTrue: [ notImplemented add: (NotImplementedMethod class: aType selector: selector) ]
			ifFalse: [ implementors addAll: typeImplementors ]].

	^self! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724234!
literalStrings
	| litStrs |
	litStrs := OrderedCollectio new: self numLiterals.
	self literalsDo:
		[:lit | 
		(lit isVariableBinding)
			ifTrue: [litStrs addLast: lit key]
			ifFalse: [(lit isSymbol)
				ifTrue: [litStrs addAll: lit keywords]
				ifFalse: [litStrs addLast: lit printString]]].
	^ litStrs! !
!ChangeListWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724248 overrides: 50733452!
optionalButtonRow
	"Answer a row of buttons to occur in a tool pane"

	| row buttons widths buttonColor |
	buttons _ OrderedCollectio new.
	widths _ OrderedCollectio new.
	buttonColor _ self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: model
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second.
		buttons add: button.
		button setBalloonText: tuple fourth].
	buttons add: self lineDiffButton.
	widths add: 14.
	buttons add: self wordDiffButton.
	widths add: 16.
	model wantsPrettyDiffOption ifTrue: [
		buttons add:  self prettyLineDiffButton.
		widths add: 21.
		buttons add:  self prettyWordDiffButton.
		widths add: 23 ].
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!DefinedByRulesTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724281!
testSpecies

	self assert: (DefinedByRules for: #()) species = OrderedCollectio! !
!CodeFileBrowserWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724288 overrides: 16797263!
messageCategoryMenu
	| aMenu itemColl |
	aMenu _ MenuMorph new defaultTarget: model.
	"All the options are for the model."
	aMenu addTitle: 'Message Category'.
	itemColl _ OrderedCollectio new.
	self model baseCodeSource isLiveSmalltalkImage ifTrue: [
		itemColl add:
			{#label -> 'fileIn'. #selector -> #fileInMessageCategories. #icon -> #updateIcon} asDictionary ].
	itemColl addAll:
		{
			{#label -> 'fileOut'. #selector -> #fileOutMessageCategories. #icon -> #fileOutIcon} asDictionary. 
			nil. 
			{#label -> 'reorganize'. #selector -> #editMessageCategories. #icon -> #sendReceiveIcon} asDictionary. 
			nil. 
			{#label -> 'add item...'. #selector -> #addCategory. #icon -> #newIcon} asDictionary. 
			nil. 
			{#label -> 'rename...'. #selector -> #renameCategory. #icon -> #saveAsIcon} asDictionary. 
			{#label -> 'remove'. #selector -> #removeMessageCategory. #icon -> #listRemoveIcon} asDictionary
		}.
	self model caseCodeSource isLiveSmalltalkImage ifFalse: [
		itemColl addAll:
			{
				nil. 
				{#label -> 'remove existing'. #selector -> #removeUnmodifiedMethods. #icon -> #deleteIcon} asDictionary
			} ].
	aMenu addItemsFromDictionaries: itemColl.
	^ aMenu.! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724329!
doublePassOuterTestResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		add: self doSomethingElseString;
		yourself! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724338!
browseViewReferencesFromNonViews
	"
	Smalltalk browseViewReferencesFromNonViews
	"
	| aLiteral aCollection |

	aCollection := OrderedCollectio new.

	"Tweak to look just for pluggables or also for menus (or maybe for all morphs)"
"	PopUpMenu withAllSubclasses , MenuMorph withAllSubclasses , PluggableMorph withAllSubclasses do: [ :view |"
	PluggableMorph withAllSubclassesDo: [ :view |
"	MenuMorph withAllSubclassesDo: [ :view |"
		
		aLiteral := view name.
		
		"tweak to linclude refs to SysWindow subhierarchy or not"
		(view includesBehavior: SystemWindow) & false ifFalse: [
			Smalltalk allBehaviorsDo: [ :class |
				((class includesBehavior: Morph) or: [ class includesBehavior: Morph class ]) ifFalse: [
					class addMethodsTo: aCollection thatReferenceTo: aLiteral special: false byte: nil ]]]].
	
	Smalltalk
		browseMessageList: aCollection asSet
		name: 'References to Views from non-Views'.! !
!ExtractToMethodObjectApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724371!
variablesToParametrize

	^OrderedCollectio newFrom: (VariablesToExtractFinder valueIn: compiledMethodToExtract notOptimizedMethodNode)! !
!PluggableListMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724379!
keyboardSearch: aChar 
	| oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionText |
	nextSelection _ oldSelection _ self getCurrentSelectionIndex.
	max _ self maximumSelection.
	milliSeconds _ Time localMillisecondClock.
	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"
		lastKeystrokes _ ''].
	lastKeystrokes _ lastKeystrokes copyWith: aChar asLowercase.
	lastKeystrokeTime _ milliSeconds.
	nextSelectionList _ OrderedCollectio newFrom: (list copyFrom: oldSelection + 1 to: max).
	nextSelectionList addAll: (list copyFrom: 1 to: oldSelection).
	"Get rid of blanks and style used in some lists"
	nextSelectionText _ nextSelectionList detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]
				ifNone: [^ self flash"match not found"].
	self owningWindow ifNotNil: [ :w |
		(w okToChangeDueTo: self) ifFalse: [^ self]].
	nextSelection _ list findFirst: [:a | a == nextSelectionText].
	"No change if model is locked"
	oldSelection == nextSelection ifTrue: [^ self flash].
	^ self setSelectionIndex: nextSelection! !
!FeatureRequirement methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724418!
satisfyRequirementsAndInstall
	"Like #require, but install me even if already satisified (i.e. installed)"

	| packagesToLoad |
		
	"Preflight before load"
	[packagesToLoad := self
			requireUnlessIn: OrderedCollectio new
			main: self
			requiringFeature: self
			allRequiringFeatures: #()]
		on: FeatureRequirementUnsatisfied  
		do: [ :error | error defaultAction. 
			^self "exit"
		].
	
	"Check to see that each requirement is actually satisfied"
	[packagesToLoad do: [ :fReq | fReq checkRequirement ]]
		on: FeatureRequirementUnsatisfied  
		do: [ :error | error defaultAction. 
			^self "exit"
		].
	
	"All requirements are satisfied; do the deed"
	packagesToLoad reverseDo: [ :requirement |
		requirement isAlreadySatisfied ifFalse: [
			requirement install ]].
	self install! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724447 overrides: 50702685!
transactions
	^ (storedFinancialEntities inject: OrderedCollectio new into: [:aCollection :anAccount| aCollection , anAccount transactions.]).! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724455!
testInlineBlockCollectionLR2
	"Test case from Lukas Renggli"
	| col |
	col := OrderedCollectio new.
	1 to: 11 do: [ :each | #(1) do: [:ignored| col add: [ each ]] ].
	self assert: (col collect: [ :each | each value ]) asArray = (1 to: 11) asArray! !
!QAbstractTally methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724467!
rootPrintOn: textStream linesOn: linesStream talliesOn: talliesStream total: total totalTime: totalTime threshold: threshold reportOnly: aProcessOrNil

	| groups dashes line tabsAndTreeLines thisTab |
	groups _ (self sonsOver: threshold)
		groupBy: [ :aTally | aTally process ]
		having: [ :g | aProcessOrNil isNil or: [ g anyOne process == aProcessOrNil ]].
	groups do: [ :g | | sons |
		sons _ self sortCollectionFrom: g.
		dashes _ '--------------------------------'.
		line _ 'Process: ', (g anyOne process browserPrintStringFull: false).
		textStream
			nextPutAll: dashes; newLine;
			nextPutAll: line; newLine;
			nextPutAll: dashes; newLine.
		linesStream
			nextPut: dashes;
			nextPut: line;
			nextPut: dashes.
		talliesStream
			nextPut: nil; nextPut: nil; nextPut: nil.
		sons do: [ :son |
			tabsAndTreeLines _ OrderedCollectio new.
			thisTab _ '  '.
			son
				treeDFSDo: [ :eachTally :parentTally |
					eachTally
						printOn: textStream
						linesOn: linesStream talliesOn: talliesStream
						tabs: tabsAndTreeLines total: total totalTime: totalTime parent: parentTally.
					tabsAndTreeLines addLast: thisTab.
					thisTab := (eachTally sonsOver: threshold) size > 1 ifTrue: ['  |'] ifFalse: ['  '].
				]
				afterChildrenDo: [ :eachTally | tabsAndTreeLines removeLast ]
				threshold: threshold
				parent: self.
			].
		textStream newLine ]! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724513!
testNodesWithoutEdges

	| graph edges |

	edges :=
		OrderedCollectio new
			add: (Edge from: 1 to: 2);
			add: (Edge from: 2 to: 3);
			yourself.

	graph := Graph edges: edges.

	self assert: (graph nodesWithoutStartingEdges size = 1).
	self assert: (graph nodesWithoutStartingEdges includes: 3).
	self assert: (graph nodesWithoutConvergingEdges size = 1).
	self assert: (graph nodesWithoutConvergingEdges includes: 1)! !
!MessageKeywordsAndParametersTable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724531!
withRows: rowsTitles withColor: aColor withPreviewModel: aPreviewModel withRefactoringModel: aRefactoringModel

	| rowsSeparation recommendedHeight numberOfRows columnsTitlesRow changeOrderButtons tableWidth inputColumnsTitles |

	backgroundColor := aColor.
	rowModels := OrderedCollectio new.
	previewModel := aPreviewModel.
	refactoringModel := aRefactoringModel.
	variablesToParametrize := rowsTitles.

	rowsSeparation := 4.
	self separation: rowsSeparation.

	"Calculate table height"
	numberOfRows := (rowsTitles size + 1).
	recommendedHeight :=  self rowHeight * numberOfRows + (rowsSeparation * (numberOfRows + 1)) * 1.1.

	"Calculate column widths"
	inputColumnsTitles := #('Keyword' 'Parameter name').
	columnWidths := self columnWidthsRequiredForRowTitles: rowsTitles forInputColumns: inputColumnsTitles size.

	"Calculate table width"
	tableWidth := columnWidths sum + (self columnSeparation * (columnWidths size + 1)) * 1.1.

	self layoutSpec: (LayoutSpec fixedWidth: tableWidth fixedHeight: recommendedHeight).

	"Buid the columns titles row"
	columnsTitlesRow := self buildColumnTitlesRowFor: inputColumnsTitles.
	self addMorph: columnsTitlesRow layoutSpec: self rowsLayoutSpec.

	"Build the input rows"
	rowsTitles withIndexDo: [:aRowTitle :index | | aRow changeOrderModel keywordInputMorph inputMorphLayoutSpec parameternameInputMorph |
		aRow := LayoutMorph newRow.
		aRow color: self backgroundColor; separation: self columnSeparation.

		aRow
			addMorph: (LabelMorph contents: aRowTitle)
			layoutSpec: (LayoutSpec fixedWidth: (columnWidths at: 1)).

		inputMorphLayoutSpec := LayoutSpec fixedWidth: (columnWidths at: 2) fixedHeight: self rowHeight.

		keywordInputMorph := self buildInputMorphWith: (aRefactoringModel keywordModelOf: aRowTitle).
		aRow addMorph: keywordInputMorph layoutSpec: inputMorphLayoutSpec.

		parameternameInputMorph := self buildInputMorphWith: (aRefactoringModel parameterModelOf: aRowTitle).
		aRow addMorph: parameternameInputMorph layoutSpec: inputMorphLayoutSpec.

		self needsToReorderRows ifTrue: [
			changeOrderModel := ChangeRowOrderButtonModel for: (rowsTitles size - (index - 1)) notifying: self.
			rowModels addFirst: changeOrderModel.
			changeOrderButtons := self buildChangeOrderButtonsWith: changeOrderModel.
			aRow addMorph: changeOrderButtons layoutSpec: (LayoutSpec fixedWidth: (columnWidths last))].

		self addMorph: aRow layoutSpec: self rowsLayoutSpec.
	].! !
!MessageTally methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724611!
fullPrintExactOn: aStream

	aStream nextPutAll: '**Tree**'; newLine.
	self
		treePrintExactOn: aStream
		tabs: OrderedCollectio new
		thisTab: ''.
	aStream nextPut: Character newPage; newLine.
	aStream nextPutAll: '**Leaves**'; newLine.
	self leavesPrintExactOn: aStream! !
!AddParameterWithActualScopeApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724625 overrides: 16803828!
createSenders

	^OrderedCollectio new.
! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724630!
writeConversionMethod: sel class: newClass was: oldName fromInstVars: oldList to: newList
	"The method convertToCurrentVersion:refStream: was not found in newClass.  Write a default conversion method for the author to modify."

	| code newOthers oldOthers copied |

	code _ WriteStream on: (String new: 500).
	code nextPutAll: 'convertToCurrentVersion: varDict refStream: smartRefStrm'; newLine; tab.
	newOthers _ newList asOrderedCollection "copy".
	oldOthers _ oldList asOrderedCollection "copy".
	copied _ OrderedCollectio new.
	newList do: [:instVar |
		(oldList includes: instVar) ifTrue: [
			instVar isInteger ifFalse: [copied add: instVar].
			newOthers remove: instVar.
			oldOthers remove: instVar]].
	code nextPutAll: '"These variables are automatically stored into the new instance '.
	code nextPutAll: copied asArray printString; nextPut: $. .
	code newLine; tab; nextPutAll: 'This method is for additional changes.'; 
		nextPutAll: ' Use statements like (foo _ varDict at: ''foo'')."'; newLine; newLine; tab.
	newOthers isEmpty & oldOthers isEmpty ifTrue: [^ self].
		"Instance variables are the same.  Only the order changed.  No conversion needed."
	newOthers notEmpty ifTrue: [
		code nextPutAll: '"New variables: ', newOthers asArray printString, '  If a non-nil value is needed, please assign it."\' withNewLines].
	oldOthers notEmpty ifTrue: [
		code nextPutAll: '	"These are going away ', oldOthers asArray printString, '.  Possibly store their info in some other variable?"'].

	code newLine; tab.
	code nextPutAll: '^ super convertToCurrentVersion: varDict refStream: smartRefStrm'.
	newClass compile: code contents classified: 'object fileIn'.


	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)
	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe."! !
!TopologicalSortTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724707!
testValueWithAnotherGraph

	"Example from: http://www.cs.fsu.edu/~cop4531/slideshow/chapter23/23-4.html"

	| graph result |

	graph :=
		Graph
			edges: (
				OrderedCollectio new
					add: (Edge from: 'undershorts' to: 'pants');
					add: (Edge from: 'undershorts' to: 'shoes');
					add: (Edge from: 'pants' to: 'shoes');
					add: (Edge from: 'pants' to: 'shoes');
					add: (Edge from: 'pants' to: 'belt');
					add: (Edge from: 'socks' to: 'shoes');
					add: (Edge from: 'shirt' to: 'belt');
					add: (Edge from: 'shirt' to: 'tie');
					add: (Edge from: 'tie' to: 'jacket');
					yourself)
			nodes: (
				Set new
					add: 'undershorts';
					add: 'pants';
					add: 'shoes';
					add: 'belt';
					add: 'shirt';
					add: 'tie';
					add: 'jacket';
					add: 'watch';
					add: 'socks';
					yourself).

	result := ((TopologicalSort for: graph) value) asArray.

	self
		assert: (result indexOf: 'undershorts') < (result indexOf: 'pants');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'belt');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'jacket');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'shoes');
		assert: (result indexOf: 'shirt') < (result indexOf: 'belt');
		assert: (result indexOf: 'shirt') < (result indexOf: 'tie');
		assert: (result indexOf: 'shirt') < (result indexOf: 'jacket');
		assert: (result indexOf: 'pants') < (result indexOf: 'shoes')! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724755!
unusedTempNames
	| unused |
	unused := OrderedCollectio new.
	scopeTable associationsDo:
		[:assn | | name |
		(assn value isUnusedTemp) ifTrue:
			[name := assn value key.
			 name ~= Encoder doItInContextName ifTrue: [unused add: name]]].
	^ unused! !
!TestsXX methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724766!
test11_PortfolioHasTransactionsFromStoredAccount
	| aTransaction anAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	aTransaction := Withdraw register: 200 on: anAccount.
	aPortfolio add: anAccount.
	
	self assert: aPortfolio transactions equals: (OrderedCollectio with: aTransaction).! !
!ClassReferencesCollector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724780!
initializeCollectionFor: withAllSubclasses
	
	withAllSubclassesNames := withAllSubclasses collect: [:aClass | aClass name ].
	referencesToClass := OrderedCollectio new.
	referencedAsClass := OrderedCollectio new.
	referencesToName := OrderedCollectio new.
	referencedAsName := OrderedCollectio new! !
!CollectTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724793!
testSortedCollection
	"
	CollectTest  new testSortedCollection
	"
	| col result |
	col _ #(1 2 3 4 5) asSortedCollection: [ :a :b | a > b ].
	result _ col collect: [ :elem |  elem * 2 ].
	self assert: result class = OrderedCollectio.
	self assert: result = #(10 8 6 4 2) asOrderedCollection! !
!CodeForNodeOnMethod class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724806!
replace: instVarNameToReplace onMethod: aCompiledMethod accessingThrough: instVarNameToUseAsReceiver for: aNode
	^self 
		replace: instVarNameToReplace 
		onMethod: aCompiledMethod 
		accessingThrough: instVarNameToUseAsReceiver 
		for: aNode
		rejectingIntervals: OrderedCollectio new! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724819!
temporaryBlockVariablesFor: aBlockNode
	"Scan and answer temporary block variables."

	| tempDeclarationNodes declarationStartIndex |
	(self match: #verticalBar) ifFalse:
		"There are't any temporary variables."
		[aBlockNode tempsMark: prevMark + requestorOffset.
		 ^ self noTempsDeclaration ].

	tempDeclarationNodes _ OrderedCollectio new.
	declarationStartIndex _ prevMark.
	[hereType == #word] whileTrue: [
		self advanceWithRangeDo: [ :variableName :range |
			| variableNode |
			variableNode _ encoder bindBlockTemp: variableName within: aBlockNode range: range.
			tempDeclarationNodes addLast: (self createTempDeclarationOf: variableNode sourceRange: range) ] ].
	(self match: #verticalBar) ifFalse:
		[^self expected: 'Vertical bar'].
	aBlockNode tempsMark: prevMark + requestorOffset.
	^ self
		createTempsDeclarationWith: tempDeclarationNodes
		sourceRange: (declarationStartIndex to: prevMark)! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724851!
allUnreferencedClassVariables
	"Answer a list of the names of all the receiver's unreferenced class vars, including those defined in superclasses"
	| aList |
	aList _ OrderedCollectio new.
	self withAllSuperclasses reverseDo: [ :aClass |
		aClass classVarNames do: [ :var |
			(Smalltalk isThereAReferenceTo: (aClass classPool associationAt: var)) ifFalse: [ aList add: var ]]].
	^ aList! !
!ActualImplementorsTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724867!
test09WhenNoHighestClassImplementingSelectorIfNoneBlockIsEvaluated

	self assert: (OrderedCollectio highestClassImplementing: #none ifNone: [ true ])! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724875!
scanFile: aFile from: startPosition to: stopPosition

	file _ aFile.
	changeList _ OrderedCollectio new.
	list _ OrderedCollectio new.
	listIndex _ 0.
	file position: startPosition.

	'Scanning ', aFile localName
		displayProgressAt: Sensor mousePoint
		from: startPosition to: stopPosition
		during: [ :barBlock | self scanUpTo: stopPosition informing: barBlock ].
		
	self clearSelections! !
!Object methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724891!
outboundPointers
"Answers a list of all objects I am causing not to be garbage-collected"

	| collection |
	collection := OrderedCollectio new.
	self outboundPointersDo: [:ea | collection add: ea].
	^ collection! !
!Utilities class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724901!
hierarchyOfClassesSurrounding: aClass
	"Answer a list of classes in the hierarchy both above and below the given class "
	| list aClassNonMeta isMeta theClassOrMeta |

	aClass ifNil: [^ OrderedCollectio new].
	aClass ifNil: [^ self].
	aClassNonMeta _ aClass theNonMetaClass.
	isMeta _ aClassNonMeta ~~ aClass.
	list _ OrderedCollectio new.
	aClass allSuperclasses reverseDo:
		[:cl | list addLast: cl].
	aClassNonMeta allSubclassesWithLevelDo:
		[:cl :level |
		theClassOrMeta _ isMeta ifTrue: [cl class] ifFalse: [cl].
		list addLast: theClassOrMeta]
	 	startingLevel: 0.
	^ list

"Utilities hierarchyOfClassesSurrounding: StringHolder "! !
!OrderedCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724925!
testStreamContentsWorksAsExpected

	| contents |
	
	contents := OrderedCollectio streamContents: [ :stream | stream nextPut: 1 ].
	
	self assert: contents equals: (OrderedCollectio with: 1).! !
!DividedUnit class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724935!
multipliedUnit: aMultipliedUnit multipliedUnit: anotherMultipliedUnit

	| numeratorFactors denominatorFactors numerator denominator |

	numeratorFactors := aMultipliedUnit factors.
	denominatorFactors := OrderedCollectio new.

	anotherMultipliedUnit factors
		do: [:aUnit | numeratorFactors remove: aUnit ifAbsent: [denominatorFactors add: aUnit]].

	numerator := MultipliedUnit factors: numeratorFactors.
	denominator := MultipliedUnit factors: denominatorFactors.

	^denominator = NullUnit new
		ifTrue: [numerator]
		ifFalse: [self new initializeNumerator: numerator denominator: denominator]! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724958!
allMegamorphicVariables

	"
	InstanceVariablesTypes allMegamorphicVariables
	MethodVariablesTypes allMegamorphicVariables
	"
	
	| allMegamorphicVariables |
	
	allMegamorphicVariables := OrderedCollectio new.
	ProtoObject withAllSubclassesDo: [ :aClass | self of: aClass do: [ :aVariablesTypes | aVariablesTypes addMegamorphicVariablesTo: allMegamorphicVariables ]].
	
	^allMegamorphicVariables ! !
!TypeCheckerTestMethods methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724974!
typeCheckMessageWithFalseInSubclass

	| temp1  |
	
	temp1 := OrderedCollectio new.
	temp1 := Color new.
	
	temp1 isCollection ifTrue: [ temp1 add: 1 ] ifFalse: [ temp1 alpha ]! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50724983!
macroBenchmark1    "Smalltalk macroBenchmark1"
	"Decompiles and prettyPrints the source for every method in the system (or less depending on the *FILTER*, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same.  Because it never installs the new method, it should not cause any flusing of the method cache."
	 | methodNode oldMethod newMethod badOnes oldCodeString n classes |
	classes _ Smalltalk allClasses select: [:c | c name < 'B3'].
	badOnes _ OrderedCollectio new.
'Decompiling and recompiling...'
displayProgressAt: Sensor mousePoint
from: 0 to: (classes sum: [:c | c selectors size] ifEmpty: [0])
during: [:barBlock | n _ 0.
	classes do:
		[:cls | 
		"Transcript cr; show: cls name."
		cls selectors do:
			[:selector | barBlock value: (n _ n+1).
			oldMethod _ cls compiledMethodAt: selector.
			oldCodeString _ (cls decompilerClass new
								decompile: selector in: cls method: oldMethod)
							decompileString.
			methodNode _ cls compilerClass new
						compile: oldCodeString
						in: cls notifying: nil ifFail: nil.
			newMethod _ methodNode generate: #(0 0 0 0).
			oldCodeString = (cls decompilerClass new
								decompile: selector in: cls method: newMethod)
							decompileString ifFalse: [badOnes add: cls name , ' ' , selector]]].
].
	^ badOnes size! !
!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725033!
beFullyExpandedAsPer: aBlock

	| allChildren |
	allChildren _ OrderedCollectio new: 10.
	self recursiveAddTo: allChildren.
	allChildren do:
		[:each |
			| shouldExpandEach |
			shouldExpandEach := each canExpand and: [aBlock value: each].
			shouldExpandEach ~= each isExpanded ifTrue:
				[
					each toggleExpandedState.
					each beFullyExpandedAsPer: aBlock
				]
		]! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725048!
testConvergingEdges

	| graph edges |
	
	edges := OrderedCollectio new
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		add: (Edge from: 3 to: 4);
		add: (Edge from: 1 to: 4);
		add: (Edge from: 4 to: 4);
		yourself.
	
	graph := Graph edges: edges.
	
	self assert: (graph edgesConvergingTo: 1) isEmpty.
	self assert: (graph edgesConvergingTo: 2) size = 1.
	self assert: ((graph edgesConvergingTo: 2) copyWithout: (Edge from: 1 to: 2)) isEmpty.
	
	self assert: (graph edgesConvergingTo: 3) size = 1.
	self assert: ((graph edgesConvergingTo: 3) copyWithout: (Edge from: 2 to: 3)) isEmpty.

	self assert: (graph edgesConvergingTo: 4) size = 3.
	self assert: ((graph edgesConvergingTo: 4) removeAll: (OrderedCollectio 
		with: (Edge from: 3 to: 4)
		with: (Edge from: 4 to: 4)
		with: (Edge from: 1 to: 4)); yourself) isEmpty.
	
	self assert: (graph edgesConvergingTo: 5) isEmpty! !
!CodeCoverageAnalyzerBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725081 overrides: 50725569!
systemCategoryRoots
	"Answer the roots of the forest of system categories."
	| categories subcategories roots name |
	categories _ self systemCategoryList.

	subcategories _ Dictionary new.
	categories do: [:each|
		name _ (each findTokens: '-') first.
		(subcategories at: name ifAbsentPut: [OrderedCollectio new]) add: each].
	roots _ OrderedCollectio new.
	categories do: [:each|
		name _ (each findTokens: '-') first.
		(roots includes: name) ifFalse:
			[(subcategories at: name) size > 1 ifTrue: [roots add: name] ifFalse: [roots add: (subcategories at: name) first]]].
	^ roots collect: [:each|
		| averagePercentCoveredInSubcategories rootName | 
		averagePercentCoveredInSubcategories := ((subcategories at: name) collect: [ :subcategory | subcategory percentCovered ]) average.
		rootName := each, ' (', (averagePercentCoveredInSubcategories printStringFractionDigits: 2 ) asString, '%)'.
		
		SystemCategoryWrapper with: each name: (rootName)  model: self]! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725115!
buildBackgroundPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollectio with: (Color fromHexString: '#FE938C') with: 'Sunset'.
	ocean := OrderedCollectio with: (Color fromHexString: '#124559') with: 'Ocean'.
	forest := OrderedCollectio with: (Color fromHexString: '#788475') with: 'Forest'.
	ash := OrderedCollectio with: (Color fromHexString: '#363946') with: 'Ash'.
	light := OrderedCollectio with: (Color fromHexString: '#F2DFD7') with: 'Light'.
	
	backgroundPalette := OrderedCollectio with: sunset with: ocean with: forest with: ash with: light.! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725138 overrides: 50524003!
composeWithNumber: aNumber

	^self isNothing
		ifTrue: [aNumber]
		ifFalse: [CompoundMeasure measures: (OrderedCollectio with: self with: aNumber)]! !
!ReceiverTypesOfMessageSendsConform methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725148 overrides: 16906976!
visitMessageNode: aMessageNode

	| receiverTypes |
	
	(aMessageNode selector isNamed: sentSelector) ifTrue: [
		"I don't care if receiverTypes is empty or if there are error collecting the types.
		This should change if we want a more restrictive rename - Hernan"
		receiverTypes := aMessageNode receiverOrCascadeReceiver typesIn: currentSender addingIncompleteTypeInfoTo: OrderedCollectio new.
		(self isMessageSendToAnyImplementor: receiverTypes) ifTrue: [ self add: aMessageNode toNotIncludedReceiverTypesIfCorrespond: receiverTypes ]].! !
!ChangeSorter methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725169!
classList
	"Computed.  View should try to preserve selections, even though index changes"

	^ myChangeSet ifNotNil: [myChangeSet changedClassNames] ifNil: [OrderedCollectio new]
! !
!TypeCheckerTestMethods methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725179!
isKindOfKeepsSubtypes

	| temp1  |
	
	temp1 := 1.
	temp1 := OrderedCollectio new.
	temp1 := LinkedList new.
	
	(temp1 isKindOf: Collection) ifTrue: [ temp1 addLast:1 ].! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725188!
buildSecondaryPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollectio with: (Color fromHexString: '#FCA17D') with: 'Sunset'.
	ocean := OrderedCollectio with: (Color fromHexString: '#AEC3B0') with: 'Ocean'.
	forest := OrderedCollectio with: (Color fromHexString: '#453643') with: 'Forest'.
	ash := OrderedCollectio with: (Color fromHexString: '#8D99AE') with: 'Ash '.
	light := OrderedCollectio with: (Color fromHexString: '#BCAA99') with: 'Light'.
	
	secondaryPalette := OrderedCollectio with: sunset with: ocean with: forest with: ash with: light.! !
!PlusInfinity methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725211 overrides: 50524008!
composeWithSimpleMeasure: aMeasure

	^CompoundMeasure measures: (OrderedCollectio with: self with: aMeasure)! !
!ArithmeticObjectIntervalTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725219!
testAddToCollection

	| collection |
	
	collection := OrderedCollectio new addAll: (ArithmeticObjectInterval from: 10 to: 20 by: 1); yourself.
	self assert: collection size = 11.
	(10 to: 20) withIndexDo: [ :value :index | self assert: (collection at: index) = value ]! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725231!
jump: dist if: condition

	| savePc sign elsePc elseStart end cond ifExpr thenBlock elseBlock
	  thenJump elseJump condHasValue isIfNil saveStack blockBody blockArgs |
	lastJumpIfPcStack addLast: lastPc.
	stack last == #CascadeFlag ifTrue: [^ [self case: dist] ensure: [lastJumpIfPcStack removeLast]].
	elsePc := lastPc.
	elseStart := pc + dist.
	end := limit.
	"Check for bfp-jmp to invert condition.
	Don't be fooled by a loop with a null body."
	sign := condition.
	savePc := pc.
	self interpretJump ifNotNil:
		[:elseDist|
		 (elseDist >= 0 and: [elseStart = pc]) ifTrue:
			 [sign := sign not.  elseStart := pc + elseDist]].
	pc := savePc.
	ifExpr := stack removeLast.
	(isIfNil := stack size > 0 and: [stack last == #IfNilFlag]) ifTrue:
		[stack removeLast].
	saveStack := stack.
	stack := OrderedCollectio new.
	thenBlock := self blockTo: elseStart.
	condHasValue := hasValue or: [isIfNil].
	"ensure jump is within block (in case thenExpr returns)"
	thenJump := exit <= end ifTrue: [exit] ifFalse: [elseStart].
	"if jump goes back, then it's a loop"
	thenJump < elseStart
		ifTrue:
			["Must be a while loop...
			  thenJump will jump to the beginning of the while expr.  In the case of while's
			  with a block in the condition, the while expr should include more than just
			  the last expression: find all the statements needed by re-decompiling."
			stack := saveStack.
			pc := thenJump.
			blockBody := self statementsTo: elsePc.
			"discard unwanted statements from block"
			blockBody size - 1 timesRepeat: [statements removeLast].
			blockArgs := thenBlock statements = constructor codeEmptyBlock statements
							ifTrue: [#()]
							ifFalse: [{ thenBlock }].
			statements addLast:
				(constructor
					codeMessage: (constructor codeBlock: blockBody returns: false)
					selector: (constructor
								codeSelector: (blockArgs isEmpty
												ifTrue:
													[sign
														ifTrue: [#whileFalse]
														ifFalse: [#whileTrue]]
												ifFalse:
													[sign
														ifTrue: [#whileFalse:]
														ifFalse: [#whileTrue:]])
								code: #macro)
					arguments: blockArgs).
			pc := elseStart.
			self convertToDoLoop]
		ifFalse:
			["Must be a conditional..."
			elseBlock := self blockTo: thenJump.
			elseJump := exit.
			"if elseJump is backwards, it is not part of the elseExpr"
			elseJump < elsePc ifTrue:
				[pc := lastPc].
			cond := isIfNil
						ifTrue:
							[constructor
								codeMessage: ifExpr ifNilReceiver
								selector: (constructor
											codeSelector: (sign ifTrue: [#ifNotNil:] ifFalse: [#ifNil:])
											code: #macro)
								arguments: (Array with: thenBlock)]
						ifFalse:
							[constructor
								codeMessage: ifExpr
								selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)
								arguments:	(sign
												ifTrue: [{elseBlock. thenBlock}]
												ifFalse: [{thenBlock. elseBlock}])].
			stack := saveStack.
			condHasValue
				ifTrue: [stack addLast: cond]
				ifFalse: [statements addLast: cond]].
	lastJumpIfPcStack removeLast.! !
!Parser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725330!
statements: argNodes innerBlock: inner blockNode: theBlockNode

	| stmts returns start |
	"give initial comment to block, since others trail statements"
	theBlockNode comment: currentComment.
	"Very important. Nil the comment, to avoid printing comments multiple times when pretty-printing"
	currentComment _ nil.
	stmts := OrderedCollectio new.
	returns := false.
	hereType ~~ #rightBracket ifTrue:
		[[theBlockNode startOfLastStatement: (start := self startOfNextToken).
		  (returns := self matchReturn)
			ifTrue: 
				[self expression ifFalse:
					[^self expected: 'Expression to return'].
				 self addComment.
				 stmts addLast: (parseNode isReturningIf
								ifTrue: [parseNode]
								ifFalse: [ReturnNode new
											expr: parseNode
											encoder: encoder
											sourceRange: (start to: self endOfLastToken)])]
			ifFalse: 
				[self expression
					ifTrue: 
						[self addComment.
						 stmts addLast: parseNode]
					ifFalse: 
						[self addComment.
						 stmts size = 0 ifTrue: 
							[stmts addLast: 
								(encoder encodeVariable:
									(inner ifTrue: ['nil'] ifFalse: ['self']))]]].
		  returns ifTrue: 
			[self match: #period.
			 (hereType == #rightBracket or: [hereType == #doIt]) ifFalse:
				[^self expected: 'End of block']].
		  returns not and: [self match: #period]] whileTrue].
	theBlockNode
		arguments: argNodes
		statements: stmts
		returns: returns
		from: encoder.
	parseNode := theBlockNode.
	^true! !
!ExtractToMethodObjectRequest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725380!
initializeFor: aCompiledMethod

	variableToParametrizeToInstVarNameModel := Dictionary new.
	instanceCreationMessageModels := OrderedCollectio new.

	methodObjectClassNameModel := PluggableTextModel on: self.
	methodObjectCategoryModel := PluggableTextModel on: self.
	methodObjectCategoryModel actualContents: aCompiledMethod methodClass category.
	methodObjectSuperclassNameModel := PluggableTextModel on: AutocompletedTextProvider new.
	methodObjectSuperclassNameModel actualContents: 'Object'.
	methodObjectEvaluationMessageSelectorModel := PluggableTextModel on: self.! !
!VersionsBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725402!
scanVersionsOf: method class: class meta: meta category: category selector: selector
	| position stamp prevPos prevFileIndex preamble tokens sourceFilesCopy |
	selectorOfMethod _ selector.
	currentCompiledMethod _ method.
	classOfMethod _ meta ifTrue: [class class] ifFalse: [class].
	changeList _ OrderedCollectio new.
	list _ OrderedCollectio new.
	self addedChangeRecord ifNotNil: [ :change |
		self addItem: change text: ('{1} (in {2})' format: { change stamp. change fileName }) ].
	listIndex _ 0.
	position _ method filePosition.
	sourceFilesCopy _ SourceFiles collect:
		[:x | x ifNotNil: [ x name asFileEntry readStream ]].
	method fileIndex = 0 ifTrue: [^ nil].
	file _ sourceFilesCopy at: method fileIndex.
	[position notNil & file notNil] whileTrue: [
		"Skip back filler"
		file position: position.
		file backChunk.
		"Get preamble"
		preamble _ file backChunk.
		"Preamble is likely a linked method preamble, if we're in
			a changes file (not the sources file).  Try to parse it
			for prior source position and file index"
		prevFileIndex _ nil.
		prevPos _ nil.
		stamp _ ''.
		(preamble includesSubString: 'methodsFor:')
			ifTrue: [
				tokens _ Scanner new scanTokens: preamble.
				stamp _ CompiledMethod stampFrom: tokens.
				(CompiledMethod priorReferenceFrom: tokens) ifNotNil: [ :priorMethodRef |
					prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: priorMethodRef.
					prevPos _ sourceFilesCopy filePositionFromSourcePointer: priorMethodRef ]].
 		self addItem:
				(ChangeRecord new file: file position: position type: #method
						class: class name category: category meta: meta stamp: stamp)
			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.
		position _ prevPos.
		prevPos notNil ifTrue: [
			file _ sourceFilesCopy at: prevFileIndex]].
	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].
	self clearSelections! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725465!
mapFromBlockKeys: keys toSchematicTemps: schematicTempNamesString
	"Decode a schematicTempNamesString that encodes the layout of temp names
	 in a method and any closures/blocks within it, matching keys in keys to
	 vectors of temp names."
	| map tempNames |
	map := Dictionary new.
	tempNames := schematicTempNamesString readStream.
	keys do:
		[:key| | tempSequence tempIndex |
		tempSequence := OrderedCollectio new.
		tempIndex := 0.
		[(tempNames skipSeparators; peek) ifNil: [true] ifNotNil: [:ch| '[]' includes: ch]] whileFalse:
			[tempNames peek = $(
				ifTrue: [tempSequence addAll: ((self tempsSubSequenceFrom: (tempNames next; yourself)) withIndexCollect:
														[:temp :index|
														{ temp. { tempIndex + 1. index } }]).
						tempNames peek ~= $) ifTrue: [self error: 'parse error'].
						tempIndex := tempIndex + 1.
						tempNames next]
				ifFalse: [tempSequence addAll: ((self tempsSubSequenceFrom: tempNames) withIndexCollect:
														[:temp :index|
														{ temp. tempIndex := tempIndex + 1 }])]].
		map at: key put: tempSequence asArray.
		[tempNames peek = $]] whileTrue: [tempNames next].
		tempNames peek = $[ ifTrue:
			[tempNames next]].
	^map! !
!DenotativeObjectDarkTheme methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725507 overrides: 16971312!
pseudoVariables

	^ (OrderedCollectio withAll: super pseudoVariables) 
		add: #parent;
		asArray! !
!DebuggerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725514!
customButtonRow
	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"

	| button buttons row buttonColor |
	
	buttons _ OrderedCollectio new.
	buttonColor _ self buttonColor.
	"button with target = self"
	button _ PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #proceed.
	button color: buttonColor.
	button label: 'Proceed'.
	button setBalloonText: 'close the debugger and proceed.'.
	buttons add: button.
	"buttons with model target"
	self customButtonSpecs do: [ :tuple |
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple second.
		button color: buttonColor.
		button label: tuple first.
		tuple size > 2 ifTrue: [button setBalloonText: tuple third].
		buttons add: button].

	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row addMorphs: buttons.
	^row! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:50' prior: 50725550!
allMethodCategoriesIntegratedThrough: mostGenericClass
	"Answer a list of all the method categories of the receiver and all its superclasses, up through mostGenericClass"

	| aColl |
	aColl _ OrderedCollectio new.
	self withAllSuperclasses do: [ :aClass |
		(aClass includesBehavior: mostGenericClass)
			ifTrue: [ aColl addAll: aClass methodCategories ]].
	
	^ aColl asSet asSortedCollection: [ :a :b | a asLowercase < b asLowercase ]

"ColorTileMorph allMethodCategoriesIntegratedThrough: TileMorph"! !
!Browser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725569!
systemCategoryRoots
	"Answer the roots of the forest of system categories."
	| categories subcategories roots name |
	categories _ self systemCategoryList.
	subcategories _ Dictionary new.
	categories do: [:each|
		name _ (each findTokens: '-') first.
		(subcategories at: name ifAbsentPut: [OrderedCollectio new]) add: each].
	roots _ OrderedCollectio new.
	categories do: [:each|
		name _ (each findTokens: '-') first.
		(roots includes: name) ifFalse:
			[(subcategories at: name) size > 1 ifTrue: [roots add: name] ifFalse: [roots add: (subcategories at: name) first]]].
	^ roots collect: [:each| SystemCategoryWrapper with: each name: each model: self]! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725594!
checkFatalReshape: setOfClasses
	| suspects oldInstVars newInstVars bad className |
	"Inform the user if any of these classes were reshaped.  A block has a method from the old system whose receiver is of this class.  The method's inst var references might be wrong.  OK if inst vars were only added."

	self flag: #bobconv.	

	setOfClasses isEmpty ifTrue: [^ self].
	suspects _ OrderedCollectio new.
	setOfClasses do: [:aClass |
		className _ renamed keyAtValue: aClass name ifAbsent: [aClass name].
		oldInstVars _ (structures at: className ifAbsent: [#(0)]) allButFirst.		"should be there"
		newInstVars _ aClass allInstVarNames.
		oldInstVars size > newInstVars size ifTrue: [bad _ true].
		oldInstVars size = newInstVars size ifTrue: [
			bad _ oldInstVars ~= newInstVars].
		oldInstVars size < newInstVars size ifTrue: [
			bad _ oldInstVars ~= (newInstVars copyFrom: 1 to: oldInstVars size)].
		bad ifTrue: [suspects add: aClass]].

	suspects isEmpty ifFalse: [
		self inform: ('Imported foreign methods will run on instances of:\',
			suspects asArray printString, 
			'\whose shape has changed.  Errors may occur.') withNewLines].! !
!MorphicCanvas methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725633!
initializeWithTranslation: aPoint
	"Set up these only on initialization."

	currentTransformation _ MorphicTranslation withTranslation: aPoint.
	cti _ 1.
	transformations
		ifNil: [ transformations _ OrderedCollectio with: currentTransformation ]
		ifNotNil: [ transformations at: cti put: currentTransformation ].
	drawingMorphStack
		ifNil: [ drawingMorphStack _ OrderedCollectio with: nil ]
		ifNotNil: [ drawingMorphStack at: cti put: nil ].
	currentMorph _ nil.! !
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725652!
divideRectHorizontally: aRectangle by: aNumber

	| w x rects |
	
	x _ aRectangle origin x.
	w _ aRectangle width // aNumber.
	rects _ OrderedCollectio new.
	
	aNumber timesRepeat: [ |rect|
		rect _ Rectangle origin: x@aRectangle origin y extent: w@aRectangle height.
		x _ x + w.
		rects add: rect].
	
	 ^ rects
	
	! !
!SHParserST80 methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725666!
parse: isAMethod 
	"Parse the receiver's text. If isAMethod is true
    then treat text as a method, if false as an
    expression with no message pattern"

	| continue prevSourcePosition |
	self initializeInstanceVariables.
	sourcePosition _ 1.
	arguments _ Dictionary new.
	temporaries _ Dictionary new.
	blockDepth _ bracketDepth _ braceDepth _ 0.
	blockDepths _ OrderedCollectio with: blockDepth.
	blockDepthsStartIndexes _ OrderedCollectio with: sourcePosition.
	ranges ifNil: [ ranges := OrderedCollectio new: 100] ifNotNil: [ ranges reset].
	errorBlock _ [^false].
	[
		self scanNext.
		isAMethod 
			ifTrue: [
				self parseMessagePattern.
				self parsePragmaSequence].
		self parseMethodTemporaries.
		isAMethod ifTrue: [self parsePragmaSequence].
		"Iterate once for methods, but pontentially several times for workspaces
		(to recover after errors, for possible good next lines or chunks)"
		continue _ true.
		[ continue ] whileTrue: [
			prevSourcePosition _ sourcePosition.
			self parseStatementList.
			continue _ sourcePosition > prevSourcePosition.
			isAMethod
				ifTrue: [
					"Only if we are parsing a method, consider everything after this point as error."
					currentToken ifNotNil: [ self error ].
					continue _ false]
				ifFalse: [
					sourcePosition > source size ifTrue: [continue _ false]]].
	] ensure: [errorBlock _ nil].
	^true! !
!TTContourConstruction methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725713!
initialMoveToAndPathCommands: anAffineTransformationOrNil
	"TrueType reasonably assumes Y coordinates increase upwards."

	| initialMoveToCommand pathCommand firstPoint prevEndPoint endPoints controlPoints cp ep |
	endPoints _ OrderedCollectio new.
	controlPoints _ OrderedCollectio new.
	self
		startPointDo: [ :firstBezierStart |
			firstPoint _ firstBezierStart.
			anAffineTransformationOrNil notNil ifTrue: [
				firstPoint _ anAffineTransformationOrNil transform: firstPoint ].
			prevEndPoint _ firstPoint ]
		quadraticBeziersDo: [ :controlPoint :endPoint |
			cp _ controlPoint.
			ep _ endPoint.
			anAffineTransformationOrNil notNil ifTrue: [
				cp _ anAffineTransformationOrNil transform: cp.
				ep _ anAffineTransformationOrNil transform: ep ].
			controlPoints add: cp - prevEndPoint.
			endPoints add: ep - prevEndPoint.
			prevEndPoint _ ep ].
	initialMoveToCommand _ PathMoveToCommand new toRelativePoint: firstPoint.
	pathCommand _ PathQuadraticCurveToCommand new toRelativePoints: endPoints controlPoints: controlPoints.
	^{initialMoveToCommand. pathCommand}! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725750!
sharedPools
	"Answer a Set of the names of the pools (Dictionaries) that the receiver 
	shares.
	9/12/96 tk  sharedPools have an order now"

	^ OrderedCollectio new! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725759!
testEdgesConvergingToSelf

	| graph edges |
	
	edges := OrderedCollectio new
		add: (Edge from: 1 to: 2);
		add: (Edge from: 2 to: 3);
		add: (Edge from: 3 to: 4);
		add: (Edge from: 1 to: 4);
		add: (Edge from: 4 to: 4);
		yourself.
	
	graph := Graph edges: edges.	
	self assert: (graph edgesConvergingToSelf) size = 1.
	self assert: ((graph edgesConvergingToSelf) copyWithout: (Edge from: 4 to:4)) isEmpty! !
!ChangeList class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725776!
browseRecentLogOn: origChangesFileEntry startingFrom: initialPos 
	"Prompt with a menu of how far back to go when browsing a changes file."

	| end banners positions pos chunk i |
	origChangesFileEntry readStreamDo: [ :changesFile |
		banners _ OrderedCollectio new.
		positions _ OrderedCollectio new.
		end _ changesFile size.
		pos _ initialPos.
		[pos = 0
			or: [banners size > 20]] 		"Go back at most 20 image exits"
			whileFalse: [
				changesFile position: pos.
				chunk _ changesFile nextChunk.
				i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.
				i > 0
					ifTrue: [
						positions addLast: pos.
						banners addLast: (chunk copyFrom: 5 to: i - 2).
						pos _ Number readFrom: (chunk copyFrom: i + 13 to: chunk size)]
					ifFalse: [
						pos _ 0]].
	].
	positions isEmpty
		ifTrue: [ pos _ 0 ]
		ifFalse: [
			positions addLast: 0.
			banners addLast: 'Whole file'.
			pos _ (SelectionMenu labelList: banners selections: positions)
						startUpWithCaption: 'Browse as far back as...'.
			pos
				ifNil: [^ self]].
	self browseRecent: end - pos on: origChangesFileEntry! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725815!
initializeVariablesRawTypesWhenMethodHasVariablesUsing: aMethodNode 

	| argumentNames remoteVectorTypes variablesTypes |

	argumentNames := aMethodNode argumentNames.
	variablesTypes := OrderedCollectio new.
	remoteVectorTypes := OrderedCollectio new.
	
	variableNameToTypeIndex := Dictionary new.
	variableNameToRemoteVectorTypeIndex := Dictionary new.
	
	aMethodNode topBlockTempsMap do: [ :aTempMap |
		self 
			initializeRawTypesOfVariableNamed: aTempMap first 
			at: aTempMap second 
			into: variablesTypes 
			or: remoteVectorTypes 
			with: argumentNames ].
	
	"There is no need to add a slot for the remote vector because the VM
	takes cares of arrays of types arrays size - Hernan"	
	
	"If there are no variable rawTypes and var name to index are initialized with nil
	to save memory space and speedup the VM - Hernan"
	variablesTypes isEmpty 
		ifTrue: [ variablesRawTypes := variableNameToTypeIndex := nil ] 
		ifFalse: [ variablesRawTypes := variablesTypes asArray ].
		
	remoteVectorTypes isEmpty 
		ifTrue: [ remoteVectorRawTypes := variableNameToRemoteVectorTypeIndex := nil ] 
		ifFalse: [ remoteVectorRawTypes := remoteVectorTypes asArray ]
! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725855!
reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	WorldMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w submorphsDo: [ :a | a delete ]].
	Preferences at: #wantsMenuIcons put: false.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollectio new.
	keep addAll: #(SpaceTally DynamicTypingSmalltalkCompleter).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725923!
init: aClass context: aContext notifying: req
	requestor := req.
	class := aClass.
	nTemps := 0.
	supered := false.
	self initScopeAndLiteralTables.
	"No Tweak Fields in Cuis"
	class variablesAndOffsetsDo: [ :variable "<String>" :offset "<Integer>" |
		scopeTable
			at: variable
			put: (offset >= 0
					ifTrue: [InstanceVariableNode new
								name: variable index: offset]
					ifFalse: [MaybeContextInstanceVariableNode new
								name: variable index: offset negated])].
	aContext ifNotNil: [
		| homeNode |
		homeNode := self bindTemp: Encoder doItInContextName.
		"0th temp = aContext passed as arg"
		aContext tempNames withIndexDo: [ :variable :index |
			variable ~= Encoder doItInContextName ifTrue: [
				scopeTable
					at: variable
					put: (MessageAsTempNode new
						receiver: homeNode
						selector: #namedTempAt:
						arguments: (Array with: (self encodeLiteral: index))
						precedence: 3
						from: self)]]].
	sourceRanges := Dictionary new: 32.
	globalSourceRanges := OrderedCollectio new: 32! !
!DenotativeObjectDebugger methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725960 overrides: 16838151!
askForCategoryIn: aClass default: aString

	| categories index category |
	
	categories := OrderedCollectio with: 'new ...'. 
	categories addAll: (aClass allMethodCategoriesIntegratedThrough: aClass).	
	index := PopUpMenu withCaption: 'Please provide a good category for the new method!!'
						chooseFrom: categories.
	index = 0 ifTrue: [^ aString].
	
	category := index = 1 
		ifTrue: [StringRequestMorph request: 'Enter category name:' orCancel: [ '' ] ]
		ifFalse: [categories at: index].
		
	^ category isEmpty ifTrue: [aString] ifFalse: [category]! !
!BehaviorTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725981!
testHighestClassImplementingValuesIfNoneBlockWhenSelectorIsNotImplemented

	OrderedCollectio highestClassImplementing: #x ifNone: [ ^self  ].
	
	self fail! !
!MonitorTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50725990!
testExample1

	| producer1 producer2  monitor goal work counter goalReached finished |
	goal := (1 to: 1000) asOrderedCollection.
	work := OrderedCollectio new.
	counter := 0.
	goalReached := false.
	finished := Semaphore new.
	monitor := Monitor new.

	producer1 := [
       [monitor critical:
             [monitor waitUntil: [counter \\5 = 0].
              goalReached or: [work add: (counter := counter + 1)].
              goalReached := counter >= goal size.
              monitor signal
            ].
           goalReached
          ]
             whileFalse.
         finished signal.
	].

	producer2 := [
         [monitor critical:
                [monitor waitWhile: [counter \\5 = 0].
                 goalReached or: [work add: (counter := counter + 1)].
                 goalReached := counter >= goal size.
                 monitor signal].
         goalReached
       ] whileFalse.
     finished signal
	].

	producer1 forkAt: Processor userBackgroundPriority.
	producer2 forkAt: Processor userBackgroundPriority.

	finished wait; wait.
	self assert: goal = work! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726028!
addRemoteTemp: aTempVariableNode encoder: encoder
	remoteTemps isNil ifTrue:
		[remoteTemps := OrderedCollectio new].
	remoteTemps addLast: aTempVariableNode.
	aTempVariableNode referenceScopesAndIndicesDo:
		[:scopeBlock "<BlockNode>" :location "<Integer>"|
		 self addReadWithin: scopeBlock at: location].
	encoder supportsClosureOpcodes ifFalse:
		[encoder encodeLiteral: remoteTemps size.
		 readNode := encoder encodeSelector: #at:.
		 writeNode := encoder encodeSelector: #at:put:]! !
!UndeclaredVariable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726047!
handleForDenotativeObjectIn: aDenotativeObjectBrowser

	| alternatives labels actions lines caption choice |
	
	alternatives := parser possibleVariablesFor: name.
	labels := OrderedCollectio new.
	actions := OrderedCollectio new.
	lines := OrderedCollectio new.

	name first isLowercase
		ifTrue: [ self addCollaboratorLabelsTo: labels andActionsTo: actions in: aDenotativeObjectBrowser ]
		ifFalse: [ self addDenotativeObjectLabelsTo: labels andActionsTo: actions in: aDenotativeObjectBrowser ].

	lines add: labels size.
	alternatives do: [ :each |
		labels add: each.
		actions add: [ parser substituteVariable: each atInterval: interval ]].
	
	lines add: labels size.
	labels add: 'cancel'.
	
	caption := 'Unknown variable: ' , name , ' please correct, or cancel:'.
	choice := (PopUpMenu labelArray: labels lines: lines) startUpWithCaption: caption.
	
	self resume: (actions at: choice ifAbsent: [ ]).

! !
!Class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726079!
addSharedPool: aSharedPool 
	"Add the argument, aSharedPool, as one of the receiver's shared pools. 
	Create an error if the shared pool is already one of the pools.
	This method will work with shared pools that are plain Dictionaries or thenewer SharedPool subclasses"

	(self sharedPools includes: aSharedPool)
		ifTrue: [^self error: 'This is already in my shared pool list'].
	sharedPools
		ifNil: [sharedPools _ OrderedCollectio with: aSharedPool]
		ifNotNil: [sharedPools add: aSharedPool]! !
!OrderedCollectionTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726099!
testIsCollection
	self assert: (OrderedCollectio new is: #Collection).! !
!ObjectExplorerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726105!
objectsToSkipDuringRescan
	"Avoid observing side effects of the reference finder itself"

	| answer |
	answer := OrderedCollectio
		with: self
		with: self model
		with: self model getCurrentSelection.
	self allMorphsDo: [:each | answer add: each].
	^answer! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726117!
createCategories

	| classCategories |
	
	categories := OrderedCollectio with: 'new ...'.
	lines := OrderedCollectio with: 1. 
	classCategories := startClass methodCategoriesAsSortedCollection.
	
	reject := classCategories asSet.
	reject
		add: ClassOrganizer nullCategory;
		add: ClassOrganizer default.
	
	startClass isMeta ifTrue: [ self initializeCategoriesWhenMeta: classCategories].
	rejectingFirst ifFalse: [ categories addAll: classCategories ]! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726136 overrides: 50626265!
warnings
	
	^typeCheckers 
		inject: OrderedCollectio new
		into: [ :warnings :typeChecker |
			warnings addAll: typeChecker warnings.
			warnings ]! !
!MethodTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726145!
initializeErrorsWarningsAndProblems
	
	errors := OrderedCollectio new.
	warnings := OrderedCollectio new.
	problems := OrderedCollectio new.! !
!FileList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726153!
itemsForAnyFile2
	"Answer a list of universal services that could apply to any file"
	
	| services |
	services _ OrderedCollectio new.
	(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse: [
		services add: self serviceGetHex ].
	services add: self serviceCopyName.
	services add: self serviceViewContentsInWorkspace.
	^ services! !
!ChangeSelectorKeepingParameters class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726169!
from: anOldSelector to: aNewSelector in: aClassToRefactor

	| implementors senders |

	implementors := OrderedCollectio new.
	senders := OrderedCollectio new.

	self 
		addImplementorsOf: anOldSelector 
		to: implementors 
		andSendersTo: senders 
		forClassAndMetaOf: aClassToRefactor theNonMetaClass.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: (self collectCompiledMethodsOf: senders)! !
!FunctionGraphMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726187 overrides: 16794195!
initialize
	super initialize.
	extent _ 320@240.
	functions _ OrderedCollectio new.
	colors _ OrderedCollectio new.
	yRangeInvalid := true! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726195!
allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."
	"Answer a Collection of all the methods that call on aLiteral."
	| aCollection special byte |

	#(23 48 'fred' (new open:label:)) size.
	"Example above should find #open:label:, though it is deeply embedded here."

	aCollection _ OrderedCollectio new.
	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:b | byte _ b ].
	self allBehaviorsDo: [:class | class addMethodsTo: aCollection thatReferenceTo: aLiteral special: special byte: byte ].
	
	^ aCollection! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726215!
firstOfBeginningOfLineOrEndOfIndentationLeftOf: position
	
	"Returns the first of beginning-of-line or end-of-indentation that appears to the left of the given position, wrapping around to the end of the line (i.e. the line is considered circular).
	This way, if the given position is beginning-of-line then end-of-indentation is returned."
	
	| currentLine beginningOfLine endOfIndentation stops |
	
	currentLine _ textComposition lines at: (textComposition lineIndexFor: position).
	beginningOfLine _ currentLine first.
	endOfIndentation _ self privateCurrentString
		skipDelimiters: (UnicodeString with: Character tab)
		startingAt: beginningOfLine.
		
	stops _ OrderedCollectio with: endOfIndentation with: beginningOfLine.
	^ stops detect: [ :stop | stop < position ] ifNone: [endOfIndentation]! !
!ClassFactoryForTesting methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726245 overrides: 16920235!
initialize

	| timestamp |
	super initialize.
	timestamp := Time millisecondClockValue.
	testSystemCategory _ '__', timestamp asString, '_TestSystemCategory__'.
	testExtensionSystemCategory _ '__', timestamp asString, '_TestExtensionSystemCategory__'.
	testSharedPool _ #DeleteMeSharedPool.

	createdClasses _ OrderedCollectio new.! !
!MethodTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726259!
errorsAndWarningsAsMethodReferencesWithProblems: showingProblems prefixing: aPrefix
	
	| listToShow |
	
	listToShow := self addMethodReferencesOf: errors prefixing: aPrefix to: OrderedCollectio new.
	self addMethodReferencesOf: warnings prefixing: aPrefix to: listToShow.
	showingProblems ifTrue: [ self addMethodReferencesOf: problems prefixing: aPrefix to: listToShow ].
	
	^listToShow! !
!PathCurveToSmoothCommand methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726276 overrides: 50431909!
buildFrom: commandChar stream: aStream

	| x2 y2 x y |
	super buildFrom: commandChar stream: aStream.
	toPoints _ OrderedCollectio new.
	control2Points _ OrderedCollectio new.
	[
		x2 _ aStream nextNumber.
		y2 _ aStream nextNumber.
		x _ aStream nextNumber.
		y _ aStream nextNumber.
		y notNil ] whileTrue: [
			toPoints add: x@y.
			control2Points add: x2@y2 ]! !
!OrderedDictionaryTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726292!
testRemove
	| data dict dataToRemove desiredOrder orderingByDo |

	"Test that #do:, #select: and #collect: iterate in the correct order"
	dict _ OrderedDictionary new.
	data _ self sampleData.
	dataToRemove _ self sampleData2.

	data do: [ :pair |
		dict at: pair first put: pair second ].
	dataToRemove do: [ :pair |
		dict removeKey: pair first ].

	orderingByDo _ Array streamContents: [ :strm | dict do: [ :each | strm nextPut: each ]].

	desiredOrder _ OrderedCollectio new.
	data do: [ :pair | desiredOrder add: pair second ].
	dataToRemove do: [ :pair | desiredOrder remove: pair second ].
	
	self assert: orderingByDo = desiredOrder asArray.! !
!MessageSendingBlocksVariablesToExtractFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:39:51' prior: 50726318 overrides: 16902254!
value

	messageNode arguments do: [:argument |
		currentScopeTemporaries := Bag new.
		argument accept: self].

	variablesToExtract remove: 'true' ifAbsent: [nil].
	variablesToExtract remove: 'false' ifAbsent: [nil].
	variablesToExtract remove: 'nil' ifAbsent: [nil].
	variablesToExtract remove: variableToExclude ifAbsent: [nil].

	^OrderedCollectio newFrom: variablesToExtract! !
!Object methodsFor: 'tracing' stamp: 'mtf 8/19/2008 22:33' prior: 50734963!
outboundPointers
"Answers a list of all objects I am causing not to be garbage-collected"

	| collection |
	collection := OrderedCollection new.
	self outboundPointersDo: [:ea | collection add: ea].
	^ collection! !

!testRun: #TrieTest #testAllMesssagesLikeDicionary stamp: 'psm 10/17/2023 21:41:40'!
PASSED!

!testRun: #TrieTest #testAllMesssagesLikeSet stamp: 'psm 10/17/2023 21:41:46'!
PASSED!

!testRun: #TrieTest #testIncludesReturnsFalseForObjectsThatAreNotString stamp: 'psm 10/17/2023 21:41:46'!
PASSED!

!testRun: #TrieTest #testIncludesReturnsFalseForStringsNotIncluded stamp: 'psm 10/17/2023 21:41:46'!
PASSED!

!testRun: #TrieTest #testIncludesReturnsTrueForIncludedStrings stamp: 'psm 10/17/2023 21:41:46'!
PASSED!

!testRun: #TrieTest #testKeyNotFoundSignalTheRightMessage stamp: 'psm 10/17/2023 21:41:46'!
PASSED!

!testRun: #TrieTest #testPrefixIteration stamp: 'psm 10/17/2023 21:41:46'!
PASSED!

!testRun: #TrieTest #testPrefixIteration2 stamp: 'psm 10/17/2023 21:41:49'!
PASSED!

!testRun: #TrieTest #testRemoveLikeDicionary stamp: 'psm 10/17/2023 21:41:55'!
PASSED!

!testRun: #TrieTest #testRemoveLikeSet stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TrieTest #testSetProtocol stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testAdd stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testAddRules stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testAlwaysFulfills stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testAsOrderedCollection stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testAsSortedCollection stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testComposite stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testCreation stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testDo stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testExcludedFromTo stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testExcludedIn stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testExcludes stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testExcludesAll stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testIncludedFromTo stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testIncludedIn stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testIncludes stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testIncludesAll stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testInvalidDo stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testIsEmpty stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testRemoveAllRules stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testRemoveIfAbsent stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testRemoveRule stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testRulesCopy stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testRulesThatInclude stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testSize stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #DefinedByRulesTest #testSpecies stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testAllAccessToInstVarReturnsAccessReceiversBranch stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testAllAccessToIsEmptyForVariableNotDefinedInClass stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testAllBroadAccessToReturnsAccessInAllHierarchy stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testAllSuperclassesUpToFailsWhenWantsToStopOnInvalidSuperclass stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testAllSuperclassesUpToPutsFirstSuperclassesFirst stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testAllSuperclassesUpToStopsOnRightClass stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testAllUnreferencedInstanceVariablesReturnsOnlyUnreferencedVariables stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testHasReferencesToInstanceVariableNamedLooksInClassOnly stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testHighestClassImplementingReturnsReceiverWhenNoOtherSuperclassImplementsSelector stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testHighestClassImplementingReturnsTheTopSuperclassImplementingSelector stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testHighestClassImplementingValuesIfNoneBlockWhenSelectorIsNotImplemented stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testIsInstanceVariableNamedReferencedInHierarchyLooksReferencesInHierarchy stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testProtoObjectAllRegularInstVarNamesDoesNotFail stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testUnreferencedInstanceVariablesReturnsOnlyUnreferencedVariables stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #BehaviorTest #testWithAllSuperclassesUpToIncludesReceiverClass stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testAddArgentineLaw23555Rule stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testAddCardinalDayMonthRuleRule stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testAddDateRule stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testAddDayOfMonthRule stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testAddDayRule stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testAddRuleFrom stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testAddRuleFromTo stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testAddRules stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testAddRulesFrom stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testAddRulesFromTo stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testDateRule stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testDatesBetween stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testDayOfMonthRule stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testDayRule stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testExcludedFromTo stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testExcludedIn stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testExcludes stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testExcludesAll stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testFromString stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testHash stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testIncludedFromTo stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testIncludedIn stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testIncludes stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testIncludesAll stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testNegatedIncludes stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testNegatedNext stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testNextNegativeDuration stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testNextPositiveDuration stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testNumberOfDatesBetweenTwoDates stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testPrintOn stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testRemoveAllRules stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testRuleFromTo stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testRules stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testRulesThatIncludeADate stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!testRun: #TimeLineFilterTest #testStream stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:02'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:02'!
m1 anInstVar ifNil: [ super isNil ]! !

!classDefinition: #ConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:02'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #NullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:02'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test01BlocksToExtractMustNotContainReferencesToSuper stamp: 'psm 10/17/2023 21:42:02'!
PASSED!

!classRemoval: #NullClass stamp: 'psm 10/17/2023 21:42:04'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'psm 10/17/2023 21:42:04'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:04'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:05'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:05'!
m1 anInstVar ifNil: [ anInstVar := 1 ]! !

!classDefinition: #ConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:05'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #NullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:05'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test02BlocksToExtractMustNotContainAssignmentsToVariablesThatAreNotTemporals stamp: 'psm 10/17/2023 21:42:05'!
PASSED!

!classRemoval: #NullClass stamp: 'psm 10/17/2023 21:42:06'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'psm 10/17/2023 21:42:06'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:07'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:07'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:07'!
m1 anInstVar ifNil: [
			1 = 2 ifFalse: [ |aTemp| aTemp := 3]]! !

!classDefinition: #ConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:07'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #NullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:07'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test03BlocksToExtractCanAssignToTemporalsOfNestedBlocks stamp: 'psm 10/17/2023 21:42:07'!
PASSED!

!classRemoval: #NullClass stamp: 'psm 10/17/2023 21:42:08'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'psm 10/17/2023 21:42:08'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:08'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:08'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:08'!
m1 anInstVar ifNil: [ |aTemp| aTemp := 2]! !

!classDefinition: #ConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:08'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #NullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:08'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test04BlocksToExtractCanAssignToTemporalsOfBlocks stamp: 'psm 10/17/2023 21:42:08'!
PASSED!

!classRemoval: #NullClass stamp: 'psm 10/17/2023 21:42:10'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'psm 10/17/2023 21:42:10'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:10'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:10'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:10'!
m1 anInstVar ifNil: [^anInstVar is Nil]! !

!classDefinition: #ConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:10'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #NullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:10'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test07BlocksToExtractMustNotContainReturnStatements stamp: 'psm 10/17/2023 21:42:10'!
PASSED!

!classRemoval: #NullClass stamp: 'psm 10/17/2023 21:42:12'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'psm 10/17/2023 21:42:12'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:12'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactorSuperclass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:12'!
RefactoringClassTestData subclass: #AClassToRefactorSuperclass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:12'!
AClassToRefactorSuperclass subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:12'!
m1 anInstVar ifNil: [anInstVar isNil ]! !

!classDefinition: #ConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:12'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #NullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:12'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test08InstanceVariableMustBelongToTheClassToRefactor stamp: 'psm 10/17/2023 21:42:12'!
PASSED!

!classRemoval: #NullClass stamp: 'psm 10/17/2023 21:42:14'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'psm 10/17/2023 21:42:14'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:14'!
AClassToRefactorSuperclass subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactorSuperclass stamp: 'psm 10/17/2023 21:42:15'!
RefactoringClassTestData subclass: #AClassToRefactorSuperclass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:15'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:15'!
m1 anInstVar ifNil: [anInstVar isNil ]! !

!classDefinition: #AClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:15'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test09ConcreteClassMustBeDifferentToNullClass stamp: 'psm 10/17/2023 21:42:15'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:16'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'psm 10/17/2023 21:42:16'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:16'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClasOutsideTheHierarchy category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:16'!
RefactoringClassTestData subclass: #AClasOutsideTheHierarchy
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClasOutsideTheHierarchy methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:16'!
m1 anInstVar ifNil: [anInstVar isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:16'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:16'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test10MethodsMustBelongToTheHierarchyToRefactor stamp: 'psm 10/17/2023 21:42:16'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:18'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:18'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:18'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClasOutsideTheHierarchy stamp: 'psm 10/17/2023 21:42:19'!
RefactoringClassTestData subclass: #AClasOutsideTheHierarchy
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:19'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:19'!
m1 anInstVar ifNil: [anInstVar isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:19'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:19'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test13MessageNodesMustNotBeDuplicated stamp: 'psm 10/17/2023 21:42:19'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:20'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:20'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:21'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:21'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:21'!
m1 self ifNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:21'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:21'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test14MessageNodesReceiverMustBeTheInstVar stamp: 'psm 10/17/2023 21:42:21'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:22'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:22'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:23'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:23'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:23'!
m1 anInstVar ifNil: [ 1 + 1 ]! !

!classDefinition: #ConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:23'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:23'!
unaryPolymorphicSelector! !

!classDefinition: #NullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:23'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test15ConcreteClassMustNotContainAnyPolymorphicSelector stamp: 'psm 10/17/2023 21:42:23'!
PASSED!

!classRemoval: #NullClass stamp: 'psm 10/17/2023 21:42:24'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'psm 10/17/2023 21:42:24'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:25'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:25'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:25'!
m1 anInstVar ifNil: [ 1 + 1 ]! !

!classDefinition: #NullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:25'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!NullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:25'!
unaryPolymorphicSelector! !

!classDefinition: #ConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:25'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test16NullClassMustNotContainAnyPolymorphicSelector stamp: 'psm 10/17/2023 21:42:25'!
PASSED!

!classRemoval: #NullClass stamp: 'psm 10/17/2023 21:42:26'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRenamed: #OrderedCollectio as: #OrderedCollectiodfdsgg stamp: 'psm 10/17/2023 21:42:26'!
Smalltalk renameClassNamed: #OrderedCollectio as: #OrderedCollectiodfdsgg!

!classRemoval: #ConcreteClass stamp: 'psm 10/17/2023 21:42:27'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50733663!
testCreationWithMeasuresCopiesCollection
	"This test verifies that when bag is created using the private message  #measures:,
	the collection that goes as collaborating is copied"
	
	| measures measureBag |

	measures := OrderedCollectiodfdsgg
		with: self tenPesos
		with: self twentyDollars
		with: self tenEuros.
	measureBag := CompoundMeasure measures: measures.

	measures add: self oneMeter.
	self assert: measureBag numberOfMeasures = 3.
	self assert: (measureBag atSameBaseUnitAs: self peso) = self tenPesos.
	self assert: (measureBag atSameBaseUnitAs: self dollar) = self twentyDollars.
	self assert: (measureBag atSameBaseUnitAs: self euro) = self tenEuros


! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50732418!
buildLabelsPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollectiodfdsgg with: (Color fromHexString: '#fCD89A') with: 'Sunset'.
	ocean := OrderedCollectiodfdsgg with: (Color fromHexString: '#EFF6E0') with: 'Ocean'.
	forest := OrderedCollectiodfdsgg with: (Color fromHexString: '#8DAA91') with: 'Forest'.
	ash := OrderedCollectiodfdsgg with: (Color fromHexString: '#000000') with: 'Ash'.
	light := OrderedCollectiodfdsgg with: (Color fromHexString: '#946846') with: 'Light'.
	
	labelsPalette := OrderedCollectiodfdsgg with: sunset with: ocean with: forest with: ash with: light.! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50727728!
simpleEnsureTestResults

	^OrderedCollectiodfdsgg new
		add: self doSomethingString;
		add: self doSomethingElseString;
		add: self doYetAnotherThingString;
		yourself! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50726934!
log

	log == nil
		ifTrue: [log := OrderedCollectiodfdsgg new].
	^log! !
!FileList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50726458!
itemsForNoFile

	| services |
	services := OrderedCollectiodfdsgg new: 6.
	services add: self serviceSortByName.
	services add: self serviceSortBySize.
	services add: (self serviceSortByDate useLineAfter: true).
	services add: self serviceAddNewFile.
	services add: self serviceAddNewDirectory.
	^ services

		! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50730695!
askAddedInstVars: classList
	| pairList pairClasses index pls |
	"Ask the author whether these newly added inst vars need to be non-nil"

	pairList _ OrderedCollectiodfdsgg new.
	pairClasses _ OrderedCollectiodfdsgg new.
	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."
	classList do: [ :cls |
		| newStruct oldStruct |
		newStruct _ (cls allInstVarNames).
		oldStruct _ (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.
		newStruct do: [ :instVarName |
			(oldStruct includes: instVarName) ifFalse: [
				pairList add: cls name, ' ', instVarName.
				pairClasses add: cls]]].

	pairList isEmpty ifTrue: [^ #()].
	[
		index _ PopUpMenu withCaption: 'These instance variables were added.
When an old project comes in, newly added 
instance variables will have the value nil.
Click on items to remove them from the list.
Click on any for which nil is an OK value.'
			chooseFrom: pairList, #('all of these need a non-nil value'
						'all of these are OK with a nil value').
		(index <= (pls _ pairList size)) & (index > 0) ifTrue: [
			pairList removeAt: index.
			pairClasses removeAt: index].
		index = (pls + 2) ifTrue: ["all are OK" ^ #()].
		pairList isEmpty | (index = (pls + 1)) "all need conversion, exit"] whileFalse.

	^ pairClasses asSet asArray	"non redundant"! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50729964 overrides: 50626282!
errors
	
	^typeCheckers 
		inject: OrderedCollectiodfdsgg new
		into: [ :errors :typeChecker |
			errors addAll: typeChecker errors.
			errors ]! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50726425!
testCreationWithMeasures

	| measures measureBag |

	measures := OrderedCollectiodfdsgg with: self tenPesos with: self twentyDollars with: self tenEuros.	
	measureBag := CompoundMeasure measures: measures.
	
	self assert: measureBag numberOfMeasures = 3.
	self assert: (measureBag atSameBaseUnitAs: self peso) = self tenPesos.
	self assert: (measureBag atSameBaseUnitAs: self dollar) = self twentyDollars.
	self assert: (measureBag atSameBaseUnitAs: self euro) = self tenEuros! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50729290!
browseAllStoresInto: instVarName from: aClass
	"Create and schedule a Message Set browser for all the receiver's methods
	or any methods of a subclass/superclass that refer to the instance variable name."

	"self new browseAllStoresInto: 'contents' from: Collection."

	| coll |
	coll := OrderedCollectiodfdsgg new.
	aClass withAllSubAndSuperclassesDo: [:class |
		(class whichSelectorsStoreInto: instVarName) do: [:sel |
			coll add: (MethodReference class: class selector: sel)]].
	^ self
		browseMessageList: coll
		name: 'Stores into ' , instVarName
		autoHighlight: instVarName
		allOccurrences: true! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50735990!
init: aClass context: aContext notifying: req
	requestor := req.
	class := aClass.
	nTemps := 0.
	supered := false.
	self initScopeAndLiteralTables.
	"No Tweak Fields in Cuis"
	class variablesAndOffsetsDo: [ :variable "<String>" :offset "<Integer>" |
		scopeTable
			at: variable
			put: (offset >= 0
					ifTrue: [InstanceVariableNode new
								name: variable index: offset]
					ifFalse: [MaybeContextInstanceVariableNode new
								name: variable index: offset negated])].
	aContext ifNotNil: [
		| homeNode |
		homeNode := self bindTemp: Encoder doItInContextName.
		"0th temp = aContext passed as arg"
		aContext tempNames withIndexDo: [ :variable :index |
			variable ~= Encoder doItInContextName ifTrue: [
				scopeTable
					at: variable
					put: (MessageAsTempNode new
						receiver: homeNode
						selector: #namedTempAt:
						arguments: (Array with: (self encodeLiteral: index))
						precedence: 3
						from: self)]]].
	sourceRanges := Dictionary new: 32.
	globalSourceRanges := OrderedCollectiodfdsgg new: 32! !
!PlusInfinity methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50728940 overrides: 50524003!
composeWithNumber: aNumber

	^CompoundMeasure measures: (OrderedCollectiodfdsgg with: self with: aNumber)! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50731016!
allActualSendersOn: aSentCompiledMethod 
	
	| allSenders sureSenders possibleSenders actualMessageSendersCollector |
	
	allSenders := self allCallsOn: aSentCompiledMethod selector.
	
	sureSenders := OrderedCollectiodfdsgg new.
	possibleSenders := OrderedCollectiodfdsgg new.
	
	allSenders do: [ :aSender | 
		actualMessageSendersCollector := aSender actualSendersOf: aSentCompiledMethod.
		actualMessageSendersCollector hasSureMessageSends ifTrue: [ sureSenders add: aSender ].
		actualMessageSendersCollector hasPossibleMessageSends ifTrue: [ 
			possibleSenders add: (PossibleSender in: aSender withPossibleMessageSends: actualMessageSendersCollector possibleMessageSends) ]].
		
	^Array with: sureSenders with: possibleSenders ! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50731873!
stackOfSize: limit 
	"Answer an OrderedCollection of the top 'limit' contexts
	 on the receiver's sender chain."

	| stack ctxt |
	stack := OrderedCollectiodfdsgg new.
	stack addLast: (ctxt := self).
	[(ctxt := ctxt sender) notNil
	 and: [stack size < limit]] whileTrue:
		[stack addLast: ctxt].
	^stack! !

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:27'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50729928!
removeOlderMethodVersions
	"Remove older versions of entries from the receiver."

	| newChangeList newList found |
	newChangeList _ OrderedCollectiodfdsgg new.
	newList _ OrderedCollectiodfdsgg new.
	found _ OrderedCollectiodfdsgg new.
	changeList reverseWith: list do: [ :chRec :strNstamp | | str |
		str _ strNstamp copyUpTo: $;.
		(found includes: str) ifFalse: [
			found add: str.
			newChangeList add: chRec.
			newList add: strNstamp]].
	newChangeList size < changeList size ifTrue: [
		changeList _ newChangeList reversed.
		list _ newList reversed.
		listIndex _ 0.
		self clearSelections ].
	self changed: #list! !
!ActualImplementorsTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50734939!
test09WhenNoHighestClassImplementingSelectorIfNoneBlockIsEvaluated

	self assert: (OrderedCollectiodfdsgg highestClassImplementing: #none ifNone: [ true ])! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50728244!
keysSortedSafely
	"Answer a sorted Collection containing the receiver's keys."
	| sortedKeys |
	sortedKeys _ OrderedCollectiodfdsgg new: self size.
	self keysDo: [:each | sortedKeys addLast: each].
	sortedKeys sort:
		[ :x :y |  "Should really be use <obj, string, num> compareSafely..."
		((x isString and: [y isString])
			or: [x isNumber and: [y isNumber]])
			ifTrue: [x < y]
			ifFalse: [x class == y class
				ifTrue: [x printString < y printString]
				ifFalse: [x class name < y class name]]].
	^ sortedKeys! !
!ChangeSelectorKeepingParameters class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50729323!
from: anOldSelector to: aNewSelector inCategoryOf: aClass organizedBy: anOrganization

	| implementors senders |

	implementors := OrderedCollectiodfdsgg new.
	senders := OrderedCollectiodfdsgg new.

	self 
		addImplementorsOf: anOldSelector 
		to: implementors 
		andSendersTo: senders
		inCategory: aClass category 
		organizedBy: anOrganization.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: (self collectCompiledMethodsOf: senders)
! !

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:27'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27'!
m1 anInstVar ifNil: [ 1 + 1 ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:27'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:27'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27'!
replaceIfNilSelector! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50731168!
testNumberOfDatesBetweenTwoDates

	| timeLineFilter rule1 rule2 rule3 |

	timeLineFilter := TimeLineFilter new.
	rule1 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 14).
	rule2 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 15).
	rule3 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 16).

	timeLineFilter addRules: (OrderedCollectiodfdsgg with: rule1 with: rule2 with: rule3).

	self assert: (timeLineFilter negated numberOfDatesBetween: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 01)
		and: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 20)) = (TimeUnits day with: 17)! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27'!
replaceIfNilSelector
	1 + 1! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50737778!
replaceIfNilSelector
	^1 + 1! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50737697!
m1 anInstVar replaceIfNilSelector! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50737787!
m1 anInstVar replaceIfNilSelector! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50737792!
m1 anInstVar replaceIfNilSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27'!
nilIfNullObject
	^nil! !
!MessageKeywordsAndParametersTable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27' prior: 50733424!
buildColumnTitlesRowFor: inputColumnsTitles

	| columnsTitles row |

	row := LayoutMorph newRow.
	row color: self backgroundColor.
	row separation: self columnSeparation.

	columnsTitles := OrderedCollectiodfdsgg newFrom: inputColumnsTitles.
	columnsTitles addFirst: ''.
	self needsToReorderRows ifTrue: [columnsTitles addLast: 'Change order'].
	columnsTitles withIndexDo: [:aColumnTitle :columnIndex | | columnTitleLayoutSpec titleLayout |
		titleLayout := LayoutMorph newRow.
		titleLayout color: self backgroundColor .
		titleLayout axisEdgeWeight: #center.
		titleLayout addMorph: (LabelMorph contents: aColumnTitle).
		columnTitleLayoutSpec := LayoutSpec fixedWidth: (columnWidths at: columnIndex).
		row
			addMorph: titleLayout
			layoutSpec: columnTitleLayoutSpec].

	^row

	! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:27'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test17WhenThereAreNoVariablesToParametrizeReplacesIfNilWithPolymorphicMessageSend stamp: 'psm 10/17/2023 21:42:27'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:29'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:29'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:30'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:30'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:30'!
m1 anInstVar ifNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:30'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:30'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:30'!
with: p1! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:30'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:30' prior: 50737873!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:30' prior: 50737849!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:30' prior: 50737881!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:30'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:30' prior: 50737886!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:30'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:30'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test18WhenThereAreVariablesToParametrizeReplacesIfNilWithPolymorphicMessageSend stamp: 'psm 10/17/2023 21:42:30'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:32'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:32'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:33'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:33'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:33'!
m1 anInstVar ifNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:33'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:33'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:33'!
with: p1! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:33'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:33' prior: 50737967!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:33' prior: 50737943!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:33' prior: 50737975!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:33'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:33' prior: 50737980!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:33'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:33'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test19WhenIfNilCheckHasOneKeywordReplacesIfNilWithPolymorphicMessageSend stamp: 'psm 10/17/2023 21:42:33'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:34'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:35'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:35'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:35'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:35'!
m1 anInstVar ifNil: [ self isNil ] ifNotNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:35'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:35'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:35'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:35' prior: 50738059!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:35'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:35' prior: 50738067!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:35' prior: 50738037!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:35' prior: 50738075!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:35'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:35' prior: 50738080!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:35'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:35'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test20WhenIfNilCheckHasTwoKeywordsReplacesIfNilWithPolymorphicMessageSend stamp: 'psm 10/17/2023 21:42:35'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:36'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:37'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:37'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:37'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:37'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:37'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:37'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:37'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:37' prior: 50738159!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:37'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:37' prior: 50738167!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:38' prior: 50738137!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:38' prior: 50738175!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:38'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:38' prior: 50738180!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:38'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:38'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test21WhenIfNilCheckHasIsNilReplacesIfNilWithPolymorphicMessageSend stamp: 'psm 10/17/2023 21:42:38'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:39'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:39'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:40'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:40'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:40'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:40'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:40'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:40'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:40' prior: 50738259!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:40'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:40' prior: 50738267!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:40' prior: 50738237!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:40' prior: 50738275!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:40'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:40' prior: 50738280!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:40'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:40'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test22PolymorphicMessageIsAddedToTheConcreteClass stamp: 'psm 10/17/2023 21:42:40'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:41'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:41'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:42'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:42'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:42'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:42'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:42'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:42'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:42' prior: 50738358!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:42'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:42' prior: 50738366!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:42' prior: 50738336!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:42' prior: 50738374!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:42'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:42' prior: 50738379!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:42'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:42'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test23PolymorphicMessageIsAddedToTheConcreteClassWithChosenParameterNames stamp: 'psm 10/17/2023 21:42:42'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:43'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:44'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:44'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:44'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:44'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:44'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:44'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:44'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:44' prior: 50738458!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:44'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:44' prior: 50738466!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:44' prior: 50738436!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:44' prior: 50738474!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:44'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:44' prior: 50738479!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:44'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:44'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test24PolymorphicMessageIsAddedToTheConcreteClassReplacingParametrizedVariables stamp: 'psm 10/17/2023 21:42:44'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:46'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!Parser methodsFor: 'error handling' stamp: 'jmv 7/3/2019 10:11:21' prior: 50404256 overrides: 16931658!
notify: string at: location
	| adjustedLocation |
	adjustedLocation _ location - self sourceDelta.
	requestor
		ifNil: [
			(encoder == self or: [encoder isNil]) ifTrue: [^ self fail  "failure setting up syntax error"].
				SyntaxErrorNotification
					inClass: encoder classEncoding
					category: category
					withCode: 
						(source contents
							copyReplaceFrom: adjustedLocation
							to: adjustedLocation - 1
							with: string , ' ->')
					doitFlag: doitFlag
					errorMessage: string
					location: adjustedLocation]
		ifNotNil: [
			requestor
					notify: string , ' ->'
					at: adjustedLocation
					in: source].
	^self fail! !

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:46'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:47'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:47'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:47'!
m1 anInstVar ifNil: [ self isNil ] ifNotNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:47'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:47'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:47'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:47' prior: 50738582!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:47'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:47' prior: 50738590!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:47' prior: 50738560!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:47' prior: 50738598!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:47'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:47' prior: 50738603!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:47'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:47'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test25ReplacesIfNilIfNotNilWithPolymorphicMessageSend stamp: 'psm 10/17/2023 21:42:47'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:48'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:49'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:49'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:49'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:49'!
m1 anInstVar ifNotNil: [ self isNil ] ifNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:49'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:49'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:49'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:49' prior: 50738682!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:49'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:49' prior: 50738690!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:49' prior: 50738660!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:49' prior: 50738698!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:49'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:49' prior: 50738703!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:49'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:49'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test26ReplacesIfNotNilIfNilWithPolymorphicMessageSend stamp: 'psm 10/17/2023 21:42:49'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:51'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:51'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:52'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:52'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:52'!
m1 anInstVar ifNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:52'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:52'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:52'!
with: p1! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:52'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:52' prior: 50738784!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:52' prior: 50738760!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:52' prior: 50738792!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:52'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:52' prior: 50738797!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:52'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:52'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test27ReplacesIfNilWithPolymorphicMessageSend stamp: 'psm 10/17/2023 21:42:52'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:53'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:54'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:54'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:54'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:54'!
m1 anInstVar ifNotNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:54'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:54'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:54'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:54' prior: 50738874!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:54'!
with: p1! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:54' prior: 50738853!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:54' prior: 50738886!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:54'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:54' prior: 50738891!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:54'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:55'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test28ReplacesIfNotNilWithPolymorphicMessageSend stamp: 'psm 10/17/2023 21:42:55'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:56'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:56'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:57'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:57'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:57'!
m1 anInstVar isNil ifTrue: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:57'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:57'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:57'!
with: p1! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:57'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:57' prior: 50738971!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:57' prior: 50738947!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:57' prior: 50738979!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:57'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:57' prior: 50738984!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:57'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:57'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test29ReplacesIsNilIfTrueWithPolymorphicMessageSend stamp: 'psm 10/17/2023 21:42:57'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:42:58'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:42:59'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:42:59'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:59'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:59'!
m1 anInstVar isNil ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:59'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:42:59'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:59'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:59' prior: 50739062!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:59'!
with: p1! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:59' prior: 50739041!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:59' prior: 50739074!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:59'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:59' prior: 50739079!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:59'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:42:59'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test30ReplacesIsNilIfFalseWithPolymorphicMessageSend stamp: 'psm 10/17/2023 21:42:59'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:43:00'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:43:01'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:43:01'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:01'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:01'!
m1 anInstVar isNil ifTrue: [self isNil] ifFalse: [self isNil]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:01'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:01'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:01'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:01' prior: 50739158!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:01'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:01' prior: 50739166!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:01' prior: 50739136!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:01' prior: 50739174!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:01'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:01' prior: 50739179!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:01'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:01'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test31ReplacesIsNilIfTrueIfFalseWithPolymorphicMessageSend stamp: 'psm 10/17/2023 21:43:01'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:43:02'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:43:03'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:43:03'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:03'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:03'!
m1 anInstVar isNil ifFalse: [self isNil] ifTrue: [self isNil]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:03'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:03'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:03'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:03' prior: 50739258!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:03'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:03' prior: 50739266!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:03' prior: 50739236!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:03' prior: 50739274!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:03'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:03' prior: 50739279!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:03'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:03'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test32ReplacesIsNilIfFalseIfTrueWithPolymorphicMessageSend stamp: 'psm 10/17/2023 21:43:03'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:43:04'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:43:05'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:43:05'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:06'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:06'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:06'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:06'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:06'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:06' prior: 50739358!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:06'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:06' prior: 50739366!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:06' prior: 50739336!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:06' prior: 50739374!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:06'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:06' prior: 50739379!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:06'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:06'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test33PolymorphicMessageIsAddedToTheNullClass stamp: 'psm 10/17/2023 21:43:06'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:43:07'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:43:07'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:43:08'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:08'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:08'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:08'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:08'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:08'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:08' prior: 50739457!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:08'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:08' prior: 50739465!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:08' prior: 50739435!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:08' prior: 50739473!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:08'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:08' prior: 50739478!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:08'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:08'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test34PolymorphicMessageIsAddedToTheNullClassWithChosenParameterNames stamp: 'psm 10/17/2023 21:43:08'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:43:09'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:43:09'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:43:10'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:10'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:10'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:10'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:10'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:10'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:10' prior: 50739557!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:10'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:10' prior: 50739565!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:10' prior: 50739535!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:10' prior: 50739573!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:10'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:10' prior: 50739578!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:10'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:10'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test35PolymorphicMessageIsAddedToTheNullClassReplacingParametrizedVariables stamp: 'psm 10/17/2023 21:43:10'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:43:11'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:43:11'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:43:12'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:12'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:12'!
m1 anInstVar isNil ifFalse: [self isNil]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:12'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:12'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:12'!
with: p1
	p1 isNil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:12' prior: 50739656!
with: p1
	^p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:12'!
with: p1! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:12' prior: 50739635!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:12' prior: 50739668!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:12'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:12' prior: 50739673!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:12'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:12'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test36WhenNoNullBlockIsPresentEmptyPolymorphicMessageIsAddedToTheNullClass stamp: 'psm 10/17/2023 21:43:12'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:43:13'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:43:14'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:43:14'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:14'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:14'!
m1 anInstVar isNil ifTrue: [self isNil]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:14'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:14'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:14'!
with: p1! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:14'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:14' prior: 50739754!
with: p1
	^p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:14' prior: 50739730!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:14' prior: 50739762!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:14'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:14' prior: 50739767!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:14'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:14'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test37WhenNoConcreteBlockIsPresentEmptyPolymorphicMessageIsAddedToTheConcreteClass stamp: 'psm 10/17/2023 21:43:14'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:43:15'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:43:16'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:43:16'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:16'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:16'!
m1 anInstVar ifNil: [1+1. 2+2]! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:16'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:16'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:16'!
unaryPolymorphicSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:16'!
unaryPolymorphicSelector
	1+1. 2+2! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:16' prior: 50739849!
unaryPolymorphicSelector
	1+1. ^2+2! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:16' prior: 50739824!
m1 anInstVar unaryPolymorphicSelector! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:16' prior: 50739859!
m1 anInstVar unaryPolymorphicSelector! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:16'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:16' prior: 50739864!
m1 anInstVar unaryPolymorphicSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:16'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:16'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test38WhenThereAreMultipleStatementsPolymorphicMessageIsAddedToTheNullClass stamp: 'psm 10/17/2023 21:43:16'!
PASSED!

!classRemoval: #ANullClass stamp: 'psm 10/17/2023 21:43:17'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'psm 10/17/2023 21:43:18'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRenamed: #OrderedCollectiodfdsgg as: #OrderedCollections stamp: 'psm 10/17/2023 21:43:18'!
Smalltalk renameClassNamed: #OrderedCollectiodfdsgg as: #OrderedCollections!

!classRemoval: #AClassToRefactor stamp: 'psm 10/17/2023 21:43:18'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:18'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:18'!
m1
	anInstVar ifNil: [1+1. 2+2].
	anInstVar := nil.! !

!classDefinition: #AConcreteClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:18'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: '__Refactoring-TestData__' stamp: 'psm 10/17/2023 21:43:18'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:18'!
unaryPolymorphicSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:18'!
unaryPolymorphicSelector
	1+1. 2+2! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:18' prior: 50739952!
unaryPolymorphicSelector
	1+1. ^2+2! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:18' prior: 50739927!
m1
	anInstVar unaryPolymorphicSelector.
	anInstVar := nil.! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:18' prior: 50739962!
m1
	anInstVar unaryPolymorphicSelector.
	anInstVar := ANullClass new.! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:18'!
assignNullObjectIfNil: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50739968!
m1
	anInstVar unaryPolymorphicSelector.
	anInstVar := ANullClass new.! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19'!
nilIfNullObject
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19'!
nilIfNullObject
	^self! !

!testRun: #IntroduceNullObjectTest #test39ReplacesNilAssignmentsWithNullObject stamp: 'psm 10/17/2023 21:43:19'!
PASSED!
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737357!
testCreationWithMeasuresCopiesCollection
	"This test verifies that when bag is created using the private message  #measures:,
	the collection that goes as collaborating is copied"
	
	| measures measureBag |

	measures := OrderedCollections
		with: self tenPesos
		with: self twentyDollars
		with: self tenEuros.
	measureBag := CompoundMeasure measures: measures.

	measures add: self oneMeter.
	self assert: measureBag numberOfMeasures = 3.
	self assert: (measureBag atSameBaseUnitAs: self peso) = self tenPesos.
	self assert: (measureBag atSameBaseUnitAs: self dollar) = self twentyDollars.
	self assert: (measureBag atSameBaseUnitAs: self euro) = self tenEuros


! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737382!
buildLabelsPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollections with: (Color fromHexString: '#fCD89A') with: 'Sunset'.
	ocean := OrderedCollections with: (Color fromHexString: '#EFF6E0') with: 'Ocean'.
	forest := OrderedCollections with: (Color fromHexString: '#8DAA91') with: 'Forest'.
	ash := OrderedCollections with: (Color fromHexString: '#000000') with: 'Ash'.
	light := OrderedCollections with: (Color fromHexString: '#946846') with: 'Light'.
	
	labelsPalette := OrderedCollections with: sunset with: ocean with: forest with: ash with: light.! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737404!
simpleEnsureTestResults

	^OrderedCollections new
		add: self doSomethingString;
		add: self doSomethingElseString;
		add: self doYetAnotherThingString;
		yourself! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737413!
log

	log == nil
		ifTrue: [log := OrderedCollections new].
	^log! !
!FileList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737419!
itemsForNoFile

	| services |
	services := OrderedCollections new: 6.
	services add: self serviceSortByName.
	services add: self serviceSortBySize.
	services add: (self serviceSortByDate useLineAfter: true).
	services add: self serviceAddNewFile.
	services add: self serviceAddNewDirectory.
	^ services

		! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737432!
askAddedInstVars: classList
	| pairList pairClasses index pls |
	"Ask the author whether these newly added inst vars need to be non-nil"

	pairList _ OrderedCollections new.
	pairClasses _ OrderedCollections new.
	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."
	classList do: [ :cls |
		| newStruct oldStruct |
		newStruct _ (cls allInstVarNames).
		oldStruct _ (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.
		newStruct do: [ :instVarName |
			(oldStruct includes: instVarName) ifFalse: [
				pairList add: cls name, ' ', instVarName.
				pairClasses add: cls]]].

	pairList isEmpty ifTrue: [^ #()].
	[
		index _ PopUpMenu withCaption: 'These instance variables were added.
When an old project comes in, newly added 
instance variables will have the value nil.
Click on items to remove them from the list.
Click on any for which nil is an OK value.'
			chooseFrom: pairList, #('all of these need a non-nil value'
						'all of these are OK with a nil value').
		(index <= (pls _ pairList size)) & (index > 0) ifTrue: [
			pairList removeAt: index.
			pairClasses removeAt: index].
		index = (pls + 2) ifTrue: ["all are OK" ^ #()].
		pairList isEmpty | (index = (pls + 1)) "all need conversion, exit"] whileFalse.

	^ pairClasses asSet asArray	"non redundant"! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737479 overrides: 50626282!
errors
	
	^typeCheckers 
		inject: OrderedCollections new
		into: [ :errors :typeChecker |
			errors addAll: typeChecker errors.
			errors ]! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737487!
testCreationWithMeasures

	| measures measureBag |

	measures := OrderedCollections with: self tenPesos with: self twentyDollars with: self tenEuros.	
	measureBag := CompoundMeasure measures: measures.
	
	self assert: measureBag numberOfMeasures = 3.
	self assert: (measureBag atSameBaseUnitAs: self peso) = self tenPesos.
	self assert: (measureBag atSameBaseUnitAs: self dollar) = self twentyDollars.
	self assert: (measureBag atSameBaseUnitAs: self euro) = self tenEuros! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737506!
browseAllStoresInto: instVarName from: aClass
	"Create and schedule a Message Set browser for all the receiver's methods
	or any methods of a subclass/superclass that refer to the instance variable name."

	"self new browseAllStoresInto: 'contents' from: Collection."

	| coll |
	coll := OrderedCollections new.
	aClass withAllSubAndSuperclassesDo: [:class |
		(class whichSelectorsStoreInto: instVarName) do: [:sel |
			coll add: (MethodReference class: class selector: sel)]].
	^ self
		browseMessageList: coll
		name: 'Stores into ' , instVarName
		autoHighlight: instVarName
		allOccurrences: true! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737528!
init: aClass context: aContext notifying: req
	requestor := req.
	class := aClass.
	nTemps := 0.
	supered := false.
	self initScopeAndLiteralTables.
	"No Tweak Fields in Cuis"
	class variablesAndOffsetsDo: [ :variable "<String>" :offset "<Integer>" |
		scopeTable
			at: variable
			put: (offset >= 0
					ifTrue: [InstanceVariableNode new
								name: variable index: offset]
					ifFalse: [MaybeContextInstanceVariableNode new
								name: variable index: offset negated])].
	aContext ifNotNil: [
		| homeNode |
		homeNode := self bindTemp: Encoder doItInContextName.
		"0th temp = aContext passed as arg"
		aContext tempNames withIndexDo: [ :variable :index |
			variable ~= Encoder doItInContextName ifTrue: [
				scopeTable
					at: variable
					put: (MessageAsTempNode new
						receiver: homeNode
						selector: #namedTempAt:
						arguments: (Array with: (self encodeLiteral: index))
						precedence: 3
						from: self)]]].
	sourceRanges := Dictionary new: 32.
	globalSourceRanges := OrderedCollections new: 32! !
!PlusInfinity methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737564 overrides: 50524003!
composeWithNumber: aNumber

	^CompoundMeasure measures: (OrderedCollections with: self with: aNumber)! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737571!
allActualSendersOn: aSentCompiledMethod 
	
	| allSenders sureSenders possibleSenders actualMessageSendersCollector |
	
	allSenders := self allCallsOn: aSentCompiledMethod selector.
	
	sureSenders := OrderedCollections new.
	possibleSenders := OrderedCollections new.
	
	allSenders do: [ :aSender | 
		actualMessageSendersCollector := aSender actualSendersOf: aSentCompiledMethod.
		actualMessageSendersCollector hasSureMessageSends ifTrue: [ sureSenders add: aSender ].
		actualMessageSendersCollector hasPossibleMessageSends ifTrue: [ 
			possibleSenders add: (PossibleSender in: aSender withPossibleMessageSends: actualMessageSendersCollector possibleMessageSends) ]].
		
	^Array with: sureSenders with: possibleSenders ! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737597!
stackOfSize: limit 
	"Answer an OrderedCollection of the top 'limit' contexts
	 on the receiver's sender chain."

	| stack ctxt |
	stack := OrderedCollections new.
	stack addLast: (ctxt := self).
	[(ctxt := ctxt sender) notNil
	 and: [stack size < limit]] whileTrue:
		[stack addLast: ctxt].
	^stack! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737618!
removeOlderMethodVersions
	"Remove older versions of entries from the receiver."

	| newChangeList newList found |
	newChangeList _ OrderedCollections new.
	newList _ OrderedCollections new.
	found _ OrderedCollections new.
	changeList reverseWith: list do: [ :chRec :strNstamp | | str |
		str _ strNstamp copyUpTo: $;.
		(found includes: str) ifFalse: [
			found add: str.
			newChangeList add: chRec.
			newList add: strNstamp]].
	newChangeList size < changeList size ifTrue: [
		changeList _ newChangeList reversed.
		list _ newList reversed.
		listIndex _ 0.
		self clearSelections ].
	self changed: #list! !
!ActualImplementorsTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737641!
test09WhenNoHighestClassImplementingSelectorIfNoneBlockIsEvaluated

	self assert: (OrderedCollections highestClassImplementing: #none ifNone: [ true ])! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737649!
keysSortedSafely
	"Answer a sorted Collection containing the receiver's keys."
	| sortedKeys |
	sortedKeys _ OrderedCollections new: self size.
	self keysDo: [:each | sortedKeys addLast: each].
	sortedKeys sort:
		[ :x :y |  "Should really be use <obj, string, num> compareSafely..."
		((x isString and: [y isString])
			or: [x isNumber and: [y isNumber]])
			ifTrue: [x < y]
			ifFalse: [x class == y class
				ifTrue: [x printString < y printString]
				ifFalse: [x class name < y class name]]].
	^ sortedKeys! !
!ChangeSelectorKeepingParameters class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737670!
from: anOldSelector to: aNewSelector inCategoryOf: aClass organizedBy: anOrganization

	| implementors senders |

	implementors := OrderedCollections new.
	senders := OrderedCollections new.

	self 
		addImplementorsOf: anOldSelector 
		to: implementors 
		andSendersTo: senders
		inCategory: aClass category 
		organizedBy: anOrganization.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: (self collectCompiledMethodsOf: senders)
! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737722!
testNumberOfDatesBetweenTwoDates

	| timeLineFilter rule1 rule2 rule3 |

	timeLineFilter := TimeLineFilter new.
	rule1 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 14).
	rule2 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 15).
	rule3 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 16).

	timeLineFilter addRules: (OrderedCollections with: rule1 with: rule2 with: rule3).

	self assert: (timeLineFilter negated numberOfDatesBetween: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 01)
		and: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 20)) = (TimeUnits day with: 17)! !
!MessageKeywordsAndParametersTable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50737750!
buildColumnTitlesRowFor: inputColumnsTitles

	| columnsTitles row |

	row := LayoutMorph newRow.
	row color: self backgroundColor.
	row separation: self columnSeparation.

	columnsTitles := OrderedCollections newFrom: inputColumnsTitles.
	columnsTitles addFirst: ''.
	self needsToReorderRows ifTrue: [columnsTitles addLast: 'Change order'].
	columnsTitles withIndexDo: [:aColumnTitle :columnIndex | | columnTitleLayoutSpec titleLayout |
		titleLayout := LayoutMorph newRow.
		titleLayout color: self backgroundColor .
		titleLayout axisEdgeWeight: #center.
		titleLayout addMorph: (LabelMorph contents: aColumnTitle).
		columnTitleLayoutSpec := LayoutSpec fixedWidth: (columnWidths at: columnIndex).
		row
			addMorph: titleLayout
			layoutSpec: columnTitleLayoutSpec].

	^row

	! !
!Form methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50728111!
asColorFormOfDepth: destDepth
	"
	Answer a ColorForm with a custom optimized palette of up to 256, 16 or 4 entries.
	self runningWorld backgroundImage asColorFormOfDepth: 8 :: display
	self runningWorld backgroundImage orderedDither32To16 asColorFormOfDepth: 8 :: display
	self runningWorld backgroundImage orderedDither32To16 asColorFormOfDepth: 4 :: display
	"
	| answer bitsPerColor clusterIndexToSplit clusterToSplit clusters colors desiredNumberOfClusters errors firstCluster map metricToSplitOn tally valueToSplitOn box hueWeightFactor brightnessWeightFactor saturationWeightFactor |
	self depth > 8 ifFalse: [
		^self error: 'Only for 16 bit and 32 bit Forms' ].
	desiredNumberOfClusters _ 1 bitShift: destDepth.

	"Wheights to balance error on each color metric"
	hueWeightFactor _ 8.0 / 360.0.
	saturationWeightFactor _ 1.0.
	brightnessWeightFactor _ 3.0.
	destDepth < 8 ifTrue: [
		brightnessWeightFactor _ 13.0.
		destDepth < 4 ifTrue: [
			hueWeightFactor _ 0.0.
			saturationWeightFactor _ 0.0. ]].
	"Assign all pixels to a single cluster"
	tally _ self tallyPixelValues.
	firstCluster _ OrderedCollectio new.
	tally withIndexDo: [ :pixelCount :pixelValuePlusOne |
		pixelCount = 0 ifFalse: [ |c|
			c _ Color colorFromPixelValue: pixelValuePlusOne -1 depth: 16.
			firstCluster add: {c hue. c saturation. c brightness. pixelCount. pixelValuePlusOne } ]].
	clusters _ OrderedCollectio with: firstCluster.

	"Pick the existing cluster with the largest error, and split it."
	[clusters size < desiredNumberOfClusters and: [ clusters anySatisfy: [:eachCluster | eachCluster size > 1]]] whileTrue: [ | cluster1 cluster2 |
		"Detect cluster with largest error, and split it"
		errors _ clusters collect: [ :eachCluster | | sum average error |
			sum _ (eachCluster sum: [ :e | {e first * e fourth. e second * e fourth. e third * e fourth. e fourth }]).
			average _ {sum first. sum second. sum third} / sum fourth.
			error _ eachCluster sum: [ :e | | hueError |
				hueError _ (e first - average first) abs. hueError > (360/2) ifTrue: [hueError _ 360 - hueError].
				{hueError * hueWeightFactor. (e second-average second) abs * saturationWeightFactor. (e third-average third) abs * brightnessWeightFactor} * e fourth ].
			{error max. error indexOfMax. average at: error indexOfMax} ].
		clusterIndexToSplit _ (errors collect: [ :e | e first]) indexOfMax.
		metricToSplitOn _ (errors at: clusterIndexToSplit) second.
		valueToSplitOn _ (errors at: clusterIndexToSplit) third.
		clusterToSplit _ clusters at: clusterIndexToSplit.
		cluster1 _ OrderedCollectio new.
		cluster2 _ OrderedCollectio new.
		clusterToSplit do: [ :pixelMetricsAndCount |
			(pixelMetricsAndCount at: metricToSplitOn) < valueToSplitOn
				ifTrue: [cluster1 add: pixelMetricsAndCount]
				ifFalse: [cluster2 add: pixelMetricsAndCount]].
		clusters at: clusterIndexToSplit put: cluster1.
		clusters add: cluster2.
	].

	colors _ clusters collect: [ :eachCluster | | sum average |
		average _ eachCluster average.
			sum _ (eachCluster sum: [ :a | {a first * a fourth. a second * a fourth. a third * a fourth. a fourth }]).
			average _ {sum first. sum second. sum third} / sum fourth.
		Color hue: average first saturation: average second brightness: average third ].
	answer _ ColorForm extent: self extent depth: destDepth.
	answer colors: colors.

	"Build colormap for displaying self on answer"
	bitsPerColor _ 5.				"To read 16bpp source"
	map _ Bitmap new: (1 bitShift: 3*bitsPerColor).
	clusters withIndexDo: [ :eachCluster :clusterIndex |
		eachCluster do: [ :pixMetrixsAndCount |
			map at: pixMetrixsAndCount fifth put: clusterIndex-1 ]].

	box _ self boundingBox.
	answer copyBits: box from: self at: 0@0 clippingBox: box rule: Form over map: map.
	^answer
! !
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50735720!
divideRectHorizontally: aRectangle by: aNumber

	| w x rects |
	
	x _ aRectangle origin x.
	w _ aRectangle width // aNumber.
	rects _ OrderedCollectio new.
	
	aNumber timesRepeat: [ |rect|
		rect _ Rectangle origin: x@aRectangle origin y extent: w@aRectangle height.
		x _ x + w.
		rects add: rect].
	
	 ^ rects
	
	! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50734312!
literalStrings
	| litStrs |
	litStrs := OrderedCollectio new: self numLiterals.
	self literalsDo:
		[:lit | 
		(lit isVariableBinding)
			ifTrue: [litStrs addLast: lit key]
			ifFalse: [(lit isSymbol)
				ifTrue: [litStrs addAll: lit keywords]
				ifFalse: [litStrs addLast: lit printString]]].
	^ litStrs! !
!DefinedByRulesTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50734163!
testRulesThatInclude

	| set rule1 rule2 |
	
	set := DefinedByRules for: NaturalNumbersTestUniverse new.
	set 
		addRule: (rule1 := SpecificObjectInclusionRule for: 1);
		addRule: (rule2 := SpecificObjectInclusionRule for: 2).
		
	self assert: (set rulesThatInclude: 1) size = 1.
	self assert: ((set rulesThatInclude: 1) includesAllOf: (OrderedCollectio with: rule1)).

	self assert: (set rulesThatInclude: 2) size = 1.
	self assert: ((set rulesThatInclude: 2) includesAllOf: (OrderedCollectio with: rule2)).

	self assert: (set rulesThatInclude: 3) isEmpty! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50733985!
simpleEnsureTestWithErrorResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: 'Unhandled Exception';
		add: self doYetAnotherThingString;
		yourself! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50734406!
doublePassOuterTestResults

	^OrderedCollectio new
		add: self doSomethingString;
		add: self doYetAnotherThingString;
		add: self doSomethingElseString;
		yourself! !
!IfNilChecksFinder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50729917 overrides: 16902254!
value

	| selectors |

	selectors := contextClass whichSelectorsAccess: instanceVariable.

	^selectors inject: OrderedCollectio new into: [:ifNilChecks :selector |
		ifNilChecks addAll: (self ifNilChecksIn: selector). ifNilChecks.].! !
!MessageKeywordsAndParametersTable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50733021!
columnWidthsRequiredForRowTitles: rowsTitles forInputColumns: numberOfInputColumns

	| widths maxRowTitleWidth widthForInputs |

	widths := OrderedCollectio new.

	maxRowTitleWidth := (rowsTitles collect: [:aRowTitle | FontFamily defaultFamilyAndPointSize widthOfString: aRowTitle]) max + 20.
	widths add: maxRowTitleWidth.

	widthForInputs := ExtractToMethodObjectForm fontProportionalUnitOfReferenceForWidth * 20.
	numberOfInputColumns timesRepeat: [widths add: widthForInputs].

	rowsTitles size > 1 ifTrue: [widths add: (FontFamily defaultFamilyAndPointSize widthOfString: 'Change order')].

	^widths

	! !
!AllActualImplementors methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50734296 overrides: 50622393!
value 

	| typeImplementors |
	
	notImplemented := OrderedCollectio new.
	implementors := Set new.
	types do: [ :aType | 
		typeImplementors := Smalltalk actualImplementorsOf: selector in: aType.
		typeImplementors isEmpty 
			ifTrue: [ notImplemented add: (NotImplementedMethod class: aType selector: selector) ]
			ifFalse: [ implementors addAll: typeImplementors ]].

	^self! !
!IntroduceNullObjectRequest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50732695!
replacementParameters

	| parameters |

	parameters := OrderedCollectio new.
	messageKeywordsAndParametersModels keysAndValuesDo: [:ifNilCheck :model |
		parameters add: (ReplaceIfNilWithPolymorphismParameters
			forIfNilMessageSending: ifNilCheck messageNode
			onMethod: ifNilCheck methodNode
			useKeywordsDefinitions: model definitions)].

	^parameters! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50728082!
definitionOf: aMetaclass

	^ String streamContents: [ :stream | | selector collaborators |
		stream
			nextPutAll: aMetaclass soleInstance name.
	
		"Done this way to support rename of #create:collarobatorNames:in: - Hernan"
		collaborators := OrderedCollectio new.
		(aMetaclass soleInstance superclass is: #DenotativeObject) 
			ifTrue: [ 
				selector := #asChildOf:collaboratorNames:in:.
				collaborators add: aMetaclass soleInstance superclass name ]
			ifFalse: [ selector := #collaboratorNames:in: ].
			
		collaborators 
			add: '''', aMetaclass instanceVariablesString, '''';
			add: '''', aMetaclass category, ''''. 
									
		selector keywords withIndexDo: [ :keyword :index |
			stream
				newLine;
				tab;
				nextPutAll: keyword;
				space;
				nextPutAll: (collaborators at: index) ]]! !
!PathQuadraticCurveToCommand methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50727328 overrides: 50431909!
buildFrom: commandChar stream: aStream

	| x1 y1 x y |
	super buildFrom: commandChar stream: aStream.
	toPoints _ OrderedCollectio new.
	controlPoints _ OrderedCollectio new.
	[
		x1 _ aStream nextNumber.
		y1 _ aStream nextNumber.
		x _ aStream nextNumber.
		y _ aStream nextNumber.
		y notNil ] whileTrue: [
			toPoints add: x@y.
			controlPoints add: x1@y1 ]! !
!PushUpInstanceVariable class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:19' prior: 50733319!
assertNoOtherMethodIn: aSuperclass definesTemporaryNamed: anInstanceVariableName

 	| methodsDefiningTemporaryInSuperclass |

	methodsDefiningTemporaryInSuperclass := OrderedCollectio new.
	methodsDefiningTemporaryInSuperclass addAll: (
		aSuperclass methodsWithArgumentOrTemporaryNamed: anInstanceVariableName).

	methodsDefiningTemporaryInSuperclass ifNotEmpty: [
		self 
			canNotRefactorDueToReferencesError: (
				self errorMessageForInstanceVariable: anInstanceVariableName isDefinedInMethodsOf: aSuperclass)
			references: (
				methodsDefiningTemporaryInSuperclass collect: [ :aMethod | MethodReference method: aMethod ])
			to: anInstanceVariableName ]! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50733093!
buildTextPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollectio with: (Color fromHexString: '#9E3F3F') with: 'Sunset'.
	ocean := OrderedCollectio with: (Color fromHexString: '#01161E') with: 'Ocean'.
	forest := OrderedCollectio with: (Color fromHexString: '#28112B') with: 'Forest'.
	ash := OrderedCollectio with: (Color fromHexString: '#2B2D42') with: 'Ash'.
	light := OrderedCollectio with: (Color fromHexString: '#3C3C3B') with: 'Light'.
	
	textPalette := OrderedCollectio with: sunset with: ocean with: forest with: ash with: light.! !
!DenotativeObjectDarkTheme methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50735576 overrides: 16971312!
pseudoVariables

	^ (OrderedCollectio withAll: super pseudoVariables) 
		add: #parent;
		asArray! !
!ThemeCustomizerWindow methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50735186!
buildBackgroundPalette
	
	| sunset ocean forest ash light |
	sunset := OrderedCollectio with: (Color fromHexString: '#FE938C') with: 'Sunset'.
	ocean := OrderedCollectio with: (Color fromHexString: '#124559') with: 'Ocean'.
	forest := OrderedCollectio with: (Color fromHexString: '#788475') with: 'Forest'.
	ash := OrderedCollectio with: (Color fromHexString: '#363946') with: 'Ash'.
	light := OrderedCollectio with: (Color fromHexString: '#F2DFD7') with: 'Light'.
	
	backgroundPalette := OrderedCollectio with: sunset with: ocean with: forest with: ash with: light.! !
!ChangeSelectorKeepingParameters class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50728646!
from: anOldSelector to: aNewSelector inSystem: aSystem

	| implementors senders |

	implementors := OrderedCollectio new.
	senders := OrderedCollectio new.

	self 
		addImplementorsOf: anOldSelector 
		to: implementors 
		andSendersTo: senders 
		inSystem: aSystem.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: (self collectCompiledMethodsOf: senders)
	! !
!PathArcCommand methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50727059 overrides: 50431909!
buildFrom: commandChar stream: aStream

	| rx ry xAxisRotation doLargerArc useIncreasingAngle x y |
	super buildFrom: commandChar stream: aStream.
	rs _ OrderedCollectio new.
	xAxisRotations _ OrderedCollectio new.
	toPoints _ OrderedCollectio new.
	doLargerArcs _ OrderedCollectio new.
	useIncreasingAngles _ OrderedCollectio new.
	[
		rx _ aStream nextNumber.
		ry _ aStream nextNumber.
		xAxisRotation _ aStream nextNumber.
		doLargerArc _ (aStream nextNumber = 0) not.
		useIncreasingAngle _ (aStream nextNumber = 0) not.
		x _ aStream nextNumber.
		y _ aStream nextNumber.
		y notNil ] whileTrue: [
			rs add: rx@ry.
			xAxisRotations add: xAxisRotation degreesToRadians.
			doLargerArcs add: doLargerArc.
			useIncreasingAngles add: useIncreasingAngle.
			toPoints add: x@y ]! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50729084!
allInstVarNamesEverywhere
	"Answer the set of inst var names used by the receiver, all superclasses, and all subclasses"

	| aList |
	aList _ OrderedCollectio new.
	(self allSuperclasses , self withAllSubclasses asOrderedCollection) do:
		[:cls | aList addAll: cls instVarNames].
	^ aList asSet

	"BoxedMorph allInstVarNamesEverywhere"! !
!RemoveParameterWithActualScopeApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50731555 overrides: 16803828!
createSenders

	^OrderedCollectio new.
! !
!ExceptionTester methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50729810!
simpleTimeoutTestResults

	| things |
	things := OrderedCollectio new: self iterationsBeforeTimeout.

	self iterationsBeforeTimeout timesRepeat: [ things add: self  doSomethingString ].
	things add: self doSomethingElseString.

	^ things! !
!RenameInstanceVariable methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50733590!
lookForMethodsReferencingOldVariable
	
	methodsAndRangesToChange := OrderedCollectio new.
	classToRefactor withAllSubclassesDo: [ :aClass |  self lookForMethodsReferencingOldVariableIn: aClass ].
! !
!AddParameterWithActualScopeApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50734698 overrides: 16803828!
createSenders

	^OrderedCollectio new.
! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50733832!
createMessageList

	messageList := OrderedCollectio new.
	numberOfTitles := 0.
	
	self 
		addCompleteSureSendersToMessageList;
		addPartialSureSendersToMessageList;
		addPossibleSendersToMessageList
		
! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50731472!
removeSelections
	"Remove the selected items from the receiver.  9/18/96 sw"

	| newChangeList newList |

	newChangeList _ OrderedCollectio new.
	newList _ OrderedCollectio new.

	1 to: changeList size do: [ :i |
		(listSelections at: i) ifFalse: [
			newChangeList add: (changeList at: i).
			newList add: (list at: i)]].
	newChangeList size < changeList size
		ifTrue: [
			changeList _ newChangeList.
			list _ newList.
			listIndex _ 0.
			self clearSelections ].
	self changed: #list

	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50727087!
hierarchicalClassList

	"classNames are an arbitrary collection of classNames of the system.
	Reorder those class names so that they are sorted and indended by inheritance"

	| classes |

	"Creating the hierarchy is *really slow* for the full class list. Skip it for now."
	selectedSystemCategory = SystemOrganizer allCategory ifTrue: [^ self defaultClassList].		
	classes := self defaultClassList collect: [:sym | Smalltalk classNamed: sym].
	
	^ self
		flattenHierarchyTree: (self createHierarchyTreeOf: classes)
		on: OrderedCollectio new
		indent: ''.! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50728545!
defaultQueue
	defaultQueue ifNil: [defaultQueue _ OrderedCollectio new].
	^ defaultQueue! !
!ClassBuilder class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50733366!
reallyObsoleteClasses
	| obsoleteClasses |
	obsoleteClasses _ OrderedCollectio new.
	Metaclass allInstances do: [:meta | meta allInstances do: [:each | 
		(self isReallyObsolete: each) ifTrue: [obsoleteClasses add: each]]].
	^ obsoleteClasses! !
!ActualImplementorsTest methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50734011!
test08highestClassImplementingSelectorReturnsHighgestClass

	self assert: (OrderedCollectio highestClassImplementing: #at:put: ifNone: [ self fail ]) equals: Object! !
!ExtractAsParameter class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50730520!
intervalsForEquivalentNodesTo: node in: methodNode

	| completeSourceRanges intervalsForEquivalentNodes | 
	
	intervalsForEquivalentNodes := OrderedCollectio new.
	completeSourceRanges := methodNode completeSourceRanges.
	
	methodNode nodesDo: [ :aNode | 
		(aNode equivalentTo: node) ifTrue: [ 
			"There can not be more than one range because of the is not a multi range node. See senders - Hernan"
			intervalsForEquivalentNodes add: (completeSourceRanges at: aNode) first ]].
	
	^intervalsForEquivalentNodes! !
!SerializableBlockClosure methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50727387!
onBlockClosure: aBlockClosure

	| both blockNode methodNode indirectTempNames sortedOuterTemps ownNames usedOuterNames sortedUsedOuterNames |
	aBlockClosure hasNonLocalReturn ifTrue: [
		self error: 'Can not serialize closures with non-local returns.' ].
	aBlockClosure sendsToSuper ifTrue: [
		self error: 'Can not currently serialize closures with super sends.' ].
	both _ SerializableClosureDecompiler new  decompileBlockAndMethod: aBlockClosure.
	blockNode _ both first.
	methodNode _ both second.

	indirectTempNames _ methodNode temporaries
		detect: [ :node | node isIndirectTempVector ]
		ifFound: [ :node | node remoteTemps collect: [ :n | n name ]]
		ifNone: [#()].
	sortedOuterTemps _ OrderedCollectio new.
	aBlockClosure outerContextsDo: [ :c | c closure ifNotNil: [ :cc |
		| ccn |
		ccn _ cc decompile.
		sortedOuterTemps addAll: ccn arguments; addAll: ccn temporaries ]].
	sortedOuterTemps addAll: methodNode temporaries; addAll: methodNode arguments.

	ownNames _ ((blockNode arguments, blockNode temporaries)
		collect: [ :node | node name ]) asSet.
	usedOuterNames _ Set new.
	blockNode nodesDo: [ :node | node isTemp ifTrue: [
		(ownNames includes: node name) | (indirectTempNames includes: node name) ifFalse: [
			usedOuterNames add: node name]]].

	sortedUsedOuterNames _ sortedOuterTemps select: [ :node |
		usedOuterNames includes: node name ]. "sort them"
	sortedUsedOuterNames _ sortedUsedOuterNames collect: [ :node | node name ].

	blockNode nodesDo: [ :node | node isTemp ifTrue: [ 
		node isRemote
			ifTrue: [node capturedIndex: (indirectTempNames indexOf: node name) ]
			ifFalse: [
				(sortedUsedOuterNames includes: node name)
					ifTrue: [node capturedIndex: (sortedUsedOuterNames indexOf: node name)]]]].

	theSelf _ aBlockClosure receiver.
	capturedValues _ aBlockClosure capturedValues.
	sourceCode _ blockNode decompileString.! !
!ExtractMethodApplier methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50733411!
extractKewordsAndArgumentsNamesFrom: userAnswer

	newSelectorKeywords := OrderedCollectio new.
	userArgumentNames := OrderedCollectio new.
	(self keywordsAndArgumentsOf: userAnswer) pairsDo: [ :keyword :argument | 
		newSelectorKeywords add: keyword, ':'.
		userArgumentNames add: argument ]! !
!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50734072!
toggleExpandedState
	| newChildren toDelete c |
	isExpanded _ isExpanded not.
	toDelete _ OrderedCollectio new.
	firstChild ifNotNil: [
		firstChild withSiblingsDo: [ :aNode |
			aNode recursiveAddTo: toDelete ]].
	container noteRemovalOfAll: toDelete.
	(isExpanded and: [ complexContents hasContents ]) ifFalse: [
		firstChild _ nil.
"	 	nextSibling _ firstChild _ nil."
		^ self redrawNeeded ].
	(c _ complexContents contents) isEmpty ifTrue: [ ^ self redrawNeeded ].
	newChildren _ container
		addSubmorphsAfter: self
		fromCollection: c
		allowSorting: true.
	firstChild _ newChildren first! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50731094!
initListFrom: selectorCollection highlighting: aClass 
	"Make up the messageList with items from aClass in boldface."
	| defClass item |

	messageList _ OrderedCollectio new.
	selectorCollection do: [ :selector |  
		defClass _ aClass whichClassIncludesSelector: selector.
		item _ selector, '     (' , defClass name , ')'.
		defClass == aClass ifTrue: [item _ item asText allBold].
		messageList add: (
			MethodReference new
				setClass: defClass 
				methodSymbol: selector 
				stringVersion: item)].
	self hierarchyForClass: (baseClass _ aClass)! !
!Class methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 21:43:20' prior: 50733878 overrides: 50735818!
sharedPools
	"Answer a Set of the pool dictionaries declared in the receiver."

	^sharedPools
		ifNil: [OrderedCollectio new]! !

!testRun: #TestCaseTest #testAssertChangesByPassesWhenActionChangesConditionByTheSpecifiedAmount stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testAssertChangesFromToPassesWhenActionChangesConditionFromAndToTheSpecifiedValues stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testAssertChangesPassesWhenConditionIsAlteredByAction stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testAssertDoeNotChangePassesWhenConditionIsNotAlteredByAction stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testAssertIncludesFailsWhenElementIsNotIncludedInCollection stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testAssertIncludesShouldNotFailWhenElementIsInCollection stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testAssertIsCloseToPassesForSameNumberDifferentToZero stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testAssertIsCloseToPassesWhenBothAreZero stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testAssertIsCloseToPassesWithSameCalculatedNumber stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testAssertIsCloseToWithPrecisionPassesWhenDifferenceIsNegativeAndLessThanPrecision stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testAssertIsCloseToWithPrecisionPassesWhenDifferenceIsPositiveAndLessThanPrecision stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testAssertIsNotCloseWithPrecisionPassesWhenDifferenceIsBiggerThanPrecision stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testIsTestCase stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testShouldFailErrorsWhenNoErrorIsSignaled stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testShouldFailPassesWhenAnErrorIsSignaled stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testShouldNotTakeMoreThanFailsWhenClosureTakesMoreThanTheLimit stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testShouldNotTakeMoreThanPassesWhenClosureTakesLessThanTheLimit stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithExceptionDoCanExpectException stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithExceptionDoFailsWhenNoExceptionIsSignaled stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithExceptionDoFailsWhenOtherExceptionTypeIsSignaled stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithExceptionDoPassSignaledExceptionToAssertionsBlock stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithExceptionDoValuesAssertionsBlockWhenExceptionIsRaised stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithMessageTextDoesNotFailWithRightMessageText stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithMessageTextFailsWithDifferentMessageText stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testShoulndFailErrorsWhenAnErrorIsSignaled stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #TestCaseTest #testShoulndFailPassesWhenNoErrorIsSignaled stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testAccessing stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testAdd stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testAddToCollection stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testAt stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testComparing stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testCopyAndGrowBy stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testDeepCopy stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testDo stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testFirst stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testHash stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testIncludes stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testInvalidAt stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testInvalidCreation stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testLast stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testPrintOn stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testReject stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testRemoveIfAbsent stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testReverse stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testReverseDo stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testSelect stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testShallowCopy stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testSize stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testStoreOn stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphPathFinderTest #testGraphPathNotFoundException stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphPathFinderTest #testInvalidPath stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphPathFinderTest #testPathToFarAwayPlaces stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphPathFinderTest #testPathToNeighborPlace stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphPathFinderTest #testSamePlace stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphPathFinderTest #testWithLoops stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testAccessImmutability stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testApplyUsingDepthFistSearch stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testConvergingEdges stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testCreateGraphWithInvalidEdge stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testCreateGraphWithUnconnectedNodes stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testCreateGraphWithoutEdges stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testCreationImmutability stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testEdgesConvergingToSelf stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testEqual stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testEqualsDifferentGraphs stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testGraphCreation stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testHash stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testIncludesNode stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testIsAcyclicWhenGraphIsAcyclic stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testIsAcyclicWhenGraphIsCyclic stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testIsEmpty stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testNodesAdjacentTo stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testNodesWithoutEdges stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testNotEmpty stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testRemoveNode stamp: 'psm 10/17/2023 21:43:20'!
PASSED!

!testRun: #GraphTest #testRemoveNodeWithInvalidNode stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #GraphTest #testRemoveNodes stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #GraphTest #testSameNodesAs stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #GraphTest #testStartingEdges stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #TopologicalSortTest #testCreateWithCyclicGraph stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #TopologicalSortTest #testValue stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #TopologicalSortTest #testValueWithAnotherGraph stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #TopologicalSortTest #testWithGraphWithoutEdges stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testAdd stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testAddAssociativity stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testAddBags stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testAddCommutativity stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testAddEquality stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testAddExistingUnit stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testAddFloatWithMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testAddFractionWithMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testAddImmutability stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testAddIntegerWithMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testAddNothing stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testAtSameBaseUnitAsWithBaseUnits stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testAtSameBaseUnitAsWithDerivedUnits stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testCeiling stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testCompoundMeasureImmutability stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testConvertAmountToBaseUnit stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testCreationWithMeasures stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testCreationWithMeasuresCopiesCollection stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testDivideByMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testDivision stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testDivisionDistributivity stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testDivisionFloatByMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testDivisionFractionByMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testDivisionIntegerByMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testDivisionMeasureByCompoundMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testEqual stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testEqualAllNothing stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testEqualNumber stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testEqualOneNothing stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testEqualWithDifferentBagSizeButRepresentSameEntity stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testEqualWithDifferentBagSizeIsNothing stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testEven stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testEvenInBaseUnit stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testFloor stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testHash stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testHashAllNothing stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testHashOneNothing stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testInvalidTruncated stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testIsCompoundMeasurement stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testIsFraction stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testIsNothing stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testLessThan stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testMeasures stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testModulo stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testModuloCompoundMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testModuloFloatByMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testModuloFractionByMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testModuloIntegerByMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testModuloMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplication stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplicationByMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplicationByZero stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplicationCommutativity stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplicationDistributivity stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplyFloatByMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplyFractionByMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplyIntegerByMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplyMeasureByCompoundMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testNegated stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testNegatedDistribution stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testNegatedZeroBag stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testNotEqual stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testNumberOfMeasures stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testOdd stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testOddInBaseUnit stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testPrintingForMany stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testPrintingForOne stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testRemFrom stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testRemainder stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testRemainderCompoundMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testRemainderFloatByMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testRemainderIntegerByMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testRemainderMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testRoundTo stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtract stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractBags stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractEquality stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractExistingUnit stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractFloatWithMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractFractionWithMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractIntegerWithMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractMeasureByCompoundMeasure stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractNothing stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testTheZeroOfTheDomainIsEqualToZero stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testToThePowerOfOneReturnsSelf stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testToThePowerOfZeroReturnsOne stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testToThePowerOf_MinusN_IsOneOverThePowerOfN stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testToThePowerOf_N_MultipliesMeasureNTimes stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testTruncated stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testUnitNameOf stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testWithWithBaseUnits stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testWithWithDerivedUnits stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testZeroDivision stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CompoundMeasureTest #testZeroEqualsTheZeroOfTheDomain stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #ActualImplementorsTest #test01WhenIsImplementedOnlyInRootReturnsThatImplementorOnly stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #ActualImplementorsTest #test02ReturnsImplementorsOfSuperclasses stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #ActualImplementorsTest #test03IfNotImplementedInRootOrSuperclassesDoesNotIncludeSubclassesImplementations stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #ActualImplementorsTest #test04IncludesSubclassesImplementations stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #ActualImplementorsTest #test05DoesNotIncludeImplementorsOfSubclassesNotDefinedInSuperclass stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #ActualImplementorsTest #test06DoesNotIncludeImplementorsOfSiblingsWhenNotDefinedInSuperclass stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #ActualImplementorsTest #test07ReturnsAllSubclassesImplementorsOfTheHighestImplementorClass stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #ActualImplementorsTest #test08highestClassImplementingSelectorReturnsHighgestClass stamp: 'psm 10/17/2023 21:43:21'!
ERROR!

!testRun: #ActualImplementorsTest #test09WhenNoHighestClassImplementingSelectorIfNoneBlockIsEvaluated stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testAfterBlanksEndsWith stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testArticle stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testAsUtf8 stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testBase64 stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testBeginsWith stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testCaseConversion stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testEncompassParagraph1 stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testEncompassParagraph2 stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testEncompassParagraph3 stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testEncompassParagraph4 stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testEncompassParagraph5 stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testFindSelector stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testFirstNonSeparator stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testIsString stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testLastNonSeparator stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testLineSeparators stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testSorting stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testWithBlanksTrimmed stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testWithoutLeadingBlanks stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testWithoutPrefix stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testWithoutSeparators stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #StringTest #testWithoutTrailingBlanks stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CodeCoverageTest #test001_1_CoversALiteralVariable stamp: 'psm 10/17/2023 21:43:21'!
ERROR!

!testRun: #CodeCoverageTest #test001_2_CoversManyLiteralVariables stamp: 'psm 10/17/2023 21:43:21'!
ERROR!

!testRun: #CodeCoverageTest #test001_3_CoversMultipleOcurrencesOfTheSameLiteralVariable stamp: 'psm 10/17/2023 21:43:21'!
ERROR!

!testRun: #CodeCoverageTest #test001_4_DoesNotCoverLiteralVariablesThatWereNotExecuted stamp: 'psm 10/17/2023 21:43:21'!
ERROR!

!testRun: #CodeCoverageTest #test002_CoversAnUnaryMessageSend stamp: 'psm 10/17/2023 21:43:21'!
ERROR!

!testRun: #CodeCoverageTest #test003_DoesNotCoverMessageSendsThatAreNotExecuted stamp: 'psm 10/17/2023 21:43:21'!
ERROR!

!testRun: #CodeCoverageTest #test004_CoversMultipleOcurrencesOfTheSameMessageSend stamp: 'psm 10/17/2023 21:43:21'!
ERROR!
!Behavior method!
binaryMessageSend
	#_coverageTracker10809274_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10809274_
		coverAll:
			{22 to: 22}
		byLiteralOrPseudoVariable: 1.
	#_coverageTracker10809274_
		coverAll:
			{24 to: 24}
		evaluating: [
			receiver1 +
				(#_coverageTracker10809274_
					coverAll:
						{25 to: 26}
					byLiteralOrPseudoVariable: 2) ]
		thatSends: #+
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test005_CoversABinaryMessageSend stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CodeCoverageTest #test006_CoversAKeywordMessageSend stamp: 'psm 10/17/2023 21:43:21'!
ERROR!

!testRun: #CodeCoverageTest #test007_CoversMultipleOcurrencesOfTheReceiverInAMessageSend stamp: 'psm 10/17/2023 21:43:21'!
ERROR!

!testRun: #CodeCoverageTest #test008_CoversMultipleOcurrencesOfAnArgumentInAMessageSend stamp: 'psm 10/17/2023 21:43:21'!
ERROR!
!Behavior method!
literal
	#_coverageTracker10809316_ markAsExecuted.
	#_coverageTracker10809316_
		coverAll:
			{11 to: 12}
		byLiteralOrPseudoVariable: 1.! !

!testRun: #CodeCoverageTest #test009_1_CoversALiteral stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
manyLiterals
	#_coverageTracker10809350_ markAsExecuted.
	#_coverageTracker10809350_
		coverAll:
			{17 to: 17}
		byLiteralOrPseudoVariable: 1.
	#_coverageTracker10809350_
		coverAll:
			{21 to: 21}
		byLiteralOrPseudoVariable: 2.! !

!testRun: #CodeCoverageTest #test009_2_CoversManyLiterals stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
multipleOcurrencesOfTheSameLiteral
	#_coverageTracker10809353_ markAsExecuted.
	#_coverageTracker10809353_
		coverAll:
			{39 to: 39}
		byLiteralOrPseudoVariable: 1.
	#_coverageTracker10809353_
		coverAll:
			{43 to: 43}
		byLiteralOrPseudoVariable: 1.! !

!testRun: #CodeCoverageTest #test009_3_CoversMultipleOcurrencesOfTheSameLiteral stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
notExecutedLiteral
	#_coverageTracker10809355_ markAsExecuted.
	[
	#_coverageTracker10809355_
		coverAll:
			{25 to: 25}
		byLiteralOrPseudoVariable: 1 ].! !

!testRun: #CodeCoverageTest #test009_4_DoesNotCoverLiteralsThatWereNotExecuted stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
instanceVariable
	#_coverageTracker10809381_ markAsExecuted.
	#_coverageTracker10809381_
		cover: (21 to: 36)
		declaredAt: (21 to: 36)
		by: instanceVariable.! !

!testRun: #CodeCoverageTest #test010_1_CoversAnInstanceVariable stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
multipleInstanceVariables
	#_coverageTracker10809383_ markAsExecuted.
	#_coverageTracker10809383_
		cover: (30 to: 45)
		declaredAt: (30 to: 45)
		by: instanceVariable.
	#_coverageTracker10809383_
		cover: (49 to: 69)
		declaredAt: (49 to: 69)
		by: otherInstanceVariable.! !

!testRun: #CodeCoverageTest #test010_2_CoversMultipleInstanceVariables stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
multipleOcurrencesOfTheSameInstanceVariable
	#_coverageTracker10809385_ markAsExecuted.
	#_coverageTracker10809385_
		cover: (48 to: 63)
		declaredAt: (48 to: 63)
		by: instanceVariable.
	#_coverageTracker10809385_
		cover: (67 to: 82)
		declaredAt: (48 to: 63)
		by: instanceVariable.! !

!testRun: #CodeCoverageTest #test010_3_CoversMultipleOcurrencesOfTheSameInstanceVariable stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
notExecutedInstanceVariable
	#_coverageTracker10809388_ markAsExecuted.
	[
	#_coverageTracker10809388_
		cover: (34 to: 49)
		declaredAt: (34 to: 49)
		by: instanceVariable ].! !

!testRun: #CodeCoverageTest #test010_4_DoesNotCoverInstanceVariablesThatWereNotExecuted stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
unusedTemporaryVariableDeclaration
	| a |
	#_coverageTracker10809390_ markAsExecuted.! !

!testRun: #CodeCoverageTest #test011_1_DoesNotCoverTemporariesDeclarations stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
temporaryVariable
	| a |
	#_coverageTracker10809423_ markAsExecuted.
	#_coverageTracker10809423_
		cover: (31 to: 31)
		declaredAt: (24 to: 24)
		by: a.! !

!testRun: #CodeCoverageTest #test011_2_CoversTemporaryVariablesAndTheirDeclarationsWhenTheTemporaryVariableIsRead stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
manyTemporaryVariables
	| a b |
	#_coverageTracker10809425_ markAsExecuted.
	#_coverageTracker10809425_
		cover: (38 to: 38)
		declaredAt: (29 to: 29)
		by: a.
	#_coverageTracker10809425_
		cover: (42 to: 42)
		declaredAt: (31 to: 31)
		by: b.! !

!testRun: #CodeCoverageTest #test011_3_CoversAManyTemporaryVariables stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
multipleOcurrencesOfTheSameTemporaryVariable
	| a |
	#_coverageTracker10809427_ markAsExecuted.
	#_coverageTracker10809427_
		cover: (58 to: 58)
		declaredAt: (51 to: 51)
		by: a.
	#_coverageTracker10809427_
		cover: (62 to: 62)
		declaredAt: (51 to: 51)
		by: a.! !

!testRun: #CodeCoverageTest #test011_4_CoversMultipleOccurrencesOfTheSameTemporaryVariable stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
notExecutedTemporaryVariable
	| a |
	#_coverageTracker10809431_ markAsExecuted.
	[
	#_coverageTracker10809431_
		cover: (44 to: 44)
		declaredAt: (35 to: 35)
		by: a ].! !

!testRun: #CodeCoverageTest #test011_5_DoesNotCoverATemporaryVariableOrItsDeclarationWhenTheTemporaryVariableIsNotReadNorWritten stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
variableNode
	#_coverageTracker10809464_ markAsExecuted.
	#_coverageTracker10809464_
		coverAll:
			{17 to: 20}
		byLiteralOrPseudoVariable: true.! !

!testRun: #CodeCoverageTest #test012_1_CoversAVariable stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
mutipleVariableNodes
	#_coverageTracker10809466_ markAsExecuted.
	#_coverageTracker10809466_
		coverAll:
			{25 to: 28}
		byLiteralOrPseudoVariable: true.
	#_coverageTracker10809466_
		coverAll:
			{32 to: 36}
		byLiteralOrPseudoVariable: false.! !

!testRun: #CodeCoverageTest #test012_2_CoversMutipleVariables stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
multipleOcurrencesOftheSameVariable
	#_coverageTracker10809468_ markAsExecuted.
	#_coverageTracker10809468_
		coverAll:
			{40 to: 43}
		byLiteralOrPseudoVariable: true.
	#_coverageTracker10809468_
		coverAll:
			{47 to: 50}
		byLiteralOrPseudoVariable: true.! !

!testRun: #CodeCoverageTest #test012_3_CoversMultipleOcurrencesOftheSameVariable stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
notExecutedVariable
	#_coverageTracker10809470_ markAsExecuted.
	[
	#_coverageTracker10809470_
		coverAll:
			{26 to: 29}
		byLiteralOrPseudoVariable: true ].! !

!testRun: #CodeCoverageTest #test012_4_DoesNotCoverVariablesThatAreNotExecuted stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
implicitSelfReturn
	"This method has an implicit self return"
	#_coverageTracker10809472_ markAsExecuted.! !

!testRun: #CodeCoverageTest #test013_1_DoesNotCoverImplicitSelfReturns stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
return
	#_coverageTracker10809472_ markAsExecuted.
	^ #_coverageTracker10809472_
		coverAll:
			{12 to: 13}
		byLiteralOrPseudoVariable: 1.! !

!testRun: #CodeCoverageTest #test013_2_CoversReturnNodes stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
notExecutedReturnNode
	#_coverageTracker10809505_ markAsExecuted.
	[ ^ #_coverageTracker10809505_
		coverAll:
			{30 to: 30}
		byLiteralOrPseudoVariable: 1 ].! !

!testRun: #CodeCoverageTest #test013_3_DoesNotCoversReturnNodesThatAreNotExecuted stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
multipleReturnNodes
	#_coverageTracker10809507_ markAsExecuted.
	[ ^ #_coverageTracker10809507_
		coverAll:
			{28 to: 28}
		byLiteralOrPseudoVariable: 1 ].
	^ #_coverageTracker10809507_
		coverAll:
			{37 to: 38}
		byLiteralOrPseudoVariable: 2.! !

!testRun: #CodeCoverageTest #test013_4_CoversTheExecutedOcurrenceOfMultipleReturnNodes stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
multipleOcurrencesOfTheSameReturnNodes
	#_coverageTracker10809509_ markAsExecuted.
	[ ^ #_coverageTracker10809509_
		coverAll:
			{47 to: 47}
		byLiteralOrPseudoVariable: 1 ].
	^ #_coverageTracker10809509_
		coverAll:
			{56 to: 57}
		byLiteralOrPseudoVariable: 1.! !

!testRun: #CodeCoverageTest #test013_5_CoversTheExecutedOcurrenceOfTheSameReturnNode stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
assignment
	#_coverageTracker10809536_ markAsExecuted.
	#_coverageTracker10809536_
		cover: (15 to: 30)
		declaredAt: (15 to: 30)
		by:
			(instanceVariable _ #_coverageTracker10809536_
				coverAll:
					{34 to: 35}
				byLiteralOrPseudoVariable: 1).! !

!testRun: #CodeCoverageTest #test014_1_CoversAnAssignment stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
multipleAssignments
	#_coverageTracker10809538_ markAsExecuted.
	#_coverageTracker10809538_
		cover: (24 to: 39)
		declaredAt: (24 to: 39)
		by:
			(instanceVariable _ #_coverageTracker10809538_
				coverAll:
					{44 to: 44}
				byLiteralOrPseudoVariable: 1).
	#_coverageTracker10809538_
		cover: (48 to: 68)
		declaredAt: (48 to: 68)
		by:
			(otherInstanceVariable _ #_coverageTracker10809538_
				coverAll:
					{73 to: 73}
				byLiteralOrPseudoVariable: 2).! !

!testRun: #CodeCoverageTest #test014_2_CoversMultipleAssignments stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
multipleOcurrencesOfTheSameAssignment
	#_coverageTracker10809542_ markAsExecuted.
	#_coverageTracker10809542_
		cover: (42 to: 57)
		declaredAt: (42 to: 57)
		by:
			(instanceVariable _ #_coverageTracker10809542_
				coverAll:
					{62 to: 62}
				byLiteralOrPseudoVariable: 1).
	#_coverageTracker10809542_
		cover: (66 to: 81)
		declaredAt: (42 to: 57)
		by:
			(instanceVariable _ #_coverageTracker10809542_
				coverAll:
					{86 to: 86}
				byLiteralOrPseudoVariable: 2).! !

!testRun: #CodeCoverageTest #test014_3_CoversMultipleOcurrencesOfTheSameAssignment stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
notExecutedAssignment
	#_coverageTracker10809544_ markAsExecuted.
	[
	#_coverageTracker10809544_
		cover: (28 to: 43)
		declaredAt: (28 to: 43)
		by:
			(instanceVariable _ #_coverageTracker10809544_
				coverAll:
					{48 to: 48}
				byLiteralOrPseudoVariable: 1) ].! !

!testRun: #CodeCoverageTest #test014_4_DoesNotCoverAssignmentsThatAreNotExecuted stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
assignVariableToItself
	#_coverageTracker10809608_ markAsExecuted.
	#_coverageTracker10809608_
		cover: (47 to: 62)
		declaredAt: (27 to: 42)
		by:
			(instanceVariable _ #_coverageTracker10809608_
				cover: (27 to: 42)
				declaredAt: (27 to: 42)
				by: instanceVariable).! !

!testRun: #CodeCoverageTest #test014_5_CoversTheUsageOfTheVariableThatIsBeingAssigned stamp: 'psm 10/17/2023 21:43:21'!
PASSED!

!testRun: #CodeCoverageTest #test015_1_CoversABacktickNode stamp: 'psm 10/17/2023 21:43:21'!
ERROR!

!testRun: #CodeCoverageTest #test015_2_CoversMultipleBacktickNodes stamp: 'psm 10/17/2023 21:43:21'!
ERROR!

!testRun: #CodeCoverageTest #test015_3_CoversMultipleOcurrencesOftheSameBacktickNode stamp: 'psm 10/17/2023 21:43:21'!
ERROR!

!testRun: #CodeCoverageTest #test015_5_DoesNotCoverBackticksNodesThatAreNotExecuted stamp: 'psm 10/17/2023 21:43:21'!
ERROR!
!Behavior method!
emptyBlock
	#_coverageTracker10809612_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [ ].
	#_coverageTracker10809612_
		coverAll:
			{18 to: 22}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test016_1_CoversTheEvaluationOfAnEmptyBlock stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
block
	#_coverageTracker10809614_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [
	#_coverageTracker10809614_
		coverAll:
			{12 to: 12}
		byLiteralOrPseudoVariable: 1 ].
	#_coverageTracker10809614_
		coverAll:
			{16 to: 20}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test016_2_CoversTheEvaluationOfABlock stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
multipleEmptyBlocks
	#_coverageTracker10809649_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [
	#_coverageTracker10809649_
		coverAll:
			{26 to: 26}
		byLiteralOrPseudoVariable: 1 ].
	#_coverageTracker10809649_
		coverAll:
			{30 to: 34}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ [
	#_coverageTracker10809649_
		coverAll:
			{40 to: 40}
		byLiteralOrPseudoVariable: 2 ].
	#_coverageTracker10809649_
		coverAll:
			{44 to: 48}
		evaluating: [ receiver2 value ]
		thatSends: #value
		to: receiver2 ] value.! !

!testRun: #CodeCoverageTest #test016_3_CoversTheEvaluationOfMultipleBlocks stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
multipleOcurrencesOfTheSameBlockNode
	#_coverageTracker10809653_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [
	#_coverageTracker10809653_
		coverAll:
			{43 to: 43}
		byLiteralOrPseudoVariable: 1 ].
	#_coverageTracker10809653_
		coverAll:
			{47 to: 51}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ [
	#_coverageTracker10809653_
		coverAll:
			{57 to: 57}
		byLiteralOrPseudoVariable: 1 ].
	#_coverageTracker10809653_
		coverAll:
			{61 to: 65}
		evaluating: [ receiver2 value ]
		thatSends: #value
		to: receiver2 ] value.! !

!testRun: #CodeCoverageTest #test016_4_CoversMultipleOcurrencesOfTheSameBlockNode stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
notEvaluatedBlockNode
	#_coverageTracker10809655_ markAsExecuted.
	[
	#_coverageTracker10809655_
		coverAll:
			{28 to: 28}
		byLiteralOrPseudoVariable: 1 ].! !

!testRun: #CodeCoverageTest #test016_5_DoesNotCoverBlockNodesThatAreNotEvaluated stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
blockWithTemporaryVariables
	#_coverageTracker10809657_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [ | a b |
	#_coverageTracker10809657_
		cover: (44 to: 44)
		declaredAt: (36 to: 36)
		by:
			(a _ #_coverageTracker10809657_
				coverAll:
					{49 to: 49}
				byLiteralOrPseudoVariable: 1).
	#_coverageTracker10809657_
		cover: (54 to: 54)
		declaredAt: (38 to: 38)
		by:
			(b _ #_coverageTracker10809657_
				coverAll:
					{59 to: 59}
				byLiteralOrPseudoVariable: 2) ].
	#_coverageTracker10809657_
		coverAll:
			{63 to: 67}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test016_7_CoversMultipleTemporaryVariablesInABlock stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
blockWithArguments
	#_coverageTracker10809692_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ :a :b |
	[ | receiver1 |
	receiver1 _ #_coverageTracker10809692_
		cover: (33 to: 33)
		declaredAt: (26 to: 26)
		by: a.
	#_coverageTracker10809692_
		coverAll:
			{35 to: 35}
		evaluating: [
			receiver1 +
				(#_coverageTracker10809692_
					cover: (37 to: 37)
					declaredAt: (29 to: 29)
					by: b) ]
		thatSends: #+
		to: receiver1 ] value ].
	#_coverageTracker10809692_
		coverAll:
			{41 to: 46. 50 to: 55}
		evaluating: [
			receiver2
				value:
					(#_coverageTracker10809692_
						coverAll:
							{48 to: 48}
						byLiteralOrPseudoVariable: 1)
				value:
					(#_coverageTracker10809692_
						coverAll:
							{56 to: 57}
						byLiteralOrPseudoVariable: 2) ]
		thatSends: #value:value:
		to: receiver2 ] value.! !

!testRun: #CodeCoverageTest #test016_8_CoversBlockArgumentsWhenTheyAreReferenced stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
braceNode
	#_coverageTracker10809698_ markAsExecuted.
	#_coverageTracker10809698_
		coverAll:
			{14 to: 18}
		byLiteralOrPseudoVariable:
			{1}.! !

!testRun: #CodeCoverageTest #test017_1_CoversABraceNode stamp: 'psm 10/17/2023 21:43:21'!
PASSED!
!Behavior method!
multipleBraceNodes
	#_coverageTracker10809698_ markAsExecuted.
	#_coverageTracker10809698_
		coverAll:
			{23 to: 27}
		byLiteralOrPseudoVariable:
			{1}.
	#_coverageTracker10809698_
		coverAll:
			{31 to: 35}
		byLiteralOrPseudoVariable:
			{2}.! !

!testRun: #CodeCoverageTest #test017_2_CoversMultipleBraceNodes stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
multipleOcurrencesOfTheSameBraceNode
	#_coverageTracker10809731_ markAsExecuted.
	#_coverageTracker10809731_
		coverAll:
			{41 to: 45}
		byLiteralOrPseudoVariable:
			{1}.
	#_coverageTracker10809731_
		coverAll:
			{49 to: 53}
		byLiteralOrPseudoVariable:
			{1}.! !

!testRun: #CodeCoverageTest #test017_3_CoversMultipleOcurrencesOfTheSameBraceNode stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
notExecutedBraceNode
	#_coverageTracker10809733_ markAsExecuted.
	[
	#_coverageTracker10809733_
		coverAll:
			{27 to: 31}
		byLiteralOrPseudoVariable:
			{1} ].! !

!testRun: #CodeCoverageTest #test017_4_DoesNotCoverBraceNodesThatAreNotExecuted stamp: 'psm 10/17/2023 21:43:22'!
PASSED!

!testRun: #CodeCoverageTest #test018_1_CoversACascadeMessageSend stamp: 'psm 10/17/2023 21:43:22'!
ERROR!

!testRun: #CodeCoverageTest #test018_2_CoversACascadeMessageSendWithArgument stamp: 'psm 10/17/2023 21:43:22'!
ERROR!
!Behavior method!
implicitSelfReturnWhenSelfIsReferenced
	#_coverageTracker10809737_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10809737_
		coverAll:
			{43 to: 46}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker10809737_
		coverAll:
			{48 to: 52}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test019_CoversCollaborationsWithImplicitSelfReturnsWhenSelfIsReferenced stamp: 'psm 10/17/2023 21:43:22'!
PASSED!

!testRun: #CodeCoverageTest #test020_DoesNotCoverMessageArgumentsThatAreNotExecuted stamp: 'psm 10/17/2023 21:43:22'!
ERROR!
!Behavior method!
optimizedMessage
	#_coverageTracker10809762_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker10809762_
		coverAll:
			{21 to: 21}
		byLiteralOrPseudoVariable: 1.
	#_coverageTracker10809762_
		coverAll:
			{23 to: 25. 30 to: 32}
		evaluating: [
			receiver2
				to:
					(#_coverageTracker10809762_
						coverAll:
							{27 to: 28}
						byLiteralOrPseudoVariable: 10)
				do: [ :number |
					[ | receiver1 |
					receiver1 _ #_coverageTracker10809762_
						cover: (46 to: 51)
						declaredAt: (37 to: 42)
						by: number.
					#_coverageTracker10809762_
						coverAll:
							{53 to: 57}
						evaluating: [ receiver1 value ]
						thatSends: #value
						to: receiver1 ] value ]]
		thatSends: #to:do:
		to: receiver2 ] value.! !

!testRun: #CodeCoverageTest #test021_CoversOptimizedMessages stamp: 'psm 10/17/2023 21:43:22'!
PASSED!

!testRun: #CodeCoverageTest #test022_CoversTheReceiverOfACascadeNodeWhenItIsAMessageSend stamp: 'psm 10/17/2023 21:43:22'!
ERROR!
!Behavior method!
cascadeNodeWithBlockReceiverThatIsEvaluated
	#_coverageTracker10809768_ markAsExecuted.
	[ | cascadeReceiver |
	cascadeReceiver _ [
	[ | receiver1 |
	receiver1 _ #_coverageTracker10809768_
		coverAll:
			{49 to: 52}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker10809768_
		coverAll:
			{54 to: 58}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value ].
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker10809768_
		coverAll:
			{64 to: 68}
		evaluating: [ receiver2 class ]
		thatSends: #class
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker10809768_
		coverAll:
			{73 to: 77}
		evaluating: [ receiver3 value ]
		thatSends: #value
		to: receiver3 ] value ] value.! !

!testRun: #CodeCoverageTest #test023_CoversTheReceiverOfACascadeNodeWhenItIsABlockThatIsEvaluated stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
cascadeNodeWithBlockReceiverThatIsNotEvaluated
	#_coverageTracker10809770_ markAsExecuted.
	[ | cascadeReceiver |
	cascadeReceiver _ [
	[ | receiver1 |
	receiver1 _ #_coverageTracker10809770_
		coverAll:
			{52 to: 55}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker10809770_
		coverAll:
			{57 to: 61}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value ].
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker10809770_
		coverAll:
			{67 to: 71}
		evaluating: [ receiver2 class ]
		thatSends: #class
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker10809770_
		coverAll:
			{76 to: 79}
		evaluating: [ receiver3 hash ]
		thatSends: #hash
		to: receiver3 ] value ] value.! !

!testRun: #CodeCoverageTest #test024_DoesNotCoverTheReceiverOfACascadeNodeWhenItIsABlockThatIsNotExecuted stamp: 'psm 10/17/2023 21:43:22'!
PASSED!

!testRun: #CodeCoverageTest #test025_CoversTheReceiverOfAMessageSendWhenItIsAMessageSend stamp: 'psm 10/17/2023 21:43:22'!
ERROR!

!testRun: #CodeCoverageTest #test026_CoversTheReceiverOfAMessageSendWhenItIsABlockThatIsEvaluated stamp: 'psm 10/17/2023 21:43:22'!
ERROR!

!testRun: #CodeCoverageTest #test027_DoesNotCoverTheReceiverOfAMessageSendWhenItIsABlockThatIsNotEvaluated stamp: 'psm 10/17/2023 21:43:22'!
ERROR!
!Behavior method!
value
	"This example overrides uses super to send the same message that was received.
	
	It is used to verify that a bug was not introduced by the code coverage machinery, because
	wrapping super in a message to track code coverage will return self and the #value message
	will end up being dispatched to self instead of super (as intended) leading to an infinite loop."
	#_coverageTracker10809838_ markAsExecuted.
	#_coverageTracker10809838_
		coverAll:
			{381 to: 385}
		evaluating: [ super value ]
		thatSends: #value
		to: super.! !

!testRun: #CodeCoverageTest #test028_DoesNotCoverSuper stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
foo: aBoolean
	#_coverageTracker10809842_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10809842_
		cover: (17 to: 24)
		declaredAt: (6 to: 13)
		by: aBoolean.
	#_coverageTracker10809842_
		coverAll:
			{28 to: 34. 44 to: 51}
		evaluating: [
			receiver1
				ifTrue: [
					#_coverageTracker10809842_
						coverAll:
							{38 to: 38}
						byLiteralOrPseudoVariable: 1 ]
				ifFalse: [
					#_coverageTracker10809842_
						coverAll:
							{55 to: 55}
						byLiteralOrPseudoVariable: 2 ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test029_Informs0PercentCoverageWhenNoneOfTheCompiledMethodCollaborationsAreCovered stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
foo: aBoolean
	#_coverageTracker10809877_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10809877_
		cover: (17 to: 24)
		declaredAt: (6 to: 13)
		by: aBoolean.
	#_coverageTracker10809877_
		coverAll:
			{28 to: 34. 44 to: 51}
		evaluating: [
			receiver1
				ifTrue: [
					#_coverageTracker10809877_
						coverAll:
							{38 to: 38}
						byLiteralOrPseudoVariable: 1 ]
				ifFalse: [
					#_coverageTracker10809877_
						coverAll:
							{55 to: 55}
						byLiteralOrPseudoVariable: 2 ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test030_Informs100PercentCoverageWhenAllOfTheCompiledMethodCollaborationsAreCovered stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
foo: aBoolean
	#_coverageTracker10809881_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10809881_
		cover: (17 to: 24)
		declaredAt: (6 to: 13)
		by: aBoolean.
	#_coverageTracker10809881_
		coverAll:
			{28 to: 34. 44 to: 51}
		evaluating: [
			receiver1
				ifTrue: [
					#_coverageTracker10809881_
						coverAll:
							{38 to: 38}
						byLiteralOrPseudoVariable: 1 ]
				ifFalse: [
					#_coverageTracker10809881_
						coverAll:
							{55 to: 55}
						byLiteralOrPseudoVariable: 2 ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test030_InformsThePercentageOfCollaborationsThatWereCoveredInACompiledMethod stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
foo: aBoolean
	#_coverageTracker10809883_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10809883_
		cover: (17 to: 24)
		declaredAt: (6 to: 13)
		by: aBoolean.
	#_coverageTracker10809883_
		coverAll:
			{28 to: 34. 44 to: 51}
		evaluating: [
			receiver1
				ifTrue: [
					#_coverageTracker10809883_
						coverAll:
							{38 to: 38}
						byLiteralOrPseudoVariable: 1 ]
				ifFalse: [
					#_coverageTracker10809883_
						coverAll:
							{55 to: 55}
						byLiteralOrPseudoVariable: 2 ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test031_DoesNotCountCoveredCollaborationsMoreThanOnce stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
foo: aBoolean
	#_coverageTracker10809921_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10809921_
		cover: (17 to: 24)
		declaredAt: (6 to: 13)
		by: aBoolean.
	#_coverageTracker10809921_
		coverAll:
			{28 to: 34. 44 to: 51}
		evaluating: [
			receiver1
				ifTrue: [
					#_coverageTracker10809921_
						coverAll:
							{38 to: 38}
						byLiteralOrPseudoVariable: 1 ]
				ifFalse: [
					#_coverageTracker10809921_
						coverAll:
							{55 to: 55}
						byLiteralOrPseudoVariable: 2 ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test032_AppendsCoveredCollaborationsMadeFromDifferentCallsToACompiledMethod stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
foo: aBoolean
	#_coverageTracker10809925_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10809925_
		cover: (17 to: 24)
		declaredAt: (6 to: 13)
		by: aBoolean.
	#_coverageTracker10809925_
		coverAll:
			{28 to: 34. 44 to: 51}
		evaluating: [
			receiver1
				ifTrue: [
					#_coverageTracker10809925_
						coverAll:
							{38 to: 38}
						byLiteralOrPseudoVariable: 1 ]
				ifFalse: [
					#_coverageTracker10809925_
						coverAll:
							{55 to: 55}
						byLiteralOrPseudoVariable: 2 ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver1 ] value.! !
!Behavior method!
foo: aBoolean
	#_coverageTracker10809927_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10809927_
		cover: (17 to: 24)
		declaredAt: (6 to: 13)
		by: aBoolean.
	#_coverageTracker10809927_
		coverAll:
			{28 to: 34. 44 to: 51}
		evaluating: [
			receiver1
				ifTrue: [
					#_coverageTracker10809927_
						coverAll:
							{38 to: 38}
						byLiteralOrPseudoVariable: 1 ]
				ifFalse: [
					#_coverageTracker10809927_
						coverAll:
							{55 to: 55}
						byLiteralOrPseudoVariable: 2 ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test034_OverwritesCodeCoverageReportsGeneratedFromPreviouslyAnalizedBlocks stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
emptyMethod
	#_coverageTracker10809962_ markAsExecuted.! !

!testRun: #CodeCoverageTest #test035_Informs100PercentCoverageWhenCoveringAnEmptyCompiledMethod stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
foo: aBoolean
	#_coverageTracker10809964_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10809964_
		cover: (17 to: 24)
		declaredAt: (6 to: 13)
		by: aBoolean.
	#_coverageTracker10809964_
		coverAll:
			{28 to: 34. 44 to: 51}
		evaluating: [
			receiver1
				ifTrue: [
					#_coverageTracker10809964_
						coverAll:
							{38 to: 38}
						byLiteralOrPseudoVariable: 1 ]
				ifFalse: [
					#_coverageTracker10809964_
						coverAll:
							{55 to: 55}
						byLiteralOrPseudoVariable: 2 ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test036_Informs0PercentCoverageWhenNoneOfTheAnalyzedCompiledMethodsOfAClassHaveBeenCovered stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
emptyMethod
	#_coverageTracker10809966_ markAsExecuted.! !

!testRun: #CodeCoverageTest #test037_DoesNotCoverEmptyMethods stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
emptyMethod
	#_coverageTracker10809968_ markAsExecuted.! !

!testRun: #CodeCoverageTest #test039_Informs100PercentCoverageWhenAllOfTheAnalyzedCompiledMethodsOfAClassHaveBeenCovered stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
emptyMethod
	#_coverageTracker10810001_ markAsExecuted.! !
!Behavior method!
foo: aBoolean
	#_coverageTracker10810001_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810001_
		cover: (17 to: 24)
		declaredAt: (6 to: 13)
		by: aBoolean.
	#_coverageTracker10810001_
		coverAll:
			{28 to: 34. 44 to: 51}
		evaluating: [
			receiver1
				ifTrue: [
					#_coverageTracker10810001_
						coverAll:
							{38 to: 38}
						byLiteralOrPseudoVariable: 1 ]
				ifFalse: [
					#_coverageTracker10810001_
						coverAll:
							{55 to: 55}
						byLiteralOrPseudoVariable: 2 ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test040_CalculatesThePercentCoverageOfAClassBasedOnThePercentCoverageOfItsAnalyzedCompiledMethods stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
emptyMethod
	#_coverageTracker10810005_ markAsExecuted.! !
!Behavior method!
foo: aBoolean
	#_coverageTracker10810007_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810007_
		cover: (17 to: 24)
		declaredAt: (6 to: 13)
		by: aBoolean.
	#_coverageTracker10810007_
		coverAll:
			{28 to: 34. 44 to: 51}
		evaluating: [
			receiver1
				ifTrue: [
					#_coverageTracker10810007_
						coverAll:
							{38 to: 38}
						byLiteralOrPseudoVariable: 1 ]
				ifFalse: [
					#_coverageTracker10810007_
						coverAll:
							{55 to: 55}
						byLiteralOrPseudoVariable: 2 ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver1 ] value.! !
!Behavior method!
emptyMethod
	#_coverageTracker10810009_ markAsExecuted.! !
!Behavior method!
foo: aBoolean
	#_coverageTracker10810042_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810042_
		cover: (17 to: 24)
		declaredAt: (6 to: 13)
		by: aBoolean.
	#_coverageTracker10810042_
		coverAll:
			{28 to: 34. 44 to: 51}
		evaluating: [
			receiver1
				ifTrue: [
					#_coverageTracker10810042_
						coverAll:
							{38 to: 38}
						byLiteralOrPseudoVariable: 1 ]
				ifFalse: [
					#_coverageTracker10810042_
						coverAll:
							{55 to: 55}
						byLiteralOrPseudoVariable: 2 ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test041_OverwritesCodeCoverageReportsForClassesGeneratedFromPreviouslyAnalizedBlocks stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
m1
	#_coverageTracker10810063_ markAsExecuted.
	^ #_coverageTracker10810063_
		coverAll:
			{8 to: 11}
		byLiteralOrPseudoVariable: #foo.! !

!testRun: #CodeCoverageTest #test043_Informs100PercentCoverageWhenAllOfTheAnalizedClassesInASystemCategoryHave100PercentCoverage stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
m1
	#_coverageTracker10810065_ markAsExecuted.
	^ #_coverageTracker10810065_
		coverAll:
			{8 to: 11}
		byLiteralOrPseudoVariable: #foo.! !

!testRun: #CodeCoverageTest #test044_Informs0PercentCoverageWhenNoneOfTheAnalizedClassesInASystemCategoryHaveBeenCovered stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
m1
	#_coverageTracker10810067_ markAsExecuted.
	^ #_coverageTracker10810067_
		coverAll:
			{8 to: 11}
		byLiteralOrPseudoVariable: #foo.! !
!Behavior method!
m2
	#_coverageTracker10810067_ markAsExecuted.! !
!Behavior method!
m3
	#_coverageTracker10810067_ markAsExecuted.! !

!testRun: #CodeCoverageTest #test045_InformsThePercentageOfCollaborationsThatWereCoveredInACompiledMethod stamp: 'psm 10/17/2023 21:43:22'!
PASSED!

!testRun: #CodeCoverageTest #test046_CoversMessagesThatSignalAnError stamp: 'psm 10/17/2023 21:43:22'!
FAILURE!
!Behavior method!
messageWithArgument: anArgument
	#_coverageTracker10810069_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810069_
		cover: (36 to: 45)
		declaredAt: (22 to: 31)
		by: anArgument.
	#_coverageTracker10810069_
		coverAll:
			{47 to: 51}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test047_CoversSelectorArgumentsWhenTheyAreReferenced stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
raiseErrorFromBlock
	#_coverageTracker10810104_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ [
	[ | receiver2 |
	receiver2 _ #_coverageTracker10810104_
		coverAll:
			{25 to: 28}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker10810104_
		coverAll:
			{30 to: 35}
		evaluating: [
			receiver2 error:
				[ | receiver1 |
				receiver1 _ #_coverageTracker10810104_
					coverAll:
						{37 to: 40}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker10810104_
					coverAll:
						{42 to: 63}
					evaluating: [ receiver1 errorMessageForTesting ]
					thatSends: #errorMessageForTesting
					to: receiver1 ] value ]
		thatSends: #error:
		to: receiver2 ] value ].
	#_coverageTracker10810104_
		coverAll:
			{67 to: 71}
		evaluating: [ receiver3 value ]
		thatSends: #value
		to: receiver3 ] value.! !

!testRun: #CodeCoverageTest #test048_CoversBlocksThatSignalAnError stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
temporaryVariableAssignment
	| a |
	#_coverageTracker10810108_ markAsExecuted.
	#_coverageTracker10810108_
		cover: (39 to: 39)
		declaredAt: (33 to: 33)
		by:
			(a _ #_coverageTracker10810108_
				coverAll:
					{43 to: 44}
				byLiteralOrPseudoVariable: 1).! !

!testRun: #CodeCoverageTest #test049_CoversTemporaryVariablesAndTheirDeclarationsWhenTheTemporaryVariableIsWritten stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
temporaryVariableReadAndAssignment
	| a |
	#_coverageTracker10810110_ markAsExecuted.
	#_coverageTracker10810110_
		cover: (45 to: 45)
		declaredAt: (40 to: 40)
		by:
			(a _ #_coverageTracker10810110_
				coverAll:
					{50 to: 50}
				byLiteralOrPseudoVariable: 1).
	#_coverageTracker10810110_
		cover: (55 to: 55)
		declaredAt: (40 to: 40)
		by: a.! !

!testRun: #CodeCoverageTest #test050_CoversTemporaryVariablesAndTheirDeclarationsOnlyOnceWhenTheTemporaryVariableIsReadOrWrittenMoreThanOnce stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
messageWithUnusedArgument: anArgument
	#_coverageTracker10810112_ markAsExecuted.
	[
	#_coverageTracker10810112_
		cover: (43 to: 52)
		declaredAt: (28 to: 37)
		by: anArgument ].! !

!testRun: #CodeCoverageTest #test051_DoesNotCoversSelectorArgumentsWhenTheyAreNotReferenced stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
messageArgumentUsedManyTimes: anArgument
	#_coverageTracker10810145_ markAsExecuted.
	#_coverageTracker10810145_
		cover: (44 to: 53)
		declaredAt: (31 to: 40)
		by: anArgument.
	#_coverageTracker10810145_
		cover: (57 to: 66)
		declaredAt: (31 to: 40)
		by: anArgument.! !

!testRun: #CodeCoverageTest #test052_CoversSelectorArgumentsOnlyOnceWhenTheyAreReferencedMultipleTimes stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
blockWithUnusedArgument
	#_coverageTracker10810149_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [ :a |
	nil ].
	#_coverageTracker10810149_
		coverAll:
			{36 to: 41}
		evaluating: [
			receiver1 value:
				(#_coverageTracker10810149_
					coverAll:
						{42 to: 43}
					byLiteralOrPseudoVariable: 1) ]
		thatSends: #value:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test053_DoesNotCoverBlockArgumentsWhenTheyAreNotReferenced stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
blockWithArgumentUsedManyTimes
	#_coverageTracker10810151_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ :argument |
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810151_
		cover: (48 to: 55)
		declaredAt: (37 to: 44)
		by: argument.
	#_coverageTracker10810151_
		coverAll:
			{57 to: 57}
		evaluating: [
			receiver1 +
				(#_coverageTracker10810151_
					cover: (59 to: 66)
					declaredAt: (37 to: 44)
					by: argument) ]
		thatSends: #+
		to: receiver1 ] value ].
	#_coverageTracker10810151_
		coverAll:
			{70 to: 75}
		evaluating: [
			receiver2 value:
				(#_coverageTracker10810151_
					coverAll:
						{76 to: 77}
					byLiteralOrPseudoVariable: 1) ]
		thatSends: #value:
		to: receiver2 ] value.! !

!testRun: #CodeCoverageTest #test054_CoversBlockArgumentsOnlyOnceWhenTheyAreReferencedMultipleTimes stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
blockWithReadTemporaryVariable
	#_coverageTracker10810186_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [ | a |
	#_coverageTracker10810186_
		cover: (40 to: 40)
		declaredAt: (37 to: 37)
		by: a ].
	#_coverageTracker10810186_
		coverAll:
			{44 to: 48}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test055_CoversBlockTemporaryVariablesAndTheirDeclarationsWhenTheTemporaryVariablesAreRead stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
blockWithWrittenTemporaryVariable
	#_coverageTracker10810190_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [ | a |
	#_coverageTracker10810190_
		cover: (43 to: 43)
		declaredAt: (40 to: 40)
		by:
			(a _ #_coverageTracker10810190_
				coverAll:
					{47 to: 47}
				byLiteralOrPseudoVariable: 1) ].
	#_coverageTracker10810190_
		coverAll:
			{51 to: 55}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test056_CoversBlockTemporaryVariablesAndTheirDeclarationsWhenTheTemporaryVariablesAreWritten stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
blockWithReadAndWrittenTemporaryVariable
	#_coverageTracker10810192_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [ | a |
	#_coverageTracker10810192_
		cover: (50 to: 50)
		declaredAt: (47 to: 47)
		by:
			(a _ #_coverageTracker10810192_
				coverAll:
					{55 to: 55}
				byLiteralOrPseudoVariable: 1).
	#_coverageTracker10810192_
		cover: (58 to: 58)
		declaredAt: (47 to: 47)
		by: a ].
	#_coverageTracker10810192_
		coverAll:
			{62 to: 66}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test057_CoversBlockTemporaryVariablesAndTheirDeclarationsOnlyOnceWhenTheTemporaryVariablesAreReferencedMultipleTimes stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
assignment
	#_coverageTracker10810219_ markAsExecuted.
	#_coverageTracker10810219_
		cover: (15 to: 30)
		declaredAt: (15 to: 30)
		by:
			(instanceVariable _ #_coverageTracker10810219_
				coverAll:
					{34 to: 35}
				byLiteralOrPseudoVariable: 1).! !

!testRun: #CodeCoverageTest #test058_DoesNotCoverMethodsThatWereNotExecuted stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
temporaryVariableAssignedToTrue
	| a |
	#_coverageTracker10810221_ markAsExecuted.
	#_coverageTracker10810221_
		cover: (44 to: 44)
		declaredAt: (37 to: 37)
		by:
			(a _ #_coverageTracker10810221_
				coverAll:
					{48 to: 51}
				byLiteralOrPseudoVariable: true).! !

!testRun: #CodeCoverageTest #test059_PartiallyCoversABooleanTemporaryVariableDeclarationThatHasOnlyBeenAssignedToTrue stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
temporaryVariableAssignedToFalse
	| a |
	#_coverageTracker10810223_ markAsExecuted.
	#_coverageTracker10810223_
		cover: (45 to: 45)
		declaredAt: (38 to: 38)
		by:
			(a _ #_coverageTracker10810223_
				coverAll:
					{49 to: 53}
				byLiteralOrPseudoVariable: false).! !

!testRun: #CodeCoverageTest #test060_PartiallyCoversABooleanTemporaryVariableDeclarationThatHasOnlyBeenAssignedToFalse stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
temporaryVariableAssignedToTrueAndFalse
	| a |
	#_coverageTracker10810225_ markAsExecuted.
	#_coverageTracker10810225_
		cover: (52 to: 52)
		declaredAt: (45 to: 45)
		by:
			(a _ #_coverageTracker10810225_
				coverAll:
					{56 to: 59}
				byLiteralOrPseudoVariable: true).
	#_coverageTracker10810225_
		cover: (63 to: 63)
		declaredAt: (45 to: 45)
		by:
			(a _ #_coverageTracker10810225_
				coverAll:
					{67 to: 71}
				byLiteralOrPseudoVariable: false).! !

!testRun: #CodeCoverageTest #test061_FullyCoversABooleanTemporaryVariableDeclarationThatHasBeenAssignedToTrueAndFalse stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
temporaryVariableAssignedToTrueMoreThanOnce
	| a |
	#_coverageTracker10810289_ markAsExecuted.
	#_coverageTracker10810289_
		cover: (56 to: 56)
		declaredAt: (49 to: 49)
		by:
			(a _ #_coverageTracker10810289_
				coverAll:
					{60 to: 63}
				byLiteralOrPseudoVariable: true).
	#_coverageTracker10810289_
		cover: (67 to: 67)
		declaredAt: (49 to: 49)
		by:
			(a _ #_coverageTracker10810289_
				coverAll:
					{71 to: 74}
				byLiteralOrPseudoVariable: true).! !

!testRun: #CodeCoverageTest #test062_DoesNotCountMultipleAssignmentsWithTheSameValueToBooleanTemporaryVariables stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
temporaryVariableAssignedToBooleanAndThenNonBoolean
	| a |
	#_coverageTracker10810293_ markAsExecuted.
	#_coverageTracker10810293_
		cover: (64 to: 64)
		declaredAt: (57 to: 57)
		by:
			(a _ #_coverageTracker10810293_
				coverAll:
					{68 to: 71}
				byLiteralOrPseudoVariable: true).
	#_coverageTracker10810293_
		cover: (75 to: 75)
		declaredAt: (57 to: 57)
		by:
			(a _ #_coverageTracker10810293_
				coverAll:
					{79 to: 79}
				byLiteralOrPseudoVariable: 1).! !

!testRun: #CodeCoverageTest #test063_DoesNotConsiderATemporaryDeclarationAsBooleanWhenItIsAssignedToABooleanAndThenToANonBoolean stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
temporaryVariableAssignedToNonBooleanAndThenBoolean
	| a |
	#_coverageTracker10810295_ markAsExecuted.
	#_coverageTracker10810295_
		cover: (64 to: 64)
		declaredAt: (57 to: 57)
		by:
			(a _ #_coverageTracker10810295_
				coverAll:
					{68 to: 68}
				byLiteralOrPseudoVariable: 1).
	#_coverageTracker10810295_
		cover: (72 to: 72)
		declaredAt: (57 to: 57)
		by:
			(a _ #_coverageTracker10810295_
				coverAll:
					{76 to: 79}
				byLiteralOrPseudoVariable: true).! !

!testRun: #CodeCoverageTest #test064_DoesNotConsiderATemporaryDeclarationAsBooleanWhenItIsAssignedToANonBooleanAndThenToABoolean stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
methodWithOneArgument: arg
	#_coverageTracker10810330_ markAsExecuted.
	#_coverageTracker10810330_
		cover: (30 to: 32)
		declaredAt: (24 to: 26)
		by: arg.! !

!testRun: #CodeCoverageTest #test065_PartiallyCoversABooleanArgumentThatHasOnlyBeenAssignedToTrue stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
methodWithOneArgument: arg
	#_coverageTracker10810332_ markAsExecuted.
	#_coverageTracker10810332_
		cover: (30 to: 32)
		declaredAt: (24 to: 26)
		by: arg.! !

!testRun: #CodeCoverageTest #test066_PartiallyCoversABooleanArgumentThatHasOnlyBeenAssignedToFalse stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
methodWithOneArgument: arg
	#_coverageTracker10810332_ markAsExecuted.
	#_coverageTracker10810332_
		cover: (30 to: 32)
		declaredAt: (24 to: 26)
		by: arg.! !

!testRun: #CodeCoverageTest #test067_FullyCoversABooleanArgumentThatHasBeenAssignedToTrueAndFalse stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
methodWithOneArgument: arg
	#_coverageTracker10810336_ markAsExecuted.
	#_coverageTracker10810336_
		cover: (30 to: 32)
		declaredAt: (24 to: 26)
		by: arg.! !

!testRun: #CodeCoverageTest #test068_DoesNotCountMultipleAssignmentsWithTheSameValueToBooleanArguments stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
methodWithOneArgument: arg
	#_coverageTracker10810338_ markAsExecuted.
	#_coverageTracker10810338_
		cover: (30 to: 32)
		declaredAt: (24 to: 26)
		by: arg.! !

!testRun: #CodeCoverageTest #test069_DoesNotConsiderAnArgumentAsBooleanWhenItIsAssignedToABooleanAndThenToANonBoolean stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
methodWithOneArgument: arg
	#_coverageTracker10810371_ markAsExecuted.
	#_coverageTracker10810371_
		cover: (30 to: 32)
		declaredAt: (24 to: 26)
		by: arg.! !

!testRun: #CodeCoverageTest #test070_DoesNotConsiderAnArgumentAsBooleanWhenItIsAssignedToANonBooleanAndThenToABoolean stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
blockWithArgumentAssignedToTrue
	#_coverageTracker10810376_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ :arg |
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810376_
		cover: (44 to: 46)
		declaredAt: (38 to: 40)
		by: arg.
	#_coverageTracker10810376_
		coverAll:
			{48 to: 58}
		evaluating: [ receiver1 printString ]
		thatSends: #printString
		to: receiver1 ] value ].
	#_coverageTracker10810376_
		coverAll:
			{62 to: 67}
		evaluating: [
			receiver2 value:
				(#_coverageTracker10810376_
					coverAll:
						{69 to: 72}
					byLiteralOrPseudoVariable: true) ]
		thatSends: #value:
		to: receiver2 ] value.! !

!testRun: #CodeCoverageTest #test071_PartiallyCoversABooleanBlockArgumentThatHasOnlyBeenAssignedToTrue stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
blockWithArgumentAssignedToFalse
	#_coverageTracker10810380_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ :arg |
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810380_
		cover: (45 to: 47)
		declaredAt: (39 to: 41)
		by: arg.
	#_coverageTracker10810380_
		coverAll:
			{49 to: 59}
		evaluating: [ receiver1 printString ]
		thatSends: #printString
		to: receiver1 ] value ].
	#_coverageTracker10810380_
		coverAll:
			{63 to: 68}
		evaluating: [
			receiver2 value:
				(#_coverageTracker10810380_
					coverAll:
						{70 to: 74}
					byLiteralOrPseudoVariable: false) ]
		thatSends: #value:
		to: receiver2 ] value.! !

!testRun: #CodeCoverageTest #test072_PartiallyCoversABooleanBlockArgumentThatHasOnlyBeenAssignedToFalse stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
blockWithArgument: anArgument
	#_coverageTracker10810415_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ :arg |
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810415_
		cover: (42 to: 44)
		declaredAt: (36 to: 38)
		by: arg.
	#_coverageTracker10810415_
		coverAll:
			{46 to: 56}
		evaluating: [ receiver1 printString ]
		thatSends: #printString
		to: receiver1 ] value ].
	#_coverageTracker10810415_
		coverAll:
			{60 to: 65}
		evaluating: [
			receiver2 value:
				(#_coverageTracker10810415_
					cover: (67 to: 76)
					declaredAt: (20 to: 29)
					by: anArgument) ]
		thatSends: #value:
		to: receiver2 ] value.! !

!testRun: #CodeCoverageTest #test073_FullyCoversABooleanBlockArgumentThatHasBeenAssignedToTrueAndFalse stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
blockWithArgument: anArgument
	#_coverageTracker10810443_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ :arg |
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810443_
		cover: (42 to: 44)
		declaredAt: (36 to: 38)
		by: arg.
	#_coverageTracker10810443_
		coverAll:
			{46 to: 56}
		evaluating: [ receiver1 printString ]
		thatSends: #printString
		to: receiver1 ] value ].
	#_coverageTracker10810443_
		coverAll:
			{60 to: 65}
		evaluating: [
			receiver2 value:
				(#_coverageTracker10810443_
					cover: (67 to: 76)
					declaredAt: (20 to: 29)
					by: anArgument) ]
		thatSends: #value:
		to: receiver2 ] value.! !

!testRun: #CodeCoverageTest #test074_DoesNotCountMultipleAssignmentsWithTheSameValueToBlockBooleanArguments stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
blockWithArgument: anArgument
	#_coverageTracker10810450_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ :arg |
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810450_
		cover: (42 to: 44)
		declaredAt: (36 to: 38)
		by: arg.
	#_coverageTracker10810450_
		coverAll:
			{46 to: 56}
		evaluating: [ receiver1 printString ]
		thatSends: #printString
		to: receiver1 ] value ].
	#_coverageTracker10810450_
		coverAll:
			{60 to: 65}
		evaluating: [
			receiver2 value:
				(#_coverageTracker10810450_
					cover: (67 to: 76)
					declaredAt: (20 to: 29)
					by: anArgument) ]
		thatSends: #value:
		to: receiver2 ] value.! !

!testRun: #CodeCoverageTest #test075_DoesNotConsiderABlockArgumentAsBooleanWhenItIsAssignedToABooleanAndThenToANonBoolean stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
blockWithArgument: anArgument
	#_coverageTracker10810515_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ :arg |
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810515_
		cover: (42 to: 44)
		declaredAt: (36 to: 38)
		by: arg.
	#_coverageTracker10810515_
		coverAll:
			{46 to: 56}
		evaluating: [ receiver1 printString ]
		thatSends: #printString
		to: receiver1 ] value ].
	#_coverageTracker10810515_
		coverAll:
			{60 to: 65}
		evaluating: [
			receiver2 value:
				(#_coverageTracker10810515_
					cover: (67 to: 76)
					declaredAt: (20 to: 29)
					by: anArgument) ]
		thatSends: #value:
		to: receiver2 ] value.! !

!testRun: #CodeCoverageTest #test076_DoesNotConsiderABlockArgumentAsBooleanWhenItIsAssignedToANonBooleanAndThenToABoolean stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
assignBlockTemporary: aValue
	"This example returns 1 when evaluating the block to avoid excersicing the boolean selector feature as well"
	#_coverageTracker10810519_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [ | a |
	#_coverageTracker10810519_
		cover: (153 to: 153)
		declaredAt: (148 to: 148)
		by:
			(a _ #_coverageTracker10810519_
				cover: (157 to: 162)
				declaredAt: (23 to: 28)
				by: aValue).
	#_coverageTracker10810519_
		coverAll:
			{167 to: 167}
		byLiteralOrPseudoVariable: 1 ].
	#_coverageTracker10810519_
		coverAll:
			{171 to: 175}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test077_PartiallyCoversABlockBooleanTemporaryVariableDeclarationThatHasOnlyBeenAssignedToTrue stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
assignBlockTemporary: aValue
	"This example returns 1 when evaluating the block to avoid excersicing the boolean selector feature as well"
	#_coverageTracker10810556_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [ | a |
	#_coverageTracker10810556_
		cover: (153 to: 153)
		declaredAt: (148 to: 148)
		by:
			(a _ #_coverageTracker10810556_
				cover: (157 to: 162)
				declaredAt: (23 to: 28)
				by: aValue).
	#_coverageTracker10810556_
		coverAll:
			{167 to: 167}
		byLiteralOrPseudoVariable: 1 ].
	#_coverageTracker10810556_
		coverAll:
			{171 to: 175}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test078_PartiallyCoversABlockBooleanTemporaryVariableDeclarationThatHasOnlyBeenAssignedToFalse stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
assignBlockTemporary: aValue
	"This example returns 1 when evaluating the block to avoid excersicing the boolean selector feature as well"
	#_coverageTracker10810563_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [ | a |
	#_coverageTracker10810563_
		cover: (153 to: 153)
		declaredAt: (148 to: 148)
		by:
			(a _ #_coverageTracker10810563_
				cover: (157 to: 162)
				declaredAt: (23 to: 28)
				by: aValue).
	#_coverageTracker10810563_
		coverAll:
			{167 to: 167}
		byLiteralOrPseudoVariable: 1 ].
	#_coverageTracker10810563_
		coverAll:
			{171 to: 175}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test079_FullyCoversABlockBooleanTemporaryVariableDeclarationThatHasOnlyBeenAssignedToTrueAndFalse stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
assignBlockTemporary: aValue
	"This example returns 1 when evaluating the block to avoid excersicing the boolean selector feature as well"
	#_coverageTracker10810598_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [ | a |
	#_coverageTracker10810598_
		cover: (153 to: 153)
		declaredAt: (148 to: 148)
		by:
			(a _ #_coverageTracker10810598_
				cover: (157 to: 162)
				declaredAt: (23 to: 28)
				by: aValue).
	#_coverageTracker10810598_
		coverAll:
			{167 to: 167}
		byLiteralOrPseudoVariable: 1 ].
	#_coverageTracker10810598_
		coverAll:
			{171 to: 175}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test080_DoesNotCountMultipleAssignmentsWithTheSameValueToBlockBooleanTemporaryVariables stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
assignBlockTemporary: aValue
	"This example returns 1 when evaluating the block to avoid excersicing the boolean selector feature as well"
	#_coverageTracker10810604_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [ | a |
	#_coverageTracker10810604_
		cover: (153 to: 153)
		declaredAt: (148 to: 148)
		by:
			(a _ #_coverageTracker10810604_
				cover: (157 to: 162)
				declaredAt: (23 to: 28)
				by: aValue).
	#_coverageTracker10810604_
		coverAll:
			{167 to: 167}
		byLiteralOrPseudoVariable: 1 ].
	#_coverageTracker10810604_
		coverAll:
			{171 to: 175}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test081_DoesNotConsiderABlockTemporaryDeclarationAsBooleanWhenItIsAssignedToABooleanAndThenToANonBoolean stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
assignBlockTemporary: aValue
	"This example returns 1 when evaluating the block to avoid excersicing the boolean selector feature as well"
	#_coverageTracker10810641_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ [ | a |
	#_coverageTracker10810641_
		cover: (153 to: 153)
		declaredAt: (148 to: 148)
		by:
			(a _ #_coverageTracker10810641_
				cover: (157 to: 162)
				declaredAt: (23 to: 28)
				by: aValue).
	#_coverageTracker10810641_
		coverAll:
			{167 to: 167}
		byLiteralOrPseudoVariable: 1 ].
	#_coverageTracker10810641_
		coverAll:
			{171 to: 175}
		evaluating: [ receiver1 value ]
		thatSends: #value
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test082_DoesNotConsiderABlockTemporaryDeclarationAsBooleanWhenItIsAssignedToANonBooleanAndThenToABoolean stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
messageSendReturningMessageResultInstanceVariable
	#_coverageTracker10810647_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810647_
		coverAll:
			{53 to: 56}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker10810647_
		coverAll:
			{58 to: 92}
		evaluating: [ receiver1 returnMessageResultInstanceVariable ]
		thatSends: #returnMessageResultInstanceVariable
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test083_PartiallyCoversABooleanSelectorThatOnlyReturnsTrue stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
messageSendReturningMessageResultInstanceVariable
	#_coverageTracker10810680_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810680_
		coverAll:
			{53 to: 56}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker10810680_
		coverAll:
			{58 to: 92}
		evaluating: [ receiver1 returnMessageResultInstanceVariable ]
		thatSends: #returnMessageResultInstanceVariable
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test084_PartiallyCoversABooleanSelectorThatOnlyReturnsFalse stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
messageSendReturningMessageResultInstanceVariable
	#_coverageTracker10810684_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810684_
		coverAll:
			{53 to: 56}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker10810684_
		coverAll:
			{58 to: 92}
		evaluating: [ receiver1 returnMessageResultInstanceVariable ]
		thatSends: #returnMessageResultInstanceVariable
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test085_FullyCoversABooleanSelectorThatReturnsTrueAndFalse stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
messageSendReturningMessageResultInstanceVariable
	#_coverageTracker10810711_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810711_
		coverAll:
			{53 to: 56}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker10810711_
		coverAll:
			{58 to: 92}
		evaluating: [ receiver1 returnMessageResultInstanceVariable ]
		thatSends: #returnMessageResultInstanceVariable
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test086_DoesNotCountMultipleReturnsOfSameValueFromBooleanSelectors stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
messageSendReturningMessageResultInstanceVariable
	#_coverageTracker10810713_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810713_
		coverAll:
			{53 to: 56}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker10810713_
		coverAll:
			{58 to: 92}
		evaluating: [ receiver1 returnMessageResultInstanceVariable ]
		thatSends: #returnMessageResultInstanceVariable
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test087_DoesNotConsiderASelectorAsBooleanWhenItReturnsABooleanAndThenANonBoolean stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
messageSendReturningMessageResultInstanceVariable
	#_coverageTracker10810717_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810717_
		coverAll:
			{53 to: 56}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker10810717_
		coverAll:
			{58 to: 92}
		evaluating: [ receiver1 returnMessageResultInstanceVariable ]
		thatSends: #returnMessageResultInstanceVariable
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test088_DoesNotConsiderASelectorAsBooleanWhenItReturnsANonBooleanAndThenABoolean stamp: 'psm 10/17/2023 21:43:22'!
PASSED!
!Behavior method!
instanceVariableAssignedToTrue
	#_coverageTracker10810719_ markAsExecuted.
	#_coverageTracker10810719_
		cover: (34 to: 49)
		declaredAt: (34 to: 49)
		by:
			(instanceVariable _ #_coverageTracker10810719_
				coverAll:
					{53 to: 56}
				byLiteralOrPseudoVariable: true).! !

!testRun: #CodeCoverageTest #test090_PartiallyCoversAnInstanceTemporaryVariableDeclarationThatHasOnlyBeenAssignedToTrue stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
instanceVariableAssignedToFalse
	#_coverageTracker10810754_ markAsExecuted.
	#_coverageTracker10810754_
		cover: (35 to: 50)
		declaredAt: (35 to: 50)
		by:
			(instanceVariable _ #_coverageTracker10810754_
				coverAll:
					{54 to: 58}
				byLiteralOrPseudoVariable: false).! !

!testRun: #CodeCoverageTest #test091_PartiallyCoversAnInstanceTemporaryVariableDeclarationThatHasOnlyBeenAssignedToFalse stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
instanceVariableAssignedToTrueAndFalse
	#_coverageTracker10810756_ markAsExecuted.
	#_coverageTracker10810756_
		cover: (42 to: 57)
		declaredAt: (42 to: 57)
		by:
			(instanceVariable _ #_coverageTracker10810756_
				coverAll:
					{61 to: 64}
				byLiteralOrPseudoVariable: true).
	#_coverageTracker10810756_
		cover: (68 to: 83)
		declaredAt: (42 to: 57)
		by:
			(instanceVariable _ #_coverageTracker10810756_
				coverAll:
					{87 to: 91}
				byLiteralOrPseudoVariable: false).! !

!testRun: #CodeCoverageTest #test092_FullyCoversABooleanInstanceVariableDeclarationThatHasBeenAssignedToTrueAndFalse stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
instanceVariableAssignedToTrueMoreThanOnce
	#_coverageTracker10810758_ markAsExecuted.
	#_coverageTracker10810758_
		cover: (47 to: 62)
		declaredAt: (47 to: 62)
		by:
			(instanceVariable _ #_coverageTracker10810758_
				coverAll:
					{66 to: 69}
				byLiteralOrPseudoVariable: true).
	#_coverageTracker10810758_
		cover: (73 to: 88)
		declaredAt: (47 to: 62)
		by:
			(instanceVariable _ #_coverageTracker10810758_
				coverAll:
					{92 to: 95}
				byLiteralOrPseudoVariable: true).! !

!testRun: #CodeCoverageTest #test093_DoesNotCountMultipleAssignmentsWithTheSameValueToBooleanInstanceVariables stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
instanceVariableAssignedToABooleanAndThenToANonBoolean
	#_coverageTracker10810793_ markAsExecuted.
	#_coverageTracker10810793_
		cover: (58 to: 73)
		declaredAt: (58 to: 73)
		by:
			(instanceVariable _ #_coverageTracker10810793_
				coverAll:
					{77 to: 80}
				byLiteralOrPseudoVariable: true).
	#_coverageTracker10810793_
		cover: (84 to: 99)
		declaredAt: (58 to: 73)
		by:
			(instanceVariable _ #_coverageTracker10810793_
				coverAll:
					{103 to: 103}
				byLiteralOrPseudoVariable: 1).! !

!testRun: #CodeCoverageTest #test094_DoesNotConsiderAnInstanceVariableAsBooleanWhenItIsAssignedToABooleanAndThenToANonBoolean stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
instanceVariableAssignedToANonBooleanAndThenToABoolean
	#_coverageTracker10810795_ markAsExecuted.
	#_coverageTracker10810795_
		cover: (58 to: 73)
		declaredAt: (58 to: 73)
		by:
			(instanceVariable _ #_coverageTracker10810795_
				coverAll:
					{77 to: 77}
				byLiteralOrPseudoVariable: 1).
	#_coverageTracker10810795_
		cover: (81 to: 96)
		declaredAt: (58 to: 73)
		by:
			(instanceVariable _ #_coverageTracker10810795_
				coverAll:
					{100 to: 103}
				byLiteralOrPseudoVariable: true).! !

!testRun: #CodeCoverageTest #test095_DoesNotConsiderAnInstanceVariableAsBooleanWhenItIsAssignedToANonBooleanAndThenToABoolean stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
instanceVariableAssignedToTrue
	#_coverageTracker10810799_ markAsExecuted.
	#_coverageTracker10810799_
		cover: (34 to: 49)
		declaredAt: (34 to: 49)
		by:
			(instanceVariable _ #_coverageTracker10810799_
				coverAll:
					{53 to: 56}
				byLiteralOrPseudoVariable: true).! !
!Behavior method!
instanceVariableAssignedToFalse
	#_coverageTracker10810799_ markAsExecuted.
	#_coverageTracker10810799_
		cover: (35 to: 50)
		declaredAt: (35 to: 50)
		by:
			(instanceVariable _ #_coverageTracker10810799_
				coverAll:
					{54 to: 58}
				byLiteralOrPseudoVariable: false).! !

!testRun: #CodeCoverageTest #test096_DoesNotCoverABooleanInstanceVariableAssignedInDifferentMethods stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
emptyMethodWithUnusedArgument: arg
	#_coverageTracker10810801_ markAsExecuted.! !

!testRun: #CodeCoverageTest #test097_DoesNotCoverUnusedMethodArguments stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
classVariableAssignedToTrue
	#_coverageTracker10810834_ markAsExecuted.
	#_coverageTracker10810834_
		cover: (31 to: 43)
		declaredAt: (31 to: 43)
		by:
			(ClassVariable _ #_coverageTracker10810834_
				coverAll:
					{47 to: 50}
				byLiteralOrPseudoVariable: true).! !

!testRun: #CodeCoverageTest #test098_PartiallyCoversABooleanClassVariableThatHasOnlyBeenAssignedToTrue stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
classVariableAssignedToFalse
	#_coverageTracker10810836_ markAsExecuted.
	#_coverageTracker10810836_
		cover: (32 to: 44)
		declaredAt: (32 to: 44)
		by:
			(ClassVariable _ #_coverageTracker10810836_
				coverAll:
					{48 to: 52}
				byLiteralOrPseudoVariable: false).! !

!testRun: #CodeCoverageTest #test099_PartiallyCoversABooleanClassVariableThatHasOnlyBeenAssignedToFalse stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
classVariableAssignedToTrueAndFalse
	#_coverageTracker10810838_ markAsExecuted.
	#_coverageTracker10810838_
		cover: (39 to: 51)
		declaredAt: (39 to: 51)
		by:
			(ClassVariable _ #_coverageTracker10810838_
				coverAll:
					{55 to: 58}
				byLiteralOrPseudoVariable: true).
	#_coverageTracker10810838_
		cover: (62 to: 74)
		declaredAt: (39 to: 51)
		by:
			(ClassVariable _ #_coverageTracker10810838_
				coverAll:
					{78 to: 82}
				byLiteralOrPseudoVariable: false).! !

!testRun: #CodeCoverageTest #test100_FullyCoversABooleanClassVariableThatHasBeenAssignedToTrueAndFalse stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
classVariableAssignedToABooleanMoreThanOnce
	#_coverageTracker10810842_ markAsExecuted.
	#_coverageTracker10810842_
		cover: (47 to: 59)
		declaredAt: (47 to: 59)
		by:
			(ClassVariable _ #_coverageTracker10810842_
				coverAll:
					{63 to: 66}
				byLiteralOrPseudoVariable: true).
	#_coverageTracker10810842_
		cover: (70 to: 82)
		declaredAt: (47 to: 59)
		by:
			(ClassVariable _ #_coverageTracker10810842_
				coverAll:
					{86 to: 89}
				byLiteralOrPseudoVariable: true).! !

!testRun: #CodeCoverageTest #test101_DoesNotCountMultipleAssignmentsWithTheSameValueToClassTemporaryVariables stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
classVariableAssignedToABooleanAndThenToANonBoolean
	#_coverageTracker10810875_ markAsExecuted.
	#_coverageTracker10810875_
		cover: (55 to: 67)
		declaredAt: (55 to: 67)
		by:
			(ClassVariable _ #_coverageTracker10810875_
				coverAll:
					{71 to: 74}
				byLiteralOrPseudoVariable: true).
	#_coverageTracker10810875_
		cover: (78 to: 90)
		declaredAt: (55 to: 67)
		by:
			(ClassVariable _ #_coverageTracker10810875_
				coverAll:
					{94 to: 94}
				byLiteralOrPseudoVariable: 1).! !

!testRun: #CodeCoverageTest #test102_DoesNotConsiderAClassVariableAsBooleanWhenItIsAssignedToABooleanAndThenToANonBoolean stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
classVariableAssignedToANonBooleanAndThenToABoolean
	#_coverageTracker10810937_ markAsExecuted.
	#_coverageTracker10810937_
		cover: (55 to: 67)
		declaredAt: (55 to: 67)
		by:
			(ClassVariable _ #_coverageTracker10810937_
				coverAll:
					{71 to: 71}
				byLiteralOrPseudoVariable: 1).
	#_coverageTracker10810937_
		cover: (75 to: 87)
		declaredAt: (55 to: 67)
		by:
			(ClassVariable _ #_coverageTracker10810937_
				coverAll:
					{91 to: 94}
				byLiteralOrPseudoVariable: true).! !

!testRun: #CodeCoverageTest #test103_DoesNotConsiderAClassVariableAsBooleanWhenItIsAssignedToANonBooleanAndThenToABoolean stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CodeCoverageTest #test104_IgnoresAbstractMethods stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
ifTrue: aBoolean
	#_coverageTracker10810941_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810941_
		cover: (20 to: 27)
		declaredAt: (9 to: 16)
		by: aBoolean.
	#_coverageTracker10810941_
		coverAll:
			{29 to: 35}
		evaluating: [
			receiver1 ifTrue: [
				#_coverageTracker10810941_
					coverAll:
						{39 to: 39}
					byLiteralOrPseudoVariable: 1 ]]
		thatSends: #ifTrue:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test105_PartiallyCoversIfTrueMessageSendsWhenBothBranchesAreNotExercised stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
ifTrue: aBoolean
	#_coverageTracker10810945_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810945_
		cover: (20 to: 27)
		declaredAt: (9 to: 16)
		by: aBoolean.
	#_coverageTracker10810945_
		coverAll:
			{29 to: 35}
		evaluating: [
			receiver1 ifTrue: [
				#_coverageTracker10810945_
					coverAll:
						{39 to: 39}
					byLiteralOrPseudoVariable: 1 ]]
		thatSends: #ifTrue:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test106_FullyCoversIfTrueMessageSendsWhenBothBranchesAreExercised stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
ifTrueIfFalse: aReceiver
	#_coverageTracker10810978_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810978_
		cover: (28 to: 36)
		declaredAt: (16 to: 24)
		by: aReceiver.
	#_coverageTracker10810978_
		coverAll:
			{40 to: 46. 53 to: 60}
		evaluating: [
			receiver1
				ifTrue: [ ]
				ifFalse: [ ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test107_PartiallyCoversIfTrueIfFalseMessageSendsWhenBothBranchesAreNotExercised stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
ifTrueIfFalse: aReceiver
	#_coverageTracker10810982_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810982_
		cover: (28 to: 36)
		declaredAt: (16 to: 24)
		by: aReceiver.
	#_coverageTracker10810982_
		coverAll:
			{40 to: 46. 53 to: 60}
		evaluating: [
			receiver1
				ifTrue: [ ]
				ifFalse: [ ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test108_FullyCoversIfTrueIfFalseMessageSendsWhenBothBranchesAreExercised stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
ifFalse: aReceiver
	#_coverageTracker10810986_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10810986_
		cover: (22 to: 30)
		declaredAt: (10 to: 18)
		by: aReceiver.
	#_coverageTracker10810986_
		coverAll:
			{32 to: 39}
		evaluating: [
			receiver1 ifFalse: [
				#_coverageTracker10810986_
					coverAll:
						{43 to: 43}
					byLiteralOrPseudoVariable: 1 ]]
		thatSends: #ifFalse:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test109_PartiallyCoversIfFalseMessageSendsWhenBothBranchesAreNotExercised stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
ifFalse: aReceiver
	#_coverageTracker10811019_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10811019_
		cover: (22 to: 30)
		declaredAt: (10 to: 18)
		by: aReceiver.
	#_coverageTracker10811019_
		coverAll:
			{32 to: 39}
		evaluating: [
			receiver1 ifFalse: [
				#_coverageTracker10811019_
					coverAll:
						{43 to: 43}
					byLiteralOrPseudoVariable: 1 ]]
		thatSends: #ifFalse:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test110_FullyCoversIfFalseMessageSendsWhenBothBranchesAreExercised stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
ifFalseIfTrue: aReceiver
	#_coverageTracker10811025_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10811025_
		cover: (28 to: 36)
		declaredAt: (16 to: 24)
		by: aReceiver.
	#_coverageTracker10811025_
		coverAll:
			{40 to: 47. 54 to: 60}
		evaluating: [
			receiver1
				ifFalse: [ ]
				ifTrue: [ ]]
		thatSends: #ifFalse:ifTrue:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test111_PartiallyCoversIfFalseIfTrueMessageSendsWhenBothBranchesAreNotExercised stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
ifFalseIfTrue: aReceiver
	#_coverageTracker10811056_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10811056_
		cover: (28 to: 36)
		declaredAt: (16 to: 24)
		by: aReceiver.
	#_coverageTracker10811056_
		coverAll:
			{40 to: 47. 54 to: 60}
		evaluating: [
			receiver1
				ifFalse: [ ]
				ifTrue: [ ]]
		thatSends: #ifFalse:ifTrue:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test112_FullyCoversIfFalseIfTrueMessageSendsWhenBothBranchesAreExercised stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
blockReturningFromMethodWith: anObject
	#_coverageTracker10811091_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker10811091_
		cover: (42 to: 49)
		declaredAt: (31 to: 38)
		by: anObject.
	#_coverageTracker10811091_
		coverAll:
			{51 to: 57}
		evaluating: [ receiver1 ifTrue: [ ^ #_coverageTracker10811091_
					coverAll:
						{63 to: 63}
					byLiteralOrPseudoVariable: 1 ]]
		thatSends: #ifTrue:
		to: receiver1 ] value.! !

!testRun: #CodeCoverageTest #test113_FullyCoversDecisionSelectorsWhenTheyReturnFromTheMethodTheyWereCreatedFrom stamp: 'psm 10/17/2023 21:43:23'!
PASSED!
!Behavior method!
messageReceiverTracker
	#_coverageTracker10811093_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker10811093_
		coverAll:
			{27 to: 30}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker10811093_
		coverAll:
			{32 to: 56}
		evaluating: [ receiver1 trackMessageReceiverUsage ]
		thatSends: #trackMessageReceiverUsage
		to: receiver1 ] value.
	#_coverageTracker10811093_
		coverAll:
			{59 to: 69}
		evaluating: [ receiver2 printString ]
		thatSends: #printString
		to: receiver2 ] value.! !

!testRun: #CodeCoverageTest #test114_EvaluatesReceiversOnlyOnceWhenCoveringMessageSends stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #NotImplementedMethodTest #test01ActualSendersIsEmpty stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #NotImplementedMethodTest #test02CategoryIsNil stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #NotImplementedMethodTest #test03CompiledMethodSignalsError stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #NotImplementedMethodTest #test04CompiledMethodIfAbsentEvaluatesIfAbsentBlock stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #NotImplementedMethodTest #test05doesOnlySurelySendReturnsFalse stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #NotImplementedMethodTest #test06dynamicTypingAutoCompleterDocumentationReturnsEmptyText stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #NotImplementedMethodTest #test07IsNotValid stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #NotImplementedMethodTest #test08liveTypingAutoCompleterDocumentationReturnsEmptyText stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #NotImplementedMethodTest #test09rangesOASentSelectorWhenSendToReceiverTypesIsEmpty stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #NotImplementedMethodTest #test10FailsWhenAsItsSourceCode stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #NotImplementedMethodTest #test11StringVersionStartsWithNotImplemented stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test01IsEmptyWhenAllTypesAreNil stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test02StoresAddedTypes stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test03StoresSameTypeOnce stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test04StoresMoreThanOneTypeCorrectly stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test05DoesNotStoreTypesWhenContainerIsNil stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test06CommonSupertypeOfSiblingsClassesReturnsRightSuperclass stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test07CommonSupertypeOnSameHierarchyIsMostTopClass stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test08CommonSupertypeOnSameHierarchyIsNotAffectedByAddingOrder stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test09ObjectIsCommonSupertypeWhenClassesAreNotSiblings stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test10ProtoObjectIsCommonSupertypeWhenThereAreNoTypesStored stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test11ProtoObjectIsCommonSupertypeWhenCointainerIsNil stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test12CommonSupertypeIfNoTypesReturnsAlternativeClosureValueWhenIsEmpty stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test13CommonSupertypeIfNoTypesReturnsAlternativeClosureValueWhenContainerIsNil stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test14UndefinedObjectIsNotConsideredWhenLookingForCommonSupertype stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test15StoresTypesIsTrueWhenContainerIsNotNil stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test16StoresTypesIsFalseWhenContainerIsNil stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test17IsMegamorphicWhenContainerIsFull stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test18IsNotMegamorphicWhenContainerIsNotFull stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test19CommonSelectorsPreviousToSameOnlyTypeIsEmpty stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test20CommonSelectorsPreviousToSuperclassOfOnlyAddedTypeAreAddedTypeSelectors stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test21CommonSelectorsPreviousToSuperclassSuperclassOfOnlyAddedTypeAreAddedTypeUpToSuperclassSelectors stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test22CommonSelectorsPreviousToInvalidSuperclassRaisesError stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test23CommonSelectorsPreviousToSuperclassOfSiblingTypesAreSiblingsCommonSelectors stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test24CommonSelectorsPreviousToOnSameHierarchyReturnsCommonSuperclassesSelectors stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test25CommonSelectorsPreviousToAddedSSupertypeOnSameHierarchyIsEmpty stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test26CommonSelectorsPreviousToWhenNotStoringTypesIsEmpty stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test27CommonSelectorsPreviousToIfInvalidSupertypeEvaluatesInvalidBlock stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test28CommonSelectorsPreviousToIfInvalidSupertypeWithManyTypesEvaluatesInvalidBlock stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test29CommonSelectosGoesUpToIncludingProtoObject stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test30CommonSupertypeIfGenericEvaluatesIfGenericBlockForObject stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test31CommonSupertypeIfGenericEvaluatesIfGenericBlockForProtoObject stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test32WithCommonSupertypeDoIfGenericEvaluatesDoBlockWhenNoGenericSupertype stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test33WithCommonSupertypeDoIfGenericEvaluatesGenericBlockWhenGenericSupertype stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test34AddingATypeWhenNoMoreSpaceEvaluatesIsFullBlock stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test35TypeIsNotMoreInTypesWhenRemoved stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test36RemovingTypeWhenTypesIsEmptyEvaluatesIfAbsent stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test37RemovingNotIncludedTypeEvaluatesIfAbsent stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test38RemovingLastAddedTypeWorksAsExpected stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test39RemoveTypeSignalExceptionWhenTypeNotFound stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #VariableTypeInfoTest #test40TypesDoEvaluatesBlockOnEachType stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test01isGetterWhenSameSelectorAsInstanceVariableAndOnlyReturnsThatVariable stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test01withPropertiesDoIfSelectorEvaluatesFirstBlockWhenMethodHasProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test02isNotGetterWhenDifferentSelectorAsInstanceVariable stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test02removePropertiesRestoresPenultimalLiteralToSelector stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test03isNotGetterWhenSameSelectorAsInstanceVariableButDoesOtherThingBesidesReturningVariable stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test03removePropertiesKeepsSelectorIfMethodDoesNotHaveProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test04isSetterWhenSameKeywordSelectorAsInstanceVariableAndOnlySetsTheVariable stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test04withPropertiesDoIfSelectorEvaluatesSecondBlockWhenMethodHasNoProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test05hasLiteralSuchThatTravelsListeralsWhenMethodHasProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test05isNotSetterWhenDifferentKeywordSelectorAsInstanceVariable stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test06hasLiteralSuchThatTravelsListeralsWhenMethodHasNoProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test06isNotSetterWhenSameKeywordSelectorAsInstanceVariableButDoesNotAssignParameter stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test0701withPropertiesDoReturnsNilIfMethodHasNoProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test07AccessorDescriptionIsGetterForAGetter stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test07withPropertiesDoEvaluatesBlockOnlyWhenMethodHasProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test08AccessorDescriptionIsSetterForASetter stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test08hasLiteralThoroughReturnTrueWhenMethodHasPropertiesAndHasLiteral stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test09AccessorDescriptionIsReadForMethodThatReadsInstanceVariable stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test09hasLiteralThoroughReturnFalseWhenMethodHasPropertiesAndHasNoLiteral stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test10AccessorDescriptionIsWriteForMethodThatWritesInstanceVariable stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test10hasLiteralThoroughReturnTrueWhenMethodHasNoPropertiesAndHasLiteral stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test11AccessorDescriptionIsWriteReadForMethodThatWritesAndReadInstanceVariable stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test11hasLiteralThoroughReturnFalseWhenMethodHasNoPropertiesAndHasNoLiteral stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test12pragmaAtReturnsPragmaIfExist stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test13pragmaAtReturnsNilIfPragmaDoesNotExist stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test14pragmasReturnsCollectionOfMethodPragmas stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test15pragmasReturnsEmptyCollectionWhenMethodHasNoProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test16propertiesReturnsAnNewAdditionalMethodStateWhenNoPropertiesHasBeenSet stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test17propertiesReturnsTheAlreadySetAdditionalMethodStateWhenHasProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test18propertyKeysAndValuesDoIteratesOverProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test19propertyKeysAndValuesDoDoesNotEvaluateBlockWhenMethodHasNoProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test20propertyValueAtReturnsPropertyValueWhenSetted stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test21propertyValueAtReturnsNilWhenPropertyIsNotFound stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test22propertyValueAtReturnsNilWhenMethodHasNoProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test23propertyValueAtIfAbsetReturnsPropertyValueWhenFound stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test24propertyValueAtIfAbsetEvaluatesIfAbsentBlockWhenNotFound stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test25propertyValueAtIfAbsetEvaluatesIfAbsentBlockWhenMethodHasNoProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test26propertyValueAtPutCreatesPropertiesWithNewOne stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test27propertyValueAtPutReplacesPropertyIfAlreadyExisted stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test28propertyValueAtPutAddsNewPropertyIfPropertiesExisted stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test29selectorReturnsMethodSelectorWhenNoProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test30selectorReturnsMethodSelectorWhenHasProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test31SettingSelectorWhenHasNoProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

!testRun: #CompiledMethodTest #test32SettingSelectorWhenHasProperties stamp: 'psm 10/17/2023 21:43:23'!
PASSED!

----STARTUP---- (17 October 2023 21:47:15) as /home/pablosm/cuisUniversity/CuisUniversity-5981.image!

!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:31' prior: 50713675 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:50' prior: 50713666 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self! !
!Portfolio methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:53:55' prior: 50707233 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.
! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:54:00' prior: 50708631 overrides: 16920235!
initialize

	transactions := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:55:34' prior: 50713569 overrides: 50713545!
uncolorIt: aFinancialEntity

	^self! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:56:23' prior: 50713563 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	aFinancialEntity coloredAsTheAdderRecursively.
	^AsAdder new.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:56:48'!
coloredAsTheAdderRecursively

	storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:48'!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' overrides: 50744482!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50744482!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:22' prior: 50744488 overrides: 50744494!
coloredAsTheAdderRecursively

	^self! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:42' prior: 50712324 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:59:39' prior: 50712314 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:01:06' prior: 50713449 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	^AsAdded new.! !

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:57:48'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:57:48'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:57:48'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:57:48'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:57:48'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:57:48'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:02:37' overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new! !

!methodRemoval: AsAdded #uncolorIt: stamp: 'psm 10/17/2023 21:57:48'!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new!

!methodRemoval: AsAdder #uncolorIt: stamp: 'psm 10/17/2023 21:57:48'!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:14:18' prior: 50712350 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoredAsTheAddedRecursively.! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:14:41'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50744604!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50744604!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' prior: 50744604!
tryColoredAsTheAddedRecursively

	self subclassResponsibility! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50744629!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50744629!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' prior: 50744597 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 21:57:48'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 21:57:48'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 21:57:48'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:15:59' prior: 50712328 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:00' prior: 50744635 overrides: 50744629!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:01' prior: 50744680 overrides: 50744629!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50744642!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50744642!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' prior: 50744642 overrides: 50744629!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:57:48'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50744718!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50744718!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50744718!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50744673 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50744648 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:57:49'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:57:49'!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:57:49'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:57:49'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:18:36' prior: 50744737 overrides: 50744718!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06' overrides: 50744787!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50744787!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50744787!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50744744 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50744752 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:57:49'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:57:49'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:57:49'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:57:49'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:20:53' prior: 50713186!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:21:35' prior: 50744850!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:00' prior: 50744800 overrides: 50744787!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^aFinacialEntity coloredAsTheAddedRecursively.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:40' prior: 50744898 overrides: 50744787!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:25:58' prior: 50744874!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:27' prior: 50744820 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.
	"coloredAsTheAddedRecursively"! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39'!
canIColoreAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' overrides: 50744943!
canIColoreAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' overrides: 50744943!
canIColoreAsTheAddedRecursively

	^true.! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' overrides: 50744943!
canIColoreAsTheAddedRecursively

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50744812 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50744935 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.
	"coloredAsTheAddedRecursively"! !

!methodRemoval: ColoredStateForFinancialEntityStruct #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:57:49'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:57:49'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:57:49'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.!

!methodRemoval: AsAdder #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:57:49'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:57' prior: 50744974 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: self coloredAsTheAddedRecursively.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:28:55'!
coloredAsTheAddedRecursively.

	storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !

!methodRemoval: ColoredStateForFinancialEntityStruct class #new stamp: 'psm 10/17/2023 21:57:49'!
new
	
	^uniqueInstance.!

!methodRemoval: ColoredStateForFinancialEntityStruct class #initialize stamp: 'psm 10/17/2023 21:57:49'!
initialize
	
	uniqueInstance := self basicNew.!

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:57:49'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:57:49'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:33' prior: 50745005 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: [self coloredAsTheAddedRecursively].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:50' prior: 50745013!
coloredAsTheAddedRecursively.

	^storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !

!methodRemoval: Portfolio #rootPortfoliosHaveFinancialEntityInCommon: stamp: 'psm 10/17/2023 21:57:49'!
rootPortfoliosHaveFinancialEntityInCommon: aReceptiveAccount
	^(self rootPortfolio anySatisfy: [:aRootPortfolio|
		aReceptiveAccount rootPortfolio anySatisfy:[: rootFE |
					 aRootPortfolio hasFinancialEntityInCommon: rootFE]])				
		
		
		
	!

!methodRemoval: Portfolio #hasFinancialEntityInCommon: stamp: 'psm 10/17/2023 21:57:49'!
hasFinancialEntityInCommon: aFinancialEntity
	
	^(self = aFinancialEntity) or: [storedFinancialEntities anySatisfy: 
		[:storedFinancialEntity |(aFinancialEntity hasFinancialEntityInCommon: storedFinancialEntity) 
			        or: [storedFinancialEntity hasFinancialEntityInCommon: aFinancialEntity.].].].!

!methodRemoval: Portfolio #includesReceptiveAccount: stamp: 'psm 10/17/2023 21:57:49'!
includesReceptiveAccount: aReceptiveAccount
	^ self hasFinancialEntityInCommon: aReceptiveAccount !

!methodRemoval: SetOfFinancialEntities #hasFinancialEntityInCommon: stamp: 'psm 10/17/2023 21:57:49'!
hasFinancialEntityInCommon: aReceptiveAccount

	self subclassResponsibility!

!methodRemoval: SetOfFinancialEntities #includesReceptiveAccount: stamp: 'psm 10/17/2023 21:57:49'!
includesReceptiveAccount: aReceptiveAccount

	self subclassResponsibility!

!methodRemoval: ReceptiveAccount #hasFinancialEntityInCommon: stamp: 'psm 10/17/2023 21:57:49'!
hasFinancialEntityInCommon: aFinancialEntity
	
	^aFinancialEntity includesReceptiveAccount: self!

!methodRemoval: ReceptiveAccount #includesReceptiveAccount: stamp: 'psm 10/17/2023 21:57:49'!
includesReceptiveAccount: aReceptiveAccount

	^self = aReceptiveAccount !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:40:47'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:12' prior: 50744910!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdder. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:21'!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:41:21' prior: 50745118!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #coloredRootsAsAdder stamp: 'psm 10/17/2023 21:57:49'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:28' prior: 50745147!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:44:37'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:03' prior: 50745176!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity .
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:08' prior: 50745204!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:26'!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:45:26' prior: 50745220!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #uncolorAllEntitysInvolved: stamp: 'psm 10/17/2023 21:57:49'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:46:56'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:04'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' overrides: 50745277!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' prior: 50745277!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:29' prior: 50745284 overrides: 50745291!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .! !

!methodRemoval: ReceptiveAccount #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 21:57:49'!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .!

!methodRemoval: SetOfFinancialEntities #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 21:57:49'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:15' prior: 50745245!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAdded: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:36'!
tryToColorRootsAsAddedIn: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:49:36' prior: 50745315!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAddedIn: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 21:57:50'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].!
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:52:31'!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio sendTo: aMessage ]. 
	! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:31' prior: 50744435 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:50' prior: 50744441 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self! !
!Portfolio methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:53:55' prior: 50744446 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.
! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:54:00' prior: 50744454 overrides: 16920235!
initialize

	transactions := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:55:34' prior: 50744462 overrides: 50713545!
uncolorIt: aFinancialEntity

	^self! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:56:23' prior: 50744467 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	aFinancialEntity coloredAsTheAdderRecursively.
	^AsAdder new.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:56:48' prior: 50744474 overrides: 50744494!
coloredAsTheAdderRecursively

	storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:48' prior: 50744494!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50744501 overrides: 50745413!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50745413!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:22' prior: 50745420 overrides: 50745426!
coloredAsTheAdderRecursively

	^self! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:42' prior: 50744507 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:59:39' prior: 50744514 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:01:06' prior: 50744520 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	^AsAdded new.! !

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:58:06'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:58:06'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:58:06'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:58:06'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:58:06'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:58:06'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:02:37' prior: 50744580 overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:14:18' prior: 50745043 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoredAsTheAddedRecursively.! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:14:41'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50745526!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50745526!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' prior: 50745526!
tryColoredAsTheAddedRecursively

	self subclassResponsibility! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50745551!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50745551!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' prior: 50745519 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 21:58:06'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 21:58:06'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 21:58:07'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:15:59' prior: 50744966 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:00' prior: 50745557 overrides: 50745551!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:01' prior: 50745602 overrides: 50745551!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50745564!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50745564!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' prior: 50745564 overrides: 50745551!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:58:07'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50745640!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50745640!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50745640!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50745595 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50745570 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:58:07'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:58:07'!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:58:07'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:58:07'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:18:36' prior: 50745659 overrides: 50745640!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06' overrides: 50745709!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50745709!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50745709!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50745666 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50745674 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:58:07'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:58:07'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:58:07'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:58:07'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:20:53' prior: 50745336!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:21:35' prior: 50745772!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:00' prior: 50745722 overrides: 50745709!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^aFinacialEntity coloredAsTheAddedRecursively.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:40' prior: 50745820 overrides: 50745709!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:25:58' prior: 50745796!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:27' prior: 50745742 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.
	"coloredAsTheAddedRecursively"! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50744943!
canIColoreAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50744949 overrides: 50745866!
canIColoreAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50744955 overrides: 50745866!
canIColoreAsTheAddedRecursively

	^true.! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50744960 overrides: 50745866!
canIColoreAsTheAddedRecursively

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50745734 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50745857 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.
	"coloredAsTheAddedRecursively"! !

!methodRemoval: ColoredStateForFinancialEntityStruct #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:58:07'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:58:07'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:58:07'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.!

!methodRemoval: AsAdder #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:58:07'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:57' prior: 50745898 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: self coloredAsTheAddedRecursively.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:28:55' prior: 50745052!
coloredAsTheAddedRecursively.

	storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:58:07'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:58:07'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:33' prior: 50745929 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: [self coloredAsTheAddedRecursively].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:50' prior: 50745938!
coloredAsTheAddedRecursively.

	^storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:40:47'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:12' prior: 50745832!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdder. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:21' prior: 50745140!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:41:21' prior: 50745983!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #coloredRootsAsAdder stamp: 'psm 10/17/2023 21:58:07'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:28' prior: 50746013!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:44:37'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:03' prior: 50746042!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity .
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:08' prior: 50746070!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:26' prior: 50745235!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:45:26' prior: 50746086!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #uncolorAllEntitysInvolved: stamp: 'psm 10/17/2023 21:58:07'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:46:56'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:04'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' overrides: 50746143!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' prior: 50746143!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:29' prior: 50746150 overrides: 50746157!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .! !

!methodRemoval: ReceptiveAccount #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 21:58:07'!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .!

!methodRemoval: SetOfFinancialEntities #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 21:58:07'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:15' prior: 50746111!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAdded: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:36' prior: 50745328!
tryToColorRootsAsAddedIn: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:49:36' prior: 50746181!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAddedIn: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 21:58:07'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].!
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:52:31' prior: 50745357!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio sendTo: aMessage ]. 
	! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:31' prior: 50745365 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:50' prior: 50745371 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self! !
!Portfolio methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:53:55' prior: 50745376 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.
! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:54:00' prior: 50745384 overrides: 16920235!
initialize

	transactions := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:55:34' prior: 50745392 overrides: 50713545!
uncolorIt: aFinancialEntity

	^self! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:56:23' prior: 50745397 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	aFinancialEntity coloredAsTheAdderRecursively.
	^AsAdder new.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:56:48' prior: 50745405 overrides: 50745426!
coloredAsTheAdderRecursively

	storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:48' prior: 50745426!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50745433 overrides: 50746280!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50746280!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:22' prior: 50746287 overrides: 50746293!
coloredAsTheAdderRecursively

	^self! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:42' prior: 50745439 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:59:39' prior: 50745446 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:01:06' prior: 50745452 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	^AsAdded new.! !

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:59:12'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:59:12'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:59:12'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:59:12'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:59:12'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:59:12'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:02:37' prior: 50745512 overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:14:18' prior: 50745959 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoredAsTheAddedRecursively.! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:14:41'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50746393!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50746393!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' prior: 50746393!
tryColoredAsTheAddedRecursively

	self subclassResponsibility! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50746418!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50746418!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' prior: 50746386 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 21:59:12'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 21:59:12'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 21:59:12'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:15:59' prior: 50745890 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:00' prior: 50746424 overrides: 50746418!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:01' prior: 50746469 overrides: 50746418!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50746431!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50746431!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' prior: 50746431 overrides: 50746418!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:59:12'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50746507!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50746507!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50746507!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50746462 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50746437 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:59:12'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:59:12'!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:59:12'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 21:59:12'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:18:36' prior: 50746526 overrides: 50746507!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06' overrides: 50746576!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50746576!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50746576!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50746533 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50746541 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:59:12'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:59:12'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:59:12'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:59:12'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:20:53' prior: 50746203!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:21:35' prior: 50746639!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:00' prior: 50746589 overrides: 50746576!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^aFinacialEntity coloredAsTheAddedRecursively.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:40' prior: 50746687 overrides: 50746576!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:25:58' prior: 50746663!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:27' prior: 50746609 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.
	"coloredAsTheAddedRecursively"! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50745866!
canIColoreAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50745872 overrides: 50746733!
canIColoreAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50745879 overrides: 50746733!
canIColoreAsTheAddedRecursively

	^true.! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50745884 overrides: 50746733!
canIColoreAsTheAddedRecursively

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50746601 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50746724 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.
	"coloredAsTheAddedRecursively"! !

!methodRemoval: ColoredStateForFinancialEntityStruct #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:59:12'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:59:12'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:59:13'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.!

!methodRemoval: AsAdder #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 21:59:13'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:57' prior: 50746765 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: self coloredAsTheAddedRecursively.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:28:55' prior: 50745968!
coloredAsTheAddedRecursively.

	storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:59:13'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 21:59:13'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:33' prior: 50746796 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: [self coloredAsTheAddedRecursively].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:50' prior: 50746805!
coloredAsTheAddedRecursively.

	^storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:40:47'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:12' prior: 50746699!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdder. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:21' prior: 50746006!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:41:21' prior: 50746850!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #coloredRootsAsAdder stamp: 'psm 10/17/2023 21:59:13'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:28' prior: 50746880!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:44:37'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:03' prior: 50746909!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity .
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:08' prior: 50746937!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:26' prior: 50746101!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:45:26' prior: 50746953!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #uncolorAllEntitysInvolved: stamp: 'psm 10/17/2023 21:59:13'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:46:56'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:04'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' overrides: 50747010!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' prior: 50747010!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:29' prior: 50747017 overrides: 50747024!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .! !

!methodRemoval: ReceptiveAccount #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 21:59:13'!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .!

!methodRemoval: SetOfFinancialEntities #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 21:59:13'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:15' prior: 50746978!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAdded: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:36' prior: 50746195!
tryToColorRootsAsAddedIn: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:49:36' prior: 50747048!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAddedIn: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 21:59:13'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].!
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:52:31' prior: 50746224!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio sendTo: aMessage ]. 
	! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:31' prior: 50746232 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:50' prior: 50746238 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self! !
!Portfolio methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:53:55' prior: 50746243 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.
! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:54:00' prior: 50746251 overrides: 16920235!
initialize

	transactions := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:55:34' prior: 50746259 overrides: 50713545!
uncolorIt: aFinancialEntity

	^self! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:56:23' prior: 50746264 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	aFinancialEntity coloredAsTheAdderRecursively.
	^AsAdder new.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:56:48' prior: 50746272 overrides: 50746293!
coloredAsTheAdderRecursively

	storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:48' prior: 50746293!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50746300 overrides: 50747147!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50747147!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:22' prior: 50747154 overrides: 50747160!
coloredAsTheAdderRecursively

	^self! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:42' prior: 50746306 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:59:39' prior: 50746313 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:01:06' prior: 50746319 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	^AsAdded new.! !

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:00:02'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:00:02'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:00:02'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:00:02'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:00:02'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:00:02'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:02:37' prior: 50746379 overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:14:18' prior: 50746826 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoredAsTheAddedRecursively.! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:14:41'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50747260!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50747260!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' prior: 50747260!
tryColoredAsTheAddedRecursively

	self subclassResponsibility! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50747285!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50747285!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' prior: 50747253 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:00:02'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:00:02'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:00:02'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:15:59' prior: 50746757 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:00' prior: 50747291 overrides: 50747285!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:01' prior: 50747336 overrides: 50747285!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50747298!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50747298!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' prior: 50747298 overrides: 50747285!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:00:02'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50747374!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50747374!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50747374!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50747329 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50747304 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:00:02'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:00:02'!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:00:02'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:00:02'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:18:36' prior: 50747393 overrides: 50747374!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06' overrides: 50747443!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50747443!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50747443!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50747400 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50747408 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:00:02'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:00:02'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:00:02'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:00:02'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:20:53' prior: 50747070!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:21:35' prior: 50747506!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:00' prior: 50747456 overrides: 50747443!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^aFinacialEntity coloredAsTheAddedRecursively.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:40' prior: 50747554 overrides: 50747443!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:25:58' prior: 50747530!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:27' prior: 50747476 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.
	"coloredAsTheAddedRecursively"! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50746733!
canIColoreAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50746739 overrides: 50747600!
canIColoreAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50746746 overrides: 50747600!
canIColoreAsTheAddedRecursively

	^true.! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50746751 overrides: 50747600!
canIColoreAsTheAddedRecursively

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50747468 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50747591 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.
	"coloredAsTheAddedRecursively"! !

!methodRemoval: ColoredStateForFinancialEntityStruct #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:00:03'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:00:03'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:00:03'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.!

!methodRemoval: AsAdder #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:00:03'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:57' prior: 50747632 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: self coloredAsTheAddedRecursively.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:28:55' prior: 50746835!
coloredAsTheAddedRecursively.

	storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:00:03'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:00:03'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:33' prior: 50747663 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: [self coloredAsTheAddedRecursively].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:50' prior: 50747672!
coloredAsTheAddedRecursively.

	^storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:40:47'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:12' prior: 50747566!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdder. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:21' prior: 50746873!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:41:21' prior: 50747717!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #coloredRootsAsAdder stamp: 'psm 10/17/2023 22:00:03'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:28' prior: 50747747!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:44:37'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:03' prior: 50747776!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity .
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:08' prior: 50747804!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:26' prior: 50746968!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:45:26' prior: 50747820!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #uncolorAllEntitysInvolved: stamp: 'psm 10/17/2023 22:00:03'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:46:56'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:04'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' overrides: 50747877!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' prior: 50747877!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:29' prior: 50747884 overrides: 50747891!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .! !

!methodRemoval: ReceptiveAccount #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:00:03'!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .!

!methodRemoval: SetOfFinancialEntities #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:00:03'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:15' prior: 50747845!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAdded: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:36' prior: 50747062!
tryToColorRootsAsAddedIn: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:49:36' prior: 50747915!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAddedIn: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:00:03'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].!
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:52:31' prior: 50747091!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio sendTo: aMessage ]. 
	! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:31' prior: 50747099 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:50' prior: 50747105 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self! !
!Portfolio methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:53:55' prior: 50747110 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.
! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:54:00' prior: 50747118 overrides: 16920235!
initialize

	transactions := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:55:34' prior: 50747126 overrides: 50713545!
uncolorIt: aFinancialEntity

	^self! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:56:23' prior: 50747131 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	aFinancialEntity coloredAsTheAdderRecursively.
	^AsAdder new.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:56:48' prior: 50747139 overrides: 50747160!
coloredAsTheAdderRecursively

	storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:48' prior: 50747160!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50747167 overrides: 50748014!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50748014!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:22' prior: 50748021 overrides: 50748027!
coloredAsTheAdderRecursively

	^self! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:42' prior: 50747173 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:59:39' prior: 50747180 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:01:06' prior: 50747186 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	^AsAdded new.! !

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:23'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:23'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:23'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:23'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:23'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:23'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:02:37' prior: 50747246 overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:14:18' prior: 50747693 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoredAsTheAddedRecursively.! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:14:41'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50748127!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50748127!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' prior: 50748127!
tryColoredAsTheAddedRecursively

	self subclassResponsibility! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50748152!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50748152!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' prior: 50748120 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:23'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:23'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:23'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:15:59' prior: 50747624 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:00' prior: 50748158 overrides: 50748152!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:01' prior: 50748203 overrides: 50748152!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50748165!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50748165!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' prior: 50748165 overrides: 50748152!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:23'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50748241!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50748241!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50748241!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50748196 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50748171 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:23'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:23'!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:23'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:23'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:18:36' prior: 50748260 overrides: 50748241!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06' overrides: 50748310!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50748310!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50748310!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50748267 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50748275 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:23'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:23'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:23'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:23'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:20:53' prior: 50747937!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:21:35' prior: 50748373!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:00' prior: 50748323 overrides: 50748310!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^aFinacialEntity coloredAsTheAddedRecursively.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:40' prior: 50748421 overrides: 50748310!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:25:58' prior: 50748397!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:27' prior: 50748343 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.
	"coloredAsTheAddedRecursively"! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50747600!
canIColoreAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50747606 overrides: 50748467!
canIColoreAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50747613 overrides: 50748467!
canIColoreAsTheAddedRecursively

	^true.! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50747618 overrides: 50748467!
canIColoreAsTheAddedRecursively

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50748335 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50748458 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.
	"coloredAsTheAddedRecursively"! !

!methodRemoval: ColoredStateForFinancialEntityStruct #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:24'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:24'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:24'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.!

!methodRemoval: AsAdder #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:24'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:57' prior: 50748499 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: self coloredAsTheAddedRecursively.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:28:55' prior: 50747702!
coloredAsTheAddedRecursively.

	storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:24'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:24'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:33' prior: 50748530 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: [self coloredAsTheAddedRecursively].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:50' prior: 50748539!
coloredAsTheAddedRecursively.

	^storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:40:47'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:12' prior: 50748433!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdder. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:21' prior: 50747740!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:41:21' prior: 50748584!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #coloredRootsAsAdder stamp: 'psm 10/17/2023 22:03:24'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:28' prior: 50748614!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:44:37'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:03' prior: 50748643!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity .
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:08' prior: 50748671!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:26' prior: 50747835!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:45:26' prior: 50748687!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #uncolorAllEntitysInvolved: stamp: 'psm 10/17/2023 22:03:24'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:46:56'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:04'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' overrides: 50748744!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' prior: 50748744!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:29' prior: 50748751 overrides: 50748758!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .! !

!methodRemoval: ReceptiveAccount #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:03:24'!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .!

!methodRemoval: SetOfFinancialEntities #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:03:24'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:15' prior: 50748712!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAdded: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:36' prior: 50747929!
tryToColorRootsAsAddedIn: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:49:36' prior: 50748782!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAddedIn: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:03:24'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].!
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:52:31' prior: 50747958!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio sendTo: aMessage ]. 
	! !
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:58:11' prior: 50748825!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio perform: aMessage ]. 
	! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50748607!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:01:12' prior: 50748839!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	
	"self rootPortfolioDo: #coloredAsTheAdder."! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50748848!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:31' prior: 50747966 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:50' prior: 50747972 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self! !
!Portfolio methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:53:55' prior: 50747977 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.
! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:54:00' prior: 50747985 overrides: 16920235!
initialize

	transactions := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:55:34' prior: 50747993 overrides: 50713545!
uncolorIt: aFinancialEntity

	^self! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:56:23' prior: 50747998 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	aFinancialEntity coloredAsTheAdderRecursively.
	^AsAdder new.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:56:48' prior: 50748006 overrides: 50748027!
coloredAsTheAdderRecursively

	storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:48' prior: 50748027!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50748034 overrides: 50748914!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50748914!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:22' prior: 50748921 overrides: 50748927!
coloredAsTheAdderRecursively

	^self! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:42' prior: 50748040 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:59:39' prior: 50748047 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:01:06' prior: 50748053 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	^AsAdded new.! !

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:57'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:57'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:57'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:57'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:57'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:57'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:02:37' prior: 50748113 overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:14:18' prior: 50748560 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoredAsTheAddedRecursively.! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:14:41'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50749027!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50749027!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' prior: 50749027!
tryColoredAsTheAddedRecursively

	self subclassResponsibility! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50749052!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50749052!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' prior: 50749020 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:57'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:57'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:57'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:15:59' prior: 50748491 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:00' prior: 50749058 overrides: 50749052!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:01' prior: 50749103 overrides: 50749052!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50749065!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50749065!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' prior: 50749065 overrides: 50749052!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:57'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50749141!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50749141!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50749141!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50749096 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50749071 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:57'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:57'!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:57'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:03:57'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:18:36' prior: 50749160 overrides: 50749141!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06' overrides: 50749210!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50749210!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50749210!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50749167 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50749175 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:20:53' prior: 50748804!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:21:35' prior: 50749273!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:00' prior: 50749223 overrides: 50749210!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^aFinacialEntity coloredAsTheAddedRecursively.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:40' prior: 50749321 overrides: 50749210!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:25:58' prior: 50749297!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:27' prior: 50749243 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.
	"coloredAsTheAddedRecursively"! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50748467!
canIColoreAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50748473 overrides: 50749367!
canIColoreAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50748480 overrides: 50749367!
canIColoreAsTheAddedRecursively

	^true.! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50748485 overrides: 50749367!
canIColoreAsTheAddedRecursively

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50749235 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50749358 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.
	"coloredAsTheAddedRecursively"! !

!methodRemoval: ColoredStateForFinancialEntityStruct #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:58'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:58'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:58'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.!

!methodRemoval: AsAdder #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:03:58'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:57' prior: 50749399 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: self coloredAsTheAddedRecursively.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:28:55' prior: 50748569!
coloredAsTheAddedRecursively.

	storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:58'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:03:58'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:33' prior: 50749430 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: [self coloredAsTheAddedRecursively].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:50' prior: 50749439!
coloredAsTheAddedRecursively.

	^storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:40:47'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:12' prior: 50749333!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdder. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:21' prior: 50748857!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:41:21' prior: 50749484!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #coloredRootsAsAdder stamp: 'psm 10/17/2023 22:03:58'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:28' prior: 50749514!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:44:37'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:03' prior: 50749543!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity .
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:08' prior: 50749571!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:26' prior: 50748702!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:45:26' prior: 50749587!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #uncolorAllEntitysInvolved: stamp: 'psm 10/17/2023 22:03:58'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:46:56'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:04'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' overrides: 50749644!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' prior: 50749644!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:29' prior: 50749651 overrides: 50749658!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .! !

!methodRemoval: ReceptiveAccount #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:03:58'!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .!

!methodRemoval: SetOfFinancialEntities #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:03:58'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:15' prior: 50749612!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAdded: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:36' prior: 50748796!
tryToColorRootsAsAddedIn: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:49:36' prior: 50749682!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAddedIn: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:03:58'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].!
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:52:31' prior: 50748832!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio sendTo: aMessage ]. 
	! !
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:58:11' prior: 50749725!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio perform: aMessage ]. 
	! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50749507!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:01:12' prior: 50749739!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	
	"self rootPortfolioDo: #coloredAsTheAdder."! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50749748!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:31' prior: 50748866 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:50' prior: 50748872 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self! !
!Portfolio methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:53:55' prior: 50748877 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.
! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:54:00' prior: 50748885 overrides: 16920235!
initialize

	transactions := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:55:34' prior: 50748893 overrides: 50713545!
uncolorIt: aFinancialEntity

	^self! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:56:23' prior: 50748898 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	aFinancialEntity coloredAsTheAdderRecursively.
	^AsAdder new.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:56:48' prior: 50748906 overrides: 50748927!
coloredAsTheAdderRecursively

	storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:48' prior: 50748927!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50748934 overrides: 50749814!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50749814!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:22' prior: 50749821 overrides: 50749827!
coloredAsTheAdderRecursively

	^self! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:42' prior: 50748940 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:59:39' prior: 50748947 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:01:06' prior: 50748953 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	^AsAdded new.! !

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:05:16'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:05:16'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:05:16'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:05:16'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:05:16'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:05:16'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:02:37' prior: 50749013 overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:14:18' prior: 50749460 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoredAsTheAddedRecursively.! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:14:41'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50749927!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50749927!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' prior: 50749927!
tryColoredAsTheAddedRecursively

	self subclassResponsibility! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50749952!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50749952!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' prior: 50749920 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:05:16'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:05:16'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:05:16'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:15:59' prior: 50749391 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:00' prior: 50749958 overrides: 50749952!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:01' prior: 50750003 overrides: 50749952!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50749965!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50749965!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' prior: 50749965 overrides: 50749952!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:05:16'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50750041!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50750041!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50750041!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50749996 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50749971 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:05:17'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:05:17'!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:05:17'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:05:17'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:18:36' prior: 50750060 overrides: 50750041!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06' overrides: 50750110!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50750110!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50750110!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50750067 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50750075 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:05:17'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:05:17'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:05:17'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:05:17'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:20:53' prior: 50749704!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:21:35' prior: 50750173!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:00' prior: 50750123 overrides: 50750110!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^aFinacialEntity coloredAsTheAddedRecursively.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:40' prior: 50750221 overrides: 50750110!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:25:58' prior: 50750197!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:27' prior: 50750143 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.
	"coloredAsTheAddedRecursively"! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50749367!
canIColoreAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50749373 overrides: 50750267!
canIColoreAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50749380 overrides: 50750267!
canIColoreAsTheAddedRecursively

	^true.! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50749385 overrides: 50750267!
canIColoreAsTheAddedRecursively

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50750135 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50750258 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.
	"coloredAsTheAddedRecursively"! !

!methodRemoval: ColoredStateForFinancialEntityStruct #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:05:17'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:05:17'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:05:17'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.!

!methodRemoval: AsAdder #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:05:17'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:57' prior: 50750299 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: self coloredAsTheAddedRecursively.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:28:55' prior: 50749469!
coloredAsTheAddedRecursively.

	storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:05:17'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:05:17'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:33' prior: 50750330 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: [self coloredAsTheAddedRecursively].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:50' prior: 50750339!
coloredAsTheAddedRecursively.

	^storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:40:47'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:12' prior: 50750233!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdder. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:21' prior: 50749757!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:41:21' prior: 50750384!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #coloredRootsAsAdder stamp: 'psm 10/17/2023 22:05:17'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:28' prior: 50750414!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:44:37'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:03' prior: 50750443!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity .
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:08' prior: 50750471!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:26' prior: 50749602!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:45:26' prior: 50750487!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #uncolorAllEntitysInvolved: stamp: 'psm 10/17/2023 22:05:17'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:46:56'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:04'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' overrides: 50750544!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' prior: 50750544!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:29' prior: 50750551 overrides: 50750558!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .! !

!methodRemoval: ReceptiveAccount #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:05:17'!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .!

!methodRemoval: SetOfFinancialEntities #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:05:17'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:15' prior: 50750512!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAdded: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:36' prior: 50749696!
tryToColorRootsAsAddedIn: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:49:36' prior: 50750582!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAddedIn: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:05:17'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].!
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:52:31' prior: 50749732!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio sendTo: aMessage ]. 
	! !
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:58:11' prior: 50750625!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio perform: aMessage ]. 
	! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50750407!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:01:12' prior: 50750639!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	
	"self rootPortfolioDo: #coloredAsTheAdder."! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50750648!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:31' prior: 50749766 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:50' prior: 50749772 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self! !
!Portfolio methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:53:55' prior: 50749777 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.
! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:54:00' prior: 50749785 overrides: 16920235!
initialize

	transactions := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:55:34' prior: 50749793 overrides: 50713545!
uncolorIt: aFinancialEntity

	^self! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:56:23' prior: 50749798 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	aFinancialEntity coloredAsTheAdderRecursively.
	^AsAdder new.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:56:48' prior: 50749806 overrides: 50749827!
coloredAsTheAdderRecursively

	storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:48' prior: 50749827!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50749834 overrides: 50750714!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50750714!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:22' prior: 50750721 overrides: 50750727!
coloredAsTheAdderRecursively

	^self! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:42' prior: 50749840 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:59:39' prior: 50749847 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:01:06' prior: 50749853 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	^AsAdded new.! !

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:30'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:30'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:30'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:30'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:30'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:30'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:02:37' prior: 50749913 overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:14:18' prior: 50750360 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoredAsTheAddedRecursively.! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:14:41'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50750827!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50750827!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' prior: 50750827!
tryColoredAsTheAddedRecursively

	self subclassResponsibility! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50750852!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50750852!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' prior: 50750820 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:30'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:30'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:30'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:15:59' prior: 50750291 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:00' prior: 50750858 overrides: 50750852!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:01' prior: 50750903 overrides: 50750852!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50750865!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50750865!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' prior: 50750865 overrides: 50750852!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:30'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50750941!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50750941!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50750941!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50750896 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50750871 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:30'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:30'!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:30'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:30'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:18:36' prior: 50750960 overrides: 50750941!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06' overrides: 50751010!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50751010!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50751010!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50750967 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50750975 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:30'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:30'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:30'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:30'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:20:53' prior: 50750604!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:21:35' prior: 50751073!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:00' prior: 50751023 overrides: 50751010!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^aFinacialEntity coloredAsTheAddedRecursively.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:40' prior: 50751121 overrides: 50751010!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:25:58' prior: 50751097!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:27' prior: 50751043 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.
	"coloredAsTheAddedRecursively"! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50750267!
canIColoreAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50750273 overrides: 50751167!
canIColoreAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50750280 overrides: 50751167!
canIColoreAsTheAddedRecursively

	^true.! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50750285 overrides: 50751167!
canIColoreAsTheAddedRecursively

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50751035 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50751158 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.
	"coloredAsTheAddedRecursively"! !

!methodRemoval: ColoredStateForFinancialEntityStruct #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:30'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:30'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:30'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.!

!methodRemoval: AsAdder #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:30'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:57' prior: 50751199 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: self coloredAsTheAddedRecursively.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:28:55' prior: 50750369!
coloredAsTheAddedRecursively.

	storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:31'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:31'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:33' prior: 50751230 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: [self coloredAsTheAddedRecursively].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:50' prior: 50751239!
coloredAsTheAddedRecursively.

	^storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:40:47'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:12' prior: 50751133!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdder. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:21' prior: 50750657!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:41:21' prior: 50751284!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #coloredRootsAsAdder stamp: 'psm 10/17/2023 22:07:31'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:28' prior: 50751314!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:44:37'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:03' prior: 50751343!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity .
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:08' prior: 50751371!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:26' prior: 50750502!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:45:26' prior: 50751387!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #uncolorAllEntitysInvolved: stamp: 'psm 10/17/2023 22:07:31'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:46:56'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:04'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' overrides: 50751444!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' prior: 50751444!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:29' prior: 50751451 overrides: 50751458!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .! !

!methodRemoval: ReceptiveAccount #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:07:31'!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .!

!methodRemoval: SetOfFinancialEntities #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:07:31'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:15' prior: 50751412!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAdded: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:36' prior: 50750596!
tryToColorRootsAsAddedIn: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:49:36' prior: 50751482!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAddedIn: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:07:31'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].!
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:52:31' prior: 50750632!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio sendTo: aMessage ]. 
	! !
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:58:11' prior: 50751525!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio perform: aMessage ]. 
	! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50751307!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:01:12' prior: 50751539!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	
	"self rootPortfolioDo: #coloredAsTheAdder."! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50751548!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:05:49' prior: 50751557!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 21:06:14' prior: 50751532!
rootPortfolioDo: aMessage
	self rootPortfolio do:[:rootPortfolio | rootPortfolio perform: aMessage ]. 
	! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:25:29' prior: 50751402!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolioDo: #uncolorIt.
	aFinancialEntity rootPortfolioDo: #uncolorIt.! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:31' prior: 50750666 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:50' prior: 50750672 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self! !
!Portfolio methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:53:55' prior: 50750677 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.
! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:54:00' prior: 50750685 overrides: 16920235!
initialize

	transactions := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:55:34' prior: 50750693 overrides: 50713545!
uncolorIt: aFinancialEntity

	^self! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:56:23' prior: 50750698 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	aFinancialEntity coloredAsTheAdderRecursively.
	^AsAdder new.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:56:48' prior: 50750706 overrides: 50750727!
coloredAsTheAdderRecursively

	storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:48' prior: 50750727!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50750734 overrides: 50751639!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50751639!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:22' prior: 50751646 overrides: 50751652!
coloredAsTheAdderRecursively

	^self! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:42' prior: 50750740 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:59:39' prior: 50750747 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:01:06' prior: 50750753 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	^AsAdded new.! !

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:35'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:35'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:35'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:35'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:35'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:35'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:02:37' prior: 50750813 overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:14:18' prior: 50751260 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoredAsTheAddedRecursively.! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:14:41'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50751752!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50751752!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' prior: 50751752!
tryColoredAsTheAddedRecursively

	self subclassResponsibility! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50751777!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50751777!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' prior: 50751745 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:36'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:36'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:36'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:15:59' prior: 50751191 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:00' prior: 50751783 overrides: 50751777!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:01' prior: 50751828 overrides: 50751777!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50751790!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50751790!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' prior: 50751790 overrides: 50751777!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:36'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50751866!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50751866!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50751866!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50751821 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50751796 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:36'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:36'!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:36'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:36'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:18:36' prior: 50751885 overrides: 50751866!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06' overrides: 50751935!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50751935!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50751935!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50751892 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50751900 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:36'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:36'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:36'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:36'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:20:53' prior: 50751504!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:21:35' prior: 50751998!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:00' prior: 50751948 overrides: 50751935!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^aFinacialEntity coloredAsTheAddedRecursively.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:40' prior: 50752046 overrides: 50751935!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:25:58' prior: 50752022!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:27' prior: 50751968 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.
	"coloredAsTheAddedRecursively"! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50751167!
canIColoreAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50751173 overrides: 50752092!
canIColoreAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50751180 overrides: 50752092!
canIColoreAsTheAddedRecursively

	^true.! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50751185 overrides: 50752092!
canIColoreAsTheAddedRecursively

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50751960 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50752083 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.
	"coloredAsTheAddedRecursively"! !

!methodRemoval: ColoredStateForFinancialEntityStruct #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:36'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:36'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:36'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.!

!methodRemoval: AsAdder #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:36'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:57' prior: 50752124 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: self coloredAsTheAddedRecursively.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:28:55' prior: 50751269!
coloredAsTheAddedRecursively.

	storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:36'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:36'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:33' prior: 50752155 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: [self coloredAsTheAddedRecursively].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:50' prior: 50752164!
coloredAsTheAddedRecursively.

	^storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:40:47'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:12' prior: 50752058!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdder. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:21' prior: 50751566!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:41:21' prior: 50752209!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #coloredRootsAsAdder stamp: 'psm 10/17/2023 22:07:36'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:28' prior: 50752239!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:44:37'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:03' prior: 50752268!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity .
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:08' prior: 50752296!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:26' prior: 50751582!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:45:26' prior: 50752312!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #uncolorAllEntitysInvolved: stamp: 'psm 10/17/2023 22:07:36'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:46:56'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:04'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' overrides: 50752369!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' prior: 50752369!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:29' prior: 50752376 overrides: 50752383!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .! !

!methodRemoval: ReceptiveAccount #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:07:36'!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .!

!methodRemoval: SetOfFinancialEntities #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:07:36'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:15' prior: 50752337!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAdded: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:36' prior: 50751496!
tryToColorRootsAsAddedIn: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:49:36' prior: 50752407!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAddedIn: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:07:36'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].!
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:52:31' prior: 50751575!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio sendTo: aMessage ]. 
	! !
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:58:11' prior: 50752450!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio perform: aMessage ]. 
	! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50752232!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:01:12' prior: 50752464!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	
	"self rootPortfolioDo: #coloredAsTheAdder."! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50752473!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:05:49' prior: 50752482!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 21:06:14' prior: 50752457!
rootPortfolioDo: aMessage
	self rootPortfolio do:[:rootPortfolio | rootPortfolio perform: aMessage ]. 
	! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:25:29' prior: 50752327!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolioDo: #uncolorIt.
	aFinancialEntity rootPortfolioDo: #uncolorIt.! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:31' prior: 50751591 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:47:50' prior: 50751597 overrides: 50712418!
uncolorIt

	colored := colored uncolorIt: self! !
!Portfolio methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:53:55' prior: 50751602 overrides: 16920235!
initialize 
	storedFinancialEntities := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.
! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'psm 10/17/2023 19:54:00' prior: 50751610 overrides: 16920235!
initialize

	transactions := OrderedCollection new.
	fatherPortfolio := OrderedCollection new.
	colored := AsBlank new.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:55:34' prior: 50751618 overrides: 50713545!
uncolorIt: aFinancialEntity

	^self! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 19:56:23' prior: 50751623 overrides: 50713539!
coloredAsTheAdder: aFinancialEntity

	aFinancialEntity coloredAsTheAdderRecursively.
	^AsAdder new.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:56:48' prior: 50751631 overrides: 50751652!
coloredAsTheAdderRecursively

	storedFinancialEntities do:[:storedFinacialEntity | storedFinacialEntity coloredAsTheAdder]! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:48' prior: 50751652!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50751659 overrides: 50752564!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:57:58' prior: 50752564!
coloredAsTheAdderRecursively

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:22' prior: 50752571 overrides: 50752577!
coloredAsTheAdderRecursively

	^self! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:58:42' prior: 50751665 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 19:59:39' prior: 50751672 overrides: 50712245!
coloredAsTheAdder

	colored := colored coloredAsTheAdder: self.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:01:06' prior: 50751678 overrides: 50713456!
coloredAsTheAdded: aFinancialEntity

	^AsAdded new.! !

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:51'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ColoredStateForFinancialEntityStructNotNull category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:51'!
ColoredStateForFinancialEntityStruct subclass: #ColoredStateForFinancialEntityStructNotNull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:51'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdded category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:51'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdded
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:51'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AsAdder category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:51'!
ColoredStateForFinancialEntityStructNotNull subclass: #AsAdder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:02:37' prior: 50751738 overrides: 50713545!
uncolorIt: aFinancialEntity
	
	aFinancialEntity unColorItRecursively.
	^AsBlank new! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:14:18' prior: 50752185 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoredAsTheAddedRecursively.! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:14:41'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50752677!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' overrides: 50752677!
tryColoredAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:02' prior: 50752677!
tryColoredAsTheAddedRecursively

	self subclassResponsibility! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50752702!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' overrides: 50752702!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:15:34' prior: 50752670 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:51'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:51'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoredAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:51'!
tryColoredAsTheAddedRecursively

	self subclassResponsibility !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:15:59' prior: 50752116 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively.! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:00' prior: 50752708 overrides: 50752702!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:01' prior: 50752753 overrides: 50752702!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50752715!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' overrides: 50752715!
tryColoringAsTheAddedRecursively

	self subclassResponsibility ! !
!ColoredStateForFinancialEntityStructNotNull methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:08' prior: 50752715 overrides: 50752702!
tryColoringAsTheAddedRecursively

	self subclassResponsibility! !

!methodRemoval: ColoredStateForFinancialEntityStructNotNull #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:51'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50752791!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50752791!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' overrides: 50752791!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50752746 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:17:57' prior: 50752721 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored tryColoringAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:51'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:51'!
tryColoringAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:51'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively stamp: 'psm 10/17/2023 22:07:51'!
tryColoringAsTheAddedRecursively

	self subclassResponsibility !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:18:36' prior: 50752810 overrides: 50752791!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:06' overrides: 50752860!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50752860!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility ! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' overrides: 50752860!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50752817 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:19:07' prior: 50752825 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.! !

!methodRemoval: ColoredStateForFinancialEntityStruct #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:51'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:51'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:51'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility !

!methodRemoval: AsAdder #tryColoringAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:51'!
tryColoringAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:20:53' prior: 50752429!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifTrue: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:21:35' prior: 50752923!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio anySatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:00' prior: 50752873 overrides: 50752860!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^aFinacialEntity coloredAsTheAddedRecursively.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:25:40' prior: 50752971 overrides: 50752860!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.! !
!Portfolio methodsFor: 'collition prevention' stamp: 'psm 10/17/2023 20:25:58' prior: 50752947!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:27' prior: 50752893 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively: self.
	"coloredAsTheAddedRecursively"! !
!ColoredStateForFinancialEntityStruct methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50752092!
canIColoreAsTheAddedRecursively

	self subclassResponsibility! !
!AsBlank methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50752098 overrides: 50753017!
canIColoreAsTheAddedRecursively

	self error: 'primero pinta como aded despues recorre'.! !
!AsAdded methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50752105 overrides: 50753017!
canIColoreAsTheAddedRecursively

	^true.! !
!AsAdder methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50752110 overrides: 50753017!
canIColoreAsTheAddedRecursively

	^false! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50752885 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:26:39' prior: 50753008 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively.
	"coloredAsTheAddedRecursively"! !

!methodRemoval: ColoredStateForFinancialEntityStruct #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:51'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self subclassResponsibility!

!methodRemoval: AsBlank #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:51'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	self error: 'primero pinta como aded despues recorre'.!

!methodRemoval: AsAdded #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:51'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^true.!

!methodRemoval: AsAdder #canIColoreAsTheAddedRecursively: stamp: 'psm 10/17/2023 22:07:51'!
canIColoreAsTheAddedRecursively: aFinacialEntity

	^false!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:26:57' prior: 50753049 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: self coloredAsTheAddedRecursively.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:28:55' prior: 50752194!
coloredAsTheAddedRecursively.

	storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:51'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!

!classDefinition: 'ColoredStateForFinancialEntityStruct class' category: 'Portfolio-Ejercicio' stamp: 'psm 10/17/2023 22:07:51'!
ColoredStateForFinancialEntityStruct class
	instanceVariableNames: ''!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:33' prior: 50753080 overrides: 50712344!
coloredAsTheAdded

	colored := colored coloredAsTheAdded: self.
	^colored canIColoreAsTheAddedRecursively and: [self coloredAsTheAddedRecursively].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:37:50' prior: 50753089!
coloredAsTheAddedRecursively.

	^storedFinancialEntities allSatisfy: [:storedFinacialEntity|storedFinacialEntity coloredAsTheAdded]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:40:47'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:12' prior: 50752983!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdder. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:21' prior: 50752491!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:41:21' prior: 50753134!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 
	|cannotAddEntity|
	 "(self rootPortfoliosHaveFinancialEntityInCommon: aFinancialEntity )				
		       ifTrue: [^self error: aFinancialEntity collisionErrorMessage.]"
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #coloredRootsAsAdder stamp: 'psm 10/17/2023 22:07:52'!
coloredRootsAsAdder
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:41:28' prior: 50753164!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:44:37'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:03' prior: 50753193!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity .
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:08' prior: 50753221!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self uncolorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:45:26' prior: 50752507!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:45:26' prior: 50753237!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #uncolorAllEntitysInvolved: stamp: 'psm 10/17/2023 22:07:52'!
uncolorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].
	aFinancialEntity rootPortfolio do:[:rootPortfolio | rootPortfolio uncolorIt].!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:46:56'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:04'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' overrides: 50753294!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!SetOfFinancialEntities methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:15' prior: 50753294!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:47:29' prior: 50753301 overrides: 50753308!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .! !

!methodRemoval: ReceptiveAccount #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:07:52'!
tryToColorRootsAsAdded: aFinancialEntity

	^self coloredAsTheAdded .!

!methodRemoval: SetOfFinancialEntities #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:07:52'!
tryToColorRootsAsAdded: aFinancialEntity

	self subclassResponsibility!
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:15' prior: 50753262!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAdded: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 20:49:36' prior: 50752421!
tryToColorRootsAsAddedIn: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'psm 10/17/2023 20:49:36' prior: 50753332!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|cannotAddEntity|
		
	self coloredRootsAsAdders. 
	cannotAddEntity := self tryToColorRootsAsAddedIn: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	cannotAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !

!methodRemoval: Portfolio #tryToColorRootsAsAdded: stamp: 'psm 10/17/2023 22:07:52'!
tryToColorRootsAsAdded: aFinancialEntity

	 ^aFinancialEntity rootPortfolio allSatisfy: [:rootPortfolio | rootPortfolio coloredAsTheAdded].!
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:52:31' prior: 50752500!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio sendTo: aMessage ]. 
	! !
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 20:58:11' prior: 50753375!
rootPortfolioDo: aMessage
	fatherPortfolio do:[:rootPortfolio | rootPortfolio perform: aMessage ]. 
	! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50753157!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:01:12' prior: 50753389!
coloredRootsAsAdders
	
	self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder].
	
	"self rootPortfolioDo: #coloredAsTheAdder."! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:00:35' prior: 50753398!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:05:49' prior: 50753407!
coloredRootsAsAdders
	
	"self rootPortfolio do:[:rootPortfolio | rootPortfolio coloredAsTheAdder]."
	
	self rootPortfolioDo: #coloredAsTheAdder.! !
!SetOfFinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/17/2023 21:06:14' prior: 50753382!
rootPortfolioDo: aMessage
	self rootPortfolio do:[:rootPortfolio | rootPortfolio perform: aMessage ]. 
	! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 21:25:29' prior: 50753252!
unColorAllEntitysInvolved: aFinancialEntity 

	self rootPortfolioDo: #uncolorIt.
	aFinancialEntity rootPortfolioDo: #uncolorIt.! !
!Portfolio methodsFor: 'collition prevention with coloring' stamp: 'psm 10/17/2023 22:10:26' prior: 50753354!
avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity 

	|canAddEntity|
		
	self coloredRootsAsAdders. 
	canAddEntity := self tryToColorRootsAsAddedIn: aFinancialEntity.
	
	self unColorAllEntitysInvolved: aFinancialEntity.
	
	canAddEntity ifFalse: [self error: aFinancialEntity collisionErrorMessage]! !
!Portfolio methodsFor: 'transactions' stamp: 'psm 10/17/2023 22:11:01' prior: 50710339!
add: aFinancialEntity 
	
	self avoidConectedPortfoliosFromHavingTheSameEntity: aFinancialEntity .
	
	aFinancialEntity newFatherPortfolio: self.	
	storedFinancialEntities add: aFinancialEntity .! !

!testRun: #TestsXX #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test22_PruebaDeFuego stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

!testRun: #TestsXX #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 22:11:02'!
PASSED!

----SNAPSHOT----(17 October 2023 22:11:44) CuisUniversity-5981.image priorSource: 12227530!

!classRenamed: #TestsXX as: #FinantialEntityTests stamp: 'psm 10/17/2023 22:13:36'!
Smalltalk renameClassNamed: #TestsXX as: #FinantialEntityTests!

!classRenamed: #FinantialEntityTests as: #SetOfFinancialEntitiesTests stamp: 'psm 10/17/2023 22:13:56'!
Smalltalk renameClassNamed: #FinantialEntityTests as: #SetOfFinancialEntitiesTests!

!testRun: #SetOfFinancialEntitiesTests #test01_NewPortfolioHasNoBalance stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test16_PortfolioCantStoreHimself stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test22_PruebaDeFuego stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test23_PruebaDeMuchoFuego stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!testRun: #SetOfFinancialEntitiesTests #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/17/2023 22:14:03'!
PASSED!

!classRenamed: #SetOfFinancialEntitiesTests as: #PortfolioTests stamp: 'psm 10/17/2023 22:14:24'!
Smalltalk renameClassNamed: #SetOfFinancialEntitiesTests as: #PortfolioTests!

----SNAPSHOT----(17 October 2023 22:14:28) CuisUniversity-5981.image priorSource: 13500592!

----STARTUP---- (19 October 2023 17:18:31) as /home/pablo/cuisUniversity/CuisUniversity-5981.image!


nil!

!testRun: #PortfolioTests #test01_NewPortfolioHasNoBalance stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test16_PortfolioCantStoreHimself stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test22_PruebaDeFuego stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test23_PruebaDeMuchoFuego stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

!testRun: #PortfolioTests #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/19/2023 17:42:31'!
PASSED!

pindongo := 'unp pindongo'!

pindongo := 'unp pindongo'!

----STARTUP---- (19 October 2023 18:14:54) as /home/pablo/cuisUniversity/CuisUniversity-5981.image!


!testRun: #PortfolioTests #test01_NewPortfolioHasNoBalance stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test16_PortfolioCantStoreHimself stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test22_PruebaDeFuego stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test23_PruebaDeMuchoFuego stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!testRun: #PortfolioTests #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/19/2023 19:44:48'!
PASSED!

!classRenamed: #SetOfFinancialEntities as: #FinancialEntities stamp: 'psm 10/19/2023 19:55:38'!
Smalltalk renameClassNamed: #SetOfFinancialEntities as: #FinancialEntities!

----SNAPSHOT----(19 October 2023 19:55:48) CuisUniversity-5981.image priorSource: 13504316!
!Portfolio methodsFor: 'transactions' stamp: 'psm 10/19/2023 20:10:07' prior: 50703088 overrides: 50702685!
transactions
	"^ (storedFinancialEntities inject: OrderedCollection new into: [:aCollection :anAccount| aCollection , anAccount transactions.])."
	
	| transactions |
	transactions := OrderedCollection new.! !
!Portfolio methodsFor: 'transactions' stamp: 'psm 10/19/2023 20:11:26' prior: 50753764 overrides: 50702685!
transactions
	"^ (storedFinancialEntities inject: OrderedCollection new into: [:aCollection :anAccount| aCollection , anAccount transactions.])."
	
	| transactions |
	transactions := OrderedCollection new.
	
	storedFinancialEntities do:[:aFinancialEntity | aFinancialEntity addTransactionsTo: transactions ].
	
	^transactions ! !
!Portfolio methodsFor: 'transactions' stamp: 'psm 10/19/2023 20:12:14'!
addTransactionsTo: transactions 

	transactions addAll: storedFinancialEntities .
	
	^transactions ! !
!FinancialEntities methodsFor: 'transactions' stamp: 'psm 10/19/2023 20:12:22'!
addTransactionsTo: transactions

	self subclassResponsibility! !
!FinancialEntities methodsFor: 'transactions' stamp: 'psm 10/19/2023 20:13:48' prior: 50753793!
addTransactionsTo: transactionsToBeSaved

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'psm 10/19/2023 20:13:59' overrides: 50753799!
addTransactionsTo: transactionsToBeSaved

	self subclassResponsibility! !
!FinancialEntities methodsFor: 'transactions' stamp: 'psm 10/19/2023 20:13:59' prior: 50753799!
addTransactionsTo: transactionsToBeSaved

	self subclassResponsibility! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'psm 10/19/2023 20:14:29' prior: 50753805 overrides: 50753811!
addTransactionsTo: transactionsToBeSaved

	transactionsToBeSaved addAll: transactions .
	
	^transactionsToBeSaved ! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'psm 10/19/2023 20:14:31'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'psm 10/19/2023 20:14:31'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'psm 10/19/2023 20:14:31'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'psm 10/19/2023 20:14:31'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'psm 10/19/2023 20:14:31'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'psm 10/19/2023 20:14:31'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'psm 10/19/2023 20:14:31'!
PASSED!

!testRun: #PortfolioTests #test01_NewPortfolioHasNoBalance stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/19/2023 20:14:35'!
FAILURE!

!testRun: #PortfolioTests #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test16_PortfolioCantStoreHimself stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test22_PruebaDeFuego stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test23_PruebaDeMuchoFuego stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/19/2023 20:14:35'!
PASSED!

!testRun: #PortfolioTests #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/19/2023 20:14:35'!
FAILURE!
!Portfolio methodsFor: 'transactions' stamp: 'psm 10/19/2023 20:16:56' prior: 50753787 overrides: 50753811!
addTransactionsTo: transactionsToBeSaved 

	storedFinancialEntities do:[:aFinancialEntity | aFinancialEntity addTransactionsTo: transactionsToBeSaved ].
	
	^transactionsToBeSaved ! !

!testRun: #PortfolioTests #test01_NewPortfolioHasNoBalance stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test16_PortfolioCantStoreHimself stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test22_PruebaDeFuego stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test23_PruebaDeMuchoFuego stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

!testRun: #PortfolioTests #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/19/2023 20:16:59'!
PASSED!

----SNAPSHOT----(19 October 2023 20:17:17) CuisUniversity-5981.image priorSource: 13507488!
!FinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/19/2023 20:23:36' prior: 50709230!
rootPortfolio
	| allRootPortfolio |
	fatherPortfolio isEmpty ifTrue: [^OrderedCollection with: self].
	allRootPortfolio := OrderedCollection new.
	fatherPortfolio inject: OrderedCollection new into: [:aCollection :aFather | aCollection , aFather rootPortfolio]. 
	^allRootPortfolio! !
!FinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/19/2023 20:24:25' prior: 50754043!
rootPortfolio
	| allRootPortfolio |
	fatherPortfolio isEmpty ifTrue: [^OrderedCollection with: self].
	allRootPortfolio := OrderedCollection new.
	fatherPortfolio do: [:aFather |  aFather saveRootsTo: allRootPortfolio .]. 
	^allRootPortfolio! !
!FinancialEntities methodsFor: 'father object for myself' stamp: 'psm 10/19/2023 20:26:57'!
saveRootsTo: allRootPortfolio 

	fatherPortfolio isEmpty 
		ifTrue:[allRootPortfolio add: self]
		ifFalse:[fatherPortfolio do:[:aFatherPortfolio|
				aFatherPortfolio saveRootsTo: allRootPortfolio]].
	

	^allRootPortfolio! !

!testRun: #PortfolioTests #test01_NewPortfolioHasNoBalance stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test02_PortfolioWithAccountHasCorrectBalance stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test03_PortfolioWithMultipleAccountsHasCorrectBalance stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test05_PortfolioWithPortfolioHasCorrectBalance stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test06_PortfolioWithNestedPortfoliosHasCorrectBalance stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test07_EmptyPortfolioHasNoTransactionsRegistered stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test08_PortfolioRegistersTransactionFromAddedAccount stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test09_PortfolioRegisteresTransactionFromNestedPortfolio stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test10_EmptyPortfolioHasNoTransactions stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test11_PortfolioHasTransactionsFromStoredAccount stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test12_PortfolioHasTransactionsFromStoredPortfolios stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test13_PortfolioWithAccountCannotStoreSameAccount stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test14_PortfolioCannotStoreAccountRegisteredInNestedPortfolio stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test15_PortfolioCantStorePortfolioWithSharedAccount stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test16_PortfolioCantStoreHimself stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test17_PortfolioCantStoreTheSamePortfolioTwice stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test18_PortfolioCantStoreANestedPortoflio stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test19_PortfolioCantStoreAPortfolioWithSharedNestedPortfolio stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test20_PortfolioCantStorePortfolioStoredInFather stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test21_PortfolioCantStorePortfolioStoredInFathers stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test22_PruebaDeFuego stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test23_PruebaDeMuchoFuego stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test24_PortfolioCantStoreReceptiveAccountTwiceInPortfolioTree stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

!testRun: #PortfolioTests #test25_PruebaDeFuego_ReceptiveAccount stamp: 'psm 10/19/2023 20:27:06'!
PASSED!

----SNAPSHOT----(19 October 2023 20:27:17) CuisUniversity-5981.image priorSource: 13516426!